[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/579733495","html_url":"https://github.com/elastic/elasticsearch/issues/51606#issuecomment-579733495","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/51606","id":579733495,"node_id":"MDEyOklzc3VlQ29tbWVudDU3OTczMzQ5NQ==","user":{"login":"elasticmachine","id":15837671,"node_id":"MDQ6VXNlcjE1ODM3Njcx","avatar_url":"https://avatars3.githubusercontent.com/u/15837671?v=4","gravatar_id":"","url":"https://api.github.com/users/elasticmachine","html_url":"https://github.com/elasticmachine","followers_url":"https://api.github.com/users/elasticmachine/followers","following_url":"https://api.github.com/users/elasticmachine/following{/other_user}","gists_url":"https://api.github.com/users/elasticmachine/gists{/gist_id}","starred_url":"https://api.github.com/users/elasticmachine/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/elasticmachine/subscriptions","organizations_url":"https://api.github.com/users/elasticmachine/orgs","repos_url":"https://api.github.com/users/elasticmachine/repos","events_url":"https://api.github.com/users/elasticmachine/events{/privacy}","received_events_url":"https://api.github.com/users/elasticmachine/received_events","type":"User","site_admin":false},"created_at":"2020-01-29T12:27:34Z","updated_at":"2020-01-29T12:27:34Z","author_association":"COLLABORATOR","body":"Pinging @elastic/ml-core (:ml)","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/586428623","html_url":"https://github.com/elastic/elasticsearch/issues/51606#issuecomment-586428623","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/51606","id":586428623,"node_id":"MDEyOklzc3VlQ29tbWVudDU4NjQyODYyMw==","user":{"login":"benwtrent","id":4357155,"node_id":"MDQ6VXNlcjQzNTcxNTU=","avatar_url":"https://avatars3.githubusercontent.com/u/4357155?v=4","gravatar_id":"","url":"https://api.github.com/users/benwtrent","html_url":"https://github.com/benwtrent","followers_url":"https://api.github.com/users/benwtrent/followers","following_url":"https://api.github.com/users/benwtrent/following{/other_user}","gists_url":"https://api.github.com/users/benwtrent/gists{/gist_id}","starred_url":"https://api.github.com/users/benwtrent/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/benwtrent/subscriptions","organizations_url":"https://api.github.com/users/benwtrent/orgs","repos_url":"https://api.github.com/users/benwtrent/repos","events_url":"https://api.github.com/users/benwtrent/events{/privacy}","received_events_url":"https://api.github.com/users/benwtrent/received_events","type":"User","site_admin":false},"created_at":"2020-02-14T19:11:47Z","updated_at":"2020-02-14T19:11:47Z","author_association":"MEMBER","body":"> We can do this unconditionally providing the oldest node in the cluster is on version 7.2 or above.\r\n\r\nI think we can do this unconditionally regardless of minimum node version. If we have a mixed cluster version, the `date_histogram` aggregation must follow the same BWC guarantees that we do. I think we would have a bigger problem if a `date_histogram` that specifies a fixed/calendar interval is not BWC with older nodes.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/586905696","html_url":"https://github.com/elastic/elasticsearch/issues/51606#issuecomment-586905696","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/51606","id":586905696,"node_id":"MDEyOklzc3VlQ29tbWVudDU4NjkwNTY5Ng==","user":{"login":"droberts195","id":7405510,"node_id":"MDQ6VXNlcjc0MDU1MTA=","avatar_url":"https://avatars0.githubusercontent.com/u/7405510?v=4","gravatar_id":"","url":"https://api.github.com/users/droberts195","html_url":"https://github.com/droberts195","followers_url":"https://api.github.com/users/droberts195/followers","following_url":"https://api.github.com/users/droberts195/following{/other_user}","gists_url":"https://api.github.com/users/droberts195/gists{/gist_id}","starred_url":"https://api.github.com/users/droberts195/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/droberts195/subscriptions","organizations_url":"https://api.github.com/users/droberts195/orgs","repos_url":"https://api.github.com/users/droberts195/repos","events_url":"https://api.github.com/users/droberts195/events{/privacy}","received_events_url":"https://api.github.com/users/droberts195/received_events","type":"User","site_admin":false},"created_at":"2020-02-17T09:48:03Z","updated_at":"2020-02-17T09:48:03Z","author_association":"CONTRIBUTOR","body":"> I think we can do this unconditionally regardless of minimum node version. If we have a mixed cluster version, the `date_histogram` aggregation must follow the same BWC guarantees that we do. I think we would have a bigger problem if a `date_histogram` that specifies a fixed/calendar interval is not BWC with older nodes.\r\n\r\nFor wire serialization this is true, but the extra problem ML is adding is to store the aggregations in a document in an index that might be read by an older node in a mixed version cluster.  Usually aggregation DSL is a transient thing that only exists for the duration of one search so the wire serialization mappings are enough.  We have lenient parsing when loading configs from indices, so parsing the config on load will not cause an error.  But the older node will then see a `date_histogram` aggregation that doesn't contain an `interval`, and error at the point of trying to run it within the datafeed.  This is why I think we should only do the rewrites when the minimum node version is high enough for all nodes in the cluster to understand `fixed_interval` and `calendar_interval`.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/587453173","html_url":"https://github.com/elastic/elasticsearch/issues/51606#issuecomment-587453173","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/51606","id":587453173,"node_id":"MDEyOklzc3VlQ29tbWVudDU4NzQ1MzE3Mw==","user":{"login":"benwtrent","id":4357155,"node_id":"MDQ6VXNlcjQzNTcxNTU=","avatar_url":"https://avatars3.githubusercontent.com/u/4357155?v=4","gravatar_id":"","url":"https://api.github.com/users/benwtrent","html_url":"https://github.com/benwtrent","followers_url":"https://api.github.com/users/benwtrent/followers","following_url":"https://api.github.com/users/benwtrent/following{/other_user}","gists_url":"https://api.github.com/users/benwtrent/gists{/gist_id}","starred_url":"https://api.github.com/users/benwtrent/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/benwtrent/subscriptions","organizations_url":"https://api.github.com/users/benwtrent/orgs","repos_url":"https://api.github.com/users/benwtrent/repos","events_url":"https://api.github.com/users/benwtrent/events{/privacy}","received_events_url":"https://api.github.com/users/benwtrent/received_events","type":"User","site_admin":false},"created_at":"2020-02-18T13:12:18Z","updated_at":"2020-02-18T13:13:18Z","author_association":"MEMBER","body":"@droberts195 \r\n\r\n> For wire serialization this is true, but the extra problem ML is adding is to store the aggregations in a document in an index that might be read by an older node in a mixed version cluster.\r\n\r\nIsn't this already a problem then?\r\n\r\n- Somebody `PUT` or `_update` a datafeed and specifically sets the histogram setting to `fixed|calendar`\r\n- the doc is updated \r\n- the doc is read by an older node\r\n\r\nI thought this type of situation was why our `PUT` and `_update` requests are master node actions. This way the request that gets parsed from XContent is the same version of as the `master` node. Which should be upgraded last anyways. \r\n\r\nNOTE: With the automatic re-write, this will probably be exacerbated. To your point.\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/587458192","html_url":"https://github.com/elastic/elasticsearch/issues/51606#issuecomment-587458192","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/51606","id":587458192,"node_id":"MDEyOklzc3VlQ29tbWVudDU4NzQ1ODE5Mg==","user":{"login":"droberts195","id":7405510,"node_id":"MDQ6VXNlcjc0MDU1MTA=","avatar_url":"https://avatars0.githubusercontent.com/u/7405510?v=4","gravatar_id":"","url":"https://api.github.com/users/droberts195","html_url":"https://github.com/droberts195","followers_url":"https://api.github.com/users/droberts195/followers","following_url":"https://api.github.com/users/droberts195/following{/other_user}","gists_url":"https://api.github.com/users/droberts195/gists{/gist_id}","starred_url":"https://api.github.com/users/droberts195/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/droberts195/subscriptions","organizations_url":"https://api.github.com/users/droberts195/orgs","repos_url":"https://api.github.com/users/droberts195/repos","events_url":"https://api.github.com/users/droberts195/events{/privacy}","received_events_url":"https://api.github.com/users/droberts195/received_events","type":"User","site_admin":false},"created_at":"2020-02-18T13:24:31Z","updated_at":"2020-02-18T13:24:31Z","author_association":"CONTRIBUTOR","body":"> the `master` node. Which should be upgraded last anyways.\r\n\r\nThis is not a hard requirement.  The [docs](https://www.elastic.co/guide/en/elasticsearch/reference/current/rolling-upgrades.html) just say:\r\n\r\n> It is best to upgrade the master-eligible nodes in your cluster after all of the other nodes.\r\n\r\nAlso, even if that advice is followed, when there are multiple master-eligible nodes the actual master node at some time during the process might be on a version ahead of some other master-eligible nodes.\r\n\r\n> Somebody `PUT` or `_update` a datafeed and specifically sets the histogram setting to `fixed|calendar`\r\n\r\nThere's an assumption that users don't use new features of a particular version until the whole cluster is on that version.  I agree there could be problems if this assumption isn't followed.\r\n\r\nBasically what I am saying is that our internal upgrade code should follow that same assumption - don't start adding new syntax into configs until the whole cluster is on the version that supports that syntax.\r\n\r\nIf a user got themselves into a mess by trying to use new version functionality in a mixed version cluster we could justifiably push back and say they should have waited until the whole cluster is upgraded, and that they need to complete their upgrade before our functionality will work again.  But code we write that runs automatically breaks their mixed version cluster then they have a more justified grievance against us.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/587547739","html_url":"https://github.com/elastic/elasticsearch/issues/51606#issuecomment-587547739","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/51606","id":587547739,"node_id":"MDEyOklzc3VlQ29tbWVudDU4NzU0NzczOQ==","user":{"login":"benwtrent","id":4357155,"node_id":"MDQ6VXNlcjQzNTcxNTU=","avatar_url":"https://avatars3.githubusercontent.com/u/4357155?v=4","gravatar_id":"","url":"https://api.github.com/users/benwtrent","html_url":"https://github.com/benwtrent","followers_url":"https://api.github.com/users/benwtrent/followers","following_url":"https://api.github.com/users/benwtrent/following{/other_user}","gists_url":"https://api.github.com/users/benwtrent/gists{/gist_id}","starred_url":"https://api.github.com/users/benwtrent/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/benwtrent/subscriptions","organizations_url":"https://api.github.com/users/benwtrent/orgs","repos_url":"https://api.github.com/users/benwtrent/repos","events_url":"https://api.github.com/users/benwtrent/events{/privacy}","received_events_url":"https://api.github.com/users/benwtrent/received_events","type":"User","site_admin":false},"created_at":"2020-02-18T16:26:17Z","updated_at":"2020-02-18T16:33:36Z","author_association":"MEMBER","body":"Current plan:\r\n\r\n- Have `_update` automatically fix the interval if the min node version of the cluster is > 7.2.0\r\n- The datafeed job builder should update the lazily parsed map before validating or running the datafeed. This way we handle the situation where a datafeed has continued to run, but has the old interval settings\r\n\r\nAs for updating existing datafeeds that are not in use, i am not 100% the best way to go about this.\r\n\r\nThe options I can think of are:\r\n- provide an easy way for folks to update them (via an empty call to `_update`) if they want to use the datafeed again later. This lines up with the \"upgrade assistant\" format.\r\n- always update the interval when we parse the XContent from the index. v8 is BWC only with 7.last. So, in v8.0.0 we can do this without worry. But, this would mean the stored document could always have the old interval. Might cause issues if somebody decides to delete line of code that does the rewrite...\r\n- Have some service that reads and rewrites them (I dislike this option...)\r\n\r\n","performed_via_github_app":null}]