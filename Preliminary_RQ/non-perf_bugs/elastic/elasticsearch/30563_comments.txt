[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/388752128","html_url":"https://github.com/elastic/elasticsearch/issues/30563#issuecomment-388752128","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/30563","id":388752128,"node_id":"MDEyOklzc3VlQ29tbWVudDM4ODc1MjEyOA==","user":{"login":"elasticmachine","id":15837671,"node_id":"MDQ6VXNlcjE1ODM3Njcx","avatar_url":"https://avatars3.githubusercontent.com/u/15837671?v=4","gravatar_id":"","url":"https://api.github.com/users/elasticmachine","html_url":"https://github.com/elasticmachine","followers_url":"https://api.github.com/users/elasticmachine/followers","following_url":"https://api.github.com/users/elasticmachine/following{/other_user}","gists_url":"https://api.github.com/users/elasticmachine/gists{/gist_id}","starred_url":"https://api.github.com/users/elasticmachine/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/elasticmachine/subscriptions","organizations_url":"https://api.github.com/users/elasticmachine/orgs","repos_url":"https://api.github.com/users/elasticmachine/repos","events_url":"https://api.github.com/users/elasticmachine/events{/privacy}","received_events_url":"https://api.github.com/users/elasticmachine/received_events","type":"User","site_admin":false},"created_at":"2018-05-14T09:20:10Z","updated_at":"2018-05-14T09:20:10Z","author_association":"COLLABORATOR","body":"Pinging @elastic/es-security","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/389588507","html_url":"https://github.com/elastic/elasticsearch/issues/30563#issuecomment-389588507","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/30563","id":389588507,"node_id":"MDEyOklzc3VlQ29tbWVudDM4OTU4ODUwNw==","user":{"login":"jaymode","id":4339958,"node_id":"MDQ6VXNlcjQzMzk5NTg=","avatar_url":"https://avatars1.githubusercontent.com/u/4339958?v=4","gravatar_id":"","url":"https://api.github.com/users/jaymode","html_url":"https://github.com/jaymode","followers_url":"https://api.github.com/users/jaymode/followers","following_url":"https://api.github.com/users/jaymode/following{/other_user}","gists_url":"https://api.github.com/users/jaymode/gists{/gist_id}","starred_url":"https://api.github.com/users/jaymode/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jaymode/subscriptions","organizations_url":"https://api.github.com/users/jaymode/orgs","repos_url":"https://api.github.com/users/jaymode/repos","events_url":"https://api.github.com/users/jaymode/events{/privacy}","received_events_url":"https://api.github.com/users/jaymode/received_events","type":"User","site_admin":false},"created_at":"2018-05-16T16:49:03Z","updated_at":"2018-05-16T16:49:03Z","author_association":"MEMBER","body":"@tbrooks8 @jasontedor do you have any thoughts on whether there is something more we can/should do after security tests to wait for Netty ThreadDeathWatcher to terminate?\r\n\r\nDo we wait longer? Retry waiting (ie check the return value from awaitInactivity)? We currently have this:\r\n\r\nhttps://github.com/elastic/elasticsearch/blob/0b544550bed6e822906572776cb4e46bbb03aa6a/x-pack/plugin/security/src/test/java/org/elasticsearch/test/SecurityIntegTestCase.java#L161-L183","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/390502038","html_url":"https://github.com/elastic/elasticsearch/issues/30563#issuecomment-390502038","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/30563","id":390502038,"node_id":"MDEyOklzc3VlQ29tbWVudDM5MDUwMjAzOA==","user":{"login":"jasontedor","id":4744941,"node_id":"MDQ6VXNlcjQ3NDQ5NDE=","avatar_url":"https://avatars3.githubusercontent.com/u/4744941?v=4","gravatar_id":"","url":"https://api.github.com/users/jasontedor","html_url":"https://github.com/jasontedor","followers_url":"https://api.github.com/users/jasontedor/followers","following_url":"https://api.github.com/users/jasontedor/following{/other_user}","gists_url":"https://api.github.com/users/jasontedor/gists{/gist_id}","starred_url":"https://api.github.com/users/jasontedor/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jasontedor/subscriptions","organizations_url":"https://api.github.com/users/jasontedor/orgs","repos_url":"https://api.github.com/users/jasontedor/repos","events_url":"https://api.github.com/users/jasontedor/events{/privacy}","received_events_url":"https://api.github.com/users/jasontedor/received_events","type":"User","site_admin":false},"created_at":"2018-05-20T18:38:00Z","updated_at":"2018-05-20T18:38:00Z","author_association":"MEMBER","body":"@jaymode I think the problem here is that the `@AfterClass` on `SecurityIntegTestCase` run *before* the `@AfterClass` on `ESIntegTestCase`. This means that we are waiting on these threads to be inactive before the cluster has stopped. That means these threads might not be inactive and so they can not be stopped. Instead, I think we want to shutdown the cluster first and then stop these threads. Since JUnit always runs `@AfterClass` of a sub-class *before* `@AfterClass` of a super-class, we have to play a game to get this cleanup to run after the cluster has stopped. I propose something like this:\r\n\r\n```diff\r\ndiff --git a/test/framework/src/main/java/org/elasticsearch/test/ESIntegTestCase.java b/test/framework/src/main/java/org/elasticsearch/test/ESIntegTestCase.java\r\nindex 7210fadd7ea..b543672c205 100644\r\n--- a/test/framework/src/main/java/org/elasticsearch/test/ESIntegTestCase.java\r\n+++ b/test/framework/src/main/java/org/elasticsearch/test/ESIntegTestCase.java\r\n@@ -357,6 +357,12 @@ public abstract class ESIntegTestCase extends ESTestCase {\r\n         initializeSuiteScope();\r\n     }\r\n \r\n+    private static final List<Runnable> afterClassRunnables = new ArrayList<>();\r\n+\r\n+    protected static void registerAfterClass(final Runnable afterClassRunnable) {\r\n+        afterClassRunnables.add(afterClassRunnable);\r\n+    }\r\n+\r\n     @Override\r\n     protected final boolean enableWarningsCheck() {\r\n         //In an integ test it doesn't make sense to keep track of warnings: if the cluster is external the warnings are in another jvm,\r\n@@ -2101,6 +2107,9 @@ public abstract class ESIntegTestCase extends ESTestCase {\r\n             }\r\n         } else {\r\n             clearClusters();\r\n+            for (final Runnable afterClassRunnable : afterClassRunnables) {\r\n+                afterClassRunnable.run();\r\n+            }\r\n         }\r\n         SUITE_SEED = null;\r\n         currentCluster = null;\r\n* Unmerged path x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/CreateAndFollowIndexAction.java\r\ndiff --git a/x-pack/plugin/security/src/test/java/org/elasticsearch/test/SecurityIntegTestCase.java b/x-pack/plugin/security/src/test/java/org/elasticsearch/test/SecurityIntegTestCase.java\r\nindex 00b46b332cb..cb338aecebe 100644\r\n--- a/x-pack/plugin/security/src/test/java/org/elasticsearch/test/SecurityIntegTestCase.java\r\n+++ b/x-pack/plugin/security/src/test/java/org/elasticsearch/test/SecurityIntegTestCase.java\r\n@@ -154,6 +154,30 @@ public abstract class SecurityIntegTestCase extends ESIntegTestCase {\r\n         }\r\n     }\r\n \r\n+    @BeforeClass\r\n+    public static void addAfterClassRunnable() {\r\n+        // Wait for the network threads to finish otherwise there is the possibility that one of\r\n+        // the threads lingers and trips the thread leak detector\r\n+        ESIntegTestCase.registerAfterClass(() -> {\r\n+            try {\r\n+                GlobalEventExecutor.INSTANCE.awaitInactivity(5, TimeUnit.SECONDS);\r\n+            } catch (InterruptedException e) {\r\n+                Thread.currentThread().interrupt();\r\n+            } catch (IllegalStateException e) {\r\n+                if (e.getMessage().equals(\"thread was not started\") == false) {\r\n+                    throw e;\r\n+                }\r\n+                // ignore since the thread was never started\r\n+            }\r\n+\r\n+            try {\r\n+                ThreadDeathWatcher.awaitInactivity(5, TimeUnit.SECONDS);\r\n+            } catch (InterruptedException e) {\r\n+                Thread.currentThread().interrupt();\r\n+            }\r\n+        });\r\n+    }\r\n+\r\n     /**\r\n      * Set the static default settings to null to prevent a memory leak. The test framework also checks for memory leaks\r\n      * and computes the size, this can cause issues when running with the security manager as it tries to do reflection\r\n@@ -163,24 +187,6 @@ public abstract class SecurityIntegTestCase extends ESIntegTestCase {\r\n     public static void destroyDefaultSettings() {\r\n         SECURITY_DEFAULT_SETTINGS = null;\r\n         customSecuritySettingsSource = null;\r\n-        // Wait for the network threads to finish otherwise there is the possibility that one of\r\n-        // the threads lingers and trips the thread leak detector\r\n-        try {\r\n-            GlobalEventExecutor.INSTANCE.awaitInactivity(5, TimeUnit.SECONDS);\r\n-        } catch (InterruptedException e) {\r\n-            Thread.currentThread().interrupt();\r\n-        } catch (IllegalStateException e) {\r\n-            if (e.getMessage().equals(\"thread was not started\") == false) {\r\n-                throw e;\r\n-            }\r\n-            // ignore since the thread was never started\r\n-        }\r\n-\r\n-        try {\r\n-            ThreadDeathWatcher.awaitInactivity(5, TimeUnit.SECONDS);\r\n-        } catch (InterruptedException e) {\r\n-            Thread.currentThread().interrupt();\r\n-        }\r\n     }\r\n \r\n     @Rule\r\n```\r\n\r\nWith this change, I notice that the threads are cleaned up much faster and I think this will address these spurious failures from the threads leaking.\r\n\r\nWhat do you think of an approach like this?","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/390657046","html_url":"https://github.com/elastic/elasticsearch/issues/30563#issuecomment-390657046","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/30563","id":390657046,"node_id":"MDEyOklzc3VlQ29tbWVudDM5MDY1NzA0Ng==","user":{"login":"jaymode","id":4339958,"node_id":"MDQ6VXNlcjQzMzk5NTg=","avatar_url":"https://avatars1.githubusercontent.com/u/4339958?v=4","gravatar_id":"","url":"https://api.github.com/users/jaymode","html_url":"https://github.com/jaymode","followers_url":"https://api.github.com/users/jaymode/followers","following_url":"https://api.github.com/users/jaymode/following{/other_user}","gists_url":"https://api.github.com/users/jaymode/gists{/gist_id}","starred_url":"https://api.github.com/users/jaymode/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jaymode/subscriptions","organizations_url":"https://api.github.com/users/jaymode/orgs","repos_url":"https://api.github.com/users/jaymode/repos","events_url":"https://api.github.com/users/jaymode/events{/privacy}","received_events_url":"https://api.github.com/users/jaymode/received_events","type":"User","site_admin":false},"created_at":"2018-05-21T13:41:46Z","updated_at":"2018-05-21T13:41:46Z","author_association":"MEMBER","body":"Good point @jasontedor. I wonder if we should add something like this to our test framework in lieu of using something like a JUnit ExternalResource class rule? I may be misunderstanding how the class rule works though, but I'll give it a shot today to see the execution order.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/390660745","html_url":"https://github.com/elastic/elasticsearch/issues/30563#issuecomment-390660745","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/30563","id":390660745,"node_id":"MDEyOklzc3VlQ29tbWVudDM5MDY2MDc0NQ==","user":{"login":"jasontedor","id":4744941,"node_id":"MDQ6VXNlcjQ3NDQ5NDE=","avatar_url":"https://avatars3.githubusercontent.com/u/4744941?v=4","gravatar_id":"","url":"https://api.github.com/users/jasontedor","html_url":"https://github.com/jasontedor","followers_url":"https://api.github.com/users/jasontedor/followers","following_url":"https://api.github.com/users/jasontedor/following{/other_user}","gists_url":"https://api.github.com/users/jasontedor/gists{/gist_id}","starred_url":"https://api.github.com/users/jasontedor/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jasontedor/subscriptions","organizations_url":"https://api.github.com/users/jasontedor/orgs","repos_url":"https://api.github.com/users/jasontedor/repos","events_url":"https://api.github.com/users/jasontedor/events{/privacy}","received_events_url":"https://api.github.com/users/jasontedor/received_events","type":"User","site_admin":false},"created_at":"2018-05-21T13:56:01Z","updated_at":"2018-05-21T13:56:01Z","author_association":"MEMBER","body":"@jaymode I agree, I think that an external resource `@Rule` is worth pursuing. Thanks for picking this up.","performed_via_github_app":null}]