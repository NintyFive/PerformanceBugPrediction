[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/694983645","html_url":"https://github.com/elastic/elasticsearch/issues/62651#issuecomment-694983645","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/62651","id":694983645,"node_id":"MDEyOklzc3VlQ29tbWVudDY5NDk4MzY0NQ==","user":{"login":"elasticmachine","id":15837671,"node_id":"MDQ6VXNlcjE1ODM3Njcx","avatar_url":"https://avatars3.githubusercontent.com/u/15837671?v=4","gravatar_id":"","url":"https://api.github.com/users/elasticmachine","html_url":"https://github.com/elasticmachine","followers_url":"https://api.github.com/users/elasticmachine/followers","following_url":"https://api.github.com/users/elasticmachine/following{/other_user}","gists_url":"https://api.github.com/users/elasticmachine/gists{/gist_id}","starred_url":"https://api.github.com/users/elasticmachine/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/elasticmachine/subscriptions","organizations_url":"https://api.github.com/users/elasticmachine/orgs","repos_url":"https://api.github.com/users/elasticmachine/repos","events_url":"https://api.github.com/users/elasticmachine/events{/privacy}","received_events_url":"https://api.github.com/users/elasticmachine/received_events","type":"User","site_admin":false},"created_at":"2020-09-18T17:11:20Z","updated_at":"2020-09-18T17:11:20Z","author_association":"COLLABORATOR","body":"Pinging @elastic/es-ql (:Query Languages/EQL)","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/694986135","html_url":"https://github.com/elastic/elasticsearch/issues/62651#issuecomment-694986135","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/62651","id":694986135,"node_id":"MDEyOklzc3VlQ29tbWVudDY5NDk4NjEzNQ==","user":{"login":"rw-access","id":31489089,"node_id":"MDQ6VXNlcjMxNDg5MDg5","avatar_url":"https://avatars1.githubusercontent.com/u/31489089?v=4","gravatar_id":"","url":"https://api.github.com/users/rw-access","html_url":"https://github.com/rw-access","followers_url":"https://api.github.com/users/rw-access/followers","following_url":"https://api.github.com/users/rw-access/following{/other_user}","gists_url":"https://api.github.com/users/rw-access/gists{/gist_id}","starred_url":"https://api.github.com/users/rw-access/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/rw-access/subscriptions","organizations_url":"https://api.github.com/users/rw-access/orgs","repos_url":"https://api.github.com/users/rw-access/repos","events_url":"https://api.github.com/users/rw-access/events{/privacy}","received_events_url":"https://api.github.com/users/rw-access/received_events","type":"User","site_admin":false},"created_at":"2020-09-18T17:16:32Z","updated_at":"2020-09-18T17:16:32Z","author_association":"MEMBER","body":"> It would be good to get some numbers to see how often this pattern is being used.\r\n\r\nIf I were to take a SWAG, I would say approximately 95%+ of queries use this behavior currently.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/695067721","html_url":"https://github.com/elastic/elasticsearch/issues/62651#issuecomment-695067721","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/62651","id":695067721,"node_id":"MDEyOklzc3VlQ29tbWVudDY5NTA2NzcyMQ==","user":{"login":"rw-access","id":31489089,"node_id":"MDQ6VXNlcjMxNDg5MDg5","avatar_url":"https://avatars1.githubusercontent.com/u/31489089?v=4","gravatar_id":"","url":"https://api.github.com/users/rw-access","html_url":"https://github.com/rw-access","followers_url":"https://api.github.com/users/rw-access/followers","following_url":"https://api.github.com/users/rw-access/following{/other_user}","gists_url":"https://api.github.com/users/rw-access/gists{/gist_id}","starred_url":"https://api.github.com/users/rw-access/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/rw-access/subscriptions","organizations_url":"https://api.github.com/users/rw-access/orgs","repos_url":"https://api.github.com/users/rw-access/repos","events_url":"https://api.github.com/users/rw-access/events{/privacy}","received_events_url":"https://api.github.com/users/rw-access/received_events","type":"User","site_admin":false},"created_at":"2020-09-18T20:21:15Z","updated_at":"2020-09-18T20:22:43Z","author_association":"MEMBER","body":" I got some more stats\r\n* 84% of our production rules use wildcards, averaging 2.5 per rule. There are actually many more, but under the hood in the EQL engine for  python, adjacent usages with an `or` get compressed into one. I don't have numbers for Endgame users or other EQL in the wild.\r\n\r\nThe ease of wildcards was intentionally baked into EQL from day one, so I think we should approach it very carefully before we make plans to change this behavior. And it could be good to share some context to better understand the expectations and desires of EQL users and rule writers.\r\n\r\nWhen writing detections, you often don't have the full text and know _exactly_ what you're looking for, so wildcards are important. Wildcards are so prevalent that we deliberately made them first class, letting `==` and `!=` work for wildcard comparisons.\r\n\r\nI think it shows success that we've made it this long without needing to express a literal asterisk in a string comparison. All of these concerns have been hypothetical, and that really goes to show the value of and asterisk as a wildcard character. And we aren't the only database/query language to recognize how its importance outweighs the utility of a literal asterisk.\r\n\r\n**Addressing some of the side-affects you mentioned:**\r\n1. _one _cannot_ make a comparison to a string containing *._\r\n\r\nThere are _workarounds_ to do this, but I will concede that they aren't ideal. One example: `some_field in (\"string with literal * asterisk\")`\r\n\r\n2. _the comparison/wildcard inherits the semantics of equals such as case-insensitivity._\r\n\r\nAgreed, but I'm not sure how this is a unique side-effect\r\n\r\n3. _makes it hard to reason whether an expression is string equality or wildcard comparison_\r\n\r\nString equality is semantically identical to a wildcard comparison but without any wildcard characters, so I don't see an issue here. If the example you provided, `foo == concat(\"wild\", \"*\", \"card\")` is converted to a wildcard under the hood, then I would argue that it's a bug. You could make an argument that it's Undefined Behavior for EQL, but there is no documentation to suggest that this would be a wildcard comparison. All of the examples using wildcards use literal strings. Neither the [original documentation](https://eql.readthedocs.io/en/latest/query-guide/basic-syntax.html#strings) and the [elasticsearch documentation](/elasticsearch/reference/master/eql-syntax.html#eql-syntax-wildcards) makes no mention of wildcards for folded values.\r\n\r\n4. _for more than one pattern, the pattern ends up being more verbose_\r\n_`foo == \"wild*\" or foo == \"*card\" vs wildcard(foo, \"wild*\", \"*card\")`_\r\n\r\nYes, but this sounds like a feature not a bug.\r\n\r\n\r\n**Outstanding concerns**\r\nThe biggest problem I have is that this is the worst kind of breaking change: _a quiet one_.\r\n\r\n> My proposal is to deprecate/remove this syntactic sugar and promote explicit use of wildcard for clear semantics and clarity in intent.\r\n\r\nIt's impossible to deprecate this syntactic sugar, without coming up with a new character for quotes. Not to be a broken record, but **we can't quietly (aka no messages) change the _meaning_ of existing syntax**. Otherwise, users will have zero idea why queries that used to work no longer work.\r\n\r\n\r\n**TL;DR**\r\nIf I had to sum up this approach in a quick sentence it would be this:\r\n\"It's a feature, not a bug.\"\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/696043266","html_url":"https://github.com/elastic/elasticsearch/issues/62651#issuecomment-696043266","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/62651","id":696043266,"node_id":"MDEyOklzc3VlQ29tbWVudDY5NjA0MzI2Ng==","user":{"login":"astefan","id":893749,"node_id":"MDQ6VXNlcjg5Mzc0OQ==","avatar_url":"https://avatars2.githubusercontent.com/u/893749?v=4","gravatar_id":"","url":"https://api.github.com/users/astefan","html_url":"https://github.com/astefan","followers_url":"https://api.github.com/users/astefan/followers","following_url":"https://api.github.com/users/astefan/following{/other_user}","gists_url":"https://api.github.com/users/astefan/gists{/gist_id}","starred_url":"https://api.github.com/users/astefan/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/astefan/subscriptions","organizations_url":"https://api.github.com/users/astefan/orgs","repos_url":"https://api.github.com/users/astefan/repos","events_url":"https://api.github.com/users/astefan/events{/privacy}","received_events_url":"https://api.github.com/users/astefan/received_events","type":"User","site_admin":false},"created_at":"2020-09-21T10:58:58Z","updated_at":"2020-09-21T10:58:58Z","author_association":"CONTRIBUTOR","body":"I agree that this is an important feature @rw-access \r\n\r\n> The ease of wildcards was intentionally baked into EQL from day one, so I think we should approach it very carefully before we make plans to change this behavior. And it could be good to share some context to better understand the expectations and desires of EQL users and rule writers.\r\n\r\n> When writing detections, you often don't have the full text and know exactly what you're looking for, so wildcards are important. Wildcards are so prevalent that we deliberately made them first class, letting == and != work for wildcard comparisons.\r\n\r\nbut I cannot go over the inconsistency it adds to the language. The examples @costin provided show that a single use of the language could translate into two separate behaviors that cannot be reasoned about in a deterministic way. Is the user intention when writing `foo == concat(\"wild\", \"*\", \"card\")` either to be an exact match or a wildcard match? It could be that the user really wants to search for `wild*card` (exact match), even though the vast majority of other uses aim for the second way of using wildcards and one could argue that we make an exception in this case. But still, the language needs to be consistent and deterministic. Also, just like the other features that we want to evaluate at the eql language, [proposed changes could be deprecated in other eql implementations following those products deprecation flow and procedures](https://github.com/elastic/elasticsearch/issues/62663#issuecomment-696037464), but for ES EQL and its experimental current status, these could go in without any notice or warnings.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/696044742","html_url":"https://github.com/elastic/elasticsearch/issues/62651#issuecomment-696044742","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/62651","id":696044742,"node_id":"MDEyOklzc3VlQ29tbWVudDY5NjA0NDc0Mg==","user":{"login":"matriv","id":5058131,"node_id":"MDQ6VXNlcjUwNTgxMzE=","avatar_url":"https://avatars1.githubusercontent.com/u/5058131?v=4","gravatar_id":"","url":"https://api.github.com/users/matriv","html_url":"https://github.com/matriv","followers_url":"https://api.github.com/users/matriv/followers","following_url":"https://api.github.com/users/matriv/following{/other_user}","gists_url":"https://api.github.com/users/matriv/gists{/gist_id}","starred_url":"https://api.github.com/users/matriv/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/matriv/subscriptions","organizations_url":"https://api.github.com/users/matriv/orgs","repos_url":"https://api.github.com/users/matriv/repos","events_url":"https://api.github.com/users/matriv/events{/privacy}","received_events_url":"https://api.github.com/users/matriv/received_events","type":"User","site_admin":false},"created_at":"2020-09-21T11:02:12Z","updated_at":"2020-09-21T11:06:50Z","author_association":"CONTRIBUTOR","body":"This is a difficult decision, because unlike [replacing backquote with single quote](https://github.com/elastic/elasticsearch/pull/62638#issuecomment-695058034) were we have a clear behaviour and an error message, if we make this change users could come up with wrong results. On the other hand, I'm not fan of such syntactic sugar because although it can ease the life of a user in the common case, it can have ambiguous semantics as for example in the case of `foo == concat('wild', '*', 'card')`. Is it a way to bypass the translation to `wildcard()` function or is still considered a wildcard? What about `foo == ?\"wild*card\"`? What's happening for sequence matching keys? if we have an event/doc with value for key= \"wild*card\", and another event/doc with key=\"wildXXXXcard\" should they match?\r\n\r\nPersonally I'd always prefer clear semantics to user convenience. Imho. the `==` operator is the strongest operation for a filter in a query language, and it shouldn't have any syntactic sugar attached that translates it to something else. If we had to design the language from scratch, I'd rather have an operator like `~=` as syntactic sugar, which translates the `*` to a wildcard query, than changing the semantics of EQUAL based on the the string literal. \r\n\r\nTaking into consideration the fact that the change of this behaviour is \"silent\" and can lead to unexpected results, If we decide to make the change, and I'd vote towards it, let's make it now in the experimental stage, otherwise it will be impossible.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/696678478","html_url":"https://github.com/elastic/elasticsearch/issues/62651#issuecomment-696678478","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/62651","id":696678478,"node_id":"MDEyOklzc3VlQ29tbWVudDY5NjY3ODQ3OA==","user":{"login":"costin","id":76245,"node_id":"MDQ6VXNlcjc2MjQ1","avatar_url":"https://avatars3.githubusercontent.com/u/76245?v=4","gravatar_id":"","url":"https://api.github.com/users/costin","html_url":"https://github.com/costin","followers_url":"https://api.github.com/users/costin/followers","following_url":"https://api.github.com/users/costin/following{/other_user}","gists_url":"https://api.github.com/users/costin/gists{/gist_id}","starred_url":"https://api.github.com/users/costin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/costin/subscriptions","organizations_url":"https://api.github.com/users/costin/orgs","repos_url":"https://api.github.com/users/costin/repos","events_url":"https://api.github.com/users/costin/events{/privacy}","received_events_url":"https://api.github.com/users/costin/received_events","type":"User","site_admin":false},"created_at":"2020-09-22T12:06:49Z","updated_at":"2020-09-22T12:06:49Z","author_association":"MEMBER","body":"tl;dr\r\n\r\n`==` is arguably the most important operator in bool clauses. Its semantics and properties are well understood yet EQL breaks them.\r\nI'd like to get agreement that his is a bug and needs changing. If not, how do we resolve the inconsistencies brought by it.\r\n\r\nI don't want to get side-tracked by the actual details and timeline (deprecation, compatibility flags, etc...).\r\nThat is a separate discussion especially considering the high usage of `==`.\r\n\r\nTo your point on:\r\n\r\n> If the example you provided, foo == concat(\"wild\", \"*\", \"card\") is converted to a wildcard under the hood, then I would argue that it's a bug.  You could make an argument that it's Undefined Behavior for EQL, but there is no documentation to suggest that this would be a wildcard comparison. \r\n\r\n```\r\n// string eq\r\n\"abc\" == concat(\"ab\", \"c\")  // TRUE \r\n\"abc\" == concat(\"a\", \"bc\")  // TRUE\r\n// match eq\r\n\"abc\" == \"ab*\"              // TRUE\r\n// string eq\r\n\"abc\" == concat(\"ab\", \"*\")  // FALSE\r\n```\r\n\r\nThe above is basic math using an operator association and commutativity on **literals**.\r\n\r\nWith fields it becomes even more confusing:\r\n\r\n```\r\n// string eq\r\nfield == \"abc\"              // TRUE\r\nfield == concat(\"ab\", \"c\")  // TRUE\r\n\r\n// match eq\r\nfield == \"abc*\"             // TRUE\r\n// string eq\r\nfield == concat(\"ab\", \"c*\") // FALSE \r\n```\r\n\r\nWhich end up breaking transitivity:\r\n\r\n```\r\n// assume field == \"ab*\"\r\n\"ab\" == \"ab*\"               // TRUE\r\n\"ab*\" == field              // TRUE\r\n\"ab\" == field               //FALSE\r\n```\r\n\r\nThis is a big deal. Essentially `==` is not equals. \r\nSo why reuse the operator in the first place if it has different semantics?\r\n\r\n#### Proposal\r\n\r\nIntroduce a separate operator, say `~=` or `e=` (eql equals) that takes over the current `==` semantics, such as identifying the wildcard pattern and being case insensitive plus whatever other semantic we want to add moving forward. \r\nThis frees the `==` operator to mean exact equality and nothing else, just like the rest of the *operators*.\r\n\r\nPros:\r\n- `==` means equals just like everybody expects. No gotchas, footnotes or trappy behavior\r\n- `==` is aligned with the rest of the operators including `>=`, `<=`\r\n- the *custom* EQL semantics are captured by a *custom* operator \r\n\r\nCons:\r\n- breaking compatibility with existing queries. Requires 80-90% rewrites","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/696718859","html_url":"https://github.com/elastic/elasticsearch/issues/62651#issuecomment-696718859","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/62651","id":696718859,"node_id":"MDEyOklzc3VlQ29tbWVudDY5NjcxODg1OQ==","user":{"login":"rw-access","id":31489089,"node_id":"MDQ6VXNlcjMxNDg5MDg5","avatar_url":"https://avatars1.githubusercontent.com/u/31489089?v=4","gravatar_id":"","url":"https://api.github.com/users/rw-access","html_url":"https://github.com/rw-access","followers_url":"https://api.github.com/users/rw-access/followers","following_url":"https://api.github.com/users/rw-access/following{/other_user}","gists_url":"https://api.github.com/users/rw-access/gists{/gist_id}","starred_url":"https://api.github.com/users/rw-access/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/rw-access/subscriptions","organizations_url":"https://api.github.com/users/rw-access/orgs","repos_url":"https://api.github.com/users/rw-access/repos","events_url":"https://api.github.com/users/rw-access/events{/privacy}","received_events_url":"https://api.github.com/users/rw-access/received_events","type":"User","site_admin":false},"created_at":"2020-09-22T13:23:43Z","updated_at":"2020-09-22T13:23:43Z","author_association":"MEMBER","body":"I surveyed the primary users (@elastic/security-intelligence-analytics)of EQL, and it was unanimous (12/12) that `== \"wild*card\"` is a feature and not a bug.\n\nThis was a deliberate design decision and is one that is expected and desired. Maybe the `==` operator isn't interpreted as literally as you're proposing. But there appears to be no cognitive dissonance by the people that are already using the  I didn't ask ask for further analysis.\n\n\n We can talk more about this offline, but I think `== \"some*wildcard\"` should be here to stay.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/697247011","html_url":"https://github.com/elastic/elasticsearch/issues/62651#issuecomment-697247011","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/62651","id":697247011,"node_id":"MDEyOklzc3VlQ29tbWVudDY5NzI0NzAxMQ==","user":{"login":"costin","id":76245,"node_id":"MDQ6VXNlcjc2MjQ1","avatar_url":"https://avatars3.githubusercontent.com/u/76245?v=4","gravatar_id":"","url":"https://api.github.com/users/costin","html_url":"https://github.com/costin","followers_url":"https://api.github.com/users/costin/followers","following_url":"https://api.github.com/users/costin/following{/other_user}","gists_url":"https://api.github.com/users/costin/gists{/gist_id}","starred_url":"https://api.github.com/users/costin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/costin/subscriptions","organizations_url":"https://api.github.com/users/costin/orgs","repos_url":"https://api.github.com/users/costin/repos","events_url":"https://api.github.com/users/costin/events{/privacy}","received_events_url":"https://api.github.com/users/costin/received_events","type":"User","site_admin":false},"created_at":"2020-09-23T09:27:43Z","updated_at":"2020-09-23T10:07:50Z","author_association":"MEMBER","body":"A few more examples of `==` breaking down:\r\n\r\n```\r\n\"a\"  > \"A\"   // TRUE\r\n\"a\" == \"A\"   // TRUE\r\n\"a\" <= \"A\"   // FALSE\r\n\"a\" in (\"A\")   // FALSE\r\n```\r\n\r\n```\r\n\"ab\" == \"a*\"   // TRUE\r\n\"ab\" <= \"a*\"   // FALSE\r\n\"ab\" in (\"a*\") // FALSE\r\n```\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/697344065","html_url":"https://github.com/elastic/elasticsearch/issues/62651#issuecomment-697344065","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/62651","id":697344065,"node_id":"MDEyOklzc3VlQ29tbWVudDY5NzM0NDA2NQ==","user":{"login":"jpountz","id":299848,"node_id":"MDQ6VXNlcjI5OTg0OA==","avatar_url":"https://avatars2.githubusercontent.com/u/299848?v=4","gravatar_id":"","url":"https://api.github.com/users/jpountz","html_url":"https://github.com/jpountz","followers_url":"https://api.github.com/users/jpountz/followers","following_url":"https://api.github.com/users/jpountz/following{/other_user}","gists_url":"https://api.github.com/users/jpountz/gists{/gist_id}","starred_url":"https://api.github.com/users/jpountz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jpountz/subscriptions","organizations_url":"https://api.github.com/users/jpountz/orgs","repos_url":"https://api.github.com/users/jpountz/repos","events_url":"https://api.github.com/users/jpountz/events{/privacy}","received_events_url":"https://api.github.com/users/jpountz/received_events","type":"User","site_admin":false},"created_at":"2020-09-23T12:52:13Z","updated_at":"2020-09-23T12:52:13Z","author_association":"CONTRIBUTOR","body":"I find the semantics of `==` to be surprising too. While I understand how important wildcard matching is for users of EQL, I share Costin's concerns around giving `==` semantics that do not meet the requirements of an equivalence relation and are also very different from major query languages.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/697355751","html_url":"https://github.com/elastic/elasticsearch/issues/62651#issuecomment-697355751","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/62651","id":697355751,"node_id":"MDEyOklzc3VlQ29tbWVudDY5NzM1NTc1MQ==","user":{"login":"tsg","id":101817,"node_id":"MDQ6VXNlcjEwMTgxNw==","avatar_url":"https://avatars1.githubusercontent.com/u/101817?v=4","gravatar_id":"","url":"https://api.github.com/users/tsg","html_url":"https://github.com/tsg","followers_url":"https://api.github.com/users/tsg/followers","following_url":"https://api.github.com/users/tsg/following{/other_user}","gists_url":"https://api.github.com/users/tsg/gists{/gist_id}","starred_url":"https://api.github.com/users/tsg/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/tsg/subscriptions","organizations_url":"https://api.github.com/users/tsg/orgs","repos_url":"https://api.github.com/users/tsg/repos","events_url":"https://api.github.com/users/tsg/events{/privacy}","received_events_url":"https://api.github.com/users/tsg/received_events","type":"User","site_admin":false},"created_at":"2020-09-23T13:13:32Z","updated_at":"2020-09-23T13:13:56Z","author_association":"NONE","body":"To me, this is a hard decision. On one hand, I agree that `==` in the current form is surprising in the examples that Costin gave. If we release it like that in 7.10, we're stuck with it and might become a source of constant problems, so I totally understand the concern.\r\n\r\nOn the other hand, if we do this change and then all our example rules in the docs use `~=` and we need to tell people \"make sure you always use `~=` instead of `==` or you might miss events\", I think we made the EQL usability for security rules worse and we're affecting its chances for adoption. We don't expect, say, `<=` to be used often with strings, so while the semantics will be confusing, it might not matter all that much in practice. I'm also not sure if going as close as possible to SQL is what is best for us, in the end, we started a new language because the existing ones weren't a great fit. \r\n\r\nSo I, for one, don't have a clear opinion yet. I'm trying to speak to more people to understand how offputting having to always use `~=` would be to security users.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/697363375","html_url":"https://github.com/elastic/elasticsearch/issues/62651#issuecomment-697363375","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/62651","id":697363375,"node_id":"MDEyOklzc3VlQ29tbWVudDY5NzM2MzM3NQ==","user":{"login":"mark-dufresne","id":56889459,"node_id":"MDQ6VXNlcjU2ODg5NDU5","avatar_url":"https://avatars1.githubusercontent.com/u/56889459?v=4","gravatar_id":"","url":"https://api.github.com/users/mark-dufresne","html_url":"https://github.com/mark-dufresne","followers_url":"https://api.github.com/users/mark-dufresne/followers","following_url":"https://api.github.com/users/mark-dufresne/following{/other_user}","gists_url":"https://api.github.com/users/mark-dufresne/gists{/gist_id}","starred_url":"https://api.github.com/users/mark-dufresne/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mark-dufresne/subscriptions","organizations_url":"https://api.github.com/users/mark-dufresne/orgs","repos_url":"https://api.github.com/users/mark-dufresne/repos","events_url":"https://api.github.com/users/mark-dufresne/events{/privacy}","received_events_url":"https://api.github.com/users/mark-dufresne/received_events","type":"User","site_admin":false},"created_at":"2020-09-23T13:26:58Z","updated_at":"2020-09-23T16:48:16Z","author_association":"NONE","body":"I'll echo @rw-access's comments, speaking for the security user. Elastic's Security Solution is better if we leave this pattern in place.\r\n\r\nWildcards are extensively employed by security users. I'm unaware of users disapproving of the behavior in place today. They've appreciated the simplicity, readability, and ease of use in many EQL features, including our treatment of wildcards. Echo'ing @tsg, these usability factors with EQL and Detection Rules directly support one of the Solution's primary differentiators. We did it this way for a good reason. I'd expect but don't want to assume that the other Solutions would agree.\r\n\r\nFor what it's worth, [Splunk](https://docs.splunk.com/Documentation/SCS/current/Search/Wildcards) does it like we do today (@rw-access edit: for both wildcards _and_ case-insensitivity by default. Also, Microsoft KQL has this behavior for wildcards, although their usage is limited to prefix queries). They allow users to search for asterisks via character escaping. This implies they came to a similar conclusion about what users  expect and want.\r\n\r\n\r\n\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/697391554","html_url":"https://github.com/elastic/elasticsearch/issues/62651#issuecomment-697391554","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/62651","id":697391554,"node_id":"MDEyOklzc3VlQ29tbWVudDY5NzM5MTU1NA==","user":{"login":"rw-access","id":31489089,"node_id":"MDQ6VXNlcjMxNDg5MDg5","avatar_url":"https://avatars1.githubusercontent.com/u/31489089?v=4","gravatar_id":"","url":"https://api.github.com/users/rw-access","html_url":"https://github.com/rw-access","followers_url":"https://api.github.com/users/rw-access/followers","following_url":"https://api.github.com/users/rw-access/following{/other_user}","gists_url":"https://api.github.com/users/rw-access/gists{/gist_id}","starred_url":"https://api.github.com/users/rw-access/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/rw-access/subscriptions","organizations_url":"https://api.github.com/users/rw-access/orgs","repos_url":"https://api.github.com/users/rw-access/repos","events_url":"https://api.github.com/users/rw-access/events{/privacy}","received_events_url":"https://api.github.com/users/rw-access/received_events","type":"User","site_admin":false},"created_at":"2020-09-23T13:54:27Z","updated_at":"2020-09-23T17:01:53Z","author_association":"MEMBER","body":"There are some bugs here:\r\n  \r\n> A few more examples of `==` breaking down:\r\n\r\n```\r\n\"a\"  > \"A\"   // TRUE --> this isn't ==, so irrelevant. this is more about case sensitivity than equality\r\n\"a\" == \"A\"   // TRUE\r\n\"a\" <= \"A\"   // FALSE --> we just need to define whether this operator was case-sensitive or insensitive. my impression was that this operator is always sensitive. \r\n\"a\" in (\"A\")   // FALSE --> this is a bug. should be TRUE.\r\n```\r\n\r\n```\r\n\"ab\" == \"a*\"   // TRUE\r\n\"ab\" <= \"a*\"   // FALSE --> isn't == so wildcards aren't expanded. behaves differently and in a well defined way.\r\n\"ab\" in (\"a*\") // FALSE --> correct, but we could resolve this inconsistency and make this TRUE\r\n```\r\nAll string comparisons for Python EQL (and other Elastic Endgame implementations) are case-insensitive. This `==` functions, `in`, `startsWith` and other comparison functions.\r\n\r\nOriginally, range queries (`<`, `<=`, `>=`, `>`) were case-sensitive (feature or bug, up for debate), but at one point, we said in a sync that this exception was a bug, so https://github.com/elastic/elasticsearch/issues/56771 and https://github.com/endgameinc/eql/issues/30 were opened. Looks like we've double backed, but that's fine.\r\n\r\nI don't see that as an issue, just a matter of defining behavior. Comparing strings lexicographically is a pretty rare, but does exist. I don't think we need to overextend for the one use case.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/698017348","html_url":"https://github.com/elastic/elasticsearch/issues/62651#issuecomment-698017348","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/62651","id":698017348,"node_id":"MDEyOklzc3VlQ29tbWVudDY5ODAxNzM0OA==","user":{"login":"costin","id":76245,"node_id":"MDQ6VXNlcjc2MjQ1","avatar_url":"https://avatars3.githubusercontent.com/u/76245?v=4","gravatar_id":"","url":"https://api.github.com/users/costin","html_url":"https://github.com/costin","followers_url":"https://api.github.com/users/costin/followers","following_url":"https://api.github.com/users/costin/following{/other_user}","gists_url":"https://api.github.com/users/costin/gists{/gist_id}","starred_url":"https://api.github.com/users/costin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/costin/subscriptions","organizations_url":"https://api.github.com/users/costin/orgs","repos_url":"https://api.github.com/users/costin/repos","events_url":"https://api.github.com/users/costin/events{/privacy}","received_events_url":"https://api.github.com/users/costin/received_events","type":"User","site_admin":false},"created_at":"2020-09-23T23:08:43Z","updated_at":"2020-09-24T06:25:10Z","author_association":"MEMBER","body":"First off, thanks for engaging folks!\r\n\r\nI recognize the security focus of EQL however the vision for Elasticsearch EQL is to grow beyond that and cater to *any* user of Elasticsearch.\r\n\r\n@mark-dufresne\r\nI understand that wildcards and case insensitive string comparison are extremely common and a core feature. My intent is not to remove this functionality rather make it consistent with the rest of the languages and semantics in Elasticsearch.\r\n\r\n> For what it's worth, Splunk does it like we do today (@rw-access edit: for both wildcards and case-insensitivity by default.\r\n\r\nI'm not too familiar with Splunk; my understanding is the context/command/pipe defines the semantics. The wildcard you linked to is applied only inside a `search` context while it is unsupported in [`where`](https://docs.splunk.com/Documentation/Splunk/8.0.6/SearchReference/Where). Same seems to apply for operators.\r\n\r\n> Microsoft KQL has this behavior for wildcards\r\n\r\nUnless I'm looking at the wrong language, [the documentation](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/datatypes-string-operators) indicates `==` to be *exact* and case sensitive.\r\nIn fact for case insensitive comparison one should use `=~` and `!~`. Which is what I'm arguing for. \r\n\r\n@rw-access\r\n\r\n>\r\n>```\r\n>\"a\"  > \"A\"   // TRUE --> this isn't ==, so irrelevant.\r\n>\"a\" == \"A\"   // TRUE\r\n>```\r\n\r\nThe `>` and `==` are crucial: two invariants that contradict each other.\r\n\r\n>```\r\n>\"a\" <= \"A\"   // FALSE --> we just need to define whether this operator was case-sensitive or insensitive. my >impression was that this operator is always sensitive. \r\n>```\r\n\r\n`<=` is already defined as `< or ==`.  Not in EQL: \r\n\r\n```\r\n\"a\" < \"A\" or \"a\" == \"A\" // TRUE \r\n\"a\" <= \"A\" // FALSE\r\n```\r\n\r\nSame for wildcards:\r\n\r\n>```\r\n>\"ab\" <= \"a*\"   // FALSE\r\n> --> isn't == so wildcards aren't expanded. behaves differently and in a well defined way.\r\n>```\r\n\r\n`<=` not being equivalent to `< or =` is a bug.\r\n\r\n>```\r\n>\"ab\" in (\"a*\") // FALSE --> correct, but we could resolve this inconsistency and make this TRUE\r\n>```\r\n\r\nI've used `in` on purpose since you pointed to it [above](https://github.com/elastic/elasticsearch/issues/62651#issuecomment-695067721) due to its \"exact\" nature, as a workaround for comparing strings containing `*`:\r\n> There are workarounds to do this, but I will concede that they aren't ideal. One example: some_field in (\"string with literal * asterisk\")\r\n\r\nAnother example of unexpected behavior that surprises even power users. \r\n\r\n> but at one point, we said in a sync that this exception was a bug, so #56771 and endgameinc/eql#30 were opened. Looks like we've double backed, but that's fine.\r\n\r\nThis is inaccurate. \r\nThe `==` semantics were always an issue hence why we discussed them at length and we still do since invariants get broken. It's the reason why the `case_sensitive` parameter was added which is now being removed.\r\nCase sensitive comparisons were **never** implemented in Elasticsearch EQL; further more we agreed to keep them as such - see #61883 and #62255.\r\nI'm not sure what makes you think otherwise...\r\n\r\n#### [Moving forward](#proposal)\r\n\r\nFolks, inside QL we've given quite a lot of thought to this topic, starting with #54411 in March. Yet despite our best efforts, so far we haven't found a solid solution.\r\n\r\nWhat's clear to me is EQL should out of the box provide case-insensitive equality check with wildcard support.\r\n\r\nHence why I propose the following:\r\n\r\n1. Introduce a separate operator that offers this semantics. Whether it's `~=`/`~!` or `=~`/`!~` remains to be decided. This will perform string case-*in*sensitive comparison and support `*` expansion.\r\n2. Make `==` and `!=` be exact, meaning case-sensitive and unaware of any wildcard.\r\n3. Introduce a compatibility flag (name to be decided) that will make equal/non-equal an alias to the operator in step 1. The purpose of this flag is to allow existing rules and users to migrate to the new operator.\r\n\r\nPro:\r\n- `==`, `>=`, `<=` etc work consistently and as expected, no invariants are broken.\r\n- `=~`/`!~` are independent from the other operators and do not combine with them. However if we desire, we have the option of introducing others (e.g. `>~`).\r\n- existing users can easily migrate to Elasticsearch\r\n\r\nCons:\r\n- existing users and queries have to be changed. However the compatibility flag & co (deprecation messages + query analysis, etc..) can help with the transition.\r\n\r\n```\r\n\"a\"  > \"A\" // TRUE\r\n\"a\" >= \"A\" // TRUE\r\n\"a\" == \"A\" // FALSE\r\n\r\n\"a\" =~ \"A\" // TRUE\r\n\r\n\"ab\" == \"aB\" // FALSE\r\n\"ab\" == \"a*\" // FALSE\r\n\"ab\" =~ \"a*\" // TRUE\r\n\"ab\" =~ \"aB\" // TRUE\r\n```\r\n\r\nLet me know you think.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/699950517","html_url":"https://github.com/elastic/elasticsearch/issues/62651#issuecomment-699950517","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/62651","id":699950517,"node_id":"MDEyOklzc3VlQ29tbWVudDY5OTk1MDUxNw==","user":{"login":"costin","id":76245,"node_id":"MDQ6VXNlcjc2MjQ1","avatar_url":"https://avatars3.githubusercontent.com/u/76245?v=4","gravatar_id":"","url":"https://api.github.com/users/costin","html_url":"https://github.com/costin","followers_url":"https://api.github.com/users/costin/followers","following_url":"https://api.github.com/users/costin/following{/other_user}","gists_url":"https://api.github.com/users/costin/gists{/gist_id}","starred_url":"https://api.github.com/users/costin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/costin/subscriptions","organizations_url":"https://api.github.com/users/costin/orgs","repos_url":"https://api.github.com/users/costin/repos","events_url":"https://api.github.com/users/costin/events{/privacy}","received_events_url":"https://api.github.com/users/costin/received_events","type":"User","site_admin":false},"created_at":"2020-09-28T11:32:17Z","updated_at":"2020-09-28T11:32:17Z","author_association":"MEMBER","body":"Thanks everyone for the discussion.\r\nAfter further discussing the ticket offline, it was decided to go ahead and make EQL case sensitive/exact by default and move the case-insensitive equality and wildcard pattern matching to a separate operator.\r\nSee https://github.com/elastic/elasticsearch/issues/62949 for more information.","performed_via_github_app":null}]