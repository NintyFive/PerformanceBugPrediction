[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/546136281","html_url":"https://github.com/elastic/elasticsearch/issues/48493#issuecomment-546136281","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/48493","id":546136281,"node_id":"MDEyOklzc3VlQ29tbWVudDU0NjEzNjI4MQ==","user":{"login":"elasticmachine","id":15837671,"node_id":"MDQ6VXNlcjE1ODM3Njcx","avatar_url":"https://avatars3.githubusercontent.com/u/15837671?v=4","gravatar_id":"","url":"https://api.github.com/users/elasticmachine","html_url":"https://github.com/elasticmachine","followers_url":"https://api.github.com/users/elasticmachine/followers","following_url":"https://api.github.com/users/elasticmachine/following{/other_user}","gists_url":"https://api.github.com/users/elasticmachine/gists{/gist_id}","starred_url":"https://api.github.com/users/elasticmachine/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/elasticmachine/subscriptions","organizations_url":"https://api.github.com/users/elasticmachine/orgs","repos_url":"https://api.github.com/users/elasticmachine/repos","events_url":"https://api.github.com/users/elasticmachine/events{/privacy}","received_events_url":"https://api.github.com/users/elasticmachine/received_events","type":"User","site_admin":false},"created_at":"2019-10-24T23:03:41Z","updated_at":"2019-10-24T23:03:41Z","author_association":"COLLABORATOR","body":"Pinging @elastic/es-distributed (:Distributed/Snapshot/Restore)","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/546136283","html_url":"https://github.com/elastic/elasticsearch/issues/48493#issuecomment-546136283","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/48493","id":546136283,"node_id":"MDEyOklzc3VlQ29tbWVudDU0NjEzNjI4Mw==","user":{"login":"elasticmachine","id":15837671,"node_id":"MDQ6VXNlcjE1ODM3Njcx","avatar_url":"https://avatars3.githubusercontent.com/u/15837671?v=4","gravatar_id":"","url":"https://api.github.com/users/elasticmachine","html_url":"https://github.com/elasticmachine","followers_url":"https://api.github.com/users/elasticmachine/followers","following_url":"https://api.github.com/users/elasticmachine/following{/other_user}","gists_url":"https://api.github.com/users/elasticmachine/gists{/gist_id}","starred_url":"https://api.github.com/users/elasticmachine/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/elasticmachine/subscriptions","organizations_url":"https://api.github.com/users/elasticmachine/orgs","repos_url":"https://api.github.com/users/elasticmachine/repos","events_url":"https://api.github.com/users/elasticmachine/events{/privacy}","received_events_url":"https://api.github.com/users/elasticmachine/received_events","type":"User","site_admin":false},"created_at":"2019-10-24T23:03:42Z","updated_at":"2019-10-24T23:03:42Z","author_association":"COLLABORATOR","body":"Pinging @elastic/es-core-features (:Core/Features/ILM+SLM)","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/546205321","html_url":"https://github.com/elastic/elasticsearch/issues/48493#issuecomment-546205321","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/48493","id":546205321,"node_id":"MDEyOklzc3VlQ29tbWVudDU0NjIwNTMyMQ==","user":{"login":"original-brownbear","id":6490959,"node_id":"MDQ6VXNlcjY0OTA5NTk=","avatar_url":"https://avatars0.githubusercontent.com/u/6490959?v=4","gravatar_id":"","url":"https://api.github.com/users/original-brownbear","html_url":"https://github.com/original-brownbear","followers_url":"https://api.github.com/users/original-brownbear/followers","following_url":"https://api.github.com/users/original-brownbear/following{/other_user}","gists_url":"https://api.github.com/users/original-brownbear/gists{/gist_id}","starred_url":"https://api.github.com/users/original-brownbear/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/original-brownbear/subscriptions","organizations_url":"https://api.github.com/users/original-brownbear/orgs","repos_url":"https://api.github.com/users/original-brownbear/repos","events_url":"https://api.github.com/users/original-brownbear/events{/privacy}","received_events_url":"https://api.github.com/users/original-brownbear/received_events","type":"User","site_admin":false},"created_at":"2019-10-25T05:22:31Z","updated_at":"2019-10-25T05:22:31Z","author_association":"MEMBER","body":"I would hope that we can implement this in a way that doesn't require blocking all snapshot operations while the key rotation is happening. We are currently looking into allowing parallel operations on the repository (i.e. allowing delete, create to run at the same time) and I'd hope we can somehow fold this into that effort.\r\nIf we don't allow the key-rotation to run in parallel, we'll introduce a large window during which the user can't snapshot (since rotating the key effectively means re-uploading the whole repo) which might not be desirable?\r\n\r\nI think with the recent work in #46250 and upcoming work building on top of it, we should be able to implement key-rotation in parallel to other operations by simply rewriting the data shard by shard and only locking the repo for brief period of time when updating the shard-level metadata.\r\nConcretely I'd imagine key rotation to work like this:\r\n\r\n1. Start key rotation which puts a `RepositoryKeyRotationInProgress` entry into the CS that keeps track of all shards in the repository in the same way `ShardGenerations already does`.\r\n2. Rotate keys shard by shard on the data nodes (those could be holding the blobs/files to be re-encrypted locally already! Saving downloading the blobs if we're a little smart about the allocation of the rotation tasks here) and update the status of the rotation in the CS.\r\n\r\nWhile a `RepositoryKeyRotationInProgress` is in progress:\r\n* We do all new snapshotting/deleting using the new key already\r\n* We only have to lock the step of updating the per-shard metadata on a per-shard basis instead of the whole repository\r\n\r\nI think we will have to be smart about this anyway in that we probably want to distribute the key-rotation step (just running this on a single (master-)node means a lot of encrypting and data transfer in and out of that single node) so adding the parallelism to this operation when we're looking into parallelising other operations already anyway seems like the way to go here.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/546227939","html_url":"https://github.com/elastic/elasticsearch/issues/48493#issuecomment-546227939","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/48493","id":546227939,"node_id":"MDEyOklzc3VlQ29tbWVudDU0NjIyNzkzOQ==","user":{"login":"bizybot","id":902768,"node_id":"MDQ6VXNlcjkwMjc2OA==","avatar_url":"https://avatars2.githubusercontent.com/u/902768?v=4","gravatar_id":"","url":"https://api.github.com/users/bizybot","html_url":"https://github.com/bizybot","followers_url":"https://api.github.com/users/bizybot/followers","following_url":"https://api.github.com/users/bizybot/following{/other_user}","gists_url":"https://api.github.com/users/bizybot/gists{/gist_id}","starred_url":"https://api.github.com/users/bizybot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bizybot/subscriptions","organizations_url":"https://api.github.com/users/bizybot/orgs","repos_url":"https://api.github.com/users/bizybot/repos","events_url":"https://api.github.com/users/bizybot/events{/privacy}","received_events_url":"https://api.github.com/users/bizybot/received_events","type":"User","site_admin":false},"created_at":"2019-10-25T06:56:32Z","updated_at":"2019-10-25T06:56:32Z","author_association":"CONTRIBUTOR","body":"Thank you @original-brownbear for your comments.\r\n\r\n> I would hope that we can implement this in a way that doesn't require blocking all snapshot operations while the key rotation is happening.\r\n\r\nYes, if we can do it then that would be the preferred way.\r\nBut considering there other operations like deletion/repo-cleanup I guess it could be problematic doing key rotation and deletion in parallel and may even incur unnecessary work when eventually we are going to delete those files.\r\nSnapshot operation might be fine as it can use the new key but restore will fail (if the key rotation is not yet complete and you use the new key to decrypt). This also introduces too many ways to fail if not done properly.\r\n\r\n> If we don't allow the key-rotation to run in parallel, we'll introduce a large window during which the user can't snapshot (since rotating the key effectively means re-uploading the whole repo) which might not be desirable?\r\n> \r\n\r\nI think it is desirable to do the key rotation in parallel and if we can do it then awesome.\r\nThe key rotation process involves downloading only the metadata files containing encrypted DEK and re-encrypting it with a new KEK. _Note that we do not need to do this for the whole encrypted blobs but only for the metadata files containing the data encryption key encrypted using the old master key_. So _if we do this rotate operation in parallel for all metadata files for all snapshots then it could be faster_ assuming we can selectively work with the metadata files from the repository.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/546261026","html_url":"https://github.com/elastic/elasticsearch/issues/48493#issuecomment-546261026","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/48493","id":546261026,"node_id":"MDEyOklzc3VlQ29tbWVudDU0NjI2MTAyNg==","user":{"login":"original-brownbear","id":6490959,"node_id":"MDQ6VXNlcjY0OTA5NTk=","avatar_url":"https://avatars0.githubusercontent.com/u/6490959?v=4","gravatar_id":"","url":"https://api.github.com/users/original-brownbear","html_url":"https://github.com/original-brownbear","followers_url":"https://api.github.com/users/original-brownbear/followers","following_url":"https://api.github.com/users/original-brownbear/following{/other_user}","gists_url":"https://api.github.com/users/original-brownbear/gists{/gist_id}","starred_url":"https://api.github.com/users/original-brownbear/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/original-brownbear/subscriptions","organizations_url":"https://api.github.com/users/original-brownbear/orgs","repos_url":"https://api.github.com/users/original-brownbear/repos","events_url":"https://api.github.com/users/original-brownbear/events{/privacy}","received_events_url":"https://api.github.com/users/original-brownbear/received_events","type":"User","site_admin":false},"created_at":"2019-10-25T08:39:28Z","updated_at":"2019-10-25T08:39:28Z","author_association":"MEMBER","body":"> The key rotation process involves downloading only the metadata files containing encrypted DEK and re-encrypting it with a new KEK. \r\n\r\nright ... my bad :) Actually now I remember my original idea for this as well from the Google Doc (thanks for refreshing my memory :)) \r\nI think we can simply do key ratation without any blocking/locking whatsoever this way:\r\n\r\n1. Rotate key via a CS event, so there is a clear point at which new writes to the repo use the new key.\r\n2. Keep a reference to the fact that old keys are still used in the CS. As long as this reference in the CS is around the logic should try using the old key for decryption frst and then if it doesn't exist use the new key (this order is important so we don't accidentally read a non-existent new key metablob when it doesn't exist and mess up first-read-after-write consistency on S3).\r\n3. Simply list out all the meta blobs with the old keys in them (we can do this efficiently by changing the prefix of the meta-blobs when we change keys) and then write updated versions for them.\r\n4. Remove reference to old keys still being in use from the CS and only use the new-key prefix meta blobs going forward.\r\n\r\n> But considering there other operations like deletion/repo-cleanup I guess it could be problematic doing key rotation and deletion in parallel and may even incur unnecessary work when eventually we are going to delete those files.\r\n\r\nTrue, but I'd say that's something we can optimize for later. Key rotation is a relatively rare event and how efficient it is in terms of API call counts might not matter too much? I think it's likely the right trade-off to live with some redundant metadata updates but keep the repository fully functional during key-ratation compared to blocking the repository for potentially hours to save a trivial amount of work (logically you could also argue that if you pause deletes to prevent concurrent deletes you'll waste the effort for updating meta-blobs for blobs that you'll delete right after the pause anyway ...).\r\n\r\n-> I think the steps in the Google doc and in this comment are still a valid approach here","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/548151787","html_url":"https://github.com/elastic/elasticsearch/issues/48493#issuecomment-548151787","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/48493","id":548151787,"node_id":"MDEyOklzc3VlQ29tbWVudDU0ODE1MTc4Nw==","user":{"login":"bizybot","id":902768,"node_id":"MDQ6VXNlcjkwMjc2OA==","avatar_url":"https://avatars2.githubusercontent.com/u/902768?v=4","gravatar_id":"","url":"https://api.github.com/users/bizybot","html_url":"https://github.com/bizybot","followers_url":"https://api.github.com/users/bizybot/followers","following_url":"https://api.github.com/users/bizybot/following{/other_user}","gists_url":"https://api.github.com/users/bizybot/gists{/gist_id}","starred_url":"https://api.github.com/users/bizybot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bizybot/subscriptions","organizations_url":"https://api.github.com/users/bizybot/orgs","repos_url":"https://api.github.com/users/bizybot/repos","events_url":"https://api.github.com/users/bizybot/events{/privacy}","received_events_url":"https://api.github.com/users/bizybot/received_events","type":"User","site_admin":false},"created_at":"2019-10-30T23:15:29Z","updated_at":"2019-10-30T23:15:47Z","author_association":"CONTRIBUTOR","body":"Thank you @original-brownbear for your inputs.\r\nI see your point and makes sense for us not to pause the whole process as things can be achieved in parallel operations.\r\n\r\nI am closing this issue as I do not see a need for this API anymore. Thank you.\r\n","performed_via_github_app":null}]