{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/45371","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/45371/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/45371/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/45371/events","html_url":"https://github.com/elastic/elasticsearch/issues/45371","id":478842054,"node_id":"MDU6SXNzdWU0Nzg4NDIwNTQ=","number":45371,"title":"Optimize indexing by replacing sychroinzed lock of TranslogWriter.add  by Disruptor  in async mode","user":{"login":"dengweisysu","id":18375623,"node_id":"MDQ6VXNlcjE4Mzc1NjIz","avatar_url":"https://avatars1.githubusercontent.com/u/18375623?v=4","gravatar_id":"","url":"https://api.github.com/users/dengweisysu","html_url":"https://github.com/dengweisysu","followers_url":"https://api.github.com/users/dengweisysu/followers","following_url":"https://api.github.com/users/dengweisysu/following{/other_user}","gists_url":"https://api.github.com/users/dengweisysu/gists{/gist_id}","starred_url":"https://api.github.com/users/dengweisysu/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dengweisysu/subscriptions","organizations_url":"https://api.github.com/users/dengweisysu/orgs","repos_url":"https://api.github.com/users/dengweisysu/repos","events_url":"https://api.github.com/users/dengweisysu/events{/privacy}","received_events_url":"https://api.github.com/users/dengweisysu/received_events","type":"User","site_admin":false},"labels":[{"id":836542781,"node_id":"MDU6TGFiZWw4MzY1NDI3ODE=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/:Distributed/Engine","name":":Distributed/Engine","color":"0e8a16","default":false,"description":"Anything around managing Lucene and the Translog in an open shard."}],"state":"closed","locked":false,"assignee":{"login":"s1monw","id":973334,"node_id":"MDQ6VXNlcjk3MzMzNA==","avatar_url":"https://avatars0.githubusercontent.com/u/973334?v=4","gravatar_id":"","url":"https://api.github.com/users/s1monw","html_url":"https://github.com/s1monw","followers_url":"https://api.github.com/users/s1monw/followers","following_url":"https://api.github.com/users/s1monw/following{/other_user}","gists_url":"https://api.github.com/users/s1monw/gists{/gist_id}","starred_url":"https://api.github.com/users/s1monw/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/s1monw/subscriptions","organizations_url":"https://api.github.com/users/s1monw/orgs","repos_url":"https://api.github.com/users/s1monw/repos","events_url":"https://api.github.com/users/s1monw/events{/privacy}","received_events_url":"https://api.github.com/users/s1monw/received_events","type":"User","site_admin":false},"assignees":[{"login":"s1monw","id":973334,"node_id":"MDQ6VXNlcjk3MzMzNA==","avatar_url":"https://avatars0.githubusercontent.com/u/973334?v=4","gravatar_id":"","url":"https://api.github.com/users/s1monw","html_url":"https://github.com/s1monw","followers_url":"https://api.github.com/users/s1monw/followers","following_url":"https://api.github.com/users/s1monw/following{/other_user}","gists_url":"https://api.github.com/users/s1monw/gists{/gist_id}","starred_url":"https://api.github.com/users/s1monw/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/s1monw/subscriptions","organizations_url":"https://api.github.com/users/s1monw/orgs","repos_url":"https://api.github.com/users/s1monw/repos","events_url":"https://api.github.com/users/s1monw/events{/privacy}","received_events_url":"https://api.github.com/users/s1monw/received_events","type":"User","site_admin":false}],"milestone":null,"comments":7,"created_at":"2019-08-09T07:34:16Z","updated_at":"2019-08-22T20:16:14Z","closed_at":"2019-08-22T20:16:14Z","author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"When indexing big data in high speed, sychronized lock of TranslogWriter.add will waste a lot of time. Here is some situations that Completing for sync lock happens:\r\n\r\n- with many other thread  writing the same index shard \r\n- flush  trigger by IndexService.AsyncTranslogFSync\r\n- flush  trigger when translog reach flush_threshold_size \r\n- flush trigger when rolling generation\r\n\r\nfor user,  translog durability strategy was set **async** , but there are still much performance  losed (about 50% in my situation) compared with no translog writing. So I try to using RingBuffer(Disruptor) to make  translog adding **lock free** for writing thread.\r\n\r\nTest scenarios:\r\n- machine: Cpu=24 core, memory=64G\r\n- doc count: 10 million\r\n- field count per doc: 400+\r\n- translog size per doc: about 3k （34G tlog generate for 10 million doc）\r\n\r\nelasticsearch node config and index config:\r\n    \r\n    # large size to reduce times of full flush\r\n    translog.flush_threshold_size: 30G （default 512M）\r\n    index.translog.sync_interval: 60s （default 5s）\r\n\r\n    indices.memory.index_buffer_size: 20% (default 10%)\r\n\r\nIndexing elapsed time for  each scene list below:\r\n\r\n- translog open with async durability model : 18 minutes\r\n- translog close (change source code) : 12 minutes\r\n- translog writing async using disruptor(change source code) : 12 minutes\r\n\r\nreference: https://lmax-exchange.github.io/disruptor/","closed_by":{"login":"dnhatn","id":13474362,"node_id":"MDQ6VXNlcjEzNDc0MzYy","avatar_url":"https://avatars3.githubusercontent.com/u/13474362?v=4","gravatar_id":"","url":"https://api.github.com/users/dnhatn","html_url":"https://github.com/dnhatn","followers_url":"https://api.github.com/users/dnhatn/followers","following_url":"https://api.github.com/users/dnhatn/following{/other_user}","gists_url":"https://api.github.com/users/dnhatn/gists{/gist_id}","starred_url":"https://api.github.com/users/dnhatn/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dnhatn/subscriptions","organizations_url":"https://api.github.com/users/dnhatn/orgs","repos_url":"https://api.github.com/users/dnhatn/repos","events_url":"https://api.github.com/users/dnhatn/events{/privacy}","received_events_url":"https://api.github.com/users/dnhatn/received_events","type":"User","site_admin":false},"performed_via_github_app":null}