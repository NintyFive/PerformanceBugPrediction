[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/477927689","html_url":"https://github.com/elastic/elasticsearch/issues/40621#issuecomment-477927689","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/40621","id":477927689,"node_id":"MDEyOklzc3VlQ29tbWVudDQ3NzkyNzY4OQ==","user":{"login":"elasticmachine","id":15837671,"node_id":"MDQ6VXNlcjE1ODM3Njcx","avatar_url":"https://avatars3.githubusercontent.com/u/15837671?v=4","gravatar_id":"","url":"https://api.github.com/users/elasticmachine","html_url":"https://github.com/elasticmachine","followers_url":"https://api.github.com/users/elasticmachine/followers","following_url":"https://api.github.com/users/elasticmachine/following{/other_user}","gists_url":"https://api.github.com/users/elasticmachine/gists{/gist_id}","starred_url":"https://api.github.com/users/elasticmachine/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/elasticmachine/subscriptions","organizations_url":"https://api.github.com/users/elasticmachine/orgs","repos_url":"https://api.github.com/users/elasticmachine/repos","events_url":"https://api.github.com/users/elasticmachine/events{/privacy}","received_events_url":"https://api.github.com/users/elasticmachine/received_events","type":"User","site_admin":false},"created_at":"2019-03-29T09:22:16Z","updated_at":"2019-03-29T09:22:16Z","author_association":"COLLABORATOR","body":"Pinging @elastic/es-analytics-geo","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/477937432","html_url":"https://github.com/elastic/elasticsearch/issues/40621#issuecomment-477937432","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/40621","id":477937432,"node_id":"MDEyOklzc3VlQ29tbWVudDQ3NzkzNzQzMg==","user":{"login":"jimczi","id":15977469,"node_id":"MDQ6VXNlcjE1OTc3NDY5","avatar_url":"https://avatars0.githubusercontent.com/u/15977469?v=4","gravatar_id":"","url":"https://api.github.com/users/jimczi","html_url":"https://github.com/jimczi","followers_url":"https://api.github.com/users/jimczi/followers","following_url":"https://api.github.com/users/jimczi/following{/other_user}","gists_url":"https://api.github.com/users/jimczi/gists{/gist_id}","starred_url":"https://api.github.com/users/jimczi/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jimczi/subscriptions","organizations_url":"https://api.github.com/users/jimczi/orgs","repos_url":"https://api.github.com/users/jimczi/repos","events_url":"https://api.github.com/users/jimczi/events{/privacy}","received_events_url":"https://api.github.com/users/jimczi/received_events","type":"User","site_admin":false},"created_at":"2019-03-29T09:53:40Z","updated_at":"2019-03-29T09:53:40Z","author_association":"MEMBER","body":"> However there must be a way to build a aggregation query that returns documents with a doc_count 0 which are also filtered by a filter aggregation.\r\n\r\nThe `terms` aggregation returns buckets not documents so with `min_doc_count` set to 1 you ensure that all buckets contains at least one document that match the query and the aggregation filter. Now if you set `min_doc_count` to 0 this means that you also want to take into account terms that don't appear in any of the documents that match the query **and** the agg filter. I don't see how it would be possible to return a term with a doc_count of 0 if it appears in a document that match the filter aggregation, the fact that it matches the filter implicitly sets the doc_count to at least 1 for the term. ","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/478057533","html_url":"https://github.com/elastic/elasticsearch/issues/40621#issuecomment-478057533","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/40621","id":478057533,"node_id":"MDEyOklzc3VlQ29tbWVudDQ3ODA1NzUzMw==","user":{"login":"m5tt","id":12707929,"node_id":"MDQ6VXNlcjEyNzA3OTI5","avatar_url":"https://avatars3.githubusercontent.com/u/12707929?v=4","gravatar_id":"","url":"https://api.github.com/users/m5tt","html_url":"https://github.com/m5tt","followers_url":"https://api.github.com/users/m5tt/followers","following_url":"https://api.github.com/users/m5tt/following{/other_user}","gists_url":"https://api.github.com/users/m5tt/gists{/gist_id}","starred_url":"https://api.github.com/users/m5tt/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/m5tt/subscriptions","organizations_url":"https://api.github.com/users/m5tt/orgs","repos_url":"https://api.github.com/users/m5tt/repos","events_url":"https://api.github.com/users/m5tt/events{/privacy}","received_events_url":"https://api.github.com/users/m5tt/received_events","type":"User","site_admin":false},"created_at":"2019-03-29T16:12:57Z","updated_at":"2019-03-29T21:13:10Z","author_association":"NONE","body":"I'm not sure i follow this logic. \r\n\r\nAll i want, is a list of buckets with `doc_count >= 0` that does not include documents i previously filtered out.\r\n\r\nLogically, i feel like this is how it should work. If i have a list of _all_ documents A. Then i run a aggregation filter i should end up with a reduced document list B. Now i run a terms aggregation, which groups documents from list B into buckets on some attribute. \r\n\r\nThe resulting list of buckets should not include documents from the original list A.\r\n\r\nExample, i run a filter aggregation that matches all documents provided they do not match a `type` of `t`. Then i run nested terms aggregation on `type`. \r\n\r\nThe resulting list of buckets should _not_ include a bucket with a `key` `t`. \r\n\r\nAgain to reiterate all i want, is a list of buckets with `doc_count >= 0` that does not include documents i previously filtered out.\r\n\r\nMaybe `min_doc_count` is the wrong way to go about this, but there _must_ be some way in doing this. \r\n\r\n@jimczi \r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/478461813","html_url":"https://github.com/elastic/elasticsearch/issues/40621#issuecomment-478461813","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/40621","id":478461813,"node_id":"MDEyOklzc3VlQ29tbWVudDQ3ODQ2MTgxMw==","user":{"login":"jimczi","id":15977469,"node_id":"MDQ6VXNlcjE1OTc3NDY5","avatar_url":"https://avatars0.githubusercontent.com/u/15977469?v=4","gravatar_id":"","url":"https://api.github.com/users/jimczi","html_url":"https://github.com/jimczi","followers_url":"https://api.github.com/users/jimczi/followers","following_url":"https://api.github.com/users/jimczi/following{/other_user}","gists_url":"https://api.github.com/users/jimczi/gists{/gist_id}","starred_url":"https://api.github.com/users/jimczi/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jimczi/subscriptions","organizations_url":"https://api.github.com/users/jimczi/orgs","repos_url":"https://api.github.com/users/jimczi/repos","events_url":"https://api.github.com/users/jimczi/events{/privacy}","received_events_url":"https://api.github.com/users/jimczi/received_events","type":"User","site_admin":false},"created_at":"2019-04-01T07:09:08Z","updated_at":"2019-04-01T07:09:08Z","author_association":"MEMBER","body":"Ok thanks for explaining. There are multiple ways to perform what you want. Here's one way to do it with the `filters` aggregation and the  `other_bucket_key` option:\r\n```\r\n{\r\n    \"size\": 0,\r\n    \"aggs\": {\r\n        \"messages\": {\r\n            \"filters\": {\r\n                \"other_bucket_key\": \"neg\",\r\n                \"filters\": {\r\n                    \"pos\": {\r\n                        \"term\": {\r\n                            \"type\": \"1\"\r\n                        }\r\n                    }\r\n                }\r\n            },\r\n            \"aggs\": {\r\n                \"terms\": {\r\n                    \"terms\": {\r\n                        \"field\": \"name\"\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\nThis query will create a `pos` bucket for documents that match the filter and a bucket `neg` for documents that don't match. The nested `terms` aggregation will compute the top N for each of these buckets.\r\nI am going to close this issue because we reserve github for verified bugs and feature requests. If you have further questions we can continue to discuss in the [forum](https://discuss.elastic.co/c/elasticsearch).","performed_via_github_app":null}]