{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/61349","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/61349/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/61349/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/61349/events","html_url":"https://github.com/elastic/elasticsearch/issues/61349","id":682129486,"node_id":"MDU6SXNzdWU2ODIxMjk0ODY=","number":61349,"title":"Querying what's 'current' in a time series index is hard, there may be a better way","user":{"login":"andrewvc","id":131427,"node_id":"MDQ6VXNlcjEzMTQyNw==","avatar_url":"https://avatars2.githubusercontent.com/u/131427?v=4","gravatar_id":"","url":"https://api.github.com/users/andrewvc","html_url":"https://github.com/andrewvc","followers_url":"https://api.github.com/users/andrewvc/followers","following_url":"https://api.github.com/users/andrewvc/following{/other_user}","gists_url":"https://api.github.com/users/andrewvc/gists{/gist_id}","starred_url":"https://api.github.com/users/andrewvc/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/andrewvc/subscriptions","organizations_url":"https://api.github.com/users/andrewvc/orgs","repos_url":"https://api.github.com/users/andrewvc/repos","events_url":"https://api.github.com/users/andrewvc/events{/privacy}","received_events_url":"https://api.github.com/users/andrewvc/received_events","type":"User","site_admin":false},"labels":[{"id":141141324,"node_id":"MDU6TGFiZWwxNDExNDEzMjQ=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/:Analytics/Aggregations","name":":Analytics/Aggregations","color":"0e8a16","default":false,"description":"Aggregations"},{"id":146832564,"node_id":"MDU6TGFiZWwxNDY4MzI1NjQ=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/:Search/Search","name":":Search/Search","color":"0e8a16","default":false,"description":"Search-related issues that do not fall into other categories"},{"id":23174,"node_id":"MDU6TGFiZWwyMzE3NA==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/%3Eenhancement","name":">enhancement","color":"4a4ea8","default":false,"description":null},{"id":1967499105,"node_id":"MDU6TGFiZWwxOTY3NDk5MTA1","url":"https://api.github.com/repos/elastic/elasticsearch/labels/Team:Analytics","name":"Team:Analytics","color":"fef2c0","default":false,"description":"Meta label for analytics/geo team"},{"id":1967498216,"node_id":"MDU6TGFiZWwxOTY3NDk4MjE2","url":"https://api.github.com/repos/elastic/elasticsearch/labels/Team:Search","name":"Team:Search","color":"fef2c0","default":false,"description":"Meta label for search team"}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":4,"created_at":"2020-08-19T19:39:53Z","updated_at":"2020-11-11T03:56:45Z","closed_at":"2020-11-11T03:56:45Z","author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"I work on Uptime / Heartbeat here at Elastic, and a frequent source of query complexity is querying over the subset of our timeseries data that represents the current state of the system. For instance, \"Tell me how many monitors are up vs down\". This sounds simple, but it's not, because we have time series data. To accomplish this we must:\r\n\r\n1. Aggregate all the data by id\r\n2. Find the most recent document in per ID via the `@timestamp` field\r\n3. Count the number of those most recent documents that have a `monitor.status` value of `up` vs. `down`.\r\n\r\nThis gets even more complex when you add querying on top. What if you also want to query only the most recent documents? If you find a value that was present in a past document that matches you may display an old 'current' status, rather than a new one.\r\n\r\nWe handle this today by using composite aggs and lots of post-processing in JS. We aim for our UI to handle large numbers of monitors, ~100k today. This essentially pushes the complexity of solving this difficult problems onto developers and isn't ideal.\r\n\r\nI've discussed this a bit with @polyfractal and we've covered a few different solutions.\r\n\r\n* Some new sort of aggregation or query-phase that makes this easier. Maybe we could have a two-phase query where the first aggregates and sorts, yielding a subset of docs that the second queries / aggregates over?\r\n* A way to split writes on the ingest node so we could create a 'current' index that gets only scripted upserts written to it, 1 per monitor ID\r\n* A way to do the same as above but with data frame transforms. One pain point with DFTs is that their lifecycle needs to be managed. For stack solutions we don't have DFT integrations yet, and I'm worried about them stopping / starting or not being around. It seems like a source of bugs. Ideally we could handle this the same way we handled streams, where they are bundled with an ingestion point and either the whole thing works or it doesn't.\r\n* A way to do more complex queries with multiple levels of joins (in this case a self join) in ES via scripting in a safe way.","closed_by":{"login":"andrewvc","id":131427,"node_id":"MDQ6VXNlcjEzMTQyNw==","avatar_url":"https://avatars2.githubusercontent.com/u/131427?v=4","gravatar_id":"","url":"https://api.github.com/users/andrewvc","html_url":"https://github.com/andrewvc","followers_url":"https://api.github.com/users/andrewvc/followers","following_url":"https://api.github.com/users/andrewvc/following{/other_user}","gists_url":"https://api.github.com/users/andrewvc/gists{/gist_id}","starred_url":"https://api.github.com/users/andrewvc/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/andrewvc/subscriptions","organizations_url":"https://api.github.com/users/andrewvc/orgs","repos_url":"https://api.github.com/users/andrewvc/repos","events_url":"https://api.github.com/users/andrewvc/events{/privacy}","received_events_url":"https://api.github.com/users/andrewvc/received_events","type":"User","site_admin":false},"performed_via_github_app":null}