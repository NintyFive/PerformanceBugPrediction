{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/1311","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/1311/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/1311/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/1311/events","html_url":"https://github.com/elastic/elasticsearch/issues/1311","id":1597551,"node_id":"MDU6SXNzdWUxNTk3NTUx","number":1311,"title":"Cluster / Index level allocation filtering","user":{"login":"kimchy","id":41300,"node_id":"MDQ6VXNlcjQxMzAw","avatar_url":"https://avatars1.githubusercontent.com/u/41300?v=4","gravatar_id":"","url":"https://api.github.com/users/kimchy","html_url":"https://github.com/kimchy","followers_url":"https://api.github.com/users/kimchy/followers","following_url":"https://api.github.com/users/kimchy/following{/other_user}","gists_url":"https://api.github.com/users/kimchy/gists{/gist_id}","starred_url":"https://api.github.com/users/kimchy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/kimchy/subscriptions","organizations_url":"https://api.github.com/users/kimchy/orgs","repos_url":"https://api.github.com/users/kimchy/repos","events_url":"https://api.github.com/users/kimchy/events{/privacy}","received_events_url":"https://api.github.com/users/kimchy/received_events","type":"User","site_admin":false},"labels":[{"id":23172,"node_id":"MDU6TGFiZWwyMzE3Mg==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/%3Efeature","name":">feature","color":"006b75","default":false,"description":null},{"id":127902,"node_id":"MDU6TGFiZWwxMjc5MDI=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/v0.18.0","name":"v0.18.0","color":"DDDDDD","default":false,"description":null}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2011-09-08T11:28:29Z","updated_at":"2011-09-08T14:46:13Z","closed_at":"2011-09-08T11:29:23Z","author_association":"MEMBER","active_lock_reason":null,"body":"Allow to control allocation if indices on nodes based on include/exclude filters. The filters can be set both on the index level and on the cluster level. Lets start with an example of setting it on the cluster level:\n\nLets say we have 4 nodes, each has specific attribute called `tag` associated with it (the name of the attribute can be any name). Each node has a specific value associated with `tag`. Node 1 has a setting `node.tag: value1`, Node 2 a setting of `node.tag: value2`, and so on.\n\nWe can create an index that will only deploy on nodes that have `tag` set to `value1` and `value2` by setting `index.routing.allocation.include.tag` to `value1,value2`. For example:\n\n```\ncurl -XPUT localhost:9200/test -d '{\n    \"index.routing.allocation.include.tag\" : \"value1,value2\"\n}'\n```\n\nOn the other hand, we can create an index that will be deployed on all nodes except for nodes with a `tag` of value `value3` by setting `index.routing.allocation.exclude.tag` to `value3`. For example:\n\n```\ncurl -XPUT localhost:9200/test -d '{\n    \"index.routing.allocation.exclude.tag\" : \"value3\"\n}'\n```\n\nThe `include` and `exclude` values can have generic simple matching wildcards, for example, `value1*`. A special attribute name called `_ip` can be used to match on node ip values.\n\nObviously a node can have several attributes associated with it, and both the attribute name and value are controlled in the setting. For example, here is a sample of several node configurations:\n\n```\nnode.group1: group1_value1\nnode.group2: group2_value4\n```\n\nIn the same manner, `include` and `exclude` can work against several attributes, for example:\n\n```\ncurl -XPUT localhost:9200/test -d '{\n    \"index.routing.allocation.include.group1\" : \"xxx\"\n    \"index.routing.allocation.include.group2\" : \"yyy\",\n    \"index.routing.allocation.exclude.group3\" : \"zzz\",\n}'\n```\n\nThe provided settings can also be updated in real time using the update settings API, allowing to \"move\" indices (shards) around in realtime.\n\nCluster wide filtering can also be defined, and be updated in real time using the cluster update settings API. This setting can come in handy for things like decommissioning nodes (even if the replica count is set to 0). Here is a sample of how to decommission a node based on `_ip` address:\n\n```\ncurl -XPUT localhost:9200/_cluster/_settings -d '{\n    \"transient\" : {\n        \"cluster.routing.allocation.exclude._ip\" : \"10.0.0.1\"\n    }\n}'\n```\n","closed_by":{"login":"kimchy","id":41300,"node_id":"MDQ6VXNlcjQxMzAw","avatar_url":"https://avatars1.githubusercontent.com/u/41300?v=4","gravatar_id":"","url":"https://api.github.com/users/kimchy","html_url":"https://github.com/kimchy","followers_url":"https://api.github.com/users/kimchy/followers","following_url":"https://api.github.com/users/kimchy/following{/other_user}","gists_url":"https://api.github.com/users/kimchy/gists{/gist_id}","starred_url":"https://api.github.com/users/kimchy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/kimchy/subscriptions","organizations_url":"https://api.github.com/users/kimchy/orgs","repos_url":"https://api.github.com/users/kimchy/repos","events_url":"https://api.github.com/users/kimchy/events{/privacy}","received_events_url":"https://api.github.com/users/kimchy/received_events","type":"User","site_admin":false},"performed_via_github_app":null}