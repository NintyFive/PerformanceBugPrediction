[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/207149090","html_url":"https://github.com/elastic/elasticsearch/issues/17605#issuecomment-207149090","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/17605","id":207149090,"node_id":"MDEyOklzc3VlQ29tbWVudDIwNzE0OTA5MA==","user":{"login":"jasontedor","id":4744941,"node_id":"MDQ6VXNlcjQ3NDQ5NDE=","avatar_url":"https://avatars3.githubusercontent.com/u/4744941?v=4","gravatar_id":"","url":"https://api.github.com/users/jasontedor","html_url":"https://github.com/jasontedor","followers_url":"https://api.github.com/users/jasontedor/followers","following_url":"https://api.github.com/users/jasontedor/following{/other_user}","gists_url":"https://api.github.com/users/jasontedor/gists{/gist_id}","starred_url":"https://api.github.com/users/jasontedor/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jasontedor/subscriptions","organizations_url":"https://api.github.com/users/jasontedor/orgs","repos_url":"https://api.github.com/users/jasontedor/repos","events_url":"https://api.github.com/users/jasontedor/events{/privacy}","received_events_url":"https://api.github.com/users/jasontedor/received_events","type":"User","site_admin":false},"created_at":"2016-04-08T00:35:15Z","updated_at":"2016-04-10T15:45:48Z","author_association":"MEMBER","body":"When [Elasticsearch locks memory using `mlockall`](https://github.com/elastic/elasticsearch/blob/e0cde29a685efcf1487b008379bbe4b8f39bf115/core/src/main/java/org/elasticsearch/bootstrap/JNANatives.java#L65), it locks with the flag [`MCL_CURRENT`](http://linux.die.net/man/2/mlockall). This means that only pages that are currently mapped into the address space will be locked, and future pages that are mapped will not be locked. This means that any pages that are not mapped into the address space are eligible for swapping, and thus having `mlockall` enabled and successfully executed is not inconsistent with seeing pages swapped by the virtual memory subsystem.\n\nThere are a few circumstances under which Elasticsearch will map additional pages:\n- if min heap size (`Xms`) and max heap size (`Xmx`) are not equal to each other, then the heap size can change from its size at startup to its steady-state size as Elasticsearch executes requests\n- if using a collector that releases memory back to the operating system (the serial collector and the garbage first collector both do this but note that we [recommend _not_](https://www.elastic.co/blog/a-heap-of-trouble) using either of these collectors with Elasticsearch and their use with Elasticsearch is unsupported)\n- if index files are mapped into memory via `mmap`\n\nIt's this last case that likely hits everyone because we recommend setting `Xms` equal to `Xmx` (and you get this for free if you use `ES_HEAP_SIZE` to set the heap size), and we recommend _not_ using either of the collectors that release memory back to the operating system. Thus, only the third case remains.\n\nYou see, `mlockall` is really just a last resort for minimizing swapping. It's not completely effective for reducing swapping.\n\nIf you want to disable swapping, then disable swapping using [`swapoff -a`](http://linux.die.net/man/2/swapoff). If for some reason this is not an option for you, then minimize swapping by setting the [kernel parameter `vm.swappiness`](https://en.wikipedia.org/wiki/Swappiness) to `1` (using `sysctl` and please do not set to `0` because the [behavior](http://gitorious.ti.com/ti-linux-kernel/ti-linux-kernel/commit/fe35004fbf9eaf67482b074a2e032abb9c89b1dd?format=patch) of this value changed in the 3.x kernel series). The absolute last resort is `mlockall` because at least this prevents the JVM itself (meaning the code, data and stack of the JVM) and parts of the heap from being swapped out.\n\nA bad thing that can happen is part of the JVM's heap gets swapped out to disk and then the JVM goes to run a full garbage collection cycle and touches the entire heap leading to the disk thrashing during a garbage collection cycle. This is why ideally we want to be able to lock the entire heap in memory but with `mlockall` this is only possible if `Xms` is equal to `Xmx` and we are not using a releasing collector.\n\nYou might be wondering why we do not also lock memory with the flag `MCL_FUTURE`? This would lock memory mapped pages into physical memory but that's horrific because most user's data size exceeds their physical memory size. Further, it completely negates the amazing job the operating system does at managing memory mapped pages.\n","performed_via_github_app":null}]