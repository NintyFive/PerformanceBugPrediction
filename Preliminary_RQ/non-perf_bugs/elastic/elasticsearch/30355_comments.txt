[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/386223014","html_url":"https://github.com/elastic/elasticsearch/issues/30355#issuecomment-386223014","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/30355","id":386223014,"node_id":"MDEyOklzc3VlQ29tbWVudDM4NjIyMzAxNA==","user":{"login":"elasticmachine","id":15837671,"node_id":"MDQ6VXNlcjE1ODM3Njcx","avatar_url":"https://avatars3.githubusercontent.com/u/15837671?v=4","gravatar_id":"","url":"https://api.github.com/users/elasticmachine","html_url":"https://github.com/elasticmachine","followers_url":"https://api.github.com/users/elasticmachine/followers","following_url":"https://api.github.com/users/elasticmachine/following{/other_user}","gists_url":"https://api.github.com/users/elasticmachine/gists{/gist_id}","starred_url":"https://api.github.com/users/elasticmachine/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/elasticmachine/subscriptions","organizations_url":"https://api.github.com/users/elasticmachine/orgs","repos_url":"https://api.github.com/users/elasticmachine/repos","events_url":"https://api.github.com/users/elasticmachine/events{/privacy}","received_events_url":"https://api.github.com/users/elasticmachine/received_events","type":"User","site_admin":false},"created_at":"2018-05-03T08:21:34Z","updated_at":"2018-05-03T08:21:34Z","author_association":"COLLABORATOR","body":"Pinging @elastic/es-security","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/386233281","html_url":"https://github.com/elastic/elasticsearch/issues/30355#issuecomment-386233281","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/30355","id":386233281,"node_id":"MDEyOklzc3VlQ29tbWVudDM4NjIzMzI4MQ==","user":{"login":"albertzaharovits","id":4568420,"node_id":"MDQ6VXNlcjQ1Njg0MjA=","avatar_url":"https://avatars2.githubusercontent.com/u/4568420?v=4","gravatar_id":"","url":"https://api.github.com/users/albertzaharovits","html_url":"https://github.com/albertzaharovits","followers_url":"https://api.github.com/users/albertzaharovits/followers","following_url":"https://api.github.com/users/albertzaharovits/following{/other_user}","gists_url":"https://api.github.com/users/albertzaharovits/gists{/gist_id}","starred_url":"https://api.github.com/users/albertzaharovits/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/albertzaharovits/subscriptions","organizations_url":"https://api.github.com/users/albertzaharovits/orgs","repos_url":"https://api.github.com/users/albertzaharovits/repos","events_url":"https://api.github.com/users/albertzaharovits/events{/privacy}","received_events_url":"https://api.github.com/users/albertzaharovits/received_events","type":"User","site_admin":false},"created_at":"2018-05-03T09:05:21Z","updated_at":"2018-05-03T09:05:21Z","author_association":"CONTRIBUTOR","body":"I haven't looked at the code yet, but I have qualms moving the blocking queue **before** the cache. If we are facing the surge, instead of the downstream LDAP server, we are inherently exposing ourselves to DOS . If the blocking queue is before the cache the DOS would impact all the users in the realm, if for example there's a misconfigured beats somewhere. Considering how realms are chained, a DOSed LDAP realm could escalate into a total mess, were users are authenticated by whatever realm is not busy.\r\n\r\nI think we should take the hard route of limiting the number of outgoing resolve requests **per user**. ","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/386303921","html_url":"https://github.com/elastic/elasticsearch/issues/30355#issuecomment-386303921","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/30355","id":386303921,"node_id":"MDEyOklzc3VlQ29tbWVudDM4NjMwMzkyMQ==","user":{"login":"bizybot","id":902768,"node_id":"MDQ6VXNlcjkwMjc2OA==","avatar_url":"https://avatars2.githubusercontent.com/u/902768?v=4","gravatar_id":"","url":"https://api.github.com/users/bizybot","html_url":"https://github.com/bizybot","followers_url":"https://api.github.com/users/bizybot/followers","following_url":"https://api.github.com/users/bizybot/following{/other_user}","gists_url":"https://api.github.com/users/bizybot/gists{/gist_id}","starred_url":"https://api.github.com/users/bizybot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bizybot/subscriptions","organizations_url":"https://api.github.com/users/bizybot/orgs","repos_url":"https://api.github.com/users/bizybot/repos","events_url":"https://api.github.com/users/bizybot/events{/privacy}","received_events_url":"https://api.github.com/users/bizybot/received_events","type":"User","site_admin":false},"created_at":"2018-05-03T13:55:33Z","updated_at":"2018-05-03T13:55:33Z","author_association":"CONTRIBUTOR","body":"> This cache has a per-entry expiry, where an entry is a \"user\". That means that when the cache entry for a user expires, all authentication requests for that user will lookup the original datasource until the cache is populated again (when the first authentication succeeds).\r\n\r\nI hope I understood the problem, following is an alternative solution:\r\nDo something like Guava Cache `expireAfterAccess` - expire entries after the specified duration has passed since the entry was last accessed by a read or a write. Though this might mean that in case of beats there is a possibility of the information remains cached for long duration as periodically accessed and not refreshed from source. But this could be mitigated by `refreshAfterWrite` which queries ldap and updates cache entry async. To avoid surge the value chosen for duration for refresh after write could be random between a range so avoiding big sudden spikes to source.\r\n\r\nI have not looked at the  Cache APIs so not sure if these are possible with ES cache implementation but we could add that functionality if not present.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/386332090","html_url":"https://github.com/elastic/elasticsearch/issues/30355#issuecomment-386332090","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/30355","id":386332090,"node_id":"MDEyOklzc3VlQ29tbWVudDM4NjMzMjA5MA==","user":{"login":"jaymode","id":4339958,"node_id":"MDQ6VXNlcjQzMzk5NTg=","avatar_url":"https://avatars1.githubusercontent.com/u/4339958?v=4","gravatar_id":"","url":"https://api.github.com/users/jaymode","html_url":"https://github.com/jaymode","followers_url":"https://api.github.com/users/jaymode/followers","following_url":"https://api.github.com/users/jaymode/following{/other_user}","gists_url":"https://api.github.com/users/jaymode/gists{/gist_id}","starred_url":"https://api.github.com/users/jaymode/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jaymode/subscriptions","organizations_url":"https://api.github.com/users/jaymode/orgs","repos_url":"https://api.github.com/users/jaymode/repos","events_url":"https://api.github.com/users/jaymode/events{/privacy}","received_events_url":"https://api.github.com/users/jaymode/received_events","type":"User","site_admin":false},"created_at":"2018-05-03T15:18:24Z","updated_at":"2018-05-03T15:18:24Z","author_association":"MEMBER","body":"DOS is a concern, but I think there are many other ways to DOS a cluster so I wouldn't consider that a reason to not *consider* a proposed solution.\r\n\r\nI feel like there are two items to consider, number of concurrent authentications overall and number of concurrent authentications per user. The number of overall concurrent authentications can (and I think should) be handled at a higher level in the authentication service, with a thread limited executor (and careful handling of async actions using the same executor with higher priority).\r\n\r\nThe per user concurrent authentications should be handled at the realm level. As @tvernum mentioned, this is complicated by the asynchronous nature. I have some ideas that I can explore for this.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/386597688","html_url":"https://github.com/elastic/elasticsearch/issues/30355#issuecomment-386597688","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/30355","id":386597688,"node_id":"MDEyOklzc3VlQ29tbWVudDM4NjU5NzY4OA==","user":{"login":"s1monw","id":973334,"node_id":"MDQ6VXNlcjk3MzMzNA==","avatar_url":"https://avatars0.githubusercontent.com/u/973334?v=4","gravatar_id":"","url":"https://api.github.com/users/s1monw","html_url":"https://github.com/s1monw","followers_url":"https://api.github.com/users/s1monw/followers","following_url":"https://api.github.com/users/s1monw/following{/other_user}","gists_url":"https://api.github.com/users/s1monw/gists{/gist_id}","starred_url":"https://api.github.com/users/s1monw/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/s1monw/subscriptions","organizations_url":"https://api.github.com/users/s1monw/orgs","repos_url":"https://api.github.com/users/s1monw/repos","events_url":"https://api.github.com/users/s1monw/events{/privacy}","received_events_url":"https://api.github.com/users/s1monw/received_events","type":"User","site_admin":false},"created_at":"2018-05-04T13:15:07Z","updated_at":"2018-05-04T13:15:07Z","author_association":"CONTRIBUTOR","body":"FYI I removed the _discuss_ label seems legit.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/386974305","html_url":"https://github.com/elastic/elasticsearch/issues/30355#issuecomment-386974305","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/30355","id":386974305,"node_id":"MDEyOklzc3VlQ29tbWVudDM4Njk3NDMwNQ==","user":{"login":"tvernum","id":2244393,"node_id":"MDQ6VXNlcjIyNDQzOTM=","avatar_url":"https://avatars0.githubusercontent.com/u/2244393?v=4","gravatar_id":"","url":"https://api.github.com/users/tvernum","html_url":"https://github.com/tvernum","followers_url":"https://api.github.com/users/tvernum/followers","following_url":"https://api.github.com/users/tvernum/following{/other_user}","gists_url":"https://api.github.com/users/tvernum/gists{/gist_id}","starred_url":"https://api.github.com/users/tvernum/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/tvernum/subscriptions","organizations_url":"https://api.github.com/users/tvernum/orgs","repos_url":"https://api.github.com/users/tvernum/repos","events_url":"https://api.github.com/users/tvernum/events{/privacy}","received_events_url":"https://api.github.com/users/tvernum/received_events","type":"User","site_admin":false},"created_at":"2018-05-07T06:52:11Z","updated_at":"2018-05-07T06:52:42Z","author_association":"CONTRIBUTOR","body":"> The number of overall concurrent authentications can (and I think should) be handled at a higher level in the authentication service\r\n\r\nI think there are valid use cases for either approach of limiting it globally, or per realm.\r\nI _don't_ think we should implement both but I would like us to seriously consider which one we do.\r\n\r\nDoing it globally allows us to segregate authentication (including CPU expensive tasks like password hashing) from the other uses of the generic thread pool (& potentially freeing up some CPU time for other tasks)\r\n\r\nDoing it per realm allows the \"administrative\" realms (e.g. reserved/file) realm to be isolated from the \"user\" realms (LDAP/AD/etc). \r\n\r\nI don't know that one is _better_ than the other, but it's worth being clear about our reasoning for picking one over the other.","performed_via_github_app":null}]