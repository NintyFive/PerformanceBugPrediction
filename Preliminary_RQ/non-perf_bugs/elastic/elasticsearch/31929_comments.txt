[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/403910274","html_url":"https://github.com/elastic/elasticsearch/issues/31929#issuecomment-403910274","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/31929","id":403910274,"node_id":"MDEyOklzc3VlQ29tbWVudDQwMzkxMDI3NA==","user":{"login":"elasticmachine","id":15837671,"node_id":"MDQ6VXNlcjE1ODM3Njcx","avatar_url":"https://avatars3.githubusercontent.com/u/15837671?v=4","gravatar_id":"","url":"https://api.github.com/users/elasticmachine","html_url":"https://github.com/elasticmachine","followers_url":"https://api.github.com/users/elasticmachine/followers","following_url":"https://api.github.com/users/elasticmachine/following{/other_user}","gists_url":"https://api.github.com/users/elasticmachine/gists{/gist_id}","starred_url":"https://api.github.com/users/elasticmachine/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/elasticmachine/subscriptions","organizations_url":"https://api.github.com/users/elasticmachine/orgs","repos_url":"https://api.github.com/users/elasticmachine/repos","events_url":"https://api.github.com/users/elasticmachine/events{/privacy}","received_events_url":"https://api.github.com/users/elasticmachine/received_events","type":"User","site_admin":false},"created_at":"2018-07-10T17:51:01Z","updated_at":"2018-07-10T17:51:01Z","author_association":"COLLABORATOR","body":"Pinging @elastic/es-search-aggs","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/404081281","html_url":"https://github.com/elastic/elasticsearch/issues/31929#issuecomment-404081281","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/31929","id":404081281,"node_id":"MDEyOklzc3VlQ29tbWVudDQwNDA4MTI4MQ==","user":{"login":"elasticmachine","id":15837671,"node_id":"MDQ6VXNlcjE1ODM3Njcx","avatar_url":"https://avatars3.githubusercontent.com/u/15837671?v=4","gravatar_id":"","url":"https://api.github.com/users/elasticmachine","html_url":"https://github.com/elasticmachine","followers_url":"https://api.github.com/users/elasticmachine/followers","following_url":"https://api.github.com/users/elasticmachine/following{/other_user}","gists_url":"https://api.github.com/users/elasticmachine/gists{/gist_id}","starred_url":"https://api.github.com/users/elasticmachine/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/elasticmachine/subscriptions","organizations_url":"https://api.github.com/users/elasticmachine/orgs","repos_url":"https://api.github.com/users/elasticmachine/repos","events_url":"https://api.github.com/users/elasticmachine/events{/privacy}","received_events_url":"https://api.github.com/users/elasticmachine/received_events","type":"User","site_admin":false},"created_at":"2018-07-11T08:03:27Z","updated_at":"2018-07-11T08:03:27Z","author_association":"COLLABORATOR","body":"Pinging @elastic/es-distributed","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/404086744","html_url":"https://github.com/elastic/elasticsearch/issues/31929#issuecomment-404086744","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/31929","id":404086744,"node_id":"MDEyOklzc3VlQ29tbWVudDQwNDA4Njc0NA==","user":{"login":"colings86","id":236731,"node_id":"MDQ6VXNlcjIzNjczMQ==","avatar_url":"https://avatars0.githubusercontent.com/u/236731?v=4","gravatar_id":"","url":"https://api.github.com/users/colings86","html_url":"https://github.com/colings86","followers_url":"https://api.github.com/users/colings86/followers","following_url":"https://api.github.com/users/colings86/following{/other_user}","gists_url":"https://api.github.com/users/colings86/gists{/gist_id}","starred_url":"https://api.github.com/users/colings86/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/colings86/subscriptions","organizations_url":"https://api.github.com/users/colings86/orgs","repos_url":"https://api.github.com/users/colings86/repos","events_url":"https://api.github.com/users/colings86/events{/privacy}","received_events_url":"https://api.github.com/users/colings86/received_events","type":"User","site_admin":false},"created_at":"2018-07-11T08:24:01Z","updated_at":"2018-07-11T08:24:01Z","author_association":"MEMBER","body":"@bra-fsn could you explain a bit about your use case and why you only want to retrieve results from the primary?\r\n\r\nIf the use case is down to wanting every client to see the exact same view of the data and not have stale reads I think you'd have a hard time achieving this even with `_primary`. This is because of two things:\r\n* Shard failure - A primary shard failure will permanently change the primary and in the case where not all shard copies are up to date  you may still see stale data anyway since the new primary becomes the source of truth. If the new primary is up to date with the failed one then you would be ok but this is the same as using those shard copies in your requests anyway?\r\n* Refreshes - If your index is changing then your clients may see different views of the data anyway depending on whether a refresh happened between one being serviced and the other being serviced\r\n\r\nI also wonder why you do not consider custom preference an option since if you wanted to replicate the behaviour of `_primary` and have all requests form all clients go to the same shard copies (assuming no shard failures) then you could use the same preference value for all requests across all your clients instead of creating a preference value per client or session? This would not guarantee the primary is used but would mean that all requests from all clients should use the same shard copies (ignoring shard failures) which seems to be what you are after?","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/404829586","html_url":"https://github.com/elastic/elasticsearch/issues/31929#issuecomment-404829586","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/31929","id":404829586,"node_id":"MDEyOklzc3VlQ29tbWVudDQwNDgyOTU4Ng==","user":{"login":"DaveCTurner","id":5058284,"node_id":"MDQ6VXNlcjUwNTgyODQ=","avatar_url":"https://avatars3.githubusercontent.com/u/5058284?v=4","gravatar_id":"","url":"https://api.github.com/users/DaveCTurner","html_url":"https://github.com/DaveCTurner","followers_url":"https://api.github.com/users/DaveCTurner/followers","following_url":"https://api.github.com/users/DaveCTurner/following{/other_user}","gists_url":"https://api.github.com/users/DaveCTurner/gists{/gist_id}","starred_url":"https://api.github.com/users/DaveCTurner/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/DaveCTurner/subscriptions","organizations_url":"https://api.github.com/users/DaveCTurner/orgs","repos_url":"https://api.github.com/users/DaveCTurner/repos","events_url":"https://api.github.com/users/DaveCTurner/events{/privacy}","received_events_url":"https://api.github.com/users/DaveCTurner/received_events","type":"User","site_admin":false},"created_at":"2018-07-13T13:12:55Z","updated_at":"2018-07-13T13:12:55Z","author_association":"CONTRIBUTOR","body":"What @colings86 said is true: using `_primary` gives no stronger consistency guarantees than using a custom preference.\r\n\r\n> it just hashes the client to a given shard, which may be yet to be updated (while asking the primary would return correct result).\r\n\r\nIt is not the case that the primary always serves all acknowledged writes, because it might not have refreshed. It is also not the case that replicas lag behind the primary like this: writes are only acknowledged once written to _all_ copies, not just to the primary.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/404838523","html_url":"https://github.com/elastic/elasticsearch/issues/31929#issuecomment-404838523","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/31929","id":404838523,"node_id":"MDEyOklzc3VlQ29tbWVudDQwNDgzODUyMw==","user":{"login":"bleskes","id":1006375,"node_id":"MDQ6VXNlcjEwMDYzNzU=","avatar_url":"https://avatars1.githubusercontent.com/u/1006375?v=4","gravatar_id":"","url":"https://api.github.com/users/bleskes","html_url":"https://github.com/bleskes","followers_url":"https://api.github.com/users/bleskes/followers","following_url":"https://api.github.com/users/bleskes/following{/other_user}","gists_url":"https://api.github.com/users/bleskes/gists{/gist_id}","starred_url":"https://api.github.com/users/bleskes/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bleskes/subscriptions","organizations_url":"https://api.github.com/users/bleskes/orgs","repos_url":"https://api.github.com/users/bleskes/repos","events_url":"https://api.github.com/users/bleskes/events{/privacy}","received_events_url":"https://api.github.com/users/bleskes/received_events","type":"User","site_admin":false},"created_at":"2018-07-13T13:47:33Z","updated_at":"2018-07-13T13:47:33Z","author_association":"MEMBER","body":"we discussed it on fix it friday. The main use case for preferences are data locality (for attribute based preferences) and more efficient use of shard caches (where the custom preference value sends requests to the same shard where caches are potentially hot). We should update the docs to better reflect that and also to clarify that this is why the `_primary_*` options were deprecated. They help with neither options.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/408676811","html_url":"https://github.com/elastic/elasticsearch/issues/31929#issuecomment-408676811","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/31929","id":408676811,"node_id":"MDEyOklzc3VlQ29tbWVudDQwODY3NjgxMQ==","user":{"login":"bra-fsn","id":820331,"node_id":"MDQ6VXNlcjgyMDMzMQ==","avatar_url":"https://avatars2.githubusercontent.com/u/820331?v=4","gravatar_id":"","url":"https://api.github.com/users/bra-fsn","html_url":"https://github.com/bra-fsn","followers_url":"https://api.github.com/users/bra-fsn/followers","following_url":"https://api.github.com/users/bra-fsn/following{/other_user}","gists_url":"https://api.github.com/users/bra-fsn/gists{/gist_id}","starred_url":"https://api.github.com/users/bra-fsn/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bra-fsn/subscriptions","organizations_url":"https://api.github.com/users/bra-fsn/orgs","repos_url":"https://api.github.com/users/bra-fsn/repos","events_url":"https://api.github.com/users/bra-fsn/events{/privacy}","received_events_url":"https://api.github.com/users/bra-fsn/received_events","type":"User","site_admin":false},"created_at":"2018-07-29T13:09:05Z","updated_at":"2018-07-29T13:24:06Z","author_association":"NONE","body":"@colings86, @bleskes \r\nI use elasticsearch like a database.\r\nFor operations which need consistency I use only the doc APIs (index, update and get).\r\nThe way this API works has changed multiple times (last time in 6.3.0, where update reintroduced reading from the translog in #29264, get still does a refresh according to the docs), but AFAIK the get APIs remained consistent in all recent elastic versions.\r\nFrom the documentation I assume the following:\r\n- an index/update to a doc is written to the translog and is acknowledged only after this happens. Depending on the value of wait_for_active_shards, this happens only on the primary or the given number of replicas. If I have a number_of_replicas: 2 and wait_for_active_shards: 2, this should mean the majority of the shard copies must be updated with a write to be acknowledged. I guess if only one shard (the primary) is available (with wait_for_active_shards > 1), the write will happen there, but it won't be acknowledged as successful, but I'm not sure about that (can you clarify please?).\r\n- the doc APIs represent a consistent view, which means after the write has been acknowledged on the given nodes if a get/update request comes in on the nodes which already acknowledged the write (the primary and the given number of replica nodes), these will either do a refresh (get) or read from the translog (update), but either way, if there was a modify operation, they can't give back stale data.\r\n- after reading the resiliency page I would think with a repcount of 2 and wait_for_active_shards: 2, promoting a stale replica shouldn't be possible. Isn't this the cause of the introduction of allocation IDs?\r\n\r\nSo if I'm right using the doc APIs in the above way, a consistent view can be achieved. Or at least this is how I understand after reading the docs.\r\nThe only thing which is needed for this to be true is the usage of _primary on get operations, because this guarantees that the query will hit a node, which has already acknowledged the latest writes.\r\n\r\nCould you please tell me what I'm getting wrong?\r\n\r\nThanks,","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/408677233","html_url":"https://github.com/elastic/elasticsearch/issues/31929#issuecomment-408677233","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/31929","id":408677233,"node_id":"MDEyOklzc3VlQ29tbWVudDQwODY3NzIzMw==","user":{"login":"bra-fsn","id":820331,"node_id":"MDQ6VXNlcjgyMDMzMQ==","avatar_url":"https://avatars2.githubusercontent.com/u/820331?v=4","gravatar_id":"","url":"https://api.github.com/users/bra-fsn","html_url":"https://github.com/bra-fsn","followers_url":"https://api.github.com/users/bra-fsn/followers","following_url":"https://api.github.com/users/bra-fsn/following{/other_user}","gists_url":"https://api.github.com/users/bra-fsn/gists{/gist_id}","starred_url":"https://api.github.com/users/bra-fsn/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bra-fsn/subscriptions","organizations_url":"https://api.github.com/users/bra-fsn/orgs","repos_url":"https://api.github.com/users/bra-fsn/repos","events_url":"https://api.github.com/users/bra-fsn/events{/privacy}","received_events_url":"https://api.github.com/users/bra-fsn/received_events","type":"User","site_admin":false},"created_at":"2018-07-29T13:17:19Z","updated_at":"2018-07-29T13:26:14Z","author_association":"NONE","body":"@DaveCTurner for searches, right. But for the doc APIs, inflight data will either be served from the translog or initiate a refresh (which means no stale data). BTW, this could even be true for searches. Where I need consistency, I use refresh=wait_for on index operations, so consistency here means after an index/update operation with refresh=wait_for has returned, a new search should include that data (and now you only can assume this with setting _primary).\r\n\r\n\"writes are only acknowledged once written to all copies, not just to the primary\"\r\nIf this is true, what is wait_for_active_shards for (and why does the doc say its default value is 1, which means wait for only the primary)?\r\nFrom:\r\nhttps://www.elastic.co/guide/en/elasticsearch/reference/current/docs-index_.html\r\n\r\n> By default, write operations only wait for the primary shards to be active before proceeding (i.e. wait_for_active_shards=1).","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/408744128","html_url":"https://github.com/elastic/elasticsearch/issues/31929#issuecomment-408744128","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/31929","id":408744128,"node_id":"MDEyOklzc3VlQ29tbWVudDQwODc0NDEyOA==","user":{"login":"DaveCTurner","id":5058284,"node_id":"MDQ6VXNlcjUwNTgyODQ=","avatar_url":"https://avatars3.githubusercontent.com/u/5058284?v=4","gravatar_id":"","url":"https://api.github.com/users/DaveCTurner","html_url":"https://github.com/DaveCTurner","followers_url":"https://api.github.com/users/DaveCTurner/followers","following_url":"https://api.github.com/users/DaveCTurner/following{/other_user}","gists_url":"https://api.github.com/users/DaveCTurner/gists{/gist_id}","starred_url":"https://api.github.com/users/DaveCTurner/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/DaveCTurner/subscriptions","organizations_url":"https://api.github.com/users/DaveCTurner/orgs","repos_url":"https://api.github.com/users/DaveCTurner/repos","events_url":"https://api.github.com/users/DaveCTurner/events{/privacy}","received_events_url":"https://api.github.com/users/DaveCTurner/received_events","type":"User","site_admin":false},"created_at":"2018-07-30T04:34:09Z","updated_at":"2018-07-30T04:34:09Z","author_association":"CONTRIBUTOR","body":"> Where I need consistency, I use refresh=wait_for on index operations, so consistency here means after an index/update operation with refresh=wait_for has returned, a new search should include that data (and now you only can assume this with setting _primary). \r\n\r\nWhen an indexing request with `?refresh=wait_for` returns, _all_ active shard copies have replicated the write and exposed it to searches, not just the primary.\r\n\r\n> > writes are only acknowledged once written to all copies, not just to the primary\r\n\r\n> If this is true, what is wait_for_active_shards for (and why does the doc say its default value is 1, which means wait for only the primary)?\r\n\r\n`wait_for_active_shards` performs a preflight check on the number of active shard copies before starting work on an indexing operation. The default value of `1` means the check passes even if no replicas are active, but doesn't change the fact that write operations are only acknowledged after they have been replicated to all of the active shard copies. Note also the following paragraph from further down the docs:\r\n\r\n> It is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation commences. Once the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary. ","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/408745430","html_url":"https://github.com/elastic/elasticsearch/issues/31929#issuecomment-408745430","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/31929","id":408745430,"node_id":"MDEyOklzc3VlQ29tbWVudDQwODc0NTQzMA==","user":{"login":"DaveCTurner","id":5058284,"node_id":"MDQ6VXNlcjUwNTgyODQ=","avatar_url":"https://avatars3.githubusercontent.com/u/5058284?v=4","gravatar_id":"","url":"https://api.github.com/users/DaveCTurner","html_url":"https://github.com/DaveCTurner","followers_url":"https://api.github.com/users/DaveCTurner/followers","following_url":"https://api.github.com/users/DaveCTurner/following{/other_user}","gists_url":"https://api.github.com/users/DaveCTurner/gists{/gist_id}","starred_url":"https://api.github.com/users/DaveCTurner/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/DaveCTurner/subscriptions","organizations_url":"https://api.github.com/users/DaveCTurner/orgs","repos_url":"https://api.github.com/users/DaveCTurner/repos","events_url":"https://api.github.com/users/DaveCTurner/events{/privacy}","received_events_url":"https://api.github.com/users/DaveCTurner/received_events","type":"User","site_admin":false},"created_at":"2018-07-30T04:44:39Z","updated_at":"2018-07-30T04:44:39Z","author_association":"CONTRIBUTOR","body":"The docs were updated in #32098 to address the original question. I can see a case for addressing the followup questions with further doc improvements, so I'm leaving this open and marking it for further discussion.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/408753091","html_url":"https://github.com/elastic/elasticsearch/issues/31929#issuecomment-408753091","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/31929","id":408753091,"node_id":"MDEyOklzc3VlQ29tbWVudDQwODc1MzA5MQ==","user":{"login":"bleskes","id":1006375,"node_id":"MDQ6VXNlcjEwMDYzNzU=","avatar_url":"https://avatars1.githubusercontent.com/u/1006375?v=4","gravatar_id":"","url":"https://api.github.com/users/bleskes","html_url":"https://github.com/bleskes","followers_url":"https://api.github.com/users/bleskes/followers","following_url":"https://api.github.com/users/bleskes/following{/other_user}","gists_url":"https://api.github.com/users/bleskes/gists{/gist_id}","starred_url":"https://api.github.com/users/bleskes/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bleskes/subscriptions","organizations_url":"https://api.github.com/users/bleskes/orgs","repos_url":"https://api.github.com/users/bleskes/repos","events_url":"https://api.github.com/users/bleskes/events{/privacy}","received_events_url":"https://api.github.com/users/bleskes/received_events","type":"User","site_admin":false},"created_at":"2018-07-30T05:43:30Z","updated_at":"2018-07-30T05:43:30Z","author_association":"MEMBER","body":"@bra-fsn thanks for explaining. I think you can do what you're doing but you have to change a bit how you reason about the API. Also, there are some edge cases when things fail that you should be aware of. @DaveCTurner explained some details of the API and the higher level constructs are explained here: https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-replication.html . Please me know if you find anything unclear in that document. It's very important for us that users understand what they can (and not) expect from Elasticsearch. ","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/408786236","html_url":"https://github.com/elastic/elasticsearch/issues/31929#issuecomment-408786236","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/31929","id":408786236,"node_id":"MDEyOklzc3VlQ29tbWVudDQwODc4NjIzNg==","user":{"login":"bra-fsn","id":820331,"node_id":"MDQ6VXNlcjgyMDMzMQ==","avatar_url":"https://avatars2.githubusercontent.com/u/820331?v=4","gravatar_id":"","url":"https://api.github.com/users/bra-fsn","html_url":"https://github.com/bra-fsn","followers_url":"https://api.github.com/users/bra-fsn/followers","following_url":"https://api.github.com/users/bra-fsn/following{/other_user}","gists_url":"https://api.github.com/users/bra-fsn/gists{/gist_id}","starred_url":"https://api.github.com/users/bra-fsn/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bra-fsn/subscriptions","organizations_url":"https://api.github.com/users/bra-fsn/orgs","repos_url":"https://api.github.com/users/bra-fsn/repos","events_url":"https://api.github.com/users/bra-fsn/events{/privacy}","received_events_url":"https://api.github.com/users/bra-fsn/received_events","type":"User","site_admin":false},"created_at":"2018-07-30T08:25:04Z","updated_at":"2018-07-30T08:25:04Z","author_association":"NONE","body":"> wait_for_active_shards performs a preflight check on the number of active shard copies before starting work on an indexing operation. The default value of 1 means the check passes even if no replicas are active, but doesn't change the fact that write operations are only acknowledged after they have been replicated to all of the active shard copies. Note also the following paragraph from further down the docs:\r\n\r\nOh, I missed those, thanks for pointing that out!","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/408800123","html_url":"https://github.com/elastic/elasticsearch/issues/31929#issuecomment-408800123","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/31929","id":408800123,"node_id":"MDEyOklzc3VlQ29tbWVudDQwODgwMDEyMw==","user":{"login":"bra-fsn","id":820331,"node_id":"MDQ6VXNlcjgyMDMzMQ==","avatar_url":"https://avatars2.githubusercontent.com/u/820331?v=4","gravatar_id":"","url":"https://api.github.com/users/bra-fsn","html_url":"https://github.com/bra-fsn","followers_url":"https://api.github.com/users/bra-fsn/followers","following_url":"https://api.github.com/users/bra-fsn/following{/other_user}","gists_url":"https://api.github.com/users/bra-fsn/gists{/gist_id}","starred_url":"https://api.github.com/users/bra-fsn/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bra-fsn/subscriptions","organizations_url":"https://api.github.com/users/bra-fsn/orgs","repos_url":"https://api.github.com/users/bra-fsn/repos","events_url":"https://api.github.com/users/bra-fsn/events{/privacy}","received_events_url":"https://api.github.com/users/bra-fsn/received_events","type":"User","site_admin":false},"created_at":"2018-07-30T09:16:52Z","updated_at":"2018-07-30T09:19:09Z","author_association":"NONE","body":"@bleskes What's still unclear to me is the answer to the original question.\r\nCould you please tell me whether these are valid or not (and why)?\r\n\r\n1. if an operation is acknowledged, it must not be lost (for example by electing a stale shard copy)\r\n2. due to the replication model, this could happen to a document named doc with an original version 1 - referred to doc(version) from now on:\r\n2.1 there is doc(1) - intial version\r\n2.2 an update comes in for doc, primary applies that, resulting in doc(2)\r\n2.3 at this point any new doc API requests will see doc(2) when they hit the primary and doc(1) when they hit the shard copies\r\n2.4 primary is lost before it could reach out for the shard copies\r\n2.5 master will notice this and elect a new shard copy as the primary\r\n2.6 all further requests will see doc(1)\r\n2.7 the original client which made the doc(1)->doc(2) update will see failure\r\n3. get APIs provide linearizability on a given shard: if that shard has received a modification request any get or update after that will see that applied (whether it comes out from the translog or because of a refresh is irrelevant here)\r\n\r\nGiven all of these are true:\r\n1. by using _primary, linearizability (all later reads will return the value of a write) on all requests (no matter what client issued that) can only fail (and can fail only for unacknowledged writes) if the primary fails before it can replicate all of inflight modifications and if in-sync allocation IDs can't otherwise protect against a stale (for unacknowledged, but already written by the primary) copy to be promoted to the primary. This is far from being impossible, but can be made a pretty rare event with enough care.\r\n2. without the possibility of using _primary, linearizability will fail all the time (within the replication time interval), because clients can connect to any of the shard holders (primary and copies).\r\n\r\nSo I think it would be nicer to keep _primary and change this sentence (from #32098):\r\n\r\n> They do not help to avoid\r\n> inconsistent results that arise from the use of shards that have different\r\n> refresh states, and Elasticsearch uses synchronous replication so the primary\r\n> does not in general hold fresher data than its replicas.\r\n\r\nto something like this: _primary helps to avoid inconsistent results, but there should be a caveat: if a primary fails and it can't update the in-sync allocation IDs, unacknowledged writes may have broken linearizability.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/408818169","html_url":"https://github.com/elastic/elasticsearch/issues/31929#issuecomment-408818169","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/31929","id":408818169,"node_id":"MDEyOklzc3VlQ29tbWVudDQwODgxODE2OQ==","user":{"login":"DaveCTurner","id":5058284,"node_id":"MDQ6VXNlcjUwNTgyODQ=","avatar_url":"https://avatars3.githubusercontent.com/u/5058284?v=4","gravatar_id":"","url":"https://api.github.com/users/DaveCTurner","html_url":"https://github.com/DaveCTurner","followers_url":"https://api.github.com/users/DaveCTurner/followers","following_url":"https://api.github.com/users/DaveCTurner/following{/other_user}","gists_url":"https://api.github.com/users/DaveCTurner/gists{/gist_id}","starred_url":"https://api.github.com/users/DaveCTurner/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/DaveCTurner/subscriptions","organizations_url":"https://api.github.com/users/DaveCTurner/orgs","repos_url":"https://api.github.com/users/DaveCTurner/repos","events_url":"https://api.github.com/users/DaveCTurner/events{/privacy}","received_events_url":"https://api.github.com/users/DaveCTurner/received_events","type":"User","site_admin":false},"created_at":"2018-07-30T10:24:26Z","updated_at":"2018-07-30T10:24:26Z","author_association":"CONTRIBUTOR","body":"The situation you are describing is a [dirty read](https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-replication.html#_failures) which is indeed a counterexample to linearizability. The documentation there indicates that dirty reads can be exposed by an isolated primary, but in fact there is nothing special about primaries: they can be exposed by any shard copy. The `_primary` preference doesn't help here: a situation which could lead to a dirty read involves a failure of a primary, so `preference=_primary` will silently shift to a different shard copy.\r\n\r\n> 2. without the possibility of using _primary, linearizability will fail all the time (within the replication time interval), because clients can connect to any of the shard holders (primary and copies).\r\n\r\nThis isn't the case - there's also `prefer_nodes`, `only_nodes` and custom preference values to guide clients towards reuse of the same shard copies each time.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/408952077","html_url":"https://github.com/elastic/elasticsearch/issues/31929#issuecomment-408952077","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/31929","id":408952077,"node_id":"MDEyOklzc3VlQ29tbWVudDQwODk1MjA3Nw==","user":{"login":"bleskes","id":1006375,"node_id":"MDQ6VXNlcjEwMDYzNzU=","avatar_url":"https://avatars1.githubusercontent.com/u/1006375?v=4","gravatar_id":"","url":"https://api.github.com/users/bleskes","html_url":"https://github.com/bleskes","followers_url":"https://api.github.com/users/bleskes/followers","following_url":"https://api.github.com/users/bleskes/following{/other_user}","gists_url":"https://api.github.com/users/bleskes/gists{/gist_id}","starred_url":"https://api.github.com/users/bleskes/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bleskes/subscriptions","organizations_url":"https://api.github.com/users/bleskes/orgs","repos_url":"https://api.github.com/users/bleskes/repos","events_url":"https://api.github.com/users/bleskes/events{/privacy}","received_events_url":"https://api.github.com/users/bleskes/received_events","type":"User","site_admin":false},"created_at":"2018-07-30T17:51:26Z","updated_at":"2018-07-30T17:51:26Z","author_association":"MEMBER","body":"To add to what David said - in your description the update to doc(2) was never acknowledged (because it was not fully replicated) but all of the above can happen even for acked writes. Say a primary got isolated, but doesn't know it is the case yet. Another replica is promoted and that one happens to receive and process with doc(2). Now you issue a get and that happens to hit the node with the old primary. It will happily respond (in that moment) with doc(1). \r\n\r\nBottom line - what ever you do, the model we use (for good reasons, see the doc I linked to) doesn't offer linearization under failure modes but is way more efficient under normal operations. Instead of fighting to reduce the error window (it's already pretty small) and make the system more complex, we prefer to clearly communicate this and make it clear via the API. The goal is that people will build systems that take it into account (potentially not caring) rather then assuming we give guarantees that only seem to be true.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/416968192","html_url":"https://github.com/elastic/elasticsearch/issues/31929#issuecomment-416968192","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/31929","id":416968192,"node_id":"MDEyOklzc3VlQ29tbWVudDQxNjk2ODE5Mg==","user":{"login":"DaveCTurner","id":5058284,"node_id":"MDQ6VXNlcjUwNTgyODQ=","avatar_url":"https://avatars3.githubusercontent.com/u/5058284?v=4","gravatar_id":"","url":"https://api.github.com/users/DaveCTurner","html_url":"https://github.com/DaveCTurner","followers_url":"https://api.github.com/users/DaveCTurner/followers","following_url":"https://api.github.com/users/DaveCTurner/following{/other_user}","gists_url":"https://api.github.com/users/DaveCTurner/gists{/gist_id}","starred_url":"https://api.github.com/users/DaveCTurner/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/DaveCTurner/subscriptions","organizations_url":"https://api.github.com/users/DaveCTurner/orgs","repos_url":"https://api.github.com/users/DaveCTurner/repos","events_url":"https://api.github.com/users/DaveCTurner/events{/privacy}","received_events_url":"https://api.github.com/users/DaveCTurner/received_events","type":"User","site_admin":false},"created_at":"2018-08-29T14:11:53Z","updated_at":"2018-08-29T14:11:53Z","author_association":"CONTRIBUTOR","body":"Thanks for your questions @bra-fsn, this kind of discussion is a good way to show us where our docs might be improved. If there's anything more that we can clarify then don't hold back. I'm closing this now as there's been no activity for a while and there's no further action to be taken at the moment.","performed_via_github_app":null}]