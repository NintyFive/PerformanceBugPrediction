{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/3300","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/3300/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/3300/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/3300/events","html_url":"https://github.com/elastic/elasticsearch/issues/3300","id":16500044,"node_id":"MDU6SXNzdWUxNjUwMDA0NA==","number":3300,"title":"Aggregation Module - Phase 1 - Functional Design","user":{"login":"uboness","id":211019,"node_id":"MDQ6VXNlcjIxMTAxOQ==","avatar_url":"https://avatars3.githubusercontent.com/u/211019?v=4","gravatar_id":"","url":"https://api.github.com/users/uboness","html_url":"https://github.com/uboness","followers_url":"https://api.github.com/users/uboness/followers","following_url":"https://api.github.com/users/uboness/following{/other_user}","gists_url":"https://api.github.com/users/uboness/gists{/gist_id}","starred_url":"https://api.github.com/users/uboness/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/uboness/subscriptions","organizations_url":"https://api.github.com/users/uboness/orgs","repos_url":"https://api.github.com/users/uboness/repos","events_url":"https://api.github.com/users/uboness/events{/privacy}","received_events_url":"https://api.github.com/users/uboness/received_events","type":"User","site_admin":false},"labels":[{"id":23172,"node_id":"MDU6TGFiZWwyMzE3Mg==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/%3Efeature","name":">feature","color":"006b75","default":false,"description":null},{"id":64607794,"node_id":"MDU6TGFiZWw2NDYwNzc5NA==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/v1.0.0.Beta2","name":"v1.0.0.Beta2","color":"dddddd","default":false,"description":null}],"state":"closed","locked":false,"assignee":{"login":"uboness","id":211019,"node_id":"MDQ6VXNlcjIxMTAxOQ==","avatar_url":"https://avatars3.githubusercontent.com/u/211019?v=4","gravatar_id":"","url":"https://api.github.com/users/uboness","html_url":"https://github.com/uboness","followers_url":"https://api.github.com/users/uboness/followers","following_url":"https://api.github.com/users/uboness/following{/other_user}","gists_url":"https://api.github.com/users/uboness/gists{/gist_id}","starred_url":"https://api.github.com/users/uboness/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/uboness/subscriptions","organizations_url":"https://api.github.com/users/uboness/orgs","repos_url":"https://api.github.com/users/uboness/repos","events_url":"https://api.github.com/users/uboness/events{/privacy}","received_events_url":"https://api.github.com/users/uboness/received_events","type":"User","site_admin":false},"assignees":[{"login":"uboness","id":211019,"node_id":"MDQ6VXNlcjIxMTAxOQ==","avatar_url":"https://avatars3.githubusercontent.com/u/211019?v=4","gravatar_id":"","url":"https://api.github.com/users/uboness","html_url":"https://github.com/uboness","followers_url":"https://api.github.com/users/uboness/followers","following_url":"https://api.github.com/users/uboness/following{/other_user}","gists_url":"https://api.github.com/users/uboness/gists{/gist_id}","starred_url":"https://api.github.com/users/uboness/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/uboness/subscriptions","organizations_url":"https://api.github.com/users/uboness/orgs","repos_url":"https://api.github.com/users/uboness/repos","events_url":"https://api.github.com/users/uboness/events{/privacy}","received_events_url":"https://api.github.com/users/uboness/received_events","type":"User","site_admin":false}],"milestone":null,"comments":75,"created_at":"2013-07-08T23:27:14Z","updated_at":"2016-04-20T01:29:33Z","closed_at":"2013-11-24T11:47:31Z","author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"**_NOTE: at this point we're focusing more on the functional design aspect rather than performance. Once we get this nailed down, we'll see how far we can push and optimize.**_\n### Background\n\nThe new aggregations module is due to elasticsearch 1.0 release, and aims to serve as the next generation replacement for the functionality we currently refer to as \"faceting\". Facets, currently provide a great way to aggregate data within a document set context. This context is defined by the executed query in combination with the different levels of filters that are defined (filtered queries, top level filters, and facet level filters). Although powerful as is, the current facets implementation was not designed from ground up to support complex aggregations and thus limited. The main problem with the current implementation stem in the fact that they are hard coded to work on one level and that the different types of facets (which account for the different types of aggregations we support) cannot be mixed and matched dynamically at query time. It is not possible to compose facets out of other facet and the user is effectively bound to the top level aggregations that we defined and nothing more than that.\n\nThe goal with the new aggregations module is to break the barriers the current facet implementation put in place. The new name (\"Aggregations\") also indicate the intention here - a generic yet extremely powerful framework for defining aggregations - any type of aggregation. The idea here is to have each aggregation defined as a \"standalone\" aggregation that can perform its task within any context (as a top level aggregation or embedded within other aggregations that can potentially narrow its computation scope). We would like to take all the knowledge and experience we've gained over the years working with facets and apply it when building the new framework.\n\nBefore we dive into the meaty part, it's important to set some key concepts and terminology first.\n### Key Concepts & Terminology\n- **Aggregation** - An aggregation is the result of an aggregation :). There are many types of aggregations, some look similar , others have their own unique structure (all depending on the nature of the aggregation). For example, a `terms` aggregation holds a list of objects (buckets), each holding information about a unique term. While an `avg` aggregation, just holds the avg number aggregated over all values of a specific field/s within a well defined set of documents.\n- **Aggregator** - An aggregator is the computation unit in elasticsearch which generates aggregations. It is effectively responsible for aggregating the data during query phase, and at the end of this phase, create the output aggregation. Each aggregation type has a dedicated aggregator which knows how to compute and generate it.\n\nThere are two types of aggregators/aggregations:\n- **Bucket** - A family of aggregators whos main responsibility is to define the current document set context and split it into buckets, where each bucket defines a well defined document set context. Typically, all aggregators of this type will also return the document count in each bucket. This aggregator is composable, meaning, one can define other aggregations under it. It will then perform these defined aggregations for each of the buckets it builds. It is therefore possible to create buckets within buckets within buckets... up to any level of hierarchy one desires. For example, one can define a filter bucket that holds all the \"active\" users (for example, if the documents represent website users/visitors), under which she'll define a range bucket that build 3 buckets to represent different user age groups, under each age group she'll define a terms bucket to narrow down the most common tags each age group is using on the website. As you can see, creating hierarchies of buckets can be extremely powerful can immensely help when sliding & dicing your data.\n- **Calc** - A family of aggregators whos sole responsibility is to perform computation and calculate numbers. It always operates in a well defined scope of a document set. This document set scope is either the top most level one - the scope defined by the search query, or otherwise defined by a higher level bucket aggregator (as discussed above). The Calc Aggregators typically work on field values, therefore utilizing the field data from which they extract these values. But one can utilise scripts to compute custom values which will be aggregated in different ways (depending on the specific calc aggregator that is used). If combining (mixing & matching) all different types of aggregators, while bucket aggregators can be placed anywhere in the aggregation definition \"tree\", calc aggregators are always \"leaves\" on the tree as (unlike bucket aggregators) they cannot contain other aggregators.\n#### Structuring Aggregations\n\nThe following snippet captures the basic structure of aggregations:\n\n``` json\n\"aggregations\" : {\n    \"<aggregation_name>\" : {\n        \"<aggregation_type>\" : { \n            <aggregation_body>\n        },\n        [\"aggregations\" : { [<sub_aggregation>]* } ]\n    }\n    [,\"<aggregation_name_2>\" : { ... } ]*\n\n}\n```\n\nThe `aggregations` object (can also be `aggs` for short) in the json holds the aggregations you'd like to be computed. Each aggregation is associated with a logical name that the user defines (e.g. if the aggregation computes the average price, then it'll make sense to call it `avg_price`). These logical names, also uniquely identify the aggregations you define (you'll use the same names/keys to identify the aggregations in the response). Each aggregation has a specific type (`<aggregation_type>` in the above snippet) and is typically the first key within the named aggregation body. Each type of aggregation define its own body, depending on the nature of the aggregation (eg. the `avg` aggregation will define the field on which the avg will be calculated). At the same level of the aggregation type definition, one can optionally define a set of additional aggregations, but this only makes sense if the aggregation you defined is a bucketing aggregation. In this scenario, the aggregation you define on the bucketing aggregation level will be computed for all the buckets built by the bucketing aggregation. For example, if the you define a set of aggregations under the `range` aggregation, these aggregations will be computed for each of the range buckets that are defined.\n\nIn this manner, you can mix & match bucketing and calculating aggregations any way you'd like, create any set of complex hierarchies by embedding aggregations (of type bucket or calc) within other bucket aggregations. To better grasp how they can all work together, please refer to the examples section below.\n### Calc Aggregators\n\nIn this section will provide an overview of all calc aggregations available to date. \n\nAll the calc aggregators we have today belong to the same family which we like to call `stats`. All the aggregator in this family are based on values that can either come from the field data or from a script that the user defines. \n\nThese aggregators operate on the following context: { _D_, _FV_ } where _D_ is the the set of documents from which the field values are extracted, and _FV_ is the set of values that should be aggregated. The aggregations take all those field values and calculates statistical values (some only calculate on value - they're called `single value stats aggregators`, while others generate a set of values - these are called `multi-value stats aggregators`).\n\nHere are all currently available stats aggregators\n#### Avg\n\nSingle Value Aggregator - Will return the average over all field values in the aggregation context, or what ever values the script generates\n\n``` json\n\"aggs\" : {\n    \"avg_price\" : { \"avg\" : { \"field\" : \"price\" } }\n}\n```\n\n``` json\n\"aggs\" : {\n    \"avg_price\" : { \"avg\" : { \"script\" : \"doc['price']\" } }\n}\n```\n\n``` json\n\"aggs\" : {\n    \"avg_price\" : { \"avg\" : { \"field\" : \"price\", \"script\" : \"_value\" } }\n}\n```\n\n_NOTE: when `field` and `script` are both specified, the script will be called for every value of the field in the context, and within the script you can access this value using the reserved variable `_value`.\n\nOutput:\n\n``` json\n\"avg_price\" : {\n    \"value\" : 10\n}\n```\n#### Min\n\nSingle Value Aggregator - Will return the minimum value among all field values in the aggregation context, or what ever values the script generates\n\n``` json\n\"aggs\" : {\n    \"min_price\" : { \"min\" : { \"field\" : \"price\" } }\n}\n```\n\n``` json\n\"aggs\" : {\n    \"min_price\" : { \"min\" : { \"script\" : \"doc['price']\" } }\n}\n```\n\n``` json\n\"aggs\" : {\n    \"min_price\" : { \"min\" : { \"field\" : \"price\", \"script\" : \"_value\" } }\n}\n```\n\nOutput:\n\n``` json\n\"min_price\" : {\n    \"value\" : 1\n}\n```\n#### Max\n\nSingle Value Aggregator - Will return the maximum value among all field values in the aggregation context, or what ever values the script generates\n\n``` json\n\"aggs\" : {\n    \"max_price\" : { \"max\" : { \"field\" : \"price\" } }\n}\n```\n\n``` json\n\"aggs\" : {\n    \"max_price\" : { \"max\" : { \"script\" : \"doc['price']\" } }\n}\n```\n\n``` json\n\"aggs\" : {\n    \"max_price\" : { \"max\" : { \"field\" : \"price\", \"script\" : \"_value\" } }\n}\n```\n\nOutput:\n\n``` json\n\"max_price\" : {\n    \"value\" : 100\n}\n```\n#### Sum\n\nSingle Value Aggregator - Will return the sum of all field values in the aggregation context, or what ever values the script generates\n\n``` json\n\"aggs\" : {\n    \"sum_price\" : { \"sum\" : { \"field\" : \"price\" } }\n}\n```\n\n``` json\n\"aggs\" : {\n    \"sum_price\" : { \"sum\" : { \"script\" : \"doc['price']\" } }\n}\n```\n\n``` json\n\"aggs\" : {\n    \"sum_price\" : { \"sum\" : { \"field\" : \"price\", \"script\" : \"_value\" } }\n}\n```\n\nOutput:\n\n``` json\n\"sum_price\" : {\n    \"value\" : 350\n}\n```\n#### Count\n\nSingle Value Aggregator - Will return the number of field values in the aggregation context, or what ever values the script generates\n\n``` json\n\"aggs\" : {\n    \"prices_count\" : { \"count\" : { \"field\" : \"price\" } }\n}\n```\n\n``` json\n\"aggs\" : {\n    \"prices_count\" : { \"count\" : { \"script\" : \"doc['price']\" } }\n}\n```\n\n``` json\n\"aggs\" : {\n    \"prices_count\" : { \"count\" : { \"field\" : \"price\", \"script\" : \"_value\" } }\n}\n```\n\nOutput:\n\n``` json\n\"prices_count\" : {\n    \"value\" : 400\n}\n```\n#### Stats\n\nMulti Value Aggregator - Will return the following stats aggregated over the field values in the aggregation context, or what ever values the script generates:\n- avg\n- min\n- max\n- count\n- sum\n\n``` json\n\"aggs\" : {\n    \"price_stats\" : { \"stats\" : { \"field\" : \"price\" } }\n}\n```\n\n``` json\n\"aggs\" : {\n    \"prices_stats\" : { \"stats\" : { \"script\" : \"doc['price']\" } }\n}\n```\n\n``` json\n\"aggs\" : {\n    \"prices_stats\" : { \"stats\" : { \"field\" : \"price\", \"script\" : \"_value\" } }\n}\n```\n\nOutput:\n\n``` json\n\"prices_stats\" : {\n    \"min\" : 1,\n    \"max\" : 10,\n    \"avg\" : 5.5,\n    \"sum\" : 55,\n    \"count\" : 10,\n}\n```\n#### Extended Stats\n\nMulti Value Aggregator - an extended version of the Stats aggregation above, where in addition to its aggregated statistics the following will also be aggregated:\n- sum_of_squares\n- variance\n- std_deviation\n\n``` json\n\"aggs\" : {\n    \"price_stats\" : { \"extended_stats\" : { \"field\" : \"price\" } }\n}\n```\n\n``` json\n\"aggs\" : {\n    \"prices_stats\" : { \"extended_stats\" : { \"script\" : \"doc['price']\" } }\n}\n```\n\n``` json\n\"aggs\" : {\n    \"prices_stats\" : { \"extended_stats\" : { \"field\" : \"price\", \"script\" : \"_value\" } }\n}\n```\n\nOutput:\n\n``` json\n\"value_stats\": {\n    \"count\": 10,\n    \"min\": 1.0,\n    \"max\": 10.0,\n    \"avg\": 5.5,\n    \"sum\": 55.0,\n    \"sum_of_squares\": 385.0,\n    \"variance\": 8.25,\n    \"std_deviation\": 2.8722813232690143\n}\n```\n### Bucket Aggregators\n\nBucket aggregators don't calculate values over fields like the `calc` aggregators do, but instead, they create buckets of documents. Each bucket defines a criteria (depends on the aggregation type) that determines whether or not a document in the current context \"falls\" in it. In other words, the buckets effectively define document sets (a.k.a docsets) on which the sub-aggregations are running on.\n\nThere a different bucket aggregators, each with a different \"bucketing\" strategy. Some define a single bucket, some define fixed number of multiple bucket, and others dynamically create the buckets while evaluating the docs.\n\nThe following describe the currently supported bucket aggregators.\n#### Global\n\nDefines a single bucket of all the documents within the search execution context. This context is defined by the indices and the document types you're searching on, but is **not** influenced by the search query itself.\n\n_Note, global aggregators can only be placed as top level aggregators (it makes no sense to embed a global aggregator within another bucket aggregator)_\n\n``` json\n\"aggs\" : {\n    \"global_stats\" : {\n        \"global\" : {}, // global has an empty body\n        \"aggs\" : {\n            \"avg_price\" : { \"avg\" : { \"field\" : \"price\" } }\n        }\n    }\n}\n```\n\nOutput\n\n``` json\n\"aggs\" : {\n    \"global_stats\" : {\n        \"doc_count\" : 100,\n        \"avg_price\" : { \"value\" : 56.3 }\n    }\n}\n```\n#### Filter\n\nDefines a single bucket of all the documents in the current docset context which match a specified filter. Often this will be used to narrow down the current aggregation context to a specific set of documents.\n\n``` json\n\"aggs\" : {\n    \"active_items\" : {\n        \"filter\" : { \"term\" : { \"active\" : true } },\n        \"aggs\" : {\n            \"avg_price\" : { \"avg\" : { \"field\" : \"price\" } }\n        }\n    }\n}\n```\n\nOutput\n\n``` json\n\"aggs\" : {\n    \"active_items\" : {\n        \"doc_count\" : 100,\n        \"avg_price\" : { \"value\" : 56.3 }\n    }\n}\n```\n#### Missing\n\nA field data based single bucket aggregator, that creates a bucket of all documents in the current docset context that are missing a field value. This aggregator will often be used in conjunction with other field data bucket aggregators (such as ranges) to return information for all the documents that could not be placed in any of the other buckets due to missing field data values. (The examples bellow show how well the range and the missing aggregators play together).\n\n``` json\n\"aggs\" : {\n    \"missing_price\" : {\n        \"missing\" : { \"field\" : \"price\" }\n    }\n}\n```\n\nOutput\n\n``` json\n\"aggs\" : {\n    \"missing_price\" : {\n        \"doc_count\" : 10\n    }\n}\n```\n#### Terms\n\nA field data based multi-bucket aggregator where buckets are dynamically built - one per unique value (term) of a specific field. For each such bucket the document count will be aggregated (accounting for all the documents in the current docset context that have that term for the specified field). This aggregator is very similar to how the terms facet works except that it is an aggregator just like any other aggregator, meaning it can be embedded in other bucket aggregators and it can also hold any types of sub-aggregators itself.\n\n``` json\n\"aggs\" : {\n    \"genders\" : {\n        \"terms\" : { \"field\" : \"gender\" },\n        \"aggs\" : {\n            \"avg_height\" : { \"avg\" : { \"field\" : \"height\" } }\n        }\n    }\n}\n```\n\nOutput\n\n``` json\n\"aggs\" : {\n    \"genders\" : {\n        \"terms\" : [\n            {\n                \"term\" : \"male\",\n                \"doc_count\" : 10,\n                \"avg_height\" : 178.5\n            },\n            {\n                \"term\" : \"female\",\n                \"doc_count\" : 10,\n                \"avg_height\" : 165\n            },\n        ]\n    }\n}\n```\n\n**TODO: do we want to get rid of the \"terms\" level in the response and directly put the terms array under the aggregation name? (we do that in range aggregation)**\n##### Options\n\n| Name | Default | Required | Description |\n| :-- | :-: | :-: | :-- |\n| field | - | yes/no | the name of the field from which the terms will be taken. It is required if there is no other field data based aggregator in the current aggregation context and the **script** option is also not set |\n| size | 10 | no | Only the top _n_ terms will be returned, the size determines what this _n_ is |\n| order | count desc | no | the order in which the term bucket will be sorted, see bellow for possible values |\n| script | - | no | one can choose to let a script generate the terms instead of extracting them verbatim from the field data. If the script is define along with the field, then this script will be executed for every term/value of the field data with a special variable **_value** which will provide access to that value from within the script (this is as opposed to specifying only the script, without the field, in which case the script will execute once per document in the aggregation context) |\n##### About order\n\nOne can define the order in which the term buckets will be sorted and therefore return in the response. There are 4 fixed/pre-defined order types and one more dynamic:\n\nOrder by term (alphabetically) ascending/descending:\n\n``` json\n\"aggs\" : {\n    \"genders\" : {\n        \"terms\" : { \"field\" : \"gender\", \"order\": { \"_term\" : \"desc\" } }\n    }\n}\n```\n\nOrder by count (alphabetically) ascending/descending:\n\n``` json\n\"aggs\" : {\n    \"genders\" : {\n        \"terms\" : { \"field\" : \"gender\", \"order\": { \"_count\" : \"asc\" } }\n    }\n}\n```\n\nOrder by direct embedded calc aggregation, ascending/descending. For single value calc aggregation:\n\n``` json\n\"aggs\" : {\n    \"genders\" : {\n        \"terms\" : { \"field\" : \"gender\", \"order\": { \"avg_price\" : \"asc\" } },\n        \"aggs\" : {\n            \"avg_price\" : { \"avg\" : { \"field\" : \"price\" } }\n        }\n    }\n}\n```\n\nOr, for multi-value calc aggregation:\n\n``` json\n\"aggs\" : {\n    \"genders\" : {\n        \"terms\" : { \"field\" : \"gender\", \"order\": { \"price_stats.avg\" : \"desc\" } },\n        \"aggs\" : {\n            \"price_stats\" : { \"stats\" : { \"field\" : \"price\" } }\n        }\n    }\n}\n```\n#### Range\n\nA field data bucket aggregation that enables the user to define a field on which the bucketing will work and a set of ranges. The aggregator will check each field data value in the current docset context against each bucket range and \"bucket\" the relevant document & values if they match. Note, that here, not only we're bucketing by document, we're also bucketing by value. For example, let's say we're bucketing on multi-value field, and document _D_ has values [1, 2, 3, 4, 5] for the field. In addition, there is a range bucket [ x < 4 ]. When evaluating document _D_, it seems to fall right in this range bucket, but it does so due to field values [1, 2, 3], not because values [4, 5]. Nowâ€¦ if this bucket will also have a sub-aggregators associated with it (say, sum aggregator), the system will make sure to only aggregate values [1, 2, 3] excluding [4, 5](as 4 and 5 as values, don't really belong to this bucket). This is quite different than the other bucket aggregators we've seen until now which mainly focused on whether the document falls in the bucket or not. Here we also keep track of the values belonging to each bucket.\n\n``` json\n\"aggs\" : {\n    \"age_groups\" : {\n        \"range\" : { \n            \"field\" : \"age\",\n            \"ranges\" : [\n                { \"to\" : 5 },\n                { \"from\" : 5, \"to\" : 10 },\n                { \"from\" : 10, \"to\" : 15 },\n                { \"from\" : 15}\n            ]\n        },\n        \"aggs\" : {\n            \"avg_height\" : { \"avg\" : { \"field\" : \"height\" } }\n        }\n    }\n}\n\n```\n\nOutput\n\n``` json\n\"aggregations\" : {\n    \"age_groups\" : [\n        {\n            \"to\" : 5.0,\n            \"doc_count\" : 10,\n            \"avg_height\" : 95\n        },\n        {\n            \"from\" : 5.0,\n            \"to\" : 10.0,\n            \"doc_count\" : 5,\n            \"avg_height\" : 130\n        },\n        {\n            \"from\" : 10.0\n            \"to\" : 15.0,\n            \"doc_count\" : 4,\n            \"avg_height\" : 160\n        },\n        {\n            \"from\" : 15.0,\n            \"doc_count\" : 10,\n            \"avg_height\" : 175.5\n        }\n    ]\n}\n```\n\nOf course, you normally don't want to store the **age** as a field, but store the birthdate instead. We can use scripts to generate the age:\n\n``` json\n\"aggs\" : {\n    \"age_groups\" : {\n        \"range\" : { \n            \"script\" : \"DateTime.now().year - doc['birthdate'].date.year\",\n            \"ranges\" : [\n                { \"to\" : 5 },\n                { \"from\" : 5, \"to\" : 10 },\n                { \"from\" : 10, \"to\" : 15 },\n                { \"from\" : 15}\n            ]\n        },\n        \"aggs\" : {\n            \"avg_height\" : { \"avg\" : { \"field\" : \"height\" } }\n        }\n    }\n}\n\n```\n\nAs with all other aggregations, leaving out the **field** from calc aggregator, will fall back on the field by which the range bucketing is done.\n\n``` json\n\"aggs\" : {\n    \"age_groups\" : {\n        \"range\" : { \n            \"field\" : \"age\",\n            \"ranges\" : [\n                { \"to\" : 5 },\n                { \"from\" : 5, \"to\" : 10 },\n                { \"from\" : 10, \"to\" : 15 },\n                { \"from\" : 15}\n            ]\n        },\n        \"aggs\" : {\n            \"min\" : { \"min\" : { } },\n            \"max\" : { \"max\" : { } }\n        }\n    }\n}\n```\n\nOutput\n\n``` json\n\"aggregations\" : {\n    \"age_groups\" : [\n        {\n            \"to\" : 5.0,\n            \"doc_count\" : 10,\n            \"min\" : 4.0,\n            \"max\" : 5.0\n        },\n        {\n            \"from\" : 5.0,\n            \"to\" : 10.0,\n            \"doc_count\" : 5,\n            \"min\" : 5.0,\n            \"max\" : 8.0\n        },\n        {\n            \"from\" : 10.0\n            \"to\" : 15.0,\n            \"doc_count\" : 4,\n            \"min\" : 11.0,\n            \"max\" : 13.0\n        },\n        {\n            \"from\" : 15.0,\n            \"doc_count\" : 10,\n            \"min\" : 15.0,\n            \"max\" : 22.0\n        }\n    ]\n}\n```\n\nFurthermore, you can also define a value script which will serve as a transformation to the field data value:\n\n``` json\n\"aggs\" : {\n    \"age_groups\" : {\n        \"range\" : { \n            \"field\" : \"count\",\n            \"script\" : \"_value - 3\"\n            \"ranges\" : [\n                { \"to\" : 6 },\n                { \"from\" : 6 }\n            ]\n        },\n        \"aggs\" : {\n            \"min\" : { \"min\" : {} },\n            \"min_count\" : { \"min\" : { \"field\" : \"count\" } }\n        }\n    }\n}\n```\n\nOutput\n\n``` json\n\"aggregations\": {\n    \"count_ranges\": [\n      {\n        \"to\": 6.0,\n        \"doc_count\": 8,\n        \"min\": {\n          \"value\": -2.0\n        },\n        \"min_count\": {\n          \"value\": 1.0\n        }\n      },\n      {\n        \"from\": 6.0,\n        \"doc_count\": 2,\n        \"min\": {\n          \"value\": 6.0\n        },\n        \"min_count\": {\n          \"value\": 9.0\n        }\n      }\n    ]\n  }\n```\n\nNotice, the **min** aggregation above acts on the actual values that were used for the bucketing (after the transformation by the script), while the **min_count** aggregation act on the values of the count field that fall within their bucket.\n#### Date Range\n\nA range aggregation that is dedicated for date values. The main difference between this date range agg. to the normal range agg. is that the `from` and `to` values can be expressed in _Date Math_ expressions, and it is also possible to specify a date format by which the `from` and `to` json fields will be returned in the response:\n\n``` json\n\"aggs\": {\n    \"range\": {\n        \"date_range\": {\n            \"field\": \"date\",\n            \"format\": \"MM-yyy\",\n            \"ranges\": [\n                {\n                    \"to\": \"now-10M/M\"\n                },\n                {\n                    \"from\": \"now-10M/M\"\n                }\n            ]\n        }\n    }\n}\n```\n\nIn the example above, we created two range buckets:\n- the first will bucket all documents dated prior to 10 months ago\n- the second will bucket all document dated since 10 months ago\n\n``` json\n\"aggregations\": {\n    \"range\": [\n        {\n            \"to\": 1.3437792E+12,\n            \"to_as_string\": \"08-2012\",\n            \"doc_count\": 7\n        },\n        {\n            \"from\": 1.3437792E+12,\n            \"from_as_string\": \"08-2012\",\n            \"doc_count\": 2\n        }\n    ]\n}\n```\n#### IP Range\n\nJust like the dedicated date range aggregation, there is also a dedicated range aggregation for IPv4 typed fields:\n\n``` json\n\"aggs\" : {\n    \"ip_ranges\" : {\n        \"ip_range\" : {\n            \"field\" : \"ip\",\n            \"ranges\" : [\n                { \"to\" : \"10.0.0.5\" },\n                { \"from\" : \"10.0.0.5\" }\n            ]\n        }\n    }\n}\n```\n\nOutput:\n\n``` json\n\"aggregations\": {\n    \"ip_ranges\": [\n        {\n            \"to\": 167772165,\n            \"to_as_string\": \"10.0.0.5\",\n            \"doc_count\": 4\n        },\n        {\n            \"from\": 167772165,\n            \"from_as_string\": \"10.0.0.5\",\n            \"doc_count\": 6\n        }\n    ]\n}\n```\n\nIP ranges can also be defined as CIDR masks:\n\n``` json\n\"aggs\" : {\n    \"ip_ranges\" : {\n        \"ip_range\" : {\n            \"field\" : \"ip\",\n            \"ranges\" : [\n                { \"mask\" : \"10.0.0.0/25\" },\n                { \"mask\" : \"10.0.0.127/25\" }\n            ]\n        }\n    }\n}\n```\n\nOutput:\n\n``` json\n\"aggregations\": {\n    \"ip_ranges\": [\n      {\n        \"key\": \"10.0.0.0/25\",\n        \"from\": 1.6777216E+8,\n        \"from_as_string\": \"10.0.0.0\",\n        \"to\": 167772287,\n        \"to_as_string\": \"10.0.0.127\",\n        \"doc_count\": 127\n      },\n      {\n        \"key\": \"10.0.0.127/25\",\n        \"from\": 1.6777216E+8,\n        \"from_as_string\": \"10.0.0.0\",\n        \"to\": 167772287,\n        \"to_as_string\": \"10.0.0.127\",\n        \"doc_count\": 127\n      }\n    ]\n}\n```\n#### Histogram\n\nAn aggregation that can be applied to numeric fields, and dynamically builds fixed size (a.k.a. interval) buckets over all the values of the document fields in the docset context. For example, if the documents have a field that holds a price (numeric), we can ask this aggregator to dynamically build buckets with interval 5 (in case of `price` it may represent $5). When the aggregation executes, the price field of every document within the aggregation context will be evaluated and will be **rounded** down to its closes bucket - for example, if the price is `32` and the bucket size is `5` then the rounding will yield `30` and thus the document will \"fall\" into the bucket the bucket that is associated withe the key `30`. To make this more formal, here is the rounding function that is used:\n\n`bucket_key = value - value % interval`\n\nA basic histogram aggergation on a single numeric field `value` (maybe be single or multi valued field)\n\n``` json\n\"aggs\" : {\n    \"value_histo\" : {\n            \"histogram\" : {\n                    \"field\" : \"value\",\n                    \"interval\" : 3\n            }\n    }\n}\n```\n\nAn histogram aggregation on multiple fields\n\n``` json\n\"aggs\" : {\n    \"value_histo\" : {\n            \"histogram\" : {\n                    \"field\" : [ \"value\", \"values\" ],\n                    \"interval\" : 3\n            }\n    }\n}\n```\n\nThe output of the histogram is an array of the buckets, where each bucket holds its key and the number of documents that fall in it. This array can be sorted based on different attributes in an ascending or descending order:\n- `_key` - The buckets will be sorted by their key\n- `_count` - The buckets will be sorted by the number of documents that fall in them\n- `aggName` - Bucket may hold other aggegations that will be applied to those documents that fall in them. It is possible to sort the buckets based on direct single-valued **calc** aggregations that they hold\n- `aggName` & `valueName` - It is also possible to sort buckets based on direct multi-valued **calc** aggregations that they hold\n\nSorting by bucket `key` descending\n\n``` json\n\"aggs\" : {\n    \"histo\" : {\n        \"histogram\" : {\n            \"field\" : \"value\",\n            \"interval\" : 3,\n            \"order\" : { \"_key\" : \"desc\" }\n        }\n    }\n}\n```\n\nSorting by document count ascending\n\n``` json\n\"aggs\" : {\n    \"histo\" : {\n        \"histogram\" : {\n            \"field\" : \"value\",\n            \"interval\" : 3,\n            \"order\" : { \"_count\" : \"asc\" }\n        }\n    }\n}\n```\n\nAdding a sum aggregation (which is a single valued calc aggregation) to the buckets and sorting by it\n\n``` json\n\"aggs\" : {\n    \"histo\" : {\n        \"histogram\" : {\n            \"field\" : \"value\",\n            \"interval\" : 3,\n            \"order\" : { \"value_sum\" : \"asc\" }\n        },\n        \"aggs\" : {\n            \"value_sum\" : { \"sum\" : {} }\n        }\n    }\n}\n```\n\nAdding a stats aggregation (which is a multi-valued calc aggregation) to the buckets and sorting by the avg\n\n``` json\n\"aggs\" : {\n    \"histo\" : {\n        \"histogram\" : {\n            \"field\" : \"value\",\n            \"interval\" : 3,\n            \"order\" : { \"value_stats.avg\" : \"desc\" }\n        },\n        \"aggs\" : {\n            \"value_stats\" : { \"stats\" : {} }\n        }\n    }\n}\n```\n\nUsing value scripts to \"preprocess\" the values before the bucketing\n\n``` json\n\"aggs\" : {\n    \"histo\" : {\n        \"histogram\" : {\n            \"field\" : \"value\",\n            \"script\" : \"_value * 4\",\n            \"interval\" : 3,\n            \"order\" : { \"sum\" : \"desc\"}\n        },\n        \"aggregations\" : {\n            \"sum\" : { \"sum\" : {} }\n        }\n    }\n}\n```\n\nIt's also possible to use document level scripts to compute the value by which the documents will be \"bucketted\"\n\n``` json\n\"aggs\" : {\n    \"histo\" : {\n        \"histogram\" : {\n            \"script\" : \"doc['value'].value + doc['value2'].value\",\n            \"interval\" : 3,\n            \"order\" : { \"stats.sum\" : \"desc\" }\n        },\n        \"aggregations\" : {\n            \"stats\" : { \"stats\" : {} }\n        }\n    }\n}\n```\n\nOutput:\n\n``` json\n\"aggregations\": {\n  \"histo\": [\n    {\n      \"key\": 21,\n      \"doc_count\": 2,\n      \"stats\": {\n        \"count\": 2,\n        \"min\": 8.0,\n        \"max\": 9.0,\n        \"avg\": 8.5,\n        \"sum\": 17.0\n      }\n    },\n    {\n      \"key\": 15,\n      \"doc_count\": 2,\n      \"stats\": {\n        \"count\": 2,\n        \"min\": 5.0,\n        \"max\": 6.0,\n        \"avg\": 5.5,\n        \"sum\": 11.0\n      }\n    },\n    {\n      \"key\": 24,\n      \"doc_count\": 1,\n      \"stats\": {\n        \"count\": 1,\n        \"min\": 10.0,\n        \"max\": 10.0,\n        \"avg\": 10.0,\n        \"sum\": 10.0\n      }\n    },\n    {\n      \"key\": 18,\n      \"doc_count\": 1,\n      \"stats\": {\n        \"count\": 1,\n        \"min\": 7.0,\n        \"max\": 7.0,\n        \"avg\": 7.0,\n        \"sum\": 7.0\n      }\n    },\n    {\n      \"key\": 9,\n      \"doc_count\": 2,\n      \"stats\": {\n        \"count\": 2,\n        \"min\": 2.0,\n        \"max\": 3.0,\n        \"avg\": 2.5,\n        \"sum\": 5.0\n      }\n    },\n    {\n      \"key\": 12,\n      \"doc_count\": 1,\n      \"stats\": {\n        \"count\": 1,\n        \"min\": 4.0,\n        \"max\": 4.0,\n        \"avg\": 4.0,\n        \"sum\": 4.0\n      }\n    },\n    {\n      \"key\": 6,\n      \"doc_count\": 1,\n      \"stats\": {\n        \"count\": 1,\n        \"min\": 1.0,\n        \"max\": 1.0,\n        \"avg\": 1.0,\n        \"sum\": 1.0\n      }\n    }\n  ]\n}\n```\n#### Date Histogram\n\nDate histogram is a similar aggregation to the normal histogram (as described above) except that it can only work on date fields. Since dates are indexed internally as long values, it's possible to use the normal histogram on dates as well, but problem though stems in the fact that time based intervals are not fixed (think of leap years and on the number of days in a month). For this reason, we need a spcial support for time based data. From functionality perspective, this historam supports the same features as the normal histogram. The main difference though is that the interval can be specified by time expressions.\n\nBuilding a month length bucket intervals\n\n``` json\n\"aggs\" : {\n    \"histo\" : {\n        \"date_histogram\" : {\n            \"field\" : \"date\",\n            \"interval\" : \"month\"\n        }\n    }\n}\n```\n\nor based on 1.5 months\n\n``` json\n\"aggs\" : {\n    \"histo\" : {\n        \"date_histogram\" : {\n            \"field\" : \"date\",\n            \"interval\" : \"1.5M\"\n        }\n    }\n}\n```\n\nOther available expressions for interval: `year`, `quarter`, `week`, `day`, `hour`, `minute`, `second`\n\nSince internally, dates are represented as 64bit numbers, these numbers are returned as the bucket keys (each key representing a date). For this reason, it is also possible to define a date format, which will result in returning the dates as formatted strings next to the numeric key values:\n\n``` json\n\"aggs\" : {\n    \"histo\" : {\n        \"date_histogram\" : {\n            \"field\" : \"date\",\n            \"interval\" : \"1M\",\n            \"format\" : \"yyyy-MM-dd\"\n        }\n    }\n}\n```\n\nOutput:\n\n``` json\n\"aggregations\": {\n    \"histo\": [\n        {\n          \"key_as_string\": \"2012-02-02\",\n          \"key\": 1328140800000,\n          \"doc_count\": 1\n        },\n        {\n          \"key_as_string\": \"2012-03-02\",\n          \"key\": 1330646400000,\n          \"doc_count\": 2\n        },\n        ...\n    ]\n}\n```\n\nTimezones are also supported, enabling the user to define by which timezone they'd like to bucket the documents (this support is very similar to the TZ support in the DateHistogram facet).\n\nSimilar to the current date histogram facet, pref_offset & post_offset will are also supported, for offsets applying pre rounding and post rounding. The values are time values with a possible `-` sign. For example, to offset a week rounding to start on Sunday instead of Monday, one can pass pre_offset of -1d to decrease a day before doing the week (monday based) rounding, and then have post_offset set to -1d to actually set the return value to be Sunday, and not Monday.\n\nLike with the normal histogram, both document level scripts and value scripts are supported. It is possilbe to control the order of the buckets that are returned. And of course, nest other aggregations within the buckets.\n\nBoth the normal `histogram` and the `date_histogram` now support computing/returning empty buckets. This can be controlled by setting the `compute_empty_buckets` parameter to `true` (defaults to `false`). \n#### Geo Distance\n\nAn aggregation that works on `geo_point` fields. Conceptually, it works very similar to range aggregation. The user can define a point of `origin` and a set of distance range buckets. The aggregation evaluate the distance of each document from the `origin` point and determine the bucket it belongs to based on the ranges (a document belongs to a bucket if the distance between the document and the `origin` falls within the distance range of the bucket).\n\n``` json\n\"aggs\" : {\n    \"rings\" : {\n        \"geo_distance\" : {\n            \"field\" : \"location\",\n            \"origin\" : \"52.3760, 4.894\",\n            \"ranges\" : [\n                { \"to\" : 100 },\n                { \"from\" : 100, \"to\" : 300 },\n                { \"from\" : 300 }\n            ]\n        }\n    }\n}\n```\n\nOutput\n\n``` json\n\"aggregations\": {\n  \"rings\": [\n    {\n      \"unit\": \"km\",\n      \"to\": 100.0,\n      \"doc_count\": 3\n    },\n    {\n      \"unit\": \"km\",\n      \"from\": 100.0,\n      \"to\": 300.0,\n      \"doc_count\": 1\n    },\n    {\n      \"unit\": \"km\",\n      \"from\": 300.0,\n      \"doc_count\": 7\n    }\n  ]\n}\n```\n\nThe specified `field` must be of type `geo_point` (which can only be set explicitly in the mappings). And it can also hold an array of `geo_point` fields, in which case all will be taken into account during aggregation. The `origin` point can accept all format `geo_point` supports:\n- Object format: `{ \"lat\" : 52.3760, \"lon\" : 4.894 }` - this is the safest format as it's the most explicit about the `lat` & `lon` values\n- String format: `\"52.3760, 4.894\"` - where the first number is the `lat` and the second is the `lon`\n- Array format: `[4.894, 52.3760]` - which is based on the GeoJson standard and where the first number is the `lon` and the second one is the `lat`\n\nBy default, the distance unit is `km` but it can also accept: `mi` (miles), `in` (inch), `yd` (yards), `m` (meters), `cm` (centimeters), `mm` (millimeters).\n\n``` json\n\"aggs\" : {\n    \"rings\" : {\n        \"geo_distance\" : {\n            \"field\" : \"location\",\n            \"origin\" : \"52.3760, 4.894\",\n            \"unit\" : \"mi\",\n            \"ranges\" : [\n                { \"to\" : 100 },\n                { \"from\" : 100, \"to\" : 300 },\n                { \"from\" : 300 }\n            ]\n        }\n    }\n}\n```\n\nThere are two distance calculation modes: `arc` (the default) and `plane`. The `arc` calculation is the most accurate one but also the more expensive one in terms of performance. The `plane` is faster but less accurate. Consider using `plane` when your search context is narrow smaller areas (like cities or even countries). `plane` may return higher error mergins for searches across very large areans (e.g. cross atlantic search).\n\n``` json\n\"aggs\" : {\n    \"rings\" : {\n        \"geo_distance\" : {\n            \"field\" : \"location\",\n            \"origin\" : \"52.3760, 4.894\",\n            \"distance_type\" : \"plane\",\n            \"ranges\" : [\n                { \"to\" : 100 },\n                { \"from\" : 100, \"to\" : 300 },\n                { \"from\" : 300 }\n            ]\n        }\n    }\n}\n```\n#### Nested\n\nA special single bucket aggregation which enables aggregating nested documents:\n\nassuming the following mapping:\n\n``` json\n\"type\" : {\n        \"properties\" : {\n            \"nested\" : { \"type\" : \"nested\" }\n        }\n    }\n}\n```\n\nHere's how a nested aggregation can be defined:\n\n``` json\n\"aggs\" : {\n    \"nested_value_stats\" : {\n        \"nested\" : {\n            \"path\" : \"nested\"\n        },\n        \"aggs\" : {\n            \"stats\" : {\n                \"stats\" : { \"field\" : \"nested.value\" }\n            }\n        }\n    }\n}\n```\n\nAs you can see above, the nested aggregation requires the path of the nested documents within the top level documents. Then one can define any type of aggregation over these nested documents.\n\nOutput:\n\n``` json\n\"aggregations\": {\n    \"employees_salaries\": {\n        \"doc_count\": 25,\n        \"stats\": {\n            \"count\": 25,\n            \"min\": 1.0,\n            \"max\": 9.0,\n            \"avg\": 5.0,\n            \"sum\": 125.0\n        }\n    }\n}\n```\n### Examples\n#### Filter + Range + Missing + Stats\n\nAnalyse the online product catalog web access logs. The following aggregation will only aggregate those logs from yesterday (the **filter** aggregation), providing information for different price ranges (the **range** aggregation), where per price range we'll return the price stats on that range and the total page views for those documents in the each range. We're also interested in finding all the bloopers - all those products that for some reason don't have prices associated with them and still they are exposed to the user and being accessed and viewed.\n\n``` json\n\"aggs\" : {\n    \"yesterday\" : {\n        \"filter\" : { \"range\" : { \"date\" { \"gt\" : \"now-1d/d\", \"lt\" : \"now/d\" } } },\n        \"aggs\" : {\n            \"missing_price\" : {\n                \"missing\" : { \"field\" : \"price\" },\n                \"aggs\" : {\n                    \"total_page_views\" : { \"sum\" : { \"field\" : \"page_views\" } }\n                }\n            },\n            \"prices\" : {\n                \"range\" : {\n                    \"field\" : \"price\",\n                    \"ranges\" : [\n                        { \"to\" : 100 },\n                        { \"from\" : 100, \"to\" : 200 },\n                        { \"from\" : 200, \"to\" 300 },\n                        { \"from\" : 300 }\n                    ]\n                },\n                \"aggs\" : {\n                    \"price_stats\" : { \"stats\" : {} },\n                    \"total_page_views\" : { \"sum\" : { \"field\" : \"page_views\" } }\n                }\n            }\n        }\n    }\n}\n```\n#### Aggregating Hierarchical Data\n\nQuite often you'd like to get aggregations on location in an hierarchical manner. For example, show all countries and how many documents fall within each country, and for each country show a breakdown by city. Here's a simple way to do it using hierarchical terms aggregations:\n\n``` json\n\"aggs\" : {\n    \"country\" : {\n        \"terms\" : { \"field\" : \"country\" },\n        \"aggs\" : {\n            \"city\" : {\n                \"terms\" : { \"field\" : \"city\" }\n            }\n        }\n    }\n}\n```\n","closed_by":{"login":"uboness","id":211019,"node_id":"MDQ6VXNlcjIxMTAxOQ==","avatar_url":"https://avatars3.githubusercontent.com/u/211019?v=4","gravatar_id":"","url":"https://api.github.com/users/uboness","html_url":"https://github.com/uboness","followers_url":"https://api.github.com/users/uboness/followers","following_url":"https://api.github.com/users/uboness/following{/other_user}","gists_url":"https://api.github.com/users/uboness/gists{/gist_id}","starred_url":"https://api.github.com/users/uboness/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/uboness/subscriptions","organizations_url":"https://api.github.com/users/uboness/orgs","repos_url":"https://api.github.com/users/uboness/repos","events_url":"https://api.github.com/users/uboness/events{/privacy}","received_events_url":"https://api.github.com/users/uboness/received_events","type":"User","site_admin":false},"performed_via_github_app":null}