{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/19957","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19957/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19957/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19957/events","html_url":"https://github.com/elastic/elasticsearch/issues/19957","id":170681755,"node_id":"MDU6SXNzdWUxNzA2ODE3NTU=","number":19957,"title":"Improve resiliency of snapshot deletions","user":{"login":"abeyad","id":1631297,"node_id":"MDQ6VXNlcjE2MzEyOTc=","avatar_url":"https://avatars2.githubusercontent.com/u/1631297?v=4","gravatar_id":"","url":"https://api.github.com/users/abeyad","html_url":"https://github.com/abeyad","followers_url":"https://api.github.com/users/abeyad/followers","following_url":"https://api.github.com/users/abeyad/following{/other_user}","gists_url":"https://api.github.com/users/abeyad/gists{/gist_id}","starred_url":"https://api.github.com/users/abeyad/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/abeyad/subscriptions","organizations_url":"https://api.github.com/users/abeyad/orgs","repos_url":"https://api.github.com/users/abeyad/repos","events_url":"https://api.github.com/users/abeyad/events{/privacy}","received_events_url":"https://api.github.com/users/abeyad/received_events","type":"User","site_admin":false},"labels":[{"id":143077482,"node_id":"MDU6TGFiZWwxNDMwNzc0ODI=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/:Distributed/Snapshot/Restore","name":":Distributed/Snapshot/Restore","color":"0e8a16","default":false,"description":"Anything directly related to the `_snapshot/*` APIs"},{"id":23174,"node_id":"MDU6TGFiZWwyMzE3NA==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/%3Eenhancement","name":">enhancement","color":"4a4ea8","default":false,"description":null}],"state":"closed","locked":false,"assignee":{"login":"abeyad","id":1631297,"node_id":"MDQ6VXNlcjE2MzEyOTc=","avatar_url":"https://avatars2.githubusercontent.com/u/1631297?v=4","gravatar_id":"","url":"https://api.github.com/users/abeyad","html_url":"https://github.com/abeyad","followers_url":"https://api.github.com/users/abeyad/followers","following_url":"https://api.github.com/users/abeyad/following{/other_user}","gists_url":"https://api.github.com/users/abeyad/gists{/gist_id}","starred_url":"https://api.github.com/users/abeyad/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/abeyad/subscriptions","organizations_url":"https://api.github.com/users/abeyad/orgs","repos_url":"https://api.github.com/users/abeyad/repos","events_url":"https://api.github.com/users/abeyad/events{/privacy}","received_events_url":"https://api.github.com/users/abeyad/received_events","type":"User","site_admin":false},"assignees":[{"login":"abeyad","id":1631297,"node_id":"MDQ6VXNlcjE2MzEyOTc=","avatar_url":"https://avatars2.githubusercontent.com/u/1631297?v=4","gravatar_id":"","url":"https://api.github.com/users/abeyad","html_url":"https://github.com/abeyad","followers_url":"https://api.github.com/users/abeyad/followers","following_url":"https://api.github.com/users/abeyad/following{/other_user}","gists_url":"https://api.github.com/users/abeyad/gists{/gist_id}","starred_url":"https://api.github.com/users/abeyad/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/abeyad/subscriptions","organizations_url":"https://api.github.com/users/abeyad/orgs","repos_url":"https://api.github.com/users/abeyad/repos","events_url":"https://api.github.com/users/abeyad/events{/privacy}","received_events_url":"https://api.github.com/users/abeyad/received_events","type":"User","site_admin":false}],"milestone":null,"comments":0,"created_at":"2016-08-11T15:58:23Z","updated_at":"2016-12-26T00:00:21Z","closed_at":"2016-12-26T00:00:21Z","author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"Currently, when we try to delete a snapshot, we first check to see if a snapshot or a restore is in progress, and if so, we prevent the deletion from happening.  While this takes care of most cases, the possibility of a race condition still exists here because once the deletion operation passes this initial check, it commences with deleting the snapshot files, and if in the meantime while executing the delete operation, a snapshot or restore operation is started, we don't have any way of knowing a deletion is executing and hence the snapshot or restore operation should not be permitted.  \n\nThis can lead to race conditions where we are restoring a snapshot that is under deletion, or we are taking a snapshot of an index while some of its files are being deleted by the deletion operation.  This can also lead to more subtle bugs, for example, suppose a deletion request is started, we check that there are no snapshot/restores taking place, and then proceed with deletion.  Subsequently, we issue another deletion request while the first deletion is taking place.  This can also lead to race conditions with deletion.  Furthermore, if both of these deletions are taking place, and then we initiate a snapshot or restore operation, we have no way of knowing a deletion is in process, so the snapshot/restore will commence.  The snapshot/restore will initially read the repository data, which it gets from the index generational file.  It is possible that the snapshot/restore reads the current generation value (lets call it `N`), but before reading the index file `index-N`, both of the deletes complete, which create `index-{N+1}` and `index-{N+2}`.  We only keep around the current index file and the one before it, so then `index-N` will have been deleted.  Now, when the snapshot/restore operation resumes and tries to read `index-N`, it will fail as the file is not there.\n\nA solution would be to maintain deletions in progress in the cluster state along with snapshots in progress and restores in progress.  By using the cluster state as a point of synchronization, we can execute deletes more safely in relation to other potential operations on the repository at the same time.\n","closed_by":{"login":"abeyad","id":1631297,"node_id":"MDQ6VXNlcjE2MzEyOTc=","avatar_url":"https://avatars2.githubusercontent.com/u/1631297?v=4","gravatar_id":"","url":"https://api.github.com/users/abeyad","html_url":"https://github.com/abeyad","followers_url":"https://api.github.com/users/abeyad/followers","following_url":"https://api.github.com/users/abeyad/following{/other_user}","gists_url":"https://api.github.com/users/abeyad/gists{/gist_id}","starred_url":"https://api.github.com/users/abeyad/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/abeyad/subscriptions","organizations_url":"https://api.github.com/users/abeyad/orgs","repos_url":"https://api.github.com/users/abeyad/repos","events_url":"https://api.github.com/users/abeyad/events{/privacy}","received_events_url":"https://api.github.com/users/abeyad/received_events","type":"User","site_admin":false},"performed_via_github_app":null}