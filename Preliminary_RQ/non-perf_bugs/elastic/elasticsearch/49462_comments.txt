[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/557244555","html_url":"https://github.com/elastic/elasticsearch/issues/49462#issuecomment-557244555","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/49462","id":557244555,"node_id":"MDEyOklzc3VlQ29tbWVudDU1NzI0NDU1NQ==","user":{"login":"elasticmachine","id":15837671,"node_id":"MDQ6VXNlcjE1ODM3Njcx","avatar_url":"https://avatars3.githubusercontent.com/u/15837671?v=4","gravatar_id":"","url":"https://api.github.com/users/elasticmachine","html_url":"https://github.com/elasticmachine","followers_url":"https://api.github.com/users/elasticmachine/followers","following_url":"https://api.github.com/users/elasticmachine/following{/other_user}","gists_url":"https://api.github.com/users/elasticmachine/gists{/gist_id}","starred_url":"https://api.github.com/users/elasticmachine/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/elasticmachine/subscriptions","organizations_url":"https://api.github.com/users/elasticmachine/orgs","repos_url":"https://api.github.com/users/elasticmachine/repos","events_url":"https://api.github.com/users/elasticmachine/events{/privacy}","received_events_url":"https://api.github.com/users/elasticmachine/received_events","type":"User","site_admin":false},"created_at":"2019-11-21T19:49:38Z","updated_at":"2019-11-21T19:49:38Z","author_association":"COLLABORATOR","body":"Pinging @elastic/es-search (:Search/EQL)","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/557492236","html_url":"https://github.com/elastic/elasticsearch/issues/49462#issuecomment-557492236","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/49462","id":557492236,"node_id":"MDEyOklzc3VlQ29tbWVudDU1NzQ5MjIzNg==","user":{"login":"costin","id":76245,"node_id":"MDQ6VXNlcjc2MjQ1","avatar_url":"https://avatars3.githubusercontent.com/u/76245?v=4","gravatar_id":"","url":"https://api.github.com/users/costin","html_url":"https://github.com/costin","followers_url":"https://api.github.com/users/costin/followers","following_url":"https://api.github.com/users/costin/following{/other_user}","gists_url":"https://api.github.com/users/costin/gists{/gist_id}","starred_url":"https://api.github.com/users/costin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/costin/subscriptions","organizations_url":"https://api.github.com/users/costin/orgs","repos_url":"https://api.github.com/users/costin/repos","events_url":"https://api.github.com/users/costin/events{/privacy}","received_events_url":"https://api.github.com/users/costin/received_events","type":"User","site_admin":false},"created_at":"2019-11-22T11:11:10Z","updated_at":"2019-11-22T11:11:10Z","author_association":"MEMBER","body":"üëç for Option 1.\r\n\r\nTwo main reasons come to mind:\r\n\r\na.  Redundancy\r\nThe language already encapsulates the target in its declaration - in fact it's the first item: `target WHERE filter`. \r\nSupporting another way to override the target (URL or otherwise) makes the language redundant (which goes against the whole premise of a declarative language) and confusing - which one wins? The language or the URL/<what have you>?\r\n\r\nFurther more, this means a query is non-deterministic since depending on the URL (in your proposal), the target it declares might be considered or not. This is a significant step backwards in terms of readability. \r\n\r\nb. Scoping\r\n`target WHERE filter` is a building block - it can be used at top-level but also embedded inside `sequence` and `join` which by definition, are touching multiple targets.\r\n\r\nIn the following declaration:\r\n```\r\njoin by ip\r\n  [file where ...]\r\n  [process where ...]\r\n  [network where ...]\r\n```\r\nthere are 3 targets. \r\nIn the language they are clearly defined per-filter/rule however re-declaring them for the whole query/request means that the rules will be applied across all of them, essentially overriding the language scoping itself. Not good.\r\n\r\n ### Side-note: Mapping\r\n\r\nLanguage aside, I believe the conundrum of this issue relates to the way data is mapped.\r\nElasticsearch (and to this effect Kibana) uses indices in the URL since these are decoupled from the actual query (which has the nice effect of re-usability including aliasing).\r\n\r\nEQL is the opposite, by default it touches multiple targets which raises the question what is the target ? an index or a field? That is, how fine is the target granularity?\r\n\r\nNamely what does `target WHERE filter` mean - is target an index or a field inside the index (which in effect means the whole request runs against the same index):\r\n\r\n  x) `FROM index WHERE targetField == target AND filter` \r\nor \r\n  y) `FROM target WHERE filter`.\r\n\r\nThere's pros and cons to each:\r\n\r\ntarget as fields ( x ) means:\r\n‚ûñ   the target it can be used inside filtering which will have (unexpected) side-effects:\r\n`target WHERE targetField == target1` which would translate to `FROM index WHERE targetField == target1 AND targetField == target` which matches nothing.\r\nWe can potentially address that through dedicated validation.\r\n‚≠ïÔ∏è  using the field type for differentiation encourages different document types to be mapped under the same index. I can see both positives and negatives to this (depending on how different certain documents are).\r\n‚≠ïÔ∏è  indices will require some sort of `targetField` - not a big deal but not ideal either.\r\n‚≠ïÔ∏è  a user using x) can move to one index per field-type but vice-versa, moving from index per type to one index with multiple types would not be possible.\r\n\r\nOverall I find y) better - there's no redundancy or special mapping and different indices or the same one can be reused across rules depending on the mapping:\r\n\r\n```\r\njoin by ip\r\n  [index where someField == value]\r\n  [index where someOtherField == another]\r\n  [anotherIndex where ...]\r\n```\r\n\r\nThis avoids the need to use indices in the URL and can even allow multiple indices to be specified in \r\nthe same rule:\r\n\r\n```\r\njoin by ip\r\n  [indexA, indexB where someField == value]\r\n  ...\r\n```\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/558094758","html_url":"https://github.com/elastic/elasticsearch/issues/49462#issuecomment-558094758","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/49462","id":558094758,"node_id":"MDEyOklzc3VlQ29tbWVudDU1ODA5NDc1OA==","user":{"login":"colings86","id":236731,"node_id":"MDQ6VXNlcjIzNjczMQ==","avatar_url":"https://avatars0.githubusercontent.com/u/236731?v=4","gravatar_id":"","url":"https://api.github.com/users/colings86","html_url":"https://github.com/colings86","followers_url":"https://api.github.com/users/colings86/followers","following_url":"https://api.github.com/users/colings86/following{/other_user}","gists_url":"https://api.github.com/users/colings86/gists{/gist_id}","starred_url":"https://api.github.com/users/colings86/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/colings86/subscriptions","organizations_url":"https://api.github.com/users/colings86/orgs","repos_url":"https://api.github.com/users/colings86/repos","events_url":"https://api.github.com/users/colings86/events{/privacy}","received_events_url":"https://api.github.com/users/colings86/received_events","type":"User","site_admin":false},"created_at":"2019-11-25T10:36:11Z","updated_at":"2019-11-25T10:36:11Z","author_association":"MEMBER","body":"Thanks for raising this @stacey-gammon. I have a few thoughts here.\r\n\r\nFirstly I think that question 4 is a really important one. The EQL language is being used in the wild on endpoints and users already have rules written in EQL. If we come up with a solution which requires users to rewrite those rules and/or change the way they think about writing rules this will create friction for those users to use EQL against Elasticsearch. \r\n\r\n> or you'd have to create an alias ahead of time to point to those three indices (at which point... I suppose the query is irrelevant. just search for ip).\r\n\r\nNote that its possible to reference multiple indices as a comma delimited list e.g. `index1,index2,index3` so using `*` would not be necessary.\r\n\r\nFor question 6 I'm not sure I understand why using _index is necessary. to select the indices we would use a comma delimited list of the indices we want tot apply the rule to and then the rule would be written in terms of the event types:\r\n\r\n```\r\nGET packetbeat-*,firewall-data-*,endpoint-network-*/_eql/search\r\n{\r\n  rule: '''\r\n     join by ip\r\n       [packet where true]\r\n       [firewall where true]\r\n       [network where true]\r\n    '''\r\n}\r\n```\r\n(note this looks a little weird since the example is contrived)\r\n\r\nIt also gives the user more granularity into the event types. For example the event types that packetbeat uses may be stored in the same index so the use can easily select the event type they are interested in using the existing EQL approach e.g. `apache_packet where...`.\r\n\r\n> Supporting another way to override the target (URL or otherwise) makes the language redundant (which goes against the whole premise of a declarative language) and confusing - which one wins? The language or the URL/?\r\n\r\nI'm not sure I agree with this. This is not what option 2 does IMO. If we think about how EQL works today on the endpoint, there is a single store of events. This is analogous to an index. So the URL would be pointing to which store of events to run the rule on. The first word of the rule (or sequence element) indicates the type of event to use as context (process, file, network etc.). These do not overlap. Some users may decide to store data for different event types in different indexes and some my not, but this does not affect that the first part of the rule (or sequence element) is the event type not the index.\r\n\r\nAnother factor to consider here is that users will need to store their data in different ways (especially when we look past EQL only being used with endpoint), and rules are shipped with the product and shared between users. This means that having the index pattern in the rule itself ties the rule to particular index topologies and makes it harder to share rules. It also makes it hard to adapt the index topology over time if we need to since if we split event types into different indices in the future or combined event types into the same index in the future.\r\n\r\nPersonally I think option 2 will create a similar UX to the existing EQL implementation, and allows users to share rules without worrying about how the data is spread across indexes.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/558219470","html_url":"https://github.com/elastic/elasticsearch/issues/49462#issuecomment-558219470","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/49462","id":558219470,"node_id":"MDEyOklzc3VlQ29tbWVudDU1ODIxOTQ3MA==","user":{"login":"rw-access","id":31489089,"node_id":"MDQ6VXNlcjMxNDg5MDg5","avatar_url":"https://avatars1.githubusercontent.com/u/31489089?v=4","gravatar_id":"","url":"https://api.github.com/users/rw-access","html_url":"https://github.com/rw-access","followers_url":"https://api.github.com/users/rw-access/followers","following_url":"https://api.github.com/users/rw-access/following{/other_user}","gists_url":"https://api.github.com/users/rw-access/gists{/gist_id}","starred_url":"https://api.github.com/users/rw-access/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/rw-access/subscriptions","organizations_url":"https://api.github.com/users/rw-access/orgs","repos_url":"https://api.github.com/users/rw-access/repos","events_url":"https://api.github.com/users/rw-access/events{/privacy}","received_events_url":"https://api.github.com/users/rw-access/received_events","type":"User","site_admin":false},"created_at":"2019-11-25T15:57:48Z","updated_at":"2019-11-25T17:19:53Z","author_association":"MEMBER","body":"> If we come up with a solution which requires users to rewrite those rules and/or change the way they think about writing rules this will create friction for those users to use EQL against Elasticsearch.\r\n\r\nWe don't have a choice. None of the existing rules will work as-is, _so all rules must be rewritten._ Every field looks different now that we use ECS is the schema instead of the format represented by the Endgame platform. We can write one-off scripts, like [`eqllib convert-query`](https://eqllib.readthedocs.io/en/latest/guides/cli.html#convert-query) to help with this process.\r\n\r\nI think it's important that the language is completely independent from how its stored. Coupling a specific key-value pair, like eventType=X sounds like its trying to be flexible but makes the language and API awkwardly restrictive.\r\n\r\nI've mentioned this [in other mediums](https://github.com/elastic/dev/issues/1312), but I think it's worth bringing up again: it sounds like we're trying to achieve shareability while maintain full flexibility from how the data is stored. These are at ends with each other, but I think there's a (somewhat) simple solution to reconcile the two together. We can add a shorthand \"target\" that can be defined separately for each organization, depending on their indexing strategy. Assuming ECS is widely adopted and universal, I think this is reasonable:\r\n\r\n>  One thing that I think could work is adding another concept, similar to index patterns. We could allow users to create their own short-hand, like a narrowing query to find **process** events. For instance, a user could specify (outside of EQL) **process** means `endgame-process-* where event.category=\"process\"`. Then if you have an EQL query in the form `process where process.name == \"net.exe\"`, you know the index pattern to use, and the narrowing query to add to it. It would essentially expand to `endgame-process-* where event.category=\"process\" and process.name == \"net.exe\"`.\r\n\r\nFor example, a search request\r\n```json\r\nGET index-pattern-*/_eql/search?sync_search_threshold=5s\r\n\r\n{\r\n  \"event_mapping\": {\r\n    \"file\" : {\r\n      \"index\": \"endgame-file-*\"\r\n      },\r\n     \"process\": {\r\n       \"index\": [\"endgame-*\"],\r\n       \"filter\": \"event.category == 'process'\"\r\n     }\r\n  },\r\n  \"rule\": \"\"\"\r\n            sequence with maxspan=5h \r\n              [file where user.name != 'SYSTEM' by file.path]\r\n              [process where user.name = 'SYSTEM' by process.path]\r\n          \"\"\"\r\n}\r\n```\r\n\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/558258441","html_url":"https://github.com/elastic/elasticsearch/issues/49462#issuecomment-558258441","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/49462","id":558258441,"node_id":"MDEyOklzc3VlQ29tbWVudDU1ODI1ODQ0MQ==","user":{"login":"clintongormley","id":56599,"node_id":"MDQ6VXNlcjU2NTk5","avatar_url":"https://avatars0.githubusercontent.com/u/56599?v=4","gravatar_id":"","url":"https://api.github.com/users/clintongormley","html_url":"https://github.com/clintongormley","followers_url":"https://api.github.com/users/clintongormley/followers","following_url":"https://api.github.com/users/clintongormley/following{/other_user}","gists_url":"https://api.github.com/users/clintongormley/gists{/gist_id}","starred_url":"https://api.github.com/users/clintongormley/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/clintongormley/subscriptions","organizations_url":"https://api.github.com/users/clintongormley/orgs","repos_url":"https://api.github.com/users/clintongormley/repos","events_url":"https://api.github.com/users/clintongormley/events{/privacy}","received_events_url":"https://api.github.com/users/clintongormley/received_events","type":"User","site_admin":false},"created_at":"2019-11-25T17:28:33Z","updated_at":"2019-11-25T17:28:33Z","author_association":"CONTRIBUTOR","body":"We had a Zoom meeting and came to the following conclusions:\r\n\r\n* The index pattern should be specified in the URL of the request\r\n* EQL should default to expecting data in ECS format (ie the object type to the left of the `where` clause will be translated into a query on `event.type`), but this mapping can be overridden with a parameter in the request body\r\n* The request body should also accept a `filter` (like SQL) for applying eg a timerange filter\r\n\r\nFor example:\r\n\r\n```\r\nGET endpoint-*/_eql\r\n{\r\n  \"query\": \"process where foo...\",\r\n  \"filter\": {\r\n    \"range\": {\r\n      \"@timestamp\": {\r\n        \"gte\": \"2019-01-01\",\r\n        \"lt\": \"2020-01-01\"\r\n      }\r\n    }\r\n  },\r\n  \"event_field_lookup\": \"event.type\" # default\r\n}\r\n```\r\n\r\n\r\n\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/558272343","html_url":"https://github.com/elastic/elasticsearch/issues/49462#issuecomment-558272343","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/49462","id":558272343,"node_id":"MDEyOklzc3VlQ29tbWVudDU1ODI3MjM0Mw==","user":{"login":"jpountz","id":299848,"node_id":"MDQ6VXNlcjI5OTg0OA==","avatar_url":"https://avatars2.githubusercontent.com/u/299848?v=4","gravatar_id":"","url":"https://api.github.com/users/jpountz","html_url":"https://github.com/jpountz","followers_url":"https://api.github.com/users/jpountz/followers","following_url":"https://api.github.com/users/jpountz/following{/other_user}","gists_url":"https://api.github.com/users/jpountz/gists{/gist_id}","starred_url":"https://api.github.com/users/jpountz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jpountz/subscriptions","organizations_url":"https://api.github.com/users/jpountz/orgs","repos_url":"https://api.github.com/users/jpountz/repos","events_url":"https://api.github.com/users/jpountz/events{/privacy}","received_events_url":"https://api.github.com/users/jpountz/received_events","type":"User","site_admin":false},"created_at":"2019-11-25T18:04:41Z","updated_at":"2019-11-25T18:04:41Z","author_association":"CONTRIBUTOR","body":"@clintongormley Do you have a recording of the meeting by any chance?","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/558273768","html_url":"https://github.com/elastic/elasticsearch/issues/49462#issuecomment-558273768","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/49462","id":558273768,"node_id":"MDEyOklzc3VlQ29tbWVudDU1ODI3Mzc2OA==","user":{"login":"clintongormley","id":56599,"node_id":"MDQ6VXNlcjU2NTk5","avatar_url":"https://avatars0.githubusercontent.com/u/56599?v=4","gravatar_id":"","url":"https://api.github.com/users/clintongormley","html_url":"https://github.com/clintongormley","followers_url":"https://api.github.com/users/clintongormley/followers","following_url":"https://api.github.com/users/clintongormley/following{/other_user}","gists_url":"https://api.github.com/users/clintongormley/gists{/gist_id}","starred_url":"https://api.github.com/users/clintongormley/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/clintongormley/subscriptions","organizations_url":"https://api.github.com/users/clintongormley/orgs","repos_url":"https://api.github.com/users/clintongormley/repos","events_url":"https://api.github.com/users/clintongormley/events{/privacy}","received_events_url":"https://api.github.com/users/clintongormley/received_events","type":"User","site_admin":false},"created_at":"2019-11-25T18:08:29Z","updated_at":"2019-11-25T18:08:29Z","author_association":"CONTRIBUTOR","body":"Sorry, no, but happy to answer questions @jpountz ","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/558619123","html_url":"https://github.com/elastic/elasticsearch/issues/49462#issuecomment-558619123","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/49462","id":558619123,"node_id":"MDEyOklzc3VlQ29tbWVudDU1ODYxOTEyMw==","user":{"login":"jpountz","id":299848,"node_id":"MDQ6VXNlcjI5OTg0OA==","avatar_url":"https://avatars2.githubusercontent.com/u/299848?v=4","gravatar_id":"","url":"https://api.github.com/users/jpountz","html_url":"https://github.com/jpountz","followers_url":"https://api.github.com/users/jpountz/followers","following_url":"https://api.github.com/users/jpountz/following{/other_user}","gists_url":"https://api.github.com/users/jpountz/gists{/gist_id}","starred_url":"https://api.github.com/users/jpountz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jpountz/subscriptions","organizations_url":"https://api.github.com/users/jpountz/orgs","repos_url":"https://api.github.com/users/jpountz/repos","events_url":"https://api.github.com/users/jpountz/events{/privacy}","received_events_url":"https://api.github.com/users/jpountz/received_events","type":"User","site_admin":false},"created_at":"2019-11-26T13:04:53Z","updated_at":"2019-11-26T14:54:12Z","author_association":"CONTRIBUTOR","body":"No questions in particular, I was just curious about any details that might have been discussed in this meeting.\r\n\r\nGood arguments have been made for both options, but I think that the argument that convinced me the most is the one by Colin about decoupling rules and index topologies so that one can change topologies without having to rewrite rules. That said, I expect that targets will often match entire index patterns, which resonated with an idea that I've been thinking about for the past days about having some special fields that have the same value for all documents in an index and could get similar optimizations to `term`/`wildcard` queries on `_index` or `range` queries on `@timestamp`. It almost makes option 1 and option 2 meet in the sense that using that special field type for `event.type` and later filtering on `event.type` would be mostly the same as providing an index pattern as a target.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/559513437","html_url":"https://github.com/elastic/elasticsearch/issues/49462#issuecomment-559513437","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/49462","id":559513437,"node_id":"MDEyOklzc3VlQ29tbWVudDU1OTUxMzQzNw==","user":{"login":"colings86","id":236731,"node_id":"MDQ6VXNlcjIzNjczMQ==","avatar_url":"https://avatars0.githubusercontent.com/u/236731?v=4","gravatar_id":"","url":"https://api.github.com/users/colings86","html_url":"https://github.com/colings86","followers_url":"https://api.github.com/users/colings86/followers","following_url":"https://api.github.com/users/colings86/following{/other_user}","gists_url":"https://api.github.com/users/colings86/gists{/gist_id}","starred_url":"https://api.github.com/users/colings86/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/colings86/subscriptions","organizations_url":"https://api.github.com/users/colings86/orgs","repos_url":"https://api.github.com/users/colings86/repos","events_url":"https://api.github.com/users/colings86/events{/privacy}","received_events_url":"https://api.github.com/users/colings86/received_events","type":"User","site_admin":false},"created_at":"2019-11-28T14:25:18Z","updated_at":"2019-11-28T14:25:27Z","author_association":"MEMBER","body":"Closing this issue in favour of https://github.com/elastic/elasticsearch/issues/49634 which includes the outcome of using `event.type` discussed here but is for the EQL search REST API design as a while","performed_via_github_app":null}]