{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/30086","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/30086/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/30086/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/30086/events","html_url":"https://github.com/elastic/elasticsearch/issues/30086","id":317454844,"node_id":"MDU6SXNzdWUzMTc0NTQ4NDQ=","number":30086,"title":"Introduce cross-cluster replication","user":{"login":"elasticmachine","id":15837671,"node_id":"MDQ6VXNlcjE1ODM3Njcx","avatar_url":"https://avatars3.githubusercontent.com/u/15837671?v=4","gravatar_id":"","url":"https://api.github.com/users/elasticmachine","html_url":"https://github.com/elasticmachine","followers_url":"https://api.github.com/users/elasticmachine/followers","following_url":"https://api.github.com/users/elasticmachine/following{/other_user}","gists_url":"https://api.github.com/users/elasticmachine/gists{/gist_id}","starred_url":"https://api.github.com/users/elasticmachine/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/elasticmachine/subscriptions","organizations_url":"https://api.github.com/users/elasticmachine/orgs","repos_url":"https://api.github.com/users/elasticmachine/repos","events_url":"https://api.github.com/users/elasticmachine/events{/privacy}","received_events_url":"https://api.github.com/users/elasticmachine/received_events","type":"User","site_admin":false},"labels":[{"id":912824565,"node_id":"MDU6TGFiZWw5MTI4MjQ1NjU=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/:Distributed/CCR","name":":Distributed/CCR","color":"0e8a16","default":false,"description":"Issues around the Cross Cluster State Replication features"},{"id":158399402,"node_id":"MDU6TGFiZWwxNTgzOTk0MDI=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/Meta","name":"Meta","color":"e11d21","default":false,"description":null}],"state":"closed","locked":false,"assignee":{"login":"martijnvg","id":580421,"node_id":"MDQ6VXNlcjU4MDQyMQ==","avatar_url":"https://avatars3.githubusercontent.com/u/580421?v=4","gravatar_id":"","url":"https://api.github.com/users/martijnvg","html_url":"https://github.com/martijnvg","followers_url":"https://api.github.com/users/martijnvg/followers","following_url":"https://api.github.com/users/martijnvg/following{/other_user}","gists_url":"https://api.github.com/users/martijnvg/gists{/gist_id}","starred_url":"https://api.github.com/users/martijnvg/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/martijnvg/subscriptions","organizations_url":"https://api.github.com/users/martijnvg/orgs","repos_url":"https://api.github.com/users/martijnvg/repos","events_url":"https://api.github.com/users/martijnvg/events{/privacy}","received_events_url":"https://api.github.com/users/martijnvg/received_events","type":"User","site_admin":false},"assignees":[{"login":"martijnvg","id":580421,"node_id":"MDQ6VXNlcjU4MDQyMQ==","avatar_url":"https://avatars3.githubusercontent.com/u/580421?v=4","gravatar_id":"","url":"https://api.github.com/users/martijnvg","html_url":"https://github.com/martijnvg","followers_url":"https://api.github.com/users/martijnvg/followers","following_url":"https://api.github.com/users/martijnvg/following{/other_user}","gists_url":"https://api.github.com/users/martijnvg/gists{/gist_id}","starred_url":"https://api.github.com/users/martijnvg/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/martijnvg/subscriptions","organizations_url":"https://api.github.com/users/martijnvg/orgs","repos_url":"https://api.github.com/users/martijnvg/repos","events_url":"https://api.github.com/users/martijnvg/events{/privacy}","received_events_url":"https://api.github.com/users/martijnvg/received_events","type":"User","site_admin":false},{"login":"jasontedor","id":4744941,"node_id":"MDQ6VXNlcjQ3NDQ5NDE=","avatar_url":"https://avatars3.githubusercontent.com/u/4744941?v=4","gravatar_id":"","url":"https://api.github.com/users/jasontedor","html_url":"https://github.com/jasontedor","followers_url":"https://api.github.com/users/jasontedor/followers","following_url":"https://api.github.com/users/jasontedor/following{/other_user}","gists_url":"https://api.github.com/users/jasontedor/gists{/gist_id}","starred_url":"https://api.github.com/users/jasontedor/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jasontedor/subscriptions","organizations_url":"https://api.github.com/users/jasontedor/orgs","repos_url":"https://api.github.com/users/jasontedor/repos","events_url":"https://api.github.com/users/jasontedor/events{/privacy}","received_events_url":"https://api.github.com/users/jasontedor/received_events","type":"User","site_admin":false},{"login":"dnhatn","id":13474362,"node_id":"MDQ6VXNlcjEzNDc0MzYy","avatar_url":"https://avatars3.githubusercontent.com/u/13474362?v=4","gravatar_id":"","url":"https://api.github.com/users/dnhatn","html_url":"https://github.com/dnhatn","followers_url":"https://api.github.com/users/dnhatn/followers","following_url":"https://api.github.com/users/dnhatn/following{/other_user}","gists_url":"https://api.github.com/users/dnhatn/gists{/gist_id}","starred_url":"https://api.github.com/users/dnhatn/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dnhatn/subscriptions","organizations_url":"https://api.github.com/users/dnhatn/orgs","repos_url":"https://api.github.com/users/dnhatn/repos","events_url":"https://api.github.com/users/dnhatn/events{/privacy}","received_events_url":"https://api.github.com/users/dnhatn/received_events","type":"User","site_admin":false}],"milestone":null,"comments":6,"created_at":"2017-09-05T21:15:00Z","updated_at":"2019-03-28T00:03:49Z","closed_at":"2019-03-06T03:19:19Z","author_association":"COLLABORATOR","active_lock_reason":null,"body":"## Issue description\r\n\r\n*Original comment by @jasontedor:*\r\n\r\nThe goal of cross-cluster replication is to enable users to replicate operations from one cluster to another cluster via active-passive replication. There are three drivers for providing CCR functionality in X-Pack:\r\n - resiliency in case the primary cluster fails, a secondary cluster can serve as a hot backup\r\n - geo-proximity so that reads can be served locally\r\n - ECE can use the infrastructure for a UI to replicate data from one cluster to another\r\n\r\nThe purpose of this meta-issue is to serve as a high-level plan for the initial implementation.\r\n\r\nOur initial implementation will build a shard-to-shard pull-based model without automatic setup built on the transport layer.\r\n\r\nIn this model, shards on a following index are responsible for pulling from shards on the leader index. We chose this model because:\r\n - this model has simpler state management than a push-based model (each follower has one leader, but not vice-versa)\r\n - recovery during failure is simpler as the follower knows how far it is in the sequence of operations\r\n - operations can be streamed from any copy of the leader shard (the primary shard, or any of its replicas)\r\n\r\nAs far as automatic setup, for now users will have to manually set up a following index to a leader index, and would have to use on bootstrapping existing data via snapshot/restore. This does not necessarily mean that we will not have something more sophisticated when the first version ships, only that for the initial implementation we will not look at anything else. We can consider automatic setup (for example, for time-based indices) and remote recovery infrastructure later.\r\n\r\nUtilizing the transport layer allows us to reuse existing infrastructure, and we can follow the path blazed by cross-cluster search for reading from remote clusters.\r\n\r\nBasic infrastructure:\r\n - API to serve operations from a given sequence number\r\n   - needs to fetch the sequence number\r\n   - respond with batch of requested size to client\r\n   - only return documents below the global checkpoint\r\n - persistent task for the following index to pull data from the leader index\r\n - a following engine implementation that can index operations that already have a sequence number (from the leader)\r\n   - the engine should reject operations that do not have a sequence number\r\n   - the engine will add a primary term\r\n   - this engine will not close gaps in histories upon recoveries, that is expected to be done from the leader\r\n   - we need to carefully consider the tradeoff of having the engine open for pluggability versus a key component of the CCR infrastructure being in open source\r\n - implement a mechanism to transfer index metadata changes (e.g., mapping) to a follower from the leader\r\n   - could be done inline with the shard operation stream\r\n   - alternatively, the shard operation stream could indicate the minimum index metadata version required and the following index could wait (through an observer) until the local version catches up\r\n - CCR REST API for users to set up remote replication\r\n   - design API\r\n   - implement API\r\n\r\n## Things to do and investigate: \r\n\r\n- ~[ ] Old indices cannot be followed. The soft delete index setting should not allowed to be set on older indices (indices that have been created prior to when ccr was released) (Nhat)~. We discussed and decided not to do this for now.\r\n- [x] We currently allow duplicate seq# in lucene (marked as deleted and pointing to the same document version), in some rare cases around recovery and delayed recovery. This is not considered a big deal, but if we find a simple solution to avoid it, we would prefer a clean history. @dnhatn (no)\r\n-  ~[ ] Until rollbacks are fully implemented for Lucene, lucene make contain seq# collisions. These can be resolved by making CCR terms aware - i.e., use terms as a secondary sort and us it to dedup operations. We should decide if needs to be done, especially when at some point Lucene rollbacks will be implemented (and are expected to clean these collisions). @dnhatn (yes)~. Discussed this with Martijn, the [dedup logic](https://github.com/elastic/elasticsearch/blob/c783488e971d3099a2fc03446c978fae0286cba8/server/src/main/java/org/elasticsearch/index/engine/LuceneChangesSnapshot.java#L233-L237) we have in LuceneChangesSnapshot is sufficient.\r\n- [x] Add additional validation to FollowIndexAction#validate(...). For example mappings need to be identical and leader / follow index must be open. (MvG) #31068\r\n- [x] Reject a follow request if the follower does not have `index.xpack.ccr.following_index` setting (Nhat) (https://github.com/elastic/elasticsearch/pull/32448).\r\n- [x] Add a test that verifies that when all copies of a shard are unavailable ccr keeps on following the leader index and restart the shard follow task when a copy of this shard becomes available. (@dnhatn) (yes)\r\n- [x] Modifying a mapping of a follower index should be prohibited. The mapping is kept in sync with the leader index by an internal mechanism in CCR. (@dnhatn) (#37675)\r\n- [x] Add a version to MappingMetaData in cluster state, so that we only sync mappings between leader and follow index if the mapping has changed. Currently we keep track of changes via the index metadata version. So if the refresh rate is changed then we try to sync mappings too. @jasontedor\r\n- [x] The follow shard task should poll for the global checkpoint in a more efficient manner. Currently the shard follow checks the leader's indices stats api every fixed amount of time to get the global checkpoint of a specific primary shard. However we can add an additional api that allows us to do this in a long polling manner. That way we get notified right away when the global checkpoint has increased based on what the follow shard task knows. Also this avoids a lot of chatter in the case no changes occur in the leader index. #32651 (@jasontedor) (yes)\r\n- [x] Add validation that prevent following incompatible indexes. There is no good validation that prevents from following leader index with an incompatible existing follow index. It is likely that this will because of not matching global checkpoints and sequence numbers, but this is not guaranteed. Ideally you should only be able to follow an index that has been created by the create and follow api. Validation could be based on leader index uuid that we store in the index settings of a follow index. Or something more clever like using history uuid, but that requires more work. #31505  @martijnvg (yes)\r\n- [x] FollowingEngine shouldn't fill history gaps upon promotion and recovery https://github.com/elastic/elasticsearch/issues/31318\r\n- [x] Re-evaluate shard follow parameter defaults. #31717 (@dliappis) (yes)\r\n- [x] Improve shard follow task retry mechanism #31816\r\n- [x] ShardFollowNodeTask should fetch operations once (#32455)\r\n- [x] Move requests, response and action classes to xpack core module and verify that transport client works with ccr. (no)\r\n- [x] Make ccr work with high level rest client. (no)\r\n- [x] Store or generate autoGeneratedIdTimestamp for append-only documents. (@dnhatn) (yes) (#33656)\r\n- [x] Make `index.xpack.ccr.following_index` a final / internal setting. To avoid directly writing into the following index. Only CCR can write into a follow index. (@martijnvg) (yes)\r\n- [x] Record the history uuid of the leader index into index level metadata and validate in follow api and each fetch in shard follow task that the leader uuid is the same with what is recorded. (@martijnvg) (yes)\r\n- [x] Force a new history uuid when force allocating a stale primary. So that we can detect in the follow shard task that the history uuid has changed and then fail. #26712 (@dnhatn) (yes)\r\n- [x] Improve failure handling and by retrying failed fetch calls in exponential backoff manner. Retryable failures should be retried indefinitely. #33371 (@martijnvg) (yes)\r\n- ~~- [ ] Disable external usage of the follow api until we can safely execute a follow call after an unfollow call. (no)~~\r\n- [x] Expose current number of retries for failed fetch tasks in stats API. (@jasontedor) (yes)\r\n- [x] Auto-follow patterns #33007 (yes and no 😉)\r\n- [x] Rename `search.remote.*` settings to `cluster.remote.*` (@jasontedor) (#33413)\r\n- [x] Automatically upgrade `search.remote.*` in the cluster state to `cluster.remote.*` (@jasontedor) #33536, #33537\r\n- [x] Follow APIs should check if user has sufficient privileges before executing #33553 (yes) (@martijnvg)\r\n- [x] Add create_follow_index privilege #33555 (yes) (@martijnvg)\r\n- [ ] Auto resume following a leader index shard in case the history uuid of a follow shard has changed.\r\n- [ ] When following a leader in that is also a follower index then use the history uuid of the leader index's leader index.\r\n- [x] Auto-follow patterns should fail and report if they match an index where soft deletes are not enabled. This is likely an operator mistake.\r\n- [x] Include CCR into the xpack usage api. #37221","closed_by":{"login":"jasontedor","id":4744941,"node_id":"MDQ6VXNlcjQ3NDQ5NDE=","avatar_url":"https://avatars3.githubusercontent.com/u/4744941?v=4","gravatar_id":"","url":"https://api.github.com/users/jasontedor","html_url":"https://github.com/jasontedor","followers_url":"https://api.github.com/users/jasontedor/followers","following_url":"https://api.github.com/users/jasontedor/following{/other_user}","gists_url":"https://api.github.com/users/jasontedor/gists{/gist_id}","starred_url":"https://api.github.com/users/jasontedor/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jasontedor/subscriptions","organizations_url":"https://api.github.com/users/jasontedor/orgs","repos_url":"https://api.github.com/users/jasontedor/repos","events_url":"https://api.github.com/users/jasontedor/events{/privacy}","received_events_url":"https://api.github.com/users/jasontedor/received_events","type":"User","site_admin":false},"performed_via_github_app":null}