[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/9831924","html_url":"https://github.com/elastic/elasticsearch/issues/2361#issuecomment-9831924","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/2361","id":9831924,"node_id":"MDEyOklzc3VlQ29tbWVudDk4MzE5MjQ=","user":{"login":"chrismale","id":1080664,"node_id":"MDQ6VXNlcjEwODA2NjQ=","avatar_url":"https://avatars0.githubusercontent.com/u/1080664?v=4","gravatar_id":"","url":"https://api.github.com/users/chrismale","html_url":"https://github.com/chrismale","followers_url":"https://api.github.com/users/chrismale/followers","following_url":"https://api.github.com/users/chrismale/following{/other_user}","gists_url":"https://api.github.com/users/chrismale/gists{/gist_id}","starred_url":"https://api.github.com/users/chrismale/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/chrismale/subscriptions","organizations_url":"https://api.github.com/users/chrismale/orgs","repos_url":"https://api.github.com/users/chrismale/repos","events_url":"https://api.github.com/users/chrismale/events{/privacy}","received_events_url":"https://api.github.com/users/chrismale/received_events","type":"User","site_admin":false},"created_at":"2012-10-27T02:40:44Z","updated_at":"2012-10-27T02:40:44Z","author_association":"CONTRIBUTOR","body":"So the concern here is that the algorithms are not precise enough because they rely totally on the grid hash overlap? \n\nThis is actually partially by design.  Iterating over a large set of documents and comparing them using JTS will heavily degrade performance.  The current behaviour is similar to the effect that stemming has on free text searches.  There are countless examples where stemming results in documents being matched that don't really line up with the user's intentions.  \n\nWith that said, we are considering bringing in an alternative algorithm based on Lucene's RecursivePrefixTreeStrategy which theoretically provides a little more precision at the edges of shapes, but it doesn't exceed the SpatialPrefixTree levels.\n\nHave you done any benchmarking of the performance of using JTS? I have found even just the object creation is expensive.  If we can find a way to make the performance manageable, I can envisage maybe having an option to enable the precise filtering which is disabled by default.\n\n> does such a patch go to the elasticsearch project, or upstream (Lucene?)\n\nES uses its own version of the Lucene spatial code so we can explore the problem here and then consider contributing fixes upstream.  However due to the licensing of JTS, Lucene cannot directly use it.\n\n> documentation says we don't support storage of geometry fields, except in the _source. Where would I start to store the geometry (maybe as WKB) itself in the index (not just its tree nodes)?\n\nGood question.  I have worked on a standalone WKT parser which we could use but WKB would probably be more compact.  Given a parser, we would need to change the Mapping code fro GeoShape to add an additional field which would index the parsed shape.  Something along these lines is already done in the GeoPoint codebase. \n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/9878198","html_url":"https://github.com/elastic/elasticsearch/issues/2361#issuecomment-9878198","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/2361","id":9878198,"node_id":"MDEyOklzc3VlQ29tbWVudDk4NzgxOTg=","user":{"login":"IamJeffG","id":2002703,"node_id":"MDQ6VXNlcjIwMDI3MDM=","avatar_url":"https://avatars1.githubusercontent.com/u/2002703?v=4","gravatar_id":"","url":"https://api.github.com/users/IamJeffG","html_url":"https://github.com/IamJeffG","followers_url":"https://api.github.com/users/IamJeffG/followers","following_url":"https://api.github.com/users/IamJeffG/following{/other_user}","gists_url":"https://api.github.com/users/IamJeffG/gists{/gist_id}","starred_url":"https://api.github.com/users/IamJeffG/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/IamJeffG/subscriptions","organizations_url":"https://api.github.com/users/IamJeffG/orgs","repos_url":"https://api.github.com/users/IamJeffG/repos","events_url":"https://api.github.com/users/IamJeffG/events{/privacy}","received_events_url":"https://api.github.com/users/IamJeffG/received_events","type":"User","site_admin":false},"created_at":"2012-10-29T17:41:49Z","updated_at":"2012-10-29T17:41:49Z","author_association":"CONTRIBUTOR","body":"Chris,\nYou make a good point that the false-positives are analogous to stemming in free text, but just as elasticsearch also supports exact matches (via non-analyzed term query) when desired, I'm proposing it be able to do the same for geo-shape.  it's true there will be a performance hit, possibly severe, so we should make this extra validation optional.\n\nThat said, I benchmark WKB deserialization to be extremely fast: 3% of GeoJSON deser time and  9% of WKT deser time, using the JTS libraries.  Once instantiated, geometry comparisons can be made 58% faster when using a JTS PreparedGeometry.\n\nI'm going to attempt a patch; I'm new to the codebase but here's what I'm thinking:\nAt index time, GeoShapeFieldMapper needs to use a MultiFieldMapper (or similar), indexing both the prefix tree terms (as now), plus a BinaryMapper for the WKB, which has storage enabled.  It seems the FieldData and DocFieldData interfaces are used only at query time, and they would provide the stored WKB back to a GeoShapeFilter for polygon comparison, is this right?\n\nThanks for getting back!\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/9885617","html_url":"https://github.com/elastic/elasticsearch/issues/2361#issuecomment-9885617","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/2361","id":9885617,"node_id":"MDEyOklzc3VlQ29tbWVudDk4ODU2MTc=","user":{"login":"chrismale","id":1080664,"node_id":"MDQ6VXNlcjEwODA2NjQ=","avatar_url":"https://avatars0.githubusercontent.com/u/1080664?v=4","gravatar_id":"","url":"https://api.github.com/users/chrismale","html_url":"https://github.com/chrismale","followers_url":"https://api.github.com/users/chrismale/followers","following_url":"https://api.github.com/users/chrismale/following{/other_user}","gists_url":"https://api.github.com/users/chrismale/gists{/gist_id}","starred_url":"https://api.github.com/users/chrismale/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/chrismale/subscriptions","organizations_url":"https://api.github.com/users/chrismale/orgs","repos_url":"https://api.github.com/users/chrismale/repos","events_url":"https://api.github.com/users/chrismale/events{/privacy}","received_events_url":"https://api.github.com/users/chrismale/received_events","type":"User","site_admin":false},"created_at":"2012-10-29T21:11:25Z","updated_at":"2012-10-29T21:11:25Z","author_association":"CONTRIBUTOR","body":"> You make a good point that the false-positives are analogous to stemming in free text, but just as elasticsearch also supports exact matches (via non-analyzed term query) when desired, I'm proposing it be able to do the same for geo-shape. it's true there will be a performance hit, possibly severe, so we should make this extra validation optional.\n\nI appreciate the argument, just the severity concerns me.\n\n> That said, I benchmark WKB deserialization to be extremely fast: 3% of GeoJSON deser time and 9% of WKT deser time, using the JTS libraries. Once instantiated, geometry comparisons can be made 58% faster when using a JTS PreparedGeometry.\n\nAre you able to benchmark the comparison of 10,000 Geometrys? Just to give me an idea of the severity.\n\n> I'm going to attempt a patch; I'm new to the codebase but here's what I'm thinking:\n> At index time, GeoShapeFieldMapper needs to use a MultiFieldMapper (or similar), indexing both the prefix tree terms (as now), plus a BinaryMapper for the WKB, which has storage enabled. It seems the FieldData and DocFieldData interfaces are used only at query time, and they would provide the stored WKB back to a GeoShapeFilter for polygon comparison, is this right?\n\nI would take a look at GeoPointFieldMapper as an example.  It creates a number of different fields.  Equally, looking at GeoPolygonFilterParser will give an idea of how to use FieldData (the FilterParser uses a Filter which interacts with FieldData).\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/9958226","html_url":"https://github.com/elastic/elasticsearch/issues/2361#issuecomment-9958226","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/2361","id":9958226,"node_id":"MDEyOklzc3VlQ29tbWVudDk5NTgyMjY=","user":{"login":"dsmiley","id":377295,"node_id":"MDQ6VXNlcjM3NzI5NQ==","avatar_url":"https://avatars1.githubusercontent.com/u/377295?v=4","gravatar_id":"","url":"https://api.github.com/users/dsmiley","html_url":"https://github.com/dsmiley","followers_url":"https://api.github.com/users/dsmiley/followers","following_url":"https://api.github.com/users/dsmiley/following{/other_user}","gists_url":"https://api.github.com/users/dsmiley/gists{/gist_id}","starred_url":"https://api.github.com/users/dsmiley/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dsmiley/subscriptions","organizations_url":"https://api.github.com/users/dsmiley/orgs","repos_url":"https://api.github.com/users/dsmiley/repos","events_url":"https://api.github.com/users/dsmiley/events{/privacy}","received_events_url":"https://api.github.com/users/dsmiley/received_events","type":"User","site_admin":false},"created_at":"2012-10-31T19:17:41Z","updated_at":"2012-10-31T19:17:41Z","author_association":"CONTRIBUTOR","body":"Interesting conversation.\n\nLucene spatial's RecursivePrefixTreeStrategy (RPTS) would be great here.  It could be extended such that at the finder detail levels of intersection at the edges, it then consults the JTS shape for an exact hit.  This works well because this won't even happen for shapes that are clearly outside or clearly inside the query shape -- it's only at the intersecting edges (or very close to intersecting) where this would happen.  I don't have this requirement on my projects so I haven't bothered to do it.  RPTS will also find matches where the query shape is inside much larger indexed shapes -- a limitation to ES's spatial.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/9959253","html_url":"https://github.com/elastic/elasticsearch/issues/2361#issuecomment-9959253","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/2361","id":9959253,"node_id":"MDEyOklzc3VlQ29tbWVudDk5NTkyNTM=","user":{"login":"dsmiley","id":377295,"node_id":"MDQ6VXNlcjM3NzI5NQ==","avatar_url":"https://avatars1.githubusercontent.com/u/377295?v=4","gravatar_id":"","url":"https://api.github.com/users/dsmiley","html_url":"https://github.com/dsmiley","followers_url":"https://api.github.com/users/dsmiley/followers","following_url":"https://api.github.com/users/dsmiley/following{/other_user}","gists_url":"https://api.github.com/users/dsmiley/gists{/gist_id}","starred_url":"https://api.github.com/users/dsmiley/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dsmiley/subscriptions","organizations_url":"https://api.github.com/users/dsmiley/orgs","repos_url":"https://api.github.com/users/dsmiley/repos","events_url":"https://api.github.com/users/dsmiley/events{/privacy}","received_events_url":"https://api.github.com/users/dsmiley/received_events","type":"User","site_admin":false},"created_at":"2012-10-31T19:44:59Z","updated_at":"2012-10-31T19:44:59Z","author_association":"CONTRIBUTOR","body":"I was thinking about this a bit more and I can see that with the combination of our grid system we can do even better when paired with JTS.  Instead of verifying intersection (or lack thereof) with JTS at the edges, it could be consulted only when the shapes come closed but indeterminate wether there is overlap.  If there is clear overlap (i.e. the indexed shape has grids inside and outside the query shape) we already know there is an intersection and need not consult JTS for those shapes.  I suspect an algorithm like this would improve massively on any other approaches, as this would forgoe the need to consult JTS in I think the majority of cases, and in those cases limit the # shapes to look at to a small #.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/9961724","html_url":"https://github.com/elastic/elasticsearch/issues/2361#issuecomment-9961724","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/2361","id":9961724,"node_id":"MDEyOklzc3VlQ29tbWVudDk5NjE3MjQ=","user":{"login":"IamJeffG","id":2002703,"node_id":"MDQ6VXNlcjIwMDI3MDM=","avatar_url":"https://avatars1.githubusercontent.com/u/2002703?v=4","gravatar_id":"","url":"https://api.github.com/users/IamJeffG","html_url":"https://github.com/IamJeffG","followers_url":"https://api.github.com/users/IamJeffG/followers","following_url":"https://api.github.com/users/IamJeffG/following{/other_user}","gists_url":"https://api.github.com/users/IamJeffG/gists{/gist_id}","starred_url":"https://api.github.com/users/IamJeffG/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/IamJeffG/subscriptions","organizations_url":"https://api.github.com/users/IamJeffG/orgs","repos_url":"https://api.github.com/users/IamJeffG/repos","events_url":"https://api.github.com/users/IamJeffG/events{/privacy}","received_events_url":"https://api.github.com/users/IamJeffG/received_events","type":"User","site_admin":false},"created_at":"2012-10-31T20:56:57Z","updated_at":"2012-10-31T20:56:57Z","author_association":"CONTRIBUTOR","body":"Thanks for the ideas David.  Sounds like a good plan for efficiency.  I've also noticed that in ES queries with very large spatial extent or indexing a doc with a very large spatial extent is quite infeasible due to ES's prefix trees indexing every single grid under the shape; the hack is to use a more shallow tree, but this is untenable when different docs have vastly different extents.  I wonder if RPTS would solve this too (but that's for another bug report).\n\nMeantime, where can an overview of RPTS be found?  All I am finding with Google is the source code.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/9963005","html_url":"https://github.com/elastic/elasticsearch/issues/2361#issuecomment-9963005","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/2361","id":9963005,"node_id":"MDEyOklzc3VlQ29tbWVudDk5NjMwMDU=","user":{"login":"dsmiley","id":377295,"node_id":"MDQ6VXNlcjM3NzI5NQ==","avatar_url":"https://avatars1.githubusercontent.com/u/377295?v=4","gravatar_id":"","url":"https://api.github.com/users/dsmiley","html_url":"https://github.com/dsmiley","followers_url":"https://api.github.com/users/dsmiley/followers","following_url":"https://api.github.com/users/dsmiley/following{/other_user}","gists_url":"https://api.github.com/users/dsmiley/gists{/gist_id}","starred_url":"https://api.github.com/users/dsmiley/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dsmiley/subscriptions","organizations_url":"https://api.github.com/users/dsmiley/orgs","repos_url":"https://api.github.com/users/dsmiley/repos","events_url":"https://api.github.com/users/dsmiley/events{/privacy}","received_events_url":"https://api.github.com/users/dsmiley/received_events","type":"User","site_admin":false},"created_at":"2012-10-31T21:34:48Z","updated_at":"2012-10-31T21:34:48Z","author_association":"CONTRIBUTOR","body":"The source code for the Lucene filter is where the search algorithm is, and that's what is pertinent here: http://svn.apache.org/viewvc/lucene/dev/trunk/lucene/spatial/src/java/org/apache/lucene/spatial/prefix/RecursivePrefixTreeFilter.java?view=markup\n\nThere isn't much code to it, although it's complex.  Arguably the most complex aspect of the code is that it switches its algorithm from recursive decomposition to brute-force scan once the detail level gets high enough.\n\nI've been putting a little thought into this filter and I can see it getting overhauled a bit so that it can do contains, within, disjoint, (not just intersects), plus also supporting a callback or related mechanism to handle ambiguous intersection, which is where you could consult JTS in a 2nd phase.\n\nRPTS and ES's term query based search both inherit the same indexing approach; there's no difference there.  With the types of changes we're discussing here about using JTS as a fallback for high precision when there is ambiguity, it would not be necessary to index high-precision grids; I'd do course, which means more scalable indexing, with the trade-off of higher likelihood of consulting a serialized shape at search time.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/9965579","html_url":"https://github.com/elastic/elasticsearch/issues/2361#issuecomment-9965579","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/2361","id":9965579,"node_id":"MDEyOklzc3VlQ29tbWVudDk5NjU1Nzk=","user":{"login":"chrismale","id":1080664,"node_id":"MDQ6VXNlcjEwODA2NjQ=","avatar_url":"https://avatars0.githubusercontent.com/u/1080664?v=4","gravatar_id":"","url":"https://api.github.com/users/chrismale","html_url":"https://github.com/chrismale","followers_url":"https://api.github.com/users/chrismale/followers","following_url":"https://api.github.com/users/chrismale/following{/other_user}","gists_url":"https://api.github.com/users/chrismale/gists{/gist_id}","starred_url":"https://api.github.com/users/chrismale/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/chrismale/subscriptions","organizations_url":"https://api.github.com/users/chrismale/orgs","repos_url":"https://api.github.com/users/chrismale/repos","events_url":"https://api.github.com/users/chrismale/events{/privacy}","received_events_url":"https://api.github.com/users/chrismale/received_events","type":"User","site_admin":false},"created_at":"2012-10-31T23:07:08Z","updated_at":"2012-10-31T23:07:08Z","author_association":"CONTRIBUTOR","body":"Thanks for providing your insight David.\n\nCouple of thoughts:\n- We will definitely bring RecurisvePrefix into ES as an option, probably as part of 0.21.  It definitely has the potential to help improve the accuracy along the edges of shapes.\n- I remain really unsure about consulting JTS, even if it's now with a smaller % of shapes.  I worry about the memory consumption and the impact on query performance.  I think we really need to do some benchmarking and get an idea of what impact this is going to have on search time.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/9971935","html_url":"https://github.com/elastic/elasticsearch/issues/2361#issuecomment-9971935","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/2361","id":9971935,"node_id":"MDEyOklzc3VlQ29tbWVudDk5NzE5MzU=","user":{"login":"IamJeffG","id":2002703,"node_id":"MDQ6VXNlcjIwMDI3MDM=","avatar_url":"https://avatars1.githubusercontent.com/u/2002703?v=4","gravatar_id":"","url":"https://api.github.com/users/IamJeffG","html_url":"https://github.com/IamJeffG","followers_url":"https://api.github.com/users/IamJeffG/followers","following_url":"https://api.github.com/users/IamJeffG/following{/other_user}","gists_url":"https://api.github.com/users/IamJeffG/gists{/gist_id}","starred_url":"https://api.github.com/users/IamJeffG/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/IamJeffG/subscriptions","organizations_url":"https://api.github.com/users/IamJeffG/orgs","repos_url":"https://api.github.com/users/IamJeffG/repos","events_url":"https://api.github.com/users/IamJeffG/events{/privacy}","received_events_url":"https://api.github.com/users/IamJeffG/received_events","type":"User","site_admin":false},"created_at":"2012-11-01T06:16:46Z","updated_at":"2012-11-01T06:16:46Z","author_association":"CONTRIBUTOR","body":"I benchmarked intersects queries from a single reference shape (as a JTS PreparedGeometry for efficiency) against 10,000 other Geometrys.  My laptop can do this right around 15ms.  This is if Geometry instances are already instantiated.\n\nTo also include object instantiation, deserializing from WKB, the total time for 10,000 instantiations and comparisons is 35-45ms.\n\nThese are not stupid simple shapes either: I was using mostly MultiPolygons with mean 29 vertices per Geometry.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/9999603","html_url":"https://github.com/elastic/elasticsearch/issues/2361#issuecomment-9999603","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/2361","id":9999603,"node_id":"MDEyOklzc3VlQ29tbWVudDk5OTk2MDM=","user":{"login":"chrismale","id":1080664,"node_id":"MDQ6VXNlcjEwODA2NjQ=","avatar_url":"https://avatars0.githubusercontent.com/u/1080664?v=4","gravatar_id":"","url":"https://api.github.com/users/chrismale","html_url":"https://github.com/chrismale","followers_url":"https://api.github.com/users/chrismale/followers","following_url":"https://api.github.com/users/chrismale/following{/other_user}","gists_url":"https://api.github.com/users/chrismale/gists{/gist_id}","starred_url":"https://api.github.com/users/chrismale/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/chrismale/subscriptions","organizations_url":"https://api.github.com/users/chrismale/orgs","repos_url":"https://api.github.com/users/chrismale/repos","events_url":"https://api.github.com/users/chrismale/events{/privacy}","received_events_url":"https://api.github.com/users/chrismale/received_events","type":"User","site_admin":false},"created_at":"2012-11-01T23:12:51Z","updated_at":"2012-11-01T23:12:51Z","author_association":"CONTRIBUTOR","body":"That sounds very manageable.  Do you know how much memory say, 100,000 Geometrys consumes?\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/10767834","html_url":"https://github.com/elastic/elasticsearch/issues/2361#issuecomment-10767834","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/2361","id":10767834,"node_id":"MDEyOklzc3VlQ29tbWVudDEwNzY3ODM0","user":{"login":"IamJeffG","id":2002703,"node_id":"MDQ6VXNlcjIwMDI3MDM=","avatar_url":"https://avatars1.githubusercontent.com/u/2002703?v=4","gravatar_id":"","url":"https://api.github.com/users/IamJeffG","html_url":"https://github.com/IamJeffG","followers_url":"https://api.github.com/users/IamJeffG/followers","following_url":"https://api.github.com/users/IamJeffG/following{/other_user}","gists_url":"https://api.github.com/users/IamJeffG/gists{/gist_id}","starred_url":"https://api.github.com/users/IamJeffG/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/IamJeffG/subscriptions","organizations_url":"https://api.github.com/users/IamJeffG/orgs","repos_url":"https://api.github.com/users/IamJeffG/repos","events_url":"https://api.github.com/users/IamJeffG/events{/privacy}","received_events_url":"https://api.github.com/users/IamJeffG/received_events","type":"User","site_admin":false},"created_at":"2012-11-27T17:34:42Z","updated_at":"2012-11-27T17:34:42Z","author_association":"CONTRIBUTOR","body":"I think the memory consumption of 100k Geometrys will vary wildly depending on the complexity of the shape.  In most cases, though, I don't think it's practical to expect to store or cache them all in memory.  There will probably be a disk hit to do the extra validation, but isn't there already a disk hit to read the indexed geohash tiles?  By chance can we pull back the WKB from the index at the same time?\n\nIs it true that FieldData is the appropriate (or only?) method to access the BinaryFieldMapper data I store in the index?  I ask because http://www.elasticsearch.org/guide/reference/index-modules/cache.html says FieldData is used for sorting or caching, but doesn't mention filtering like I'm doing here.\n\nIf so, is the MultiValueByteFieldData an efficient way to retrieve the stored byte array from the index, or is it better to implement a custom GeoShapeFieldData, similar to the extant GeoPointFieldData? (and why?)\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/10769859","html_url":"https://github.com/elastic/elasticsearch/issues/2361#issuecomment-10769859","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/2361","id":10769859,"node_id":"MDEyOklzc3VlQ29tbWVudDEwNzY5ODU5","user":{"login":"dsmiley","id":377295,"node_id":"MDQ6VXNlcjM3NzI5NQ==","avatar_url":"https://avatars1.githubusercontent.com/u/377295?v=4","gravatar_id":"","url":"https://api.github.com/users/dsmiley","html_url":"https://github.com/dsmiley","followers_url":"https://api.github.com/users/dsmiley/followers","following_url":"https://api.github.com/users/dsmiley/following{/other_user}","gists_url":"https://api.github.com/users/dsmiley/gists{/gist_id}","starred_url":"https://api.github.com/users/dsmiley/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dsmiley/subscriptions","organizations_url":"https://api.github.com/users/dsmiley/orgs","repos_url":"https://api.github.com/users/dsmiley/repos","events_url":"https://api.github.com/users/dsmiley/events{/privacy}","received_events_url":"https://api.github.com/users/dsmiley/received_events","type":"User","site_admin":false},"created_at":"2012-11-27T18:22:02Z","updated_at":"2012-11-27T18:22:02Z","author_association":"CONTRIBUTOR","body":"RE \"but isn't there already a disk hit to read the indexed geohash tiles?\"\n\nThat's apples & oranges. A geohash is a simple shape with a fairly compact representation (but could be improved).  The number of geohash tiles that will be examined has a roughly fixed upper bound given the distErrPct (shape approximation statistic).  The disk seek()'s are strictly increasing across the shape, and the geohashes will tend to be co-located and thus increasing the effectiveness of the OS's disk cache.  On the other hand, looking up shape data per-document is on the order of the number of affected documents (could be a small or big number), and it is a random disk seek per document that is unlikely to be co-located with nearby shapes.  That last point is solvable using sorted DocValues and a geohash centroid prefix to the bytes.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/10770208","html_url":"https://github.com/elastic/elasticsearch/issues/2361#issuecomment-10770208","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/2361","id":10770208,"node_id":"MDEyOklzc3VlQ29tbWVudDEwNzcwMjA4","user":{"login":"IamJeffG","id":2002703,"node_id":"MDQ6VXNlcjIwMDI3MDM=","avatar_url":"https://avatars1.githubusercontent.com/u/2002703?v=4","gravatar_id":"","url":"https://api.github.com/users/IamJeffG","html_url":"https://github.com/IamJeffG","followers_url":"https://api.github.com/users/IamJeffG/followers","following_url":"https://api.github.com/users/IamJeffG/following{/other_user}","gists_url":"https://api.github.com/users/IamJeffG/gists{/gist_id}","starred_url":"https://api.github.com/users/IamJeffG/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/IamJeffG/subscriptions","organizations_url":"https://api.github.com/users/IamJeffG/orgs","repos_url":"https://api.github.com/users/IamJeffG/repos","events_url":"https://api.github.com/users/IamJeffG/events{/privacy}","received_events_url":"https://api.github.com/users/IamJeffG/received_events","type":"User","site_admin":false},"created_at":"2012-11-27T18:30:29Z","updated_at":"2012-11-27T18:30:29Z","author_association":"CONTRIBUTOR","body":"Makes perfect sense, thanks David.  Chris, can you confirm I'm on the right track around FieldData?  I'm following the GeoPolygonFilterParser, but I think what it does is overkill for our needs around this issue.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/10821574","html_url":"https://github.com/elastic/elasticsearch/issues/2361#issuecomment-10821574","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/2361","id":10821574,"node_id":"MDEyOklzc3VlQ29tbWVudDEwODIxNTc0","user":{"login":"IamJeffG","id":2002703,"node_id":"MDQ6VXNlcjIwMDI3MDM=","avatar_url":"https://avatars1.githubusercontent.com/u/2002703?v=4","gravatar_id":"","url":"https://api.github.com/users/IamJeffG","html_url":"https://github.com/IamJeffG","followers_url":"https://api.github.com/users/IamJeffG/followers","following_url":"https://api.github.com/users/IamJeffG/following{/other_user}","gists_url":"https://api.github.com/users/IamJeffG/gists{/gist_id}","starred_url":"https://api.github.com/users/IamJeffG/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/IamJeffG/subscriptions","organizations_url":"https://api.github.com/users/IamJeffG/orgs","repos_url":"https://api.github.com/users/IamJeffG/repos","events_url":"https://api.github.com/users/IamJeffG/events{/privacy}","received_events_url":"https://api.github.com/users/IamJeffG/received_events","type":"User","site_admin":false},"created_at":"2012-11-28T21:06:46Z","updated_at":"2012-11-30T07:41:39Z","author_association":"CONTRIBUTOR","body":"Followup after playing with the code a bit:\nIt seems that a FieldDataCache cannot read stored-but-not-indexed fields, such as are produced by the BinaryFieldMapper [1].  What's the best way around this?\nI can hack around this and make further progress by using a StringFieldMapper for a base-64-encoded WKB, but I hate to have that extra overhead in both encoding time and storage space.\n\n[1] http://www.elasticsearch.org/guide/reference/mapping/core-types.html \"Binary types: The field is always stored and not indexed at all.\"\n\n---\n\nUpdate: the limitation that BinaryFieldMappers were not indexed has been removed by 549900a0824e2c856b7b7cedc1d447ea854aebf2.  However this merely defers the problem to instantiation of the Field instance:\n\n```\njava.lang.IllegalArgumentException: Fields with BytesRef values cannot be indexed\n           at org.apache.lucene.document.Field.<init>(Field.java:222)\n```\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/10965386","html_url":"https://github.com/elastic/elasticsearch/issues/2361#issuecomment-10965386","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/2361","id":10965386,"node_id":"MDEyOklzc3VlQ29tbWVudDEwOTY1Mzg2","user":{"login":"IamJeffG","id":2002703,"node_id":"MDQ6VXNlcjIwMDI3MDM=","avatar_url":"https://avatars1.githubusercontent.com/u/2002703?v=4","gravatar_id":"","url":"https://api.github.com/users/IamJeffG","html_url":"https://github.com/IamJeffG","followers_url":"https://api.github.com/users/IamJeffG/followers","following_url":"https://api.github.com/users/IamJeffG/following{/other_user}","gists_url":"https://api.github.com/users/IamJeffG/gists{/gist_id}","starred_url":"https://api.github.com/users/IamJeffG/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/IamJeffG/subscriptions","organizations_url":"https://api.github.com/users/IamJeffG/orgs","repos_url":"https://api.github.com/users/IamJeffG/repos","events_url":"https://api.github.com/users/IamJeffG/events{/privacy}","received_events_url":"https://api.github.com/users/IamJeffG/received_events","type":"User","site_admin":false},"created_at":"2012-12-03T18:39:38Z","updated_at":"2012-12-03T18:39:38Z","author_association":"CONTRIBUTOR","body":"Sorry for all the stale commits up above.  Take a look at pull request 2460.  I have two doubts about the efficiency of its implementation, so please help me address these.  I'd prefer we don't merge 2460, but I'm happy to iterate based on our conversation and followup with a new pull request.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/48379434","html_url":"https://github.com/elastic/elasticsearch/issues/2361#issuecomment-48379434","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/2361","id":48379434,"node_id":"MDEyOklzc3VlQ29tbWVudDQ4Mzc5NDM0","user":{"login":"clintongormley","id":56599,"node_id":"MDQ6VXNlcjU2NTk5","avatar_url":"https://avatars0.githubusercontent.com/u/56599?v=4","gravatar_id":"","url":"https://api.github.com/users/clintongormley","html_url":"https://github.com/clintongormley","followers_url":"https://api.github.com/users/clintongormley/followers","following_url":"https://api.github.com/users/clintongormley/following{/other_user}","gists_url":"https://api.github.com/users/clintongormley/gists{/gist_id}","starred_url":"https://api.github.com/users/clintongormley/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/clintongormley/subscriptions","organizations_url":"https://api.github.com/users/clintongormley/orgs","repos_url":"https://api.github.com/users/clintongormley/repos","events_url":"https://api.github.com/users/clintongormley/events{/privacy}","received_events_url":"https://api.github.com/users/clintongormley/received_events","type":"User","site_admin":false},"created_at":"2014-07-08T18:21:53Z","updated_at":"2014-07-08T18:21:53Z","author_association":"CONTRIBUTOR","body":"According to https://github.com/elasticsearch/elasticsearch/issues/2803#issuecomment-35543599 this issue should be fixed by Lucene 4.7's [https://issues.apache.org/jira/browse/LUCENE-5408](SerializedDVStrategy).  What do we need to do to benefit from that?\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/48408371","html_url":"https://github.com/elastic/elasticsearch/issues/2361#issuecomment-48408371","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/2361","id":48408371,"node_id":"MDEyOklzc3VlQ29tbWVudDQ4NDA4Mzcx","user":{"login":"IamJeffG","id":2002703,"node_id":"MDQ6VXNlcjIwMDI3MDM=","avatar_url":"https://avatars1.githubusercontent.com/u/2002703?v=4","gravatar_id":"","url":"https://api.github.com/users/IamJeffG","html_url":"https://github.com/IamJeffG","followers_url":"https://api.github.com/users/IamJeffG/followers","following_url":"https://api.github.com/users/IamJeffG/following{/other_user}","gists_url":"https://api.github.com/users/IamJeffG/gists{/gist_id}","starred_url":"https://api.github.com/users/IamJeffG/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/IamJeffG/subscriptions","organizations_url":"https://api.github.com/users/IamJeffG/orgs","repos_url":"https://api.github.com/users/IamJeffG/repos","events_url":"https://api.github.com/users/IamJeffG/events{/privacy}","received_events_url":"https://api.github.com/users/IamJeffG/received_events","type":"User","site_admin":false},"created_at":"2014-07-08T22:38:12Z","updated_at":"2014-07-08T22:38:12Z","author_association":"CONTRIBUTOR","body":"From a long-ago discussion with @dsmiley, I believe this requires the following two changes in Elasticsearch:\n1. Index time:  Mapping for geo_shape type objects should take boolean flag whether this field should support verified matches.  If so, we write the `indexableFields` from both the PrefixTreeStrategy _and_ the SerializedDVStrategy.  The latter serializes the doc's geometry in a BinaryDocValuesField (the DocValues should be disk-resident since values might be large).\n2. A geo_shape query/filter, if \"verified matches\" are desired, will explicitly issue two filters/queries to Lucene:\n   a) The PrefixTreeStrategy as we currently do, though perhaps with less precision (as a cachable filter if possible).\n   b) In the same request, use the new SerializedDVStrategy to do exact polygon verification between the query shape and the DocValues of the remaining docs.\n\nThe SerializedDVStrategy itself has no index, it's O(N) for N documents: it should always be used in conjunction with another filter, specifically after the PrefixTreeStrategy.   Since it's slow, we'd also like to force it dead-last in the query tree; for example Solr has a mechanism called \"PostFilter\" to do this, I'm not sure what Elasticsearch provides.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/48628986","html_url":"https://github.com/elastic/elasticsearch/issues/2361#issuecomment-48628986","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/2361","id":48628986,"node_id":"MDEyOklzc3VlQ29tbWVudDQ4NjI4OTg2","user":{"login":"dsmiley","id":377295,"node_id":"MDQ6VXNlcjM3NzI5NQ==","avatar_url":"https://avatars1.githubusercontent.com/u/377295?v=4","gravatar_id":"","url":"https://api.github.com/users/dsmiley","html_url":"https://github.com/dsmiley","followers_url":"https://api.github.com/users/dsmiley/followers","following_url":"https://api.github.com/users/dsmiley/following{/other_user}","gists_url":"https://api.github.com/users/dsmiley/gists{/gist_id}","starred_url":"https://api.github.com/users/dsmiley/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dsmiley/subscriptions","organizations_url":"https://api.github.com/users/dsmiley/orgs","repos_url":"https://api.github.com/users/dsmiley/repos","events_url":"https://api.github.com/users/dsmiley/events{/privacy}","received_events_url":"https://api.github.com/users/dsmiley/received_events","type":"User","site_admin":false},"created_at":"2014-07-10T16:29:26Z","updated_at":"2014-07-10T16:29:26Z","author_association":"CONTRIBUTOR","body":"I think there are two approaches to do this that are philosophically a little different, but they don't have to be mutually exclusive:\n\n(A) Augment geo_shape with this new capability.  In this concept, one mapping/type supports everything, with some configuration flags to turn unneeded things off.  Heck, it might eventually incorporate BBoxSpatialStrategy (newly committed yesterday) too.  One mapping/type but underlying it would be potentially multiple \"SpatialStrategies\" in use and multiple fields.  This would probably be the most user-friendly because the user is less exposed to some nuts & bolts, but it hides some underlying things that may make it harder to configure each strategy a little differently.  There is an optimization easily done here too in which you can easily ensure that the underlying polygon is parsed once, since it's managed by one mapper (index time) and query.  \n\nIdeally, in this approach, the GeoShapeFilterParser would be able to somehow modify the overall query to use FilteredQuery with QUERY_FIRST_FILTER_STRATEGY with the slow SerializedDVStrategy providing the (slow) filter.  If this can't be done or is too awkward, then it may have to settle for only wrapping the spatial PrefixTree (RPT) query instead of all other queries in play (e.g. keyword & other filters), which means it'll definitely be less efficient.  If none of this is done then the user must provide a query with multiple spatial clauses (the RPT early and SerializedDV last), and if so I argue the one-mapper to rule them all abstraction breaks down.\n\n(B) Enhance GeoShapeFieldMapper to support other SpatialStrategies (only one instance).  The user would then use two spatial fields, one for the RPT index, one for serialized geometry.  This is definitely an easier approach and should offer decent control by the user as to how to compose the query, but it requires the user to know what they are doing more.  And ideally ES has mechanisms to share a parsed Shape between fields on indexing and search so that both Mappers don't have to re-construct the Shapes from JSON.\n","performed_via_github_app":null}]