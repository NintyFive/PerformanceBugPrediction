{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/24766","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/24766/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/24766/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/24766/events","html_url":"https://github.com/elastic/elasticsearch/issues/24766","id":229592650,"node_id":"MDU6SXNzdWUyMjk1OTI2NTA=","number":24766,"title":"Concurrency issue with java slice api","user":{"login":"aping","id":98853,"node_id":"MDQ6VXNlcjk4ODUz","avatar_url":"https://avatars0.githubusercontent.com/u/98853?v=4","gravatar_id":"","url":"https://api.github.com/users/aping","html_url":"https://github.com/aping","followers_url":"https://api.github.com/users/aping/followers","following_url":"https://api.github.com/users/aping/following{/other_user}","gists_url":"https://api.github.com/users/aping/gists{/gist_id}","starred_url":"https://api.github.com/users/aping/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/aping/subscriptions","organizations_url":"https://api.github.com/users/aping/orgs","repos_url":"https://api.github.com/users/aping/repos","events_url":"https://api.github.com/users/aping/events{/privacy}","received_events_url":"https://api.github.com/users/aping/received_events","type":"User","site_admin":false},"labels":[{"id":146832564,"node_id":"MDU6TGFiZWwxNDY4MzI1NjQ=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/:Search/Search","name":":Search/Search","color":"0e8a16","default":false,"description":"Search-related issues that do not fall into other categories"}],"state":"closed","locked":false,"assignee":{"login":"jimczi","id":15977469,"node_id":"MDQ6VXNlcjE1OTc3NDY5","avatar_url":"https://avatars0.githubusercontent.com/u/15977469?v=4","gravatar_id":"","url":"https://api.github.com/users/jimczi","html_url":"https://github.com/jimczi","followers_url":"https://api.github.com/users/jimczi/followers","following_url":"https://api.github.com/users/jimczi/following{/other_user}","gists_url":"https://api.github.com/users/jimczi/gists{/gist_id}","starred_url":"https://api.github.com/users/jimczi/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jimczi/subscriptions","organizations_url":"https://api.github.com/users/jimczi/orgs","repos_url":"https://api.github.com/users/jimczi/repos","events_url":"https://api.github.com/users/jimczi/events{/privacy}","received_events_url":"https://api.github.com/users/jimczi/received_events","type":"User","site_admin":false},"assignees":[{"login":"jimczi","id":15977469,"node_id":"MDQ6VXNlcjE1OTc3NDY5","avatar_url":"https://avatars0.githubusercontent.com/u/15977469?v=4","gravatar_id":"","url":"https://api.github.com/users/jimczi","html_url":"https://github.com/jimczi","followers_url":"https://api.github.com/users/jimczi/followers","following_url":"https://api.github.com/users/jimczi/following{/other_user}","gists_url":"https://api.github.com/users/jimczi/gists{/gist_id}","starred_url":"https://api.github.com/users/jimczi/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jimczi/subscriptions","organizations_url":"https://api.github.com/users/jimczi/orgs","repos_url":"https://api.github.com/users/jimczi/repos","events_url":"https://api.github.com/users/jimczi/events{/privacy}","received_events_url":"https://api.github.com/users/jimczi/received_events","type":"User","site_admin":false}],"milestone":null,"comments":3,"created_at":"2017-05-18T08:29:19Z","updated_at":"2018-02-14T13:31:04Z","closed_at":"2017-05-19T07:23:46Z","author_association":"NONE","active_lock_reason":null,"body":"**Elasticsearch version**: 5.4.0\r\n\r\n**Plugins installed**: []\r\n\r\n**JVM version** : 1.8.0_131(both client and server)\r\n\r\n**OS version** : Linux 4.4.0-77-generic\r\n\r\n**Description of the problem including expected versus actual behavior**:\r\n\r\n***serial***:\r\n```\r\n            List<SearchResponse> responses = IntStream.range(0, numSlice).mapToObj(i -> {\r\n                SliceBuilder sliceBuilder = new SliceBuilder(i, numSlice);\r\n                SearchResponse response = transportClient.prepareSearch(index).setTypes(type).\r\n                        setSource(searchSourceBuilder).\r\n                        setScroll(scrollTimeout).\r\n                        slice(sliceBuilder).\r\n                        setSize(scrollSize).get();\r\n                log.warn(\"hits for slice {}: {}\", i, response.getHits().getTotalHits());\r\n                return response;\r\n            }).collect(Collectors.toList());\r\n```\r\noutput:\r\nhits for slice 0: 1600\r\nhits for slice 1: 1571\r\nhits for slice 2: 1618\r\nhits for slice 3: 1551\r\nhits for slice 4: 1542\r\n\r\n***concurrent (note `.parallel()`)***:\r\n```\r\n            List<SearchResponse> responses =IntStream.range(0, numSlice).parallel().mapToObj(i -> {\r\n                SliceBuilder sliceBuilder = new SliceBuilder(i, numSlice);\r\n                SearchResponse response = transportClient.prepareSearch(index).setTypes(type).\r\n                        setSource(searchSourceBuilder).\r\n                        setScroll(scrollTimeout).\r\n                        slice(sliceBuilder).\r\n                        setSize(scrollSize).get();\r\n                log.warn(\"hits for slice {}: {}\", i, response.getHits().getTotalHits());\r\n                return response;\r\n            }).collect(Collectors.toList());\r\n```\r\n\r\noutput:\r\nhits for slice 1: 1571\r\nhits for slice 0: 1571\r\nhits for slice 4: 1571\r\nhits for slice 2: 1571\r\nhits for slice 3: 1551\r\n\r\nSo does it mean we have to get the first response of each slice serially(If so, I think that beats the purpose of slice itself)? After that, I can get the rest of each response in parallel.\r\n\r\nPlus, personally I feel the slice api pretty awkward.\r\nFor example, say let's first send the server a request with the usual query and sort options, together with the number of slices we want, the server returns several scroll ids matching each slice(but no need of actual data of matching documents at all).\r\nThat's request No.1\r\nThen we can use those scroll ids to retrieve the matching documents with subsequent requests.\r\nWouldn't that be more intuitive?","closed_by":{"login":"jimczi","id":15977469,"node_id":"MDQ6VXNlcjE1OTc3NDY5","avatar_url":"https://avatars0.githubusercontent.com/u/15977469?v=4","gravatar_id":"","url":"https://api.github.com/users/jimczi","html_url":"https://github.com/jimczi","followers_url":"https://api.github.com/users/jimczi/followers","following_url":"https://api.github.com/users/jimczi/following{/other_user}","gists_url":"https://api.github.com/users/jimczi/gists{/gist_id}","starred_url":"https://api.github.com/users/jimczi/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jimczi/subscriptions","organizations_url":"https://api.github.com/users/jimczi/orgs","repos_url":"https://api.github.com/users/jimczi/repos","events_url":"https://api.github.com/users/jimczi/events{/privacy}","received_events_url":"https://api.github.com/users/jimczi/received_events","type":"User","site_admin":false},"performed_via_github_app":null}