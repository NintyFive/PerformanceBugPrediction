{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/20586","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/20586/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/20586/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/20586/events","html_url":"https://github.com/elastic/elasticsearch/issues/20586","id":178108664,"node_id":"MDU6SXNzdWUxNzgxMDg2NjQ=","number":20586,"title":"\"Rare Terms\" aggregation","user":{"login":"polyfractal","id":1224228,"node_id":"MDQ6VXNlcjEyMjQyMjg=","avatar_url":"https://avatars1.githubusercontent.com/u/1224228?v=4","gravatar_id":"","url":"https://api.github.com/users/polyfractal","html_url":"https://github.com/polyfractal","followers_url":"https://api.github.com/users/polyfractal/followers","following_url":"https://api.github.com/users/polyfractal/following{/other_user}","gists_url":"https://api.github.com/users/polyfractal/gists{/gist_id}","starred_url":"https://api.github.com/users/polyfractal/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/polyfractal/subscriptions","organizations_url":"https://api.github.com/users/polyfractal/orgs","repos_url":"https://api.github.com/users/polyfractal/repos","events_url":"https://api.github.com/users/polyfractal/events{/privacy}","received_events_url":"https://api.github.com/users/polyfractal/received_events","type":"User","site_admin":false},"labels":[{"id":141141324,"node_id":"MDU6TGFiZWwxNDExNDEzMjQ=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/:Analytics/Aggregations","name":":Analytics/Aggregations","color":"0e8a16","default":false,"description":"Aggregations"},{"id":23172,"node_id":"MDU6TGFiZWwyMzE3Mg==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/%3Efeature","name":">feature","color":"006b75","default":false,"description":null}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":15,"created_at":"2016-09-20T16:23:45Z","updated_at":"2019-07-01T15:01:10Z","closed_at":"2019-07-01T14:02:37Z","author_association":"MEMBER","active_lock_reason":null,"body":"I'd like to propose a `rare_terms` aggregation that collects the set of terms which have `n` or fewer occurrences.  This is essentially the opposite of \"top-n\" queries.\n\nThe motivation is that today, the only way to _accurately_ collect the \"lowest-n\" is to execute a terms aggregation with `size: INT_MAX` so that all terms are collected, then filter client-side or with `bucket_selector`.  This is obviously expensive: it requires the memory overhead of all the terms, plus executing leaf aggregations on all terms despite only caring about the \"lowest-n\".\n\nSorting by count ascending on the terms agg without setting size INT_MAX [is trappy](https://github.com/elastic/elasticsearch/issues/17614) and we'd love to remove it :)\n### Algorithm\n\nThe algorithm uses a map and a bloom filter.  The map tracks the total set of rare terms.  The bloom filter tracks the set of terms > max_doc_count.\n\nPseudocode:\n\n``` java\nMap<String, int> terms = new Map();\nBloomFilter bloom = new BloomFilter();\n\nfunction collect(term) {\n\n  // Check to see if this term is in our bloom filter\n  if (bloom.get(term) == false) {\n    int value = map.get(term);\n    if (value == null) {\n\n      // We've never seen this term before, initialize it's counter to 1\n      map.put(term, 1);\n    } else {\n\n      value += 1;\n\n      // We've seen this term before, but less than the threshold\n      // so just increment its counter\n      if (value < max_doc_count) {\n        map.put(term, value);\n      } else {\n        // Otherwise we've breached the threshold, remove from\n        // the map and add to the bloom filter\n        map.remove(term);\n        bloom.add(term)\n      }\n    }\n  } else {\n    /* \n      There is no else clause here, because inclusion in the bloom filter\n       means the item has been seen > max_doc_count times and so is no longer\n       a \"rare\" term\n\n       Note that due to the nature of bloom filters, there will be some false-positives,\n       which translates into not adding an item to the \"rare list\" when it should\n    */\n  }\n\n}\n```\n\nNote: this ignores all the technical bits about replaying cached docs, etc.\n\nSome potential extensions:\n- If `max_doc_count: 1`, we don't need to store the count and could instead just use a Set to further reduce the size\n- We could potentially be clever and not use a full int for each counter and instead do some bit-packing (e.g. `max_doc_count: 16` only needs 4 bits), but we wouldn't be able to use a nice, convenient map :)\n### Properties\n- Size is linear to the number of \"rare\" terms, plus some constant overhead.\n  - Antagonistic input (majority of terms are \"rare\") is still undeniably expensive, but still better than a terms aggregation\n  - Worst case where all terms are rare is basically equivalent to a terms agg with `size: INT_MAX`\n  - Best we can tell, in all cases it is no worse than a terms aggregation in space or time.\n- Must be executed as a deferred bucket agg (e.g. `collect_mode: breadth_first`)\n  - As a benefit, leaf aggregations are only executed on the actually rare terms\n- Resulting rare terms are guaranteed to satisfy `max_doc_count` (e.g. **no false positives**)\n- Some terms may be rare but not represented in the list (e.g. **has false negatives**)\n- `max_doc_count` threshold is configurable, although the tradeoff between this and the `terms` agg becomes less clear-cut as `max_doc_count` increases (e.g. `max_doc_count: 1000` will likely include a large portion of a zipfian distribution, so a `terms` agg coming from the other direction may be better)\n\nPotentially this is sufficient enough that #17614 can be unblocked, and we can make the terms agg less trappy while providing better accuracy / space / time on rare term aggregations.\n\nI'm going to start poking at an implementation.\n\n/cc @colings86 @jpountz \n","closed_by":{"login":"polyfractal","id":1224228,"node_id":"MDQ6VXNlcjEyMjQyMjg=","avatar_url":"https://avatars1.githubusercontent.com/u/1224228?v=4","gravatar_id":"","url":"https://api.github.com/users/polyfractal","html_url":"https://github.com/polyfractal","followers_url":"https://api.github.com/users/polyfractal/followers","following_url":"https://api.github.com/users/polyfractal/following{/other_user}","gists_url":"https://api.github.com/users/polyfractal/gists{/gist_id}","starred_url":"https://api.github.com/users/polyfractal/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/polyfractal/subscriptions","organizations_url":"https://api.github.com/users/polyfractal/orgs","repos_url":"https://api.github.com/users/polyfractal/repos","events_url":"https://api.github.com/users/polyfractal/events{/privacy}","received_events_url":"https://api.github.com/users/polyfractal/received_events","type":"User","site_admin":false},"performed_via_github_app":null}