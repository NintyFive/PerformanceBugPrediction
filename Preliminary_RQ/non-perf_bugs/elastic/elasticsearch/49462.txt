{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/49462","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/49462/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/49462/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/49462/events","html_url":"https://github.com/elastic/elasticsearch/issues/49462","id":526805959,"node_id":"MDU6SXNzdWU1MjY4MDU5NTk=","number":49462,"title":"[Discuss] [EQL] Index selection as part of the rule vs the request  ","user":{"login":"stacey-gammon","id":16563603,"node_id":"MDQ6VXNlcjE2NTYzNjAz","avatar_url":"https://avatars3.githubusercontent.com/u/16563603?v=4","gravatar_id":"","url":"https://api.github.com/users/stacey-gammon","html_url":"https://github.com/stacey-gammon","followers_url":"https://api.github.com/users/stacey-gammon/followers","following_url":"https://api.github.com/users/stacey-gammon/following{/other_user}","gists_url":"https://api.github.com/users/stacey-gammon/gists{/gist_id}","starred_url":"https://api.github.com/users/stacey-gammon/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/stacey-gammon/subscriptions","organizations_url":"https://api.github.com/users/stacey-gammon/orgs","repos_url":"https://api.github.com/users/stacey-gammon/repos","events_url":"https://api.github.com/users/stacey-gammon/events{/privacy}","received_events_url":"https://api.github.com/users/stacey-gammon/received_events","type":"User","site_admin":false},"labels":[{"id":1690690117,"node_id":"MDU6TGFiZWwxNjkwNjkwMTE3","url":"https://api.github.com/repos/elastic/elasticsearch/labels/:Query%20Languages/EQL","name":":Query Languages/EQL","color":"0e8a16","default":false,"description":"EQL querying"}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":9,"created_at":"2019-11-21T19:49:36Z","updated_at":"2019-11-28T14:25:27Z","closed_at":"2019-11-28T14:25:19Z","author_association":"NONE","active_lock_reason":null,"body":"## Background\r\n\r\nWe are working on adding a new commercially licensed EQL search API, so that users can search their data stored in ES using the Event Query Language.  One of the biggest open questions we have right now is whether index selection should be represented in the language, or rather something sent along separately, along with the request.\r\n\r\n## Option 1: Index selection as part of the language\r\n\r\n`process WHERE process_name == \"explorer.exe\"`\r\nwould become\r\n`myIndex-* WHERE event.type == \"process\" and process_name == \"explorer.exe\"`\r\n\r\nDepending on how you ingested your data, you could also potentially form your query like:\r\n\r\n`endpoint-process-* WHERE process_name == \"explorer.exe\"`\r\n\r\nhowever structuring your data in any given way would not be required, it would be up to the user.\r\n\r\n**Example request**\r\n```\r\nGET _eql/search\r\n{\r\n  rule: `process-* WHERE process_name == \"explorer.exe\"`\r\n}\r\n```\r\n\r\n## Option 2: Index selection as part of the request\r\n\r\n`process WHERE process_name == \"explorer.exe\"`\r\n\r\nremains the same. The request would need to include the pre-where field to query on. It would simply be a shortcut to writing `any WHERE event.type == 'process' and process_name == \"explorer.exe\"`, assuming you chose `event.type` as your filtering field in the request.  For example:\r\n\r\n**Example request**\r\n\r\n```\r\nGET myIndex-*/_eql/search\r\n{\r\n  rule: `process WHERE process_name == \"explorer.exe\"`,\r\n  type_field: `event.type`\r\n}\r\n```\r\n\r\n## Considerations\r\n\r\nWhen deciding which path to take, there are many things we should keep in mind:\r\n\r\n1. The flexibility of the language.  Option 1 allows for greater flexibility. Option 2 could be just as flexible but would require additional steps/setup.\r\n\r\n2. How important is it to keep the language as close to possible as it is today?  Option 2 keeps the language more familiar.\r\n   2a. How will this decision affect EQL queries that exist today?  How difficult will it be to convert them to the ES variety? \r\n\r\n3. Can we use the same queries for searching historical data vs consecutively running queries?\r\n\r\n4. Can we use the same queries for searching data directly on an endpoint vs data stored in ES?  If not, how easy would it be to convert from one to the other?\r\n\r\n5. How might this decision affect the response and how the response is consumed by Kibana?\r\n\r\n6. Are there any search performance implications?\r\n\r\n7. How will this affect Kibana (autocomplete)\r\n\r\n###  1. The flexibility and generality of the language\r\n\r\n  Going with option one would allow someone to create an ad hoc join query on any data set.  For example:\r\n\r\n```\r\njoin by ip\r\n  [packetbeat-* where true]\r\n  [firewall-data-* where true]\r\n  [endpoint-network-* where true]\r\n```\r\n\r\nIf you wanted to achieve the same thing, with the index pattern coming from outside the language, you would either have to search on * and add an indices query, e.g.:\r\n\r\n```\r\nGET */_eql/search\r\n{\r\n  rule: '''\r\n     join by ip\r\n       [any where _index == \"packetbeat-*\"]\r\n       [any where _index == \"firewall-data-*\"]\r\n       [any where _index == \"endpoint-network-*\"]\r\n    '''\r\n}\r\n```\r\n\r\nor you'd have to create an alias ahead of time to point to those three indices (at which point... I suppose the query is irrelevant. just search for ip).\r\n\r\nIf we went this route another question is whether the user is typing in the string `*` or if they have to create an index pattern object (of course from ES API standpoint, it's just a string). But from the perspective of Kibana, this can be awkward. Is the user going to have to create a `*` index pattern object to achieve this query?  In either case, we would hit some major issues with autocomplete:\r\n\r\n<img width=\"918\" alt=\"Screen Shot 2019-11-21 at 2 24 14 PM\" src=\"https://user-images.githubusercontent.com/16563603/69369816-b458b300-0c6a-11ea-8f09-e05c6bdb115a.png\">\r\n\r\n**Winner:** Option 1 gives the user more dynamic flexibility\r\n\r\n###  2. Keeping the language as familiar as possible\r\n\r\nOption 1 changes the language up quite a bit from what users are already expecting.  It's looking like endpoint data will index all event data into a single index, which means almost every query already constructed today would change from `{eventType} WHERE xyz` to `someIndex-* WHERE xyz and event.type == {eventType}`.\r\n\r\nHowever, we could probably create an automatic converter to switch from one version to the other.\r\n\r\n**Winner:** Option 2 keeps the language more familiar\r\n\r\n###  3. Use the same queries for searching historical data vs consecutively running queries?\r\n\r\nI think Option 2 is probably the winner here, but if we have the automatic converter from one version to the other, maybe it's not as important. However it does mean that people need to understand two varieties of queries.\r\n\r\n**Winner:** Probably option 2\r\n\r\n### 4. Can we use the same queries for searching data directly on an endpoint vs data stored in ES?  If not, how easy would it be to convert from one to the other?\r\n\r\nThis might actually be the same question as 3 but I'm not certain. I haven't given this one too much thought, so please anyone feel free to add more deets here (or anywhere)!\r\n\r\n### 5. How might this decision affect the response and how the response is consumed by Kibana?\r\n\r\nThis was an interesting consideration @costin brought up.  Allowing queries to be run across really disparate indices means the result set could be a single table but with a huge number of fields. Consider the query:\r\n\r\n```\r\njoin by ip\r\n  [packetbeat-* where true]\r\n  [firewall-data-* where true]\r\n  [endpoint-network-* where true]\r\n```\r\none row will have a column for every one of these indices.\r\n\r\n**Winner:** Option 2 will make it more difficult for a user to create these giant table results. That being said, it's a restriction. Do we want that restriction?\r\n\r\n### 6. Are there any search performance implications?\r\n\r\nWell if go with option 2 and support this query:\r\n```\r\nGET */_eql/search\r\n{\r\n  rule: '''\r\n     join by ip\r\n       [any where _index == \"packetbeat-*\"]\r\n       [any where _index == \"firewall-data-*\"]\r\n       [any where _index == \"endpoint-network-*\"]\r\n    '''\r\n}\r\n```\r\n\r\nwe'd probably want indices query to be just as efficient as specifying the query in the URL.\r\n\r\n**Winner:** Option 1, but, there are probably work arounds in either case (e.g. use a index alias instead of `*`).\r\n\r\n### 7. How will this affect Kibana? (autocomplete)\r\n\r\nI mentioned autocomplete above.  It's fine from a Kibana standpoint if we ask the user for an index separately, or we expect it as part of the language.  The one caveat is autocomplete and the example given above.  Autocomplete in the case of:\r\n\r\n`sequence [myIndex-* WHERE fieldHere..]`\r\n\r\nwould be a much better experience.  KQL already has performance issues when trying to query for a field set when there is a high number of fields.\r\n\r\n## Summary\r\n\r\nI'm personally a fan of Option 1 because of the flexibility and the improved auto-complete experience (thanks @rw-access for this suggestion!).\r\n\r\ncc @colings86 @rw-access @costin @aleksmaus @jpountz @scunningham ","closed_by":{"login":"colings86","id":236731,"node_id":"MDQ6VXNlcjIzNjczMQ==","avatar_url":"https://avatars0.githubusercontent.com/u/236731?v=4","gravatar_id":"","url":"https://api.github.com/users/colings86","html_url":"https://github.com/colings86","followers_url":"https://api.github.com/users/colings86/followers","following_url":"https://api.github.com/users/colings86/following{/other_user}","gists_url":"https://api.github.com/users/colings86/gists{/gist_id}","starred_url":"https://api.github.com/users/colings86/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/colings86/subscriptions","organizations_url":"https://api.github.com/users/colings86/orgs","repos_url":"https://api.github.com/users/colings86/repos","events_url":"https://api.github.com/users/colings86/events{/privacy}","received_events_url":"https://api.github.com/users/colings86/received_events","type":"User","site_admin":false},"performed_via_github_app":null}