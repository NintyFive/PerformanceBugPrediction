{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/60848","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/60848/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/60848/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/60848/events","html_url":"https://github.com/elastic/elasticsearch/issues/60848","id":674561690,"node_id":"MDU6SXNzdWU2NzQ1NjE2OTA=","number":60848,"title":"Formalize the concept of data tiers in Elasticsearch","user":{"login":"dakrone","id":19060,"node_id":"MDQ6VXNlcjE5MDYw","avatar_url":"https://avatars3.githubusercontent.com/u/19060?v=4","gravatar_id":"","url":"https://api.github.com/users/dakrone","html_url":"https://github.com/dakrone","followers_url":"https://api.github.com/users/dakrone/followers","following_url":"https://api.github.com/users/dakrone/following{/other_user}","gists_url":"https://api.github.com/users/dakrone/gists{/gist_id}","starred_url":"https://api.github.com/users/dakrone/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dakrone/subscriptions","organizations_url":"https://api.github.com/users/dakrone/orgs","repos_url":"https://api.github.com/users/dakrone/repos","events_url":"https://api.github.com/users/dakrone/events{/privacy}","received_events_url":"https://api.github.com/users/dakrone/received_events","type":"User","site_admin":false},"labels":[{"id":1142254209,"node_id":"MDU6TGFiZWwxMTQyMjU0MjA5","url":"https://api.github.com/repos/elastic/elasticsearch/labels/:Core/Features/Features","name":":Core/Features/Features","color":"0e8a16","default":false,"description":"A catch-all label for :Core/Features that don't fit in any other bucket."},{"id":23172,"node_id":"MDU6TGFiZWwyMzE3Mg==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/%3Efeature","name":">feature","color":"006b75","default":false,"description":null},{"id":158399402,"node_id":"MDU6TGFiZWwxNTgzOTk0MDI=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/Meta","name":"Meta","color":"e11d21","default":false,"description":null},{"id":1967496097,"node_id":"MDU6TGFiZWwxOTY3NDk2MDk3","url":"https://api.github.com/repos/elastic/elasticsearch/labels/Team:Core/Features","name":"Team:Core/Features","color":"fef2c0","default":false,"description":"Meta label for core/features team"}],"state":"closed","locked":false,"assignee":{"login":"dakrone","id":19060,"node_id":"MDQ6VXNlcjE5MDYw","avatar_url":"https://avatars3.githubusercontent.com/u/19060?v=4","gravatar_id":"","url":"https://api.github.com/users/dakrone","html_url":"https://github.com/dakrone","followers_url":"https://api.github.com/users/dakrone/followers","following_url":"https://api.github.com/users/dakrone/following{/other_user}","gists_url":"https://api.github.com/users/dakrone/gists{/gist_id}","starred_url":"https://api.github.com/users/dakrone/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dakrone/subscriptions","organizations_url":"https://api.github.com/users/dakrone/orgs","repos_url":"https://api.github.com/users/dakrone/repos","events_url":"https://api.github.com/users/dakrone/events{/privacy}","received_events_url":"https://api.github.com/users/dakrone/received_events","type":"User","site_admin":false},"assignees":[{"login":"dakrone","id":19060,"node_id":"MDQ6VXNlcjE5MDYw","avatar_url":"https://avatars3.githubusercontent.com/u/19060?v=4","gravatar_id":"","url":"https://api.github.com/users/dakrone","html_url":"https://github.com/dakrone","followers_url":"https://api.github.com/users/dakrone/followers","following_url":"https://api.github.com/users/dakrone/following{/other_user}","gists_url":"https://api.github.com/users/dakrone/gists{/gist_id}","starred_url":"https://api.github.com/users/dakrone/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dakrone/subscriptions","organizations_url":"https://api.github.com/users/dakrone/orgs","repos_url":"https://api.github.com/users/dakrone/repos","events_url":"https://api.github.com/users/dakrone/events{/privacy}","received_events_url":"https://api.github.com/users/dakrone/received_events","type":"User","site_admin":false},{"login":"andreidan","id":1217601,"node_id":"MDQ6VXNlcjEyMTc2MDE=","avatar_url":"https://avatars2.githubusercontent.com/u/1217601?v=4","gravatar_id":"","url":"https://api.github.com/users/andreidan","html_url":"https://github.com/andreidan","followers_url":"https://api.github.com/users/andreidan/followers","following_url":"https://api.github.com/users/andreidan/following{/other_user}","gists_url":"https://api.github.com/users/andreidan/gists{/gist_id}","starred_url":"https://api.github.com/users/andreidan/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/andreidan/subscriptions","organizations_url":"https://api.github.com/users/andreidan/orgs","repos_url":"https://api.github.com/users/andreidan/repos","events_url":"https://api.github.com/users/andreidan/events{/privacy}","received_events_url":"https://api.github.com/users/andreidan/received_events","type":"User","site_admin":false}],"milestone":null,"comments":2,"created_at":"2020-08-06T19:51:26Z","updated_at":"2020-10-13T15:18:09Z","closed_at":"2020-10-13T15:18:08Z","author_association":"MEMBER","active_lock_reason":null,"body":"We currently have the ability for users to split their deployments into tiers based on thing like node attributes, and manually move data between the tiers within ILM. We'd like to take this one step further and formalize the concept of data tiers within Elasticsearch.\r\n\r\n## Tasks\r\n\r\n- [x] Add tiers as dedicated roles (@dakrone) #60994\r\n- [x] Add filtering for allowing indices to be assigned to a particular tier (@dakrone) #60994\r\n- [x] Add `frozen` phase to ILM (@andreidan) #60983\r\n  - [ ] ~[UI] Add UI for frozen phase~ #61345\r\n- [x] Inject step to move data between tiers within ILM automatically (@andreidan) #61377\r\n  - [x] Add check to allow moving past allocation check if allocation settings are manually unset (@andreidan) #62636 \r\n  - [ ] ~[UI] Add opt-out UI for automatic data relocation~\r\n  - [ ] [UI] Ensure UI is not lossy for actions supported by the API but not yet by the UI\r\n- [x] Automatically allocate new indices to \"hot\" tier nodes (@dakrone) #61342\r\n- [x] Add `data_content` tier (@dakrone) #62247\r\n- [x] Choose allocating new indices to hot automatically based on whether the index is a data stream (@dakrone) #62338\r\n- ~[ ] Add opt-out index level setting to bypass initial hot allocation and ILM phase migration (@andreidan) #62114~\r\n- [x] Make tier allocation decider use a prioritized list of possible values for allocation (@dakrone) #62589\r\n  - [x] Enhance ILM's injected `migrate` step to correctly set list of possible tiers for each phase (@andreidan) #62829\r\n- [x] Documentation (@andreidan)\r\n  - [x] Overview documentation (@andreidan) #63086 \r\n  - [x] ILM documentation (@andreidan) #63086 \r\n  - [x] Release notes highlights (@dakrone) #63427\r\n- [x] Telemetry (@dakrone) #63031\r\n\r\n--------------\r\n\r\n### Context\r\nSo why formalize tiers into Elasticsearch (and beyond)? There are a number of advantages to doing this.\r\n\r\n- By formalizing this inside of Elasticsearch itself we shift from descriptive best practices to prescriptive best practices. Instead of a million ways to configure hot/warm/cold, we prescribe our preferred solution.\r\n- This allows us to be consistent in our documentation for on-prem as well as on Cloud, we don’t need to make up attributes that may differ, as we can refer to the actual role names and configuration.\r\n- This solution allows us to tell a story not only in our documentation, but also in our out-of-the-box configuration. The idea of data having a lifecycle is concrete instead of abstract based on general purpose constructs.\r\n- A data stream already encapsulates some of the lifecycle of data in that we prevent certain actions to the write index, allowing them only to non-write indices in the stream. This would only be strengthened by having tiers available as a first class feature.\r\n- A better out of the box experience for users using time-series data\r\n- A user now has less to configure in their ILM policy and templates, as data can shift tiers automatically.\r\n- Since we have a distinction between tiers, we have the freedom to be more aggressive with our default ILM policies. For example, we can start to include policies that automatically freeze indices on a frozen tier, or use searchable snapshots by default, because tiers are now a first class idea.\r\n- Autoscaling can be tier-aware. Rather than having to scale based on a node attribute and not knowing whether data is even respecting that attribute by default (since we don’t respect attribute-based allocation by default), autoscaling can differentiate between the different tiers, scaling only a specific part up or down as needed.\r\n\r\n### Minimum Viable Product\r\nThere are a set of things that we’d like to provide for the MVP for formalizing data tiers. This includes functionality for the tiering itself as well as uses within other parts of ES (like ILM). While the features can be expanded at a later time, this is a good starting place for the MVP.\r\n\r\n#### Add tiers to Elasticsearch\r\nThe first step will be adding tiers to Elasticsearch itself. We can add the following roles to Elasticsearch:\r\n- data_hot\r\n- data_warm\r\n- data_cold\r\n- data_frozen\r\n\r\nThese roles are not mutually exclusive. When a user doesn’t specify any of these roles, but does specify the “data” role (or uses the default node role which includes “data”), we will treat the node as if it has all of the `data_*` roles.\r\n\r\nNot only do we need to make these tiers available for setting, we need to make them accessible for allocation, we currently have a set of built-in attributes that users can specify in our allocation APIs: `_name, _host_ip, _publish_ip, _ip, _host, and _id`. I propose that we add another: `_tier`. This new attribute could be used manually for both the cluster and index level allocation as well as within ILM. This way we could avoid having to introduce a new set of allocation deciders specifically for moving data within the different tiers, we also already have the infrastructure for include, exclude, and require for a given set of _tier attributes.\r\n\r\nAn example configuration for this would include the following in elasticsearch.yml:\r\n\r\n``` sh\r\nnode.roles: [“master”, “data_hot”, “ingest”]\r\n```\r\n\r\nOne of the first uses of the new tiers will be ILM. Currently ILM has a lifecycle that includes the hot, warm, and cold phases and their actions. Making ILM aware of our tiers is a two step process: adding the tier as a new phase, and then making ILM perform the automatic migration.\r\n\r\n#### Adding a “frozen” phase to ILM\r\nAdding a frozen phase also includes adding a set of actions that are allowed as well as the parsing for the phase itself. The “frozen” phase will occur after the “cold” phase but before the “delete” phase. The list of allowed actions for the frozen phase in their execution order will be:\r\n- set_priority\r\n- unfollow\r\n- allocate\r\n- freeze\r\n- searchable_snapshot\r\n\r\n#### Migrating data between tiers automatically\r\nCurrently ILM doesn’t migrate any data between tiers automatically, though this is something that has tripped up users in the past (they expect it to move the data, but it doesn’t). The plan is to make ILM automatically move data to the tier corresponding to the ILM phase, unless there is an existing allocate action in the phase with an allocation set (not just a replica change)\r\n\r\nThis migration should be implemented as an injected step (similar to the way we inject the “unfollow” step in phases) that happens as the first step in a phase, that way the user can monitor it through the existing ILM explain API as well as allowing it to be re-run when a user moves back to a phase. This injected step should fail fast if there are no nodes corresponding to the given phase available in the cluster, and then be retried the next time the ILM policy is executed.\r\n\r\nWe should add a way to opt-out of this automatic migration, rather than requiring a user to have a custom allocation as the only way to opt out.\r\n\r\n#### Allocate new indices on hot nodes\r\nIn addition to making tiers something a user manages, we want new data to automatically be allocated to “hot” nodes by default. This will not affect the out-of-the-box case where each node is of type “data”, because those are considered hot nodes.\r\n\r\nThis should be implemented as default settings for the index that set:\r\n\r\n```\r\n{\r\n  \"index.routing.allocation.include._role\": \"data_hot\"\r\n}\r\n```\r\n\r\nAs the settings for a brand new index. This has the nice benefit of easily allowing a user to override these default settings in their template, or manually when creating the index. These are the same settings that will be updated by ILM when migrating between phases.\r\n","closed_by":{"login":"dakrone","id":19060,"node_id":"MDQ6VXNlcjE5MDYw","avatar_url":"https://avatars3.githubusercontent.com/u/19060?v=4","gravatar_id":"","url":"https://api.github.com/users/dakrone","html_url":"https://github.com/dakrone","followers_url":"https://api.github.com/users/dakrone/followers","following_url":"https://api.github.com/users/dakrone/following{/other_user}","gists_url":"https://api.github.com/users/dakrone/gists{/gist_id}","starred_url":"https://api.github.com/users/dakrone/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dakrone/subscriptions","organizations_url":"https://api.github.com/users/dakrone/orgs","repos_url":"https://api.github.com/users/dakrone/repos","events_url":"https://api.github.com/users/dakrone/events{/privacy}","received_events_url":"https://api.github.com/users/dakrone/received_events","type":"User","site_admin":false},"performed_via_github_app":null}