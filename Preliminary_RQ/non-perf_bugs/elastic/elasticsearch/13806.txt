{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/13806","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/13806/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/13806/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/13806/events","html_url":"https://github.com/elastic/elasticsearch/issues/13806","id":108395226,"node_id":"MDU6SXNzdWUxMDgzOTUyMjY=","number":13806,"title":"Add match count scoring option","user":{"login":"jpotisch","id":583171,"node_id":"MDQ6VXNlcjU4MzE3MQ==","avatar_url":"https://avatars0.githubusercontent.com/u/583171?v=4","gravatar_id":"","url":"https://api.github.com/users/jpotisch","html_url":"https://github.com/jpotisch","followers_url":"https://api.github.com/users/jpotisch/followers","following_url":"https://api.github.com/users/jpotisch/following{/other_user}","gists_url":"https://api.github.com/users/jpotisch/gists{/gist_id}","starred_url":"https://api.github.com/users/jpotisch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jpotisch/subscriptions","organizations_url":"https://api.github.com/users/jpotisch/orgs","repos_url":"https://api.github.com/users/jpotisch/repos","events_url":"https://api.github.com/users/jpotisch/events{/privacy}","received_events_url":"https://api.github.com/users/jpotisch/received_events","type":"User","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":9,"created_at":"2015-09-25T19:41:54Z","updated_at":"2018-01-05T22:16:47Z","closed_at":"2015-09-27T10:25:26Z","author_association":"NONE","active_lock_reason":null,"body":"Feature Request:\n\nI would like to be able to run a query that simply returns a score indicating the number of terms that matched my query. As far as I can tell after poring over the documentation (& internet), this is not currently supported.\n\nSay my index contains the following records:\n- `{ \"name\": \"john jacob smith junior 3rd\" }`\n- `{ \"name\": \"john jacob smith junior\" }`\n- `{ \"name\": \"john smith 3rd\" }`\n- `{ \"name\": \"fred smith\" }`\n\nThese are the scores I'd want to get back for the following `match` queries:\n\nsearch terms: `john smith`\n- `john jacob smith junior 3rd` => 2\n- `john jacob smith junior` => 2\n- `john smith 3rd` => 2\n- `fred smith` => 1\n\nsearch terms: `fred smith 3rd`\n- `john jacob smith junior 3rd` => 2\n- `john jacob smith junior` => 1\n- `john smith 3rd` => 1\n- `fred smith` => 2\n\netc.\n\nThis should support all the semantics of a standard `match` query, e.g. `fuzziness`, `minimum_should_match`, etc., and I should be able to set a `boost` so that I may weight these queries in a `should` clause.\n\nI feel like such an approach would fill what seems to me to be a gap between the infinite granularity of standard `match` scores (closeness of the search term to the searched field normalized by TF-IDF), and `constant_score` queries that collapse everything down to a simple yes or no.\n\nThe rationale for this is that in our application we don't actually care how many terms in the searched field _don't_ match, we just care how many _do_ match, and we don't care how rare or important a search term is in the index. We want to give every single record that matches the same number of search terms the precisely same score, and then use our own business logic to boost ranking appropriately based on other fields, e.g. recency, popularity, promoted status, etc.\n\nUsing the examples above, a search for `smith` would give every record a 1, and we would use our other fields (not shown for brevity) in a `function_score` query to boost the ones we feel are most relevant to the top of the pack.\n\nI feel like it would make sense to implement this as a parameter that could be added to the existing query types. Something like `score_mode` that accepted values like `similarity` or `match_count`, where `similarity` would be the default and represents how scoring currently works, and `match_count` would be my proposed addition.\n\nSo a simple query might look like:\n\n```\n{\n    \"query\": {\n        \"match\": {\n            \"display_name\": {\n                \"fuzziness\": 0.75,\n                \"query\": \"smith\",\n                \"scoring_mode\": \"match_count\"\n            }\n        }\n    }\n}\n```\n\nIn our use case we'd want to bundle several of these up in a `should` clause, which does seem to normalize the overall score (I wrote a query with two `constant_score` clauses with `boost: 1` and matches on both clauses had score of 1.4142135 and matches on one clause had score of 0.35355338). That's not ideal, but I could work with it. In a perfect world (or my perfect world!) a `should` clause containing multiple of these `match_count` queries would emit the sum of all those scores without modification.\n","closed_by":{"login":"clintongormley","id":56599,"node_id":"MDQ6VXNlcjU2NTk5","avatar_url":"https://avatars0.githubusercontent.com/u/56599?v=4","gravatar_id":"","url":"https://api.github.com/users/clintongormley","html_url":"https://github.com/clintongormley","followers_url":"https://api.github.com/users/clintongormley/followers","following_url":"https://api.github.com/users/clintongormley/following{/other_user}","gists_url":"https://api.github.com/users/clintongormley/gists{/gist_id}","starred_url":"https://api.github.com/users/clintongormley/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/clintongormley/subscriptions","organizations_url":"https://api.github.com/users/clintongormley/orgs","repos_url":"https://api.github.com/users/clintongormley/repos","events_url":"https://api.github.com/users/clintongormley/events{/privacy}","received_events_url":"https://api.github.com/users/clintongormley/received_events","type":"User","site_admin":false},"performed_via_github_app":null}