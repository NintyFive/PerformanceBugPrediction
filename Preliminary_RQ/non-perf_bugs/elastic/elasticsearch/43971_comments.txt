[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/508446948","html_url":"https://github.com/elastic/elasticsearch/issues/43971#issuecomment-508446948","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/43971","id":508446948,"node_id":"MDEyOklzc3VlQ29tbWVudDUwODQ0Njk0OA==","user":{"login":"elasticmachine","id":15837671,"node_id":"MDQ6VXNlcjE1ODM3Njcx","avatar_url":"https://avatars3.githubusercontent.com/u/15837671?v=4","gravatar_id":"","url":"https://api.github.com/users/elasticmachine","html_url":"https://github.com/elasticmachine","followers_url":"https://api.github.com/users/elasticmachine/followers","following_url":"https://api.github.com/users/elasticmachine/following{/other_user}","gists_url":"https://api.github.com/users/elasticmachine/gists{/gist_id}","starred_url":"https://api.github.com/users/elasticmachine/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/elasticmachine/subscriptions","organizations_url":"https://api.github.com/users/elasticmachine/orgs","repos_url":"https://api.github.com/users/elasticmachine/repos","events_url":"https://api.github.com/users/elasticmachine/events{/privacy}","received_events_url":"https://api.github.com/users/elasticmachine/received_events","type":"User","site_admin":false},"created_at":"2019-07-04T11:21:18Z","updated_at":"2019-07-04T11:21:18Z","author_association":"COLLABORATOR","body":"Pinging @elastic/es-core-infra","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/508453372","html_url":"https://github.com/elastic/elasticsearch/issues/43971#issuecomment-508453372","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/43971","id":508453372,"node_id":"MDEyOklzc3VlQ29tbWVudDUwODQ1MzM3Mg==","user":{"login":"alpar-t","id":2565652,"node_id":"MDQ6VXNlcjI1NjU2NTI=","avatar_url":"https://avatars1.githubusercontent.com/u/2565652?v=4","gravatar_id":"","url":"https://api.github.com/users/alpar-t","html_url":"https://github.com/alpar-t","followers_url":"https://api.github.com/users/alpar-t/followers","following_url":"https://api.github.com/users/alpar-t/following{/other_user}","gists_url":"https://api.github.com/users/alpar-t/gists{/gist_id}","starred_url":"https://api.github.com/users/alpar-t/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alpar-t/subscriptions","organizations_url":"https://api.github.com/users/alpar-t/orgs","repos_url":"https://api.github.com/users/alpar-t/repos","events_url":"https://api.github.com/users/alpar-t/events{/privacy}","received_events_url":"https://api.github.com/users/alpar-t/received_events","type":"User","site_admin":false},"created_at":"2019-07-04T11:46:22Z","updated_at":"2019-07-04T11:48:35Z","author_association":"CONTRIBUTOR","body":"## Atomic git push \r\n\r\nIt look like git supports __atomic pushes__. \r\nOne could do the version bump on all branches and then do something like\r\n```\r\ngit push --atomic origin 6.8 7.3 7.x master\r\n```\r\nWe should update the documentation on how to do version bumps and eventually automate it. \r\n\r\n## No longer store metadata\r\n\r\nWe are currently checking out the BWC branches individually after the build starts,\r\nso we could be in the situation where we check out e.x master before the push, then a push happens before we get to the BWC checkout part and we would still get a mismatch.\r\nThe atomic push doesn't help with this problem. \r\n\r\nWe should replace the current mechanism in runbld that stores build metadata about the bwc checkout with a simple flag that would be passed in CI  that would make it so no BWC revision is newer than the one we are running on.  (Except for PR jobs, see bellow)\r\n\r\ne.x\r\nWit this timing: \r\n```\r\n        |                            time --->                                       \r\n--------|----------------------------------------------------------------------------\r\nmaster  |  m1                    m2                    m3 \r\n7.x     |            x1  x2   x3 x4   \r\n--------------------------------------------------------------------------------------\r\n                                  ^\r\n                                  | m2 and x3 are atomic\r\n```\r\nWhen we run intake on `m2` , we would use `x3`  because the tow revisions have the exact same timing. Suppose `x4` is right after `x3` so that by the time we get to the bwc checkout it's already there, we would ignore it and use `x3` because the timestamp of `x4` is newer than `m2`.  \r\nEventually we will trigger `m3` which will test with `m3`. \r\n\r\nWe don't want this behavior locally as even if it's considered bad practice, one could go a long time without creating a commit and this would limit the bwc testing to an older than actual release. \r\nThe same foes for PR builds. A long standing PR running it's checks should not use a really old BWC checkout as it could create a false sense of security.  \r\nThe checkout of these will remain as it is Today. \r\n\r\n###  How is this different from the metadata we store ? \r\n\r\nMost of the time it will be the same. \r\nWith the current infrastructure what would probably happen going back to the example from before is that we would store `x4` with `m3` instead of `x3` so in those cases where we have a quick succession of commits it will be different but not incorrect. \r\n\r\nOn the other hand we wouldn't need to persist state, which would help us with multijobs, as we could do the update of last good commit ( and only that, no metadata ) from a post build action or a publisher that calls runbld.  \r\n\r\nIt would also solve the problem from the description where we don't want to pick up a version bump if it happened after the build started but the checkout didn't happen without putting the burden on CI to do the checkouts ( which would be fine, except we still have to have them in Gradle anyhow for local development, so better to maintain a single solution ).\r\n\r\nSide note: in theory we should be triggering master on changes from  `7.x` because a merge there can influence the tests in mate. ","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/508454144","html_url":"https://github.com/elastic/elasticsearch/issues/43971#issuecomment-508454144","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/43971","id":508454144,"node_id":"MDEyOklzc3VlQ29tbWVudDUwODQ1NDE0NA==","user":{"login":"alpar-t","id":2565652,"node_id":"MDQ6VXNlcjI1NjU2NTI=","avatar_url":"https://avatars1.githubusercontent.com/u/2565652?v=4","gravatar_id":"","url":"https://api.github.com/users/alpar-t","html_url":"https://github.com/alpar-t","followers_url":"https://api.github.com/users/alpar-t/followers","following_url":"https://api.github.com/users/alpar-t/following{/other_user}","gists_url":"https://api.github.com/users/alpar-t/gists{/gist_id}","starred_url":"https://api.github.com/users/alpar-t/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alpar-t/subscriptions","organizations_url":"https://api.github.com/users/alpar-t/orgs","repos_url":"https://api.github.com/users/alpar-t/repos","events_url":"https://api.github.com/users/alpar-t/events{/privacy}","received_events_url":"https://api.github.com/users/alpar-t/received_events","type":"User","site_admin":false},"created_at":"2019-07-04T11:49:13Z","updated_at":"2019-07-04T11:49:13Z","author_association":"CONTRIBUTOR","body":"@rjernst @mark-vieira I'm happy to implement this but would like your thoughts first. ","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/508814692","html_url":"https://github.com/elastic/elasticsearch/issues/43971#issuecomment-508814692","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/43971","id":508814692,"node_id":"MDEyOklzc3VlQ29tbWVudDUwODgxNDY5Mg==","user":{"login":"mark-vieira","id":4106672,"node_id":"MDQ6VXNlcjQxMDY2NzI=","avatar_url":"https://avatars2.githubusercontent.com/u/4106672?v=4","gravatar_id":"","url":"https://api.github.com/users/mark-vieira","html_url":"https://github.com/mark-vieira","followers_url":"https://api.github.com/users/mark-vieira/followers","following_url":"https://api.github.com/users/mark-vieira/following{/other_user}","gists_url":"https://api.github.com/users/mark-vieira/gists{/gist_id}","starred_url":"https://api.github.com/users/mark-vieira/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mark-vieira/subscriptions","organizations_url":"https://api.github.com/users/mark-vieira/orgs","repos_url":"https://api.github.com/users/mark-vieira/repos","events_url":"https://api.github.com/users/mark-vieira/events{/privacy}","received_events_url":"https://api.github.com/users/mark-vieira/received_events","type":"User","site_admin":false},"created_at":"2019-07-05T16:52:37Z","updated_at":"2019-07-05T16:52:59Z","author_association":"CONTRIBUTOR","body":"I'm still not quite sure this \"time-based\" pinning of BWC commits will work. I think this will break down in CI for the same reason it does locally. What happens if `master` doesn't change, but I make a forward-incompaptible change in a BWC version branch? Using this method we would not be testing `master` against those new changes which would identify a regression. For example:\r\n\r\n1. The `master` branch is built by intake and last good commit is recorded.\r\n2. I make a change in `7.x` which breaks compatibility with `master`.\r\n3. The `master` periodic builds run against last good commit from step (1), but do not pull changes from step (2) because they are \"newer\" than last good commit.\r\n\r\nSo I don't think this will work. I think the solution to mid-build build pushes is to pin the BWC checkout commit revisions at build start time. Either by doing a single `git fetch` at the beginning of the build as discussed in our weekly, or have `runbld` inject these somehow. Essentially, we need to also do _checkouts_ atomically when BWC testing in addition to pushing atomically.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/510021244","html_url":"https://github.com/elastic/elasticsearch/issues/43971#issuecomment-510021244","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/43971","id":510021244,"node_id":"MDEyOklzc3VlQ29tbWVudDUxMDAyMTI0NA==","user":{"login":"alpar-t","id":2565652,"node_id":"MDQ6VXNlcjI1NjU2NTI=","avatar_url":"https://avatars1.githubusercontent.com/u/2565652?v=4","gravatar_id":"","url":"https://api.github.com/users/alpar-t","html_url":"https://github.com/alpar-t","followers_url":"https://api.github.com/users/alpar-t/followers","following_url":"https://api.github.com/users/alpar-t/following{/other_user}","gists_url":"https://api.github.com/users/alpar-t/gists{/gist_id}","starred_url":"https://api.github.com/users/alpar-t/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alpar-t/subscriptions","organizations_url":"https://api.github.com/users/alpar-t/orgs","repos_url":"https://api.github.com/users/alpar-t/repos","events_url":"https://api.github.com/users/alpar-t/events{/privacy}","received_events_url":"https://api.github.com/users/alpar-t/received_events","type":"User","site_admin":false},"created_at":"2019-07-10T11:23:58Z","updated_at":"2019-07-10T11:23:58Z","author_association":"CONTRIBUTOR","body":"@mark-vieira what you describe would work in the same way Today. \r\nLast good commit pins the BWC checkout refs, so unless there's an intake job to update them, any breakage coming from `7.x` would go undetected. \r\nFor the periodic jobs that is by design as we don't want them to break because something in `7.x` changed after we recorded the last good commit. \r\n\r\n\r\n\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/510023097","html_url":"https://github.com/elastic/elasticsearch/issues/43971#issuecomment-510023097","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/43971","id":510023097,"node_id":"MDEyOklzc3VlQ29tbWVudDUxMDAyMzA5Nw==","user":{"login":"alpar-t","id":2565652,"node_id":"MDQ6VXNlcjI1NjU2NTI=","avatar_url":"https://avatars1.githubusercontent.com/u/2565652?v=4","gravatar_id":"","url":"https://api.github.com/users/alpar-t","html_url":"https://github.com/alpar-t","followers_url":"https://api.github.com/users/alpar-t/followers","following_url":"https://api.github.com/users/alpar-t/following{/other_user}","gists_url":"https://api.github.com/users/alpar-t/gists{/gist_id}","starred_url":"https://api.github.com/users/alpar-t/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alpar-t/subscriptions","organizations_url":"https://api.github.com/users/alpar-t/orgs","repos_url":"https://api.github.com/users/alpar-t/repos","events_url":"https://api.github.com/users/alpar-t/events{/privacy}","received_events_url":"https://api.github.com/users/alpar-t/received_events","type":"User","site_admin":false},"created_at":"2019-07-10T11:30:26Z","updated_at":"2019-07-10T11:30:26Z","author_association":"CONTRIBUTOR","body":"I think where it would make a difference is if we were to trigger `master` intake jobs on changes to `7.x` or other branches that master is backwards compatible to. \r\nThat would pose challenges to properly  display and handle the author,  essentially the author that would get the ping needs to be from `7.x` not the master commit that happens to be building.  Always enabling the forward comparability PR check we are introducing might be a better solution to this problem to prevent that bad merge in the first place. \r\n\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/510095872","html_url":"https://github.com/elastic/elasticsearch/issues/43971#issuecomment-510095872","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/43971","id":510095872,"node_id":"MDEyOklzc3VlQ29tbWVudDUxMDA5NTg3Mg==","user":{"login":"mark-vieira","id":4106672,"node_id":"MDQ6VXNlcjQxMDY2NzI=","avatar_url":"https://avatars2.githubusercontent.com/u/4106672?v=4","gravatar_id":"","url":"https://api.github.com/users/mark-vieira","html_url":"https://github.com/mark-vieira","followers_url":"https://api.github.com/users/mark-vieira/followers","following_url":"https://api.github.com/users/mark-vieira/following{/other_user}","gists_url":"https://api.github.com/users/mark-vieira/gists{/gist_id}","starred_url":"https://api.github.com/users/mark-vieira/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mark-vieira/subscriptions","organizations_url":"https://api.github.com/users/mark-vieira/orgs","repos_url":"https://api.github.com/users/mark-vieira/repos","events_url":"https://api.github.com/users/mark-vieira/events{/privacy}","received_events_url":"https://api.github.com/users/mark-vieira/received_events","type":"User","site_admin":false},"created_at":"2019-07-10T14:53:24Z","updated_at":"2019-07-10T14:53:24Z","author_association":"CONTRIBUTOR","body":"> I think where it would make a difference is if we were to trigger master intake jobs on changes to 7.x or other branches that master is backwards compatible to.\r\n\r\nRight. This is the scenario I'm referring to. This issue is specific to intake builds where we just checkout the latest of everything.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/510481685","html_url":"https://github.com/elastic/elasticsearch/issues/43971#issuecomment-510481685","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/43971","id":510481685,"node_id":"MDEyOklzc3VlQ29tbWVudDUxMDQ4MTY4NQ==","user":{"login":"alpar-t","id":2565652,"node_id":"MDQ6VXNlcjI1NjU2NTI=","avatar_url":"https://avatars1.githubusercontent.com/u/2565652?v=4","gravatar_id":"","url":"https://api.github.com/users/alpar-t","html_url":"https://github.com/alpar-t","followers_url":"https://api.github.com/users/alpar-t/followers","following_url":"https://api.github.com/users/alpar-t/following{/other_user}","gists_url":"https://api.github.com/users/alpar-t/gists{/gist_id}","starred_url":"https://api.github.com/users/alpar-t/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alpar-t/subscriptions","organizations_url":"https://api.github.com/users/alpar-t/orgs","repos_url":"https://api.github.com/users/alpar-t/repos","events_url":"https://api.github.com/users/alpar-t/events{/privacy}","received_events_url":"https://api.github.com/users/alpar-t/received_events","type":"User","site_admin":false},"created_at":"2019-07-11T13:18:46Z","updated_at":"2019-07-11T13:18:46Z","author_association":"CONTRIBUTOR","body":"We spent some time discussing this.\r\nThere are two problems we are looking to fix here. \r\nBesides the  fallout from version bumps we would we are also considering replacing the intake job with the [multi job](https://elasticsearch-ci.elastic.co/view/Elasticsearch%20master/job/elastic+elasticsearch+master+fast/) to get much faster feedback. \r\n These are related because they both have to do with how we manage the last good commit for BWC checkouts. \r\nWith multi jobs the checkout metadata has to come from the `bwc` downstream job, but the last good commit comes from the upstream job when all downstream jobs complete. \r\n\r\n@rjernst I spent some time Today looking at how we could implement that currently and \r\nit doesn't seem straightforward at all ( or maybe I'm missing something ).\r\nFor instance we could produce the metadata as build output and then use the [Copy Artifact Plugin](https://wiki.jenkins.io/display/JENKINS/Copy+Artifact+Plugin) but then I couldn't find a way to configure that using jjb, so we might have to develop our own modules for jjb to be able to configure it.\r\n\r\nThe time based approach might not be great,  I'm really concerned that having to deal with this state in Jenkins keeps us on the wrong track will require much more maintenance and would take significantly longer to implement.\r\n\r\nAre you willing to give it a try ? Any ideas on how to do this without requiring state in Jenkins ? \r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/510484770","html_url":"https://github.com/elastic/elasticsearch/issues/43971#issuecomment-510484770","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/43971","id":510484770,"node_id":"MDEyOklzc3VlQ29tbWVudDUxMDQ4NDc3MA==","user":{"login":"alpar-t","id":2565652,"node_id":"MDQ6VXNlcjI1NjU2NTI=","avatar_url":"https://avatars1.githubusercontent.com/u/2565652?v=4","gravatar_id":"","url":"https://api.github.com/users/alpar-t","html_url":"https://github.com/alpar-t","followers_url":"https://api.github.com/users/alpar-t/followers","following_url":"https://api.github.com/users/alpar-t/following{/other_user}","gists_url":"https://api.github.com/users/alpar-t/gists{/gist_id}","starred_url":"https://api.github.com/users/alpar-t/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alpar-t/subscriptions","organizations_url":"https://api.github.com/users/alpar-t/orgs","repos_url":"https://api.github.com/users/alpar-t/repos","events_url":"https://api.github.com/users/alpar-t/events{/privacy}","received_events_url":"https://api.github.com/users/alpar-t/received_events","type":"User","site_admin":false},"created_at":"2019-07-11T13:27:10Z","updated_at":"2019-07-11T13:27:10Z","author_association":"CONTRIBUTOR","body":"Another line of taught I';m considering is to keep this information in git itself. \r\nThis would have the advantage that it would make it easier to have reproducible jobs outside of CI but would obviously create a lot of noise. \r\n\r\nI'm thinking about something like pushing a tag such as `bwc-ref-branch` ex `bwc-123-7.x` and have the build look for it  based on the current ref, so if we are building `123` it would find and use this tag instead. \r\n\r\nAFAIK builds are working off a repo hosted on the Jenkins master to speed things up, so these tags could potentially only live there, but that would cause failures when masters are rotated.  \r\n\r\nI'm just throwing around ideas ... This would need more taught \r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/510544556","html_url":"https://github.com/elastic/elasticsearch/issues/43971#issuecomment-510544556","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/43971","id":510544556,"node_id":"MDEyOklzc3VlQ29tbWVudDUxMDU0NDU1Ng==","user":{"login":"mark-vieira","id":4106672,"node_id":"MDQ6VXNlcjQxMDY2NzI=","avatar_url":"https://avatars2.githubusercontent.com/u/4106672?v=4","gravatar_id":"","url":"https://api.github.com/users/mark-vieira","html_url":"https://github.com/mark-vieira","followers_url":"https://api.github.com/users/mark-vieira/followers","following_url":"https://api.github.com/users/mark-vieira/following{/other_user}","gists_url":"https://api.github.com/users/mark-vieira/gists{/gist_id}","starred_url":"https://api.github.com/users/mark-vieira/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mark-vieira/subscriptions","organizations_url":"https://api.github.com/users/mark-vieira/orgs","repos_url":"https://api.github.com/users/mark-vieira/repos","events_url":"https://api.github.com/users/mark-vieira/events{/privacy}","received_events_url":"https://api.github.com/users/mark-vieira/received_events","type":"User","site_admin":false},"created_at":"2019-07-11T15:53:12Z","updated_at":"2019-07-11T15:53:12Z","author_association":"CONTRIBUTOR","body":"Regarding the Jenkins implementation, one thought is to use the [Clone Workspace Plugin](https://wiki.jenkins.io/display/JENKINS/Clone+Workspace+SCM+Plugin) to transfer the metadata files to some downstream build. There's still other details to sort out here that I'm not completely sure about though.\r\n\r\nFWIW, I'm pretty sure the Git date-based checkout system will work. Git supports this as a first-class function with many commands accepting options like `--since` or `--before`. The commit date is not just some mutable metadata (unlike author date), and `git log` and `git rev-list` are primarily temporal lists.\r\n\r\nWe could implement such a system something like this:\r\n\r\n```bash\r\nHEAD_COMMIT_DATE=$(git log -1 --pretty=format:\"%cd\" HEAD)\r\ngit checkout $(git rev-list -1 --until=\"$HEAD_COMMIT_DATE\" origin/7.x)\r\n```\r\n\r\nThe benefit here is there's not explicit reliance on last good commit or any other \"injected\" information by CI. We simply infer the correct BWC branch commits form the commit date of current `HEAD`. As far as I can tell this is stable and reproducible. The only thing that would cause a different set of BWC commits to be used for a given `HEAD` commit would be if the Git history was rewritten which would breaks all sorts of other reproducibility mechanisms anyhow.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/512234326","html_url":"https://github.com/elastic/elasticsearch/issues/43971#issuecomment-512234326","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/43971","id":512234326,"node_id":"MDEyOklzc3VlQ29tbWVudDUxMjIzNDMyNg==","user":{"login":"alpar-t","id":2565652,"node_id":"MDQ6VXNlcjI1NjU2NTI=","avatar_url":"https://avatars1.githubusercontent.com/u/2565652?v=4","gravatar_id":"","url":"https://api.github.com/users/alpar-t","html_url":"https://github.com/alpar-t","followers_url":"https://api.github.com/users/alpar-t/followers","following_url":"https://api.github.com/users/alpar-t/following{/other_user}","gists_url":"https://api.github.com/users/alpar-t/gists{/gist_id}","starred_url":"https://api.github.com/users/alpar-t/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alpar-t/subscriptions","organizations_url":"https://api.github.com/users/alpar-t/orgs","repos_url":"https://api.github.com/users/alpar-t/repos","events_url":"https://api.github.com/users/alpar-t/events{/privacy}","received_events_url":"https://api.github.com/users/alpar-t/received_events","type":"User","site_admin":false},"created_at":"2019-07-17T12:33:08Z","updated_at":"2019-07-17T12:33:08Z","author_association":"CONTRIBUTOR","body":"Clone workspaces will have to transfer files over the network and might not work with gobld as workspaces are not available once the build completes.\r\n\r\nI'we also considered [Parameterized Trigger Plugin](https://wiki.jenkins.io/display/JENKINS/Parameterized+Trigger+Plugin)\r\nwhich could pick up the metadata from the workspace and pass it along.\r\nAll the extra testing jobs would be downstream jobs to intake.\r\nThis would also show upstream/downstream relations in the Jenkins UI which would be a nice improvement. \r\n\r\nProblem is we don't want to trigger all the testing for all the intake jobs  and the only way to influence that is the  [Conditional BuildStep Plugin](https://wiki.jenkins.io/display/JENKINS/Conditional+BuildStep+Plugin) on a post build action but there's no way to implement the current behavior of having periodic additional testing. \r\nWe could do something like trigger every X jobs which might make more sense than time based, as sometimes the periodic builds have lots of commits and others ( like weekends ) might have nothing new. \r\n\r\nAnother problem is this doesn't help with multijobs as the problem of having a different job produce the metadata remains.\r\n\r\nOne possible solution with the multijobs is to use [EnvInject Plugin](https://wiki.jenkins.io/display/JENKINS/EnvInject+Plugin) to inject the bwc checkout metadata from the parent job. It would mean we would run something to create that metadata then pass it to all jobs and eventually use it post build to set it for the job itself with runbld.  So instead of trying to pass it back from a downstream job, we set it on the upstream job and pass it down which seems to be better supported in Jenkins.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/528227309","html_url":"https://github.com/elastic/elasticsearch/issues/43971#issuecomment-528227309","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/43971","id":528227309,"node_id":"MDEyOklzc3VlQ29tbWVudDUyODIyNzMwOQ==","user":{"login":"alpar-t","id":2565652,"node_id":"MDQ6VXNlcjI1NjU2NTI=","avatar_url":"https://avatars1.githubusercontent.com/u/2565652?v=4","gravatar_id":"","url":"https://api.github.com/users/alpar-t","html_url":"https://github.com/alpar-t","followers_url":"https://api.github.com/users/alpar-t/followers","following_url":"https://api.github.com/users/alpar-t/following{/other_user}","gists_url":"https://api.github.com/users/alpar-t/gists{/gist_id}","starred_url":"https://api.github.com/users/alpar-t/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alpar-t/subscriptions","organizations_url":"https://api.github.com/users/alpar-t/orgs","repos_url":"https://api.github.com/users/alpar-t/repos","events_url":"https://api.github.com/users/alpar-t/events{/privacy}","received_events_url":"https://api.github.com/users/alpar-t/received_events","type":"User","site_admin":false},"created_at":"2019-09-05T06:58:19Z","updated_at":"2019-09-05T06:58:19Z","author_association":"CONTRIBUTOR","body":"We changed to a solution that uses `git rev-list` and looks at the timing of each to decide what to pick.\r\nThis will cause no fallout when the version bump happens in an atomic push across branches.  All that is left here is to update the documentation on version bumps.","performed_via_github_app":null}]