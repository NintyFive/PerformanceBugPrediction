[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/468367908","html_url":"https://github.com/elastic/elasticsearch/issues/39524#issuecomment-468367908","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/39524","id":468367908,"node_id":"MDEyOklzc3VlQ29tbWVudDQ2ODM2NzkwOA==","user":{"login":"elasticmachine","id":15837671,"node_id":"MDQ6VXNlcjE1ODM3Njcx","avatar_url":"https://avatars3.githubusercontent.com/u/15837671?v=4","gravatar_id":"","url":"https://api.github.com/users/elasticmachine","html_url":"https://github.com/elasticmachine","followers_url":"https://api.github.com/users/elasticmachine/followers","following_url":"https://api.github.com/users/elasticmachine/following{/other_user}","gists_url":"https://api.github.com/users/elasticmachine/gists{/gist_id}","starred_url":"https://api.github.com/users/elasticmachine/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/elasticmachine/subscriptions","organizations_url":"https://api.github.com/users/elasticmachine/orgs","repos_url":"https://api.github.com/users/elasticmachine/repos","events_url":"https://api.github.com/users/elasticmachine/events{/privacy}","received_events_url":"https://api.github.com/users/elasticmachine/received_events","type":"User","site_admin":false},"created_at":"2019-02-28T17:44:28Z","updated_at":"2019-02-28T17:44:28Z","author_association":"COLLABORATOR","body":"Pinging @elastic/es-core-features","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/468374155","html_url":"https://github.com/elastic/elasticsearch/issues/39524#issuecomment-468374155","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/39524","id":468374155,"node_id":"MDEyOklzc3VlQ29tbWVudDQ2ODM3NDE1NQ==","user":{"login":"jakelandis","id":976291,"node_id":"MDQ6VXNlcjk3NjI5MQ==","avatar_url":"https://avatars2.githubusercontent.com/u/976291?v=4","gravatar_id":"","url":"https://api.github.com/users/jakelandis","html_url":"https://github.com/jakelandis","followers_url":"https://api.github.com/users/jakelandis/followers","following_url":"https://api.github.com/users/jakelandis/following{/other_user}","gists_url":"https://api.github.com/users/jakelandis/gists{/gist_id}","starred_url":"https://api.github.com/users/jakelandis/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jakelandis/subscriptions","organizations_url":"https://api.github.com/users/jakelandis/orgs","repos_url":"https://api.github.com/users/jakelandis/repos","events_url":"https://api.github.com/users/jakelandis/events{/privacy}","received_events_url":"https://api.github.com/users/jakelandis/received_events","type":"User","site_admin":false},"created_at":"2019-02-28T18:01:47Z","updated_at":"2019-02-28T18:01:47Z","author_association":"CONTRIBUTOR","body":"I think there are two areas of support here:\r\n\r\n>  a user should be able to specify that an index be closed\r\n\r\nIt seems that now the we have frozen indices the reasons one would want to close an index are diminishing. By offering close AND frozen as options are we asking the user to make a nuanced decision ? I suspect the most users would pick close since it seems obvious what it does, and thus we may steer people away from frozen and it's benifits. (Users can always close the index themselves, but does it make sense to do so automated ?)\r\n\r\n> The closed index should be allowed to be deleted in the delete phase\r\n\r\nSame argument as above, given that we have `frozen`, does `close` belong in an automated workflow ? \r\n\r\n@eskibars - thoughts ?","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/468377864","html_url":"https://github.com/elastic/elasticsearch/issues/39524#issuecomment-468377864","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/39524","id":468377864,"node_id":"MDEyOklzc3VlQ29tbWVudDQ2ODM3Nzg2NA==","user":{"login":"dakrone","id":19060,"node_id":"MDQ6VXNlcjE5MDYw","avatar_url":"https://avatars3.githubusercontent.com/u/19060?v=4","gravatar_id":"","url":"https://api.github.com/users/dakrone","html_url":"https://github.com/dakrone","followers_url":"https://api.github.com/users/dakrone/followers","following_url":"https://api.github.com/users/dakrone/following{/other_user}","gists_url":"https://api.github.com/users/dakrone/gists{/gist_id}","starred_url":"https://api.github.com/users/dakrone/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dakrone/subscriptions","organizations_url":"https://api.github.com/users/dakrone/orgs","repos_url":"https://api.github.com/users/dakrone/repos","events_url":"https://api.github.com/users/dakrone/events{/privacy}","received_events_url":"https://api.github.com/users/dakrone/received_events","type":"User","site_admin":false},"created_at":"2019-02-28T18:12:39Z","updated_at":"2019-02-28T18:12:39Z","author_association":"MEMBER","body":"> Same argument as above, given that we have `frozen`, does `close` belong in an automated workflow ?\r\n\r\nMy personal opinion here is yes, for instance, I can imagine that it would be nice to freeze older indices while still having them be searchable, and then, close them the day before the indices are deleted. This would allow anyone consuming the data to notice the data was missing (say, in a Kibana dashboard), and then take steps to save the data prior to it being deleted for good.\r\n\r\nDefinitely good to discuss it though.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/469509715","html_url":"https://github.com/elastic/elasticsearch/issues/39524#issuecomment-469509715","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/39524","id":469509715,"node_id":"MDEyOklzc3VlQ29tbWVudDQ2OTUwOTcxNQ==","user":{"login":"eskibars","id":2246002,"node_id":"MDQ6VXNlcjIyNDYwMDI=","avatar_url":"https://avatars0.githubusercontent.com/u/2246002?v=4","gravatar_id":"","url":"https://api.github.com/users/eskibars","html_url":"https://github.com/eskibars","followers_url":"https://api.github.com/users/eskibars/followers","following_url":"https://api.github.com/users/eskibars/following{/other_user}","gists_url":"https://api.github.com/users/eskibars/gists{/gist_id}","starred_url":"https://api.github.com/users/eskibars/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/eskibars/subscriptions","organizations_url":"https://api.github.com/users/eskibars/orgs","repos_url":"https://api.github.com/users/eskibars/repos","events_url":"https://api.github.com/users/eskibars/events{/privacy}","received_events_url":"https://api.github.com/users/eskibars/received_events","type":"User","site_admin":false},"created_at":"2019-03-05T02:26:04Z","updated_at":"2019-03-05T02:26:04Z","author_association":"CONTRIBUTOR","body":">  By offering close AND frozen as options are we asking the user to make a nuanced decision ? I suspect the most users would pick close since it seems obvious what it does, and thus we may steer people away from frozen and it's benifits.\r\n\r\nThis is my concern as well.\r\n\r\n> I can imagine that it would be nice to freeze older indices while still having them be searchable, and then, close them the day before the indices are deleted. This would allow anyone consuming the data to notice the data was missing (say, in a Kibana dashboard), and then take steps to save the data prior to it being deleted for good.\r\n\r\nI suspect it'd be a mix with users.  For smaller orgs/projects, the consumers of the data may also be the cluster administrators (or very close to them anyway) and recognize data's gone missing before they hoped.  In larger orgs/projects, you'd have to have pretty long times between the close and the delete for someone to notice, figure out why the data was gone or if it was a security configuration or someone changing index patterns in Kibana, and then doing the right thing to stop deletion (e.g. not just reopening the index, but also disabling the policy for the index).  I suspect in most cases where there are larger projects, the cluster administrator would just want to ensure that a snapshot had occurred on the index before deletion.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/506385924","html_url":"https://github.com/elastic/elasticsearch/issues/39524#issuecomment-506385924","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/39524","id":506385924,"node_id":"MDEyOklzc3VlQ29tbWVudDUwNjM4NTkyNA==","user":{"login":"dakrone","id":19060,"node_id":"MDQ6VXNlcjE5MDYw","avatar_url":"https://avatars3.githubusercontent.com/u/19060?v=4","gravatar_id":"","url":"https://api.github.com/users/dakrone","html_url":"https://github.com/dakrone","followers_url":"https://api.github.com/users/dakrone/followers","following_url":"https://api.github.com/users/dakrone/following{/other_user}","gists_url":"https://api.github.com/users/dakrone/gists{/gist_id}","starred_url":"https://api.github.com/users/dakrone/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dakrone/subscriptions","organizations_url":"https://api.github.com/users/dakrone/orgs","repos_url":"https://api.github.com/users/dakrone/repos","events_url":"https://api.github.com/users/dakrone/events{/privacy}","received_events_url":"https://api.github.com/users/dakrone/received_events","type":"User","site_admin":false},"created_at":"2019-06-27T15:06:38Z","updated_at":"2019-06-27T15:06:38Z","author_association":"MEMBER","body":"Closing this as we don't think there's enough interest in this.","performed_via_github_app":null}]