[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/428524141","html_url":"https://github.com/elastic/elasticsearch/issues/34352#issuecomment-428524141","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/34352","id":428524141,"node_id":"MDEyOklzc3VlQ29tbWVudDQyODUyNDE0MQ==","user":{"login":"s1monw","id":973334,"node_id":"MDQ6VXNlcjk3MzMzNA==","avatar_url":"https://avatars0.githubusercontent.com/u/973334?v=4","gravatar_id":"","url":"https://api.github.com/users/s1monw","html_url":"https://github.com/s1monw","followers_url":"https://api.github.com/users/s1monw/followers","following_url":"https://api.github.com/users/s1monw/following{/other_user}","gists_url":"https://api.github.com/users/s1monw/gists{/gist_id}","starred_url":"https://api.github.com/users/s1monw/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/s1monw/subscriptions","organizations_url":"https://api.github.com/users/s1monw/orgs","repos_url":"https://api.github.com/users/s1monw/repos","events_url":"https://api.github.com/users/s1monw/events{/privacy}","received_events_url":"https://api.github.com/users/s1monw/received_events","type":"User","site_admin":false},"created_at":"2018-10-10T10:37:20Z","updated_at":"2018-10-10T10:37:20Z","author_association":"CONTRIBUTOR","body":"@debadair where do you see the documentation go for this feature?","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/429275199","html_url":"https://github.com/elastic/elasticsearch/issues/34352#issuecomment-429275199","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/34352","id":429275199,"node_id":"MDEyOklzc3VlQ29tbWVudDQyOTI3NTE5OQ==","user":{"login":"elasticmachine","id":15837671,"node_id":"MDQ6VXNlcjE1ODM3Njcx","avatar_url":"https://avatars3.githubusercontent.com/u/15837671?v=4","gravatar_id":"","url":"https://api.github.com/users/elasticmachine","html_url":"https://github.com/elasticmachine","followers_url":"https://api.github.com/users/elasticmachine/followers","following_url":"https://api.github.com/users/elasticmachine/following{/other_user}","gists_url":"https://api.github.com/users/elasticmachine/gists{/gist_id}","starred_url":"https://api.github.com/users/elasticmachine/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/elasticmachine/subscriptions","organizations_url":"https://api.github.com/users/elasticmachine/orgs","repos_url":"https://api.github.com/users/elasticmachine/repos","events_url":"https://api.github.com/users/elasticmachine/events{/privacy}","received_events_url":"https://api.github.com/users/elasticmachine/received_events","type":"User","site_admin":false},"created_at":"2018-10-12T10:07:00Z","updated_at":"2018-10-12T10:07:00Z","author_association":"COLLABORATOR","body":"Pinging @elastic/es-distributed","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/431116489","html_url":"https://github.com/elastic/elasticsearch/issues/34352#issuecomment-431116489","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/34352","id":431116489,"node_id":"MDEyOklzc3VlQ29tbWVudDQzMTExNjQ4OQ==","user":{"login":"s1monw","id":973334,"node_id":"MDQ6VXNlcjk3MzMzNA==","avatar_url":"https://avatars0.githubusercontent.com/u/973334?v=4","gravatar_id":"","url":"https://api.github.com/users/s1monw","html_url":"https://github.com/s1monw","followers_url":"https://api.github.com/users/s1monw/followers","following_url":"https://api.github.com/users/s1monw/following{/other_user}","gists_url":"https://api.github.com/users/s1monw/gists{/gist_id}","starred_url":"https://api.github.com/users/s1monw/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/s1monw/subscriptions","organizations_url":"https://api.github.com/users/s1monw/orgs","repos_url":"https://api.github.com/users/s1monw/repos","events_url":"https://api.github.com/users/s1monw/events{/privacy}","received_events_url":"https://api.github.com/users/s1monw/received_events","type":"User","site_admin":false},"created_at":"2018-10-18T18:35:36Z","updated_at":"2018-10-18T18:35:36Z","author_association":"CONTRIBUTOR","body":"I thought about some future work on this and wanted to put it here for awareness and potential discussion:\r\n\r\n- The current design would open a reader before we check the cache for hits and even if we cache we would invalidate the cache after each search phase. I wonder if we can trick the lazy reader design into having it's own cache key helper that we can trick into surviving close calls of the actual reader. That way we might be able to allow request cache hits on frozen indices without actually opening the reader\r\n\r\n - should we allow forcemerge on a frozen index? This might allow us to freeze first and the select a new codec to get best compression. Itâ€™s relatively straight forward to do with our infrastructure and an IW that is not pulling NRT readers. And we have limited threads doing this anyway in the force merge threadpool. That's totally something we can do way later.\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/440599624","html_url":"https://github.com/elastic/elasticsearch/issues/34352#issuecomment-440599624","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/34352","id":440599624,"node_id":"MDEyOklzc3VlQ29tbWVudDQ0MDU5OTYyNA==","user":{"login":"cdahlqvist","id":2804455,"node_id":"MDQ6VXNlcjI4MDQ0NTU=","avatar_url":"https://avatars0.githubusercontent.com/u/2804455?v=4","gravatar_id":"","url":"https://api.github.com/users/cdahlqvist","html_url":"https://github.com/cdahlqvist","followers_url":"https://api.github.com/users/cdahlqvist/followers","following_url":"https://api.github.com/users/cdahlqvist/following{/other_user}","gists_url":"https://api.github.com/users/cdahlqvist/gists{/gist_id}","starred_url":"https://api.github.com/users/cdahlqvist/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cdahlqvist/subscriptions","organizations_url":"https://api.github.com/users/cdahlqvist/orgs","repos_url":"https://api.github.com/users/cdahlqvist/repos","events_url":"https://api.github.com/users/cdahlqvist/events{/privacy}","received_events_url":"https://api.github.com/users/cdahlqvist/received_events","type":"User","site_admin":false},"created_at":"2018-11-21T09:42:46Z","updated_at":"2018-11-23T14:02:02Z","author_association":"NONE","body":"When benchmarking frozen indices to get an idea of the overhead and added latency it adds I can see two common scenarios:\r\n\r\n**1) Dedicated Cold nodes**\r\n\r\nHere all indices will be frozen, and due to the low heap usage it may be possible to hold a lot of data with a small heap. In order to efficiently use the available resources and allow parallel processing of frozen indices, I assume it may make sense to set the number of threads used for frozen indices processing to the number of CPU cores on the host. This naturally assumes there is enough heap available to support this.\r\n\r\n**2) Warm nodes**\r\n\r\nFrozen indices could also be used to make Warm nodes able to handle larger amounts of data. Here the most recent and generally most queried data would be open, while older indices that are not queried frequently could be frozen. The ratio of frozen to open indices will naturally vary from use-case to use-case, but for the benchmark a 50% ratio might be a good starting point. In this scenario, a single thread used to handle frozen indices is probably appropriate.\r\n\r\n_Does this make sense?_\r\n\r\nIn addition to benchmarking these two scenarios, I would also like to benchmark using indices that have and have not been forcemerged down to a single segment since restoration time here may vary. If we add a reference benchmark for each scenario with all indices open, we get a total of 8 benchmark runs.\r\n\r\n**Benchmark set-up**\r\n\r\nTest data would be generated using the rally-eventdata-track. A single index with 2 primary shards and around 50GB in size would probably be reasonably realistic. Snapshots would be created before and after forcemerging it down to a single segment. This index can then be restored and renamed multiple times to reach a reasonable data volume (~1TB?). Querying would simulate the standard Kibana dashboards available in the rally-eventdata-track. As Kibana dashboards can require a good amount of processing, I would probably run querying in a single thread.\r\n\r\nAs querying using Rally is quite light, we should be able to run this on a single host. A **AWS EC2 d2.xlarge** instance might be a good choice as it has enough disk space and used the type of slower storage we often see for these node types.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/441242248","html_url":"https://github.com/elastic/elasticsearch/issues/34352#issuecomment-441242248","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/34352","id":441242248,"node_id":"MDEyOklzc3VlQ29tbWVudDQ0MTI0MjI0OA==","user":{"login":"s1monw","id":973334,"node_id":"MDQ6VXNlcjk3MzMzNA==","avatar_url":"https://avatars0.githubusercontent.com/u/973334?v=4","gravatar_id":"","url":"https://api.github.com/users/s1monw","html_url":"https://github.com/s1monw","followers_url":"https://api.github.com/users/s1monw/followers","following_url":"https://api.github.com/users/s1monw/following{/other_user}","gists_url":"https://api.github.com/users/s1monw/gists{/gist_id}","starred_url":"https://api.github.com/users/s1monw/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/s1monw/subscriptions","organizations_url":"https://api.github.com/users/s1monw/orgs","repos_url":"https://api.github.com/users/s1monw/repos","events_url":"https://api.github.com/users/s1monw/events{/privacy}","received_events_url":"https://api.github.com/users/s1monw/received_events","type":"User","site_admin":false},"created_at":"2018-11-23T13:32:58Z","updated_at":"2018-11-23T13:32:58Z","author_association":"CONTRIBUTOR","body":"> Here all indices will be frozen, and due to the low heap usage it may be possible to hold a lot of data with a small heap. In order to efficiently use the available resources and allow parallel processing of frozen indices, I assume it may make sense to set the number of threads used for frozen indices processing to the number of CPU cores on the host. This naturally assumes there is enough heap available to support this.\r\n\r\nI would like to keep the thread-settings for this to the default. We can still test this but that is for a later iteration.\r\n\r\n> Frozen indices could also be used to make Warm nodes able to handle larger amounts of data. Here the most recent and generally most queried data would be open, while older indices that are not queried frequently could be frozen. The ratio of frozen to open indices will naturally vary from use-case to use-case, but for the benchmark a 50% ratio might be a good starting point. In this scenario, a single thread used to handle frozen indices is probably appropriate.\r\n\r\nIn general I think this scenario is rare and benchmarking will be tricky. I don't want to give the impression that this is a recommended setup so I'd rather not advertise it too much.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/442872121","html_url":"https://github.com/elastic/elasticsearch/issues/34352#issuecomment-442872121","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/34352","id":442872121,"node_id":"MDEyOklzc3VlQ29tbWVudDQ0Mjg3MjEyMQ==","user":{"login":"s1monw","id":973334,"node_id":"MDQ6VXNlcjk3MzMzNA==","avatar_url":"https://avatars0.githubusercontent.com/u/973334?v=4","gravatar_id":"","url":"https://api.github.com/users/s1monw","html_url":"https://github.com/s1monw","followers_url":"https://api.github.com/users/s1monw/followers","following_url":"https://api.github.com/users/s1monw/following{/other_user}","gists_url":"https://api.github.com/users/s1monw/gists{/gist_id}","starred_url":"https://api.github.com/users/s1monw/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/s1monw/subscriptions","organizations_url":"https://api.github.com/users/s1monw/orgs","repos_url":"https://api.github.com/users/s1monw/repos","events_url":"https://api.github.com/users/s1monw/events{/privacy}","received_events_url":"https://api.github.com/users/s1monw/received_events","type":"User","site_admin":false},"created_at":"2018-11-29T15:20:46Z","updated_at":"2018-11-29T15:20:46Z","author_association":"CONTRIBUTOR","body":"This issue is basically done. I am keeping this open in order to publish numbers from benchmarks in the near future.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/445197759","html_url":"https://github.com/elastic/elasticsearch/issues/34352#issuecomment-445197759","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/34352","id":445197759,"node_id":"MDEyOklzc3VlQ29tbWVudDQ0NTE5Nzc1OQ==","user":{"login":"cdahlqvist","id":2804455,"node_id":"MDQ6VXNlcjI4MDQ0NTU=","avatar_url":"https://avatars0.githubusercontent.com/u/2804455?v=4","gravatar_id":"","url":"https://api.github.com/users/cdahlqvist","html_url":"https://github.com/cdahlqvist","followers_url":"https://api.github.com/users/cdahlqvist/followers","following_url":"https://api.github.com/users/cdahlqvist/following{/other_user}","gists_url":"https://api.github.com/users/cdahlqvist/gists{/gist_id}","starred_url":"https://api.github.com/users/cdahlqvist/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cdahlqvist/subscriptions","organizations_url":"https://api.github.com/users/cdahlqvist/orgs","repos_url":"https://api.github.com/users/cdahlqvist/repos","events_url":"https://api.github.com/users/cdahlqvist/events{/privacy}","received_events_url":"https://api.github.com/users/cdahlqvist/received_events","type":"User","site_admin":false},"created_at":"2018-12-07T10:58:31Z","updated_at":"2018-12-07T10:58:31Z","author_association":"NONE","body":"I have now run a first set of benchmarks for frozen indices where the number of indices in the cluster gradually increases from 1 to 18. Each index consists of 2 shards and is ~50GB in size and was generated and queried using the rally-eventdata-track. This was run against a build with the build hash `447e5d2`.\r\n\r\nQuerying was done using two types of simulated Kibana queries:\r\n\r\n- **Kibana Discover query:** Single histogram aggregation and 500 documents being retrieved\r\n- **Content Issues Dashboard query:** Small dashboard containing 5 aggregations, aggregating over a subset of the data.\r\n\r\nFor indices forcemerged down to a single segment, two different heap sizes were used when querying frozen indices: 1GB and 15GB. For the larger heap, a reference run with all indices open was performed at every step. Each run consists of 20 queries with a varying time interval, and 50% and 100% percentile service time values are shown.\r\n\r\nThe results are shown below in the form of Kibana screenshots from the Rally metrics store.\r\n\r\n**Discover query, 15GB Heap, Forcemerged indices, all indices open and not frozen**\r\n\r\n![screenshot 2018-12-02 at 15 46 42](https://user-images.githubusercontent.com/2804455/49643929-fdc1db00-f9e4-11e8-8857-a29451ca9688.png)\r\n\r\n**Discover query, 1GB/15GB Heap, Forcemerged indices, all indices frozen**\r\n\r\n![screenshot 2018-12-02 at 15 47 25](https://user-images.githubusercontent.com/2804455/49643941-061a1600-f9e5-11e8-82c7-105e7b6c722e.png)\r\n\r\n**Content Issues Dashboard query, 15GB Heap, Forcemerged indices, all indices open and not frozen**\r\n\r\n![screenshot 2018-12-02 at 15 47 42](https://user-images.githubusercontent.com/2804455/49643951-0d412400-f9e5-11e8-8d4b-f350e3f8d640.png)\r\n\r\n**Content Issues Dashboard query, 1GB/15GB Heap, Forcemerged indices, all indices frozen**\r\n\r\n![screenshot 2018-12-02 at 15 48 01](https://user-images.githubusercontent.com/2804455/49643963-129e6e80-f9e5-11e8-8c0b-a24e18651025.png)\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/445285465","html_url":"https://github.com/elastic/elasticsearch/issues/34352#issuecomment-445285465","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/34352","id":445285465,"node_id":"MDEyOklzc3VlQ29tbWVudDQ0NTI4NTQ2NQ==","user":{"login":"s1monw","id":973334,"node_id":"MDQ6VXNlcjk3MzMzNA==","avatar_url":"https://avatars0.githubusercontent.com/u/973334?v=4","gravatar_id":"","url":"https://api.github.com/users/s1monw","html_url":"https://github.com/s1monw","followers_url":"https://api.github.com/users/s1monw/followers","following_url":"https://api.github.com/users/s1monw/following{/other_user}","gists_url":"https://api.github.com/users/s1monw/gists{/gist_id}","starred_url":"https://api.github.com/users/s1monw/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/s1monw/subscriptions","organizations_url":"https://api.github.com/users/s1monw/orgs","repos_url":"https://api.github.com/users/s1monw/repos","events_url":"https://api.github.com/users/s1monw/events{/privacy}","received_events_url":"https://api.github.com/users/s1monw/received_events","type":"User","site_admin":false},"created_at":"2018-12-07T16:24:38Z","updated_at":"2018-12-07T16:24:38Z","author_association":"CONTRIBUTOR","body":"thanks you @cdahlqvist great results. I will now close this issue. thanks everyone involved.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/495165600","html_url":"https://github.com/elastic/elasticsearch/issues/34352#issuecomment-495165600","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/34352","id":495165600,"node_id":"MDEyOklzc3VlQ29tbWVudDQ5NTE2NTYwMA==","user":{"login":"octocat-mona","id":538170,"node_id":"MDQ6VXNlcjUzODE3MA==","avatar_url":"https://avatars3.githubusercontent.com/u/538170?v=4","gravatar_id":"","url":"https://api.github.com/users/octocat-mona","html_url":"https://github.com/octocat-mona","followers_url":"https://api.github.com/users/octocat-mona/followers","following_url":"https://api.github.com/users/octocat-mona/following{/other_user}","gists_url":"https://api.github.com/users/octocat-mona/gists{/gist_id}","starred_url":"https://api.github.com/users/octocat-mona/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/octocat-mona/subscriptions","organizations_url":"https://api.github.com/users/octocat-mona/orgs","repos_url":"https://api.github.com/users/octocat-mona/repos","events_url":"https://api.github.com/users/octocat-mona/events{/privacy}","received_events_url":"https://api.github.com/users/octocat-mona/received_events","type":"User","site_admin":false},"created_at":"2019-05-23T10:37:50Z","updated_at":"2019-05-23T10:37:50Z","author_association":"NONE","body":"> should we allow forcemerge on a frozen index?\r\n\r\n@s1monw Maybe I missed the answer in this thread, but this is/won't be allowed?\r\nBecause the docs mention that a `_forcemerge` should only be called on read-only indices it made sense to me to use `_freeze` because it does exactly this: make it read-only.\r\n\r\nBut it took me a while to figure out that `_forcemerge` doesn't do anything on a frozen index and doesn't fail either..","performed_via_github_app":null}]