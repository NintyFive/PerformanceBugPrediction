{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/49594","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/49594/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/49594/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/49594/events","html_url":"https://github.com/elastic/elasticsearch/issues/49594","id":528730260,"node_id":"MDU6SXNzdWU1Mjg3MzAyNjA=","number":49594,"title":"EQL sequence and join execution","user":{"login":"colings86","id":236731,"node_id":"MDQ6VXNlcjIzNjczMQ==","avatar_url":"https://avatars0.githubusercontent.com/u/236731?v=4","gravatar_id":"","url":"https://api.github.com/users/colings86","html_url":"https://github.com/colings86","followers_url":"https://api.github.com/users/colings86/followers","following_url":"https://api.github.com/users/colings86/following{/other_user}","gists_url":"https://api.github.com/users/colings86/gists{/gist_id}","starred_url":"https://api.github.com/users/colings86/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/colings86/subscriptions","organizations_url":"https://api.github.com/users/colings86/orgs","repos_url":"https://api.github.com/users/colings86/repos","events_url":"https://api.github.com/users/colings86/events{/privacy}","received_events_url":"https://api.github.com/users/colings86/received_events","type":"User","site_admin":false},"labels":[{"id":1690690117,"node_id":"MDU6TGFiZWwxNjkwNjkwMTE3","url":"https://api.github.com/repos/elastic/elasticsearch/labels/:Query%20Languages/EQL","name":":Query Languages/EQL","color":"0e8a16","default":false,"description":"EQL querying"},{"id":1967501040,"node_id":"MDU6TGFiZWwxOTY3NTAxMDQw","url":"https://api.github.com/repos/elastic/elasticsearch/labels/Team:QL","name":"Team:QL","color":"fef2c0","default":false,"description":"Meta label for query languages team"}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":5,"created_at":"2019-11-26T13:38:03Z","updated_at":"2020-10-28T11:12:23Z","closed_at":"2020-10-28T11:12:23Z","author_association":"MEMBER","active_lock_reason":null,"body":"Once we have EQL sequence/join parts transpiled to ES Search DSL (https://github.com/elastic/elasticsearch/issues/49590) we need to implement logic to perform the join and find results matching the sequence/join. Since joins can be thought of as unordered sequences we can think mainly about the execution of sequences and apply the same logic to joins.\r\n\r\nThe basic concept is execute a sequence similar to how Lucene executes conjunction queries. We have N streams of hits (where each stream corresponds to an element in the sequence) sorted by the join key(s) and then by timestamp. We pick a leading iterator (ideally the stream with the fewest hits), look at the first result and try to skip to the join key for that result on the other streams. If the key exists in all the streams we can iterate through the events with that key in the streams to find a matching sequence (potentially using this same skipping/leapfrogging approach with the timestamp). If the key does not exist in all the streams we know there is no matching sequence for the key so can skip to the next key on the leading iterator. \r\n\r\nThe above idea needs to be modified slightly to account for the fact that Elasticsearch returns results in pages rather than a continuous stream. Within a single page of results for each stream we can follow the logic above. When we reach the end of a page of results we have two cases:\r\n1. we are in the middle of trying to match on a key - In this case we use search_after to request a new page of results with the value of `search_after` being the join key and timestamp from the leading iterator for the key we are trying to find.\r\n2. We are looking for the next key - In this case we can use the values from the last join key(s) in `search_after` to find the next candidate.\r\n\r\nAs matches are found they can be added to the response. The match should contain the documents for each element in the sequence (there will be a separate issue regarding the response format)","closed_by":{"login":"costin","id":76245,"node_id":"MDQ6VXNlcjc2MjQ1","avatar_url":"https://avatars3.githubusercontent.com/u/76245?v=4","gravatar_id":"","url":"https://api.github.com/users/costin","html_url":"https://github.com/costin","followers_url":"https://api.github.com/users/costin/followers","following_url":"https://api.github.com/users/costin/following{/other_user}","gists_url":"https://api.github.com/users/costin/gists{/gist_id}","starred_url":"https://api.github.com/users/costin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/costin/subscriptions","organizations_url":"https://api.github.com/users/costin/orgs","repos_url":"https://api.github.com/users/costin/repos","events_url":"https://api.github.com/users/costin/events{/privacy}","received_events_url":"https://api.github.com/users/costin/received_events","type":"User","site_admin":false},"performed_via_github_app":null}