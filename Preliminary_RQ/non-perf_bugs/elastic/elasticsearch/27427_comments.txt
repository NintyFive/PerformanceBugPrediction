[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/345203526","html_url":"https://github.com/elastic/elasticsearch/issues/27427#issuecomment-345203526","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/27427","id":345203526,"node_id":"MDEyOklzc3VlQ29tbWVudDM0NTIwMzUyNg==","user":{"login":"ywelsch","id":3718355,"node_id":"MDQ6VXNlcjM3MTgzNTU=","avatar_url":"https://avatars3.githubusercontent.com/u/3718355?v=4","gravatar_id":"","url":"https://api.github.com/users/ywelsch","html_url":"https://github.com/ywelsch","followers_url":"https://api.github.com/users/ywelsch/followers","following_url":"https://api.github.com/users/ywelsch/following{/other_user}","gists_url":"https://api.github.com/users/ywelsch/gists{/gist_id}","starred_url":"https://api.github.com/users/ywelsch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ywelsch/subscriptions","organizations_url":"https://api.github.com/users/ywelsch/orgs","repos_url":"https://api.github.com/users/ywelsch/repos","events_url":"https://api.github.com/users/ywelsch/events{/privacy}","received_events_url":"https://api.github.com/users/ywelsch/received_events","type":"User","site_admin":false},"created_at":"2017-11-17T10:19:48Z","updated_at":"2017-11-17T10:19:48Z","author_association":"CONTRIBUTOR","body":"Sounds interesting. The tricky part of improving the performance of the balancer for certain cases is to keep the solution generic and modular enough so that new allocation deciders can easily be added, and also making sure that other cluster configurations don't suffer performance problems due to this.\r\nI would like to know more about this solution, especially the complexity that it adds to the balancer code. Would you be interested in working on a PR?","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/345222758","html_url":"https://github.com/elastic/elasticsearch/issues/27427#issuecomment-345222758","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/27427","id":345222758,"node_id":"MDEyOklzc3VlQ29tbWVudDM0NTIyMjc1OA==","user":{"login":"itiyama","id":7935367,"node_id":"MDQ6VXNlcjc5MzUzNjc=","avatar_url":"https://avatars3.githubusercontent.com/u/7935367?v=4","gravatar_id":"","url":"https://api.github.com/users/itiyama","html_url":"https://github.com/itiyama","followers_url":"https://api.github.com/users/itiyama/followers","following_url":"https://api.github.com/users/itiyama/following{/other_user}","gists_url":"https://api.github.com/users/itiyama/gists{/gist_id}","starred_url":"https://api.github.com/users/itiyama/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/itiyama/subscriptions","organizations_url":"https://api.github.com/users/itiyama/orgs","repos_url":"https://api.github.com/users/itiyama/repos","events_url":"https://api.github.com/users/itiyama/events{/privacy}","received_events_url":"https://api.github.com/users/itiyama/received_events","type":"User","site_admin":false},"created_at":"2017-11-17T11:45:16Z","updated_at":"2017-11-17T11:45:16Z","author_association":"NONE","body":"Yes, we are interested in working on PR. We have a working PoC ready. Just wanted to initiate a discussion before raising a formal PR.\r\nLet me know if you want to take a look at the PoC itself. Will raise an informal PR.\r\n\r\nWe have taken care of other cases. New allocation deciders can be added, but now instead of adding a canRemain per shard, we need to add a canRemain per node as well. \r\n\r\nAs far as the complexity goes, it will help improve the performance in almost all cases we could think of. The performance might not increase as much as forced awareness.\r\nSo, there are certain allocation deciders like  [DiskThresholdDecider](https://github.com/elastic/elasticsearch/blob/master/core/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDecider.java), [FilterAllocationDecider](https://github.com/elastic/elasticsearch/blob/master/core/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/FilterAllocationDecider.java),[ShardsLimitAllocationDecider](https://github.com/elastic/elasticsearch/blob/master/core/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/ShardsLimitAllocationDecider.java),[ThrottlingAllocationDecider](https://github.com/elastic/elasticsearch/blob/master/core/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/ThrottlingAllocationDecider.java) for which a node level decision can be taken, but for certain deciders like  [AwarenessAllocationDecider](https://github.com/elastic/elasticsearch/blob/master/core/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/AwarenessAllocationDecider.java), a shard level decision is required. For deciders for which shard level decision is required, we can cache the values required to take a decision in cluster state.\r\n\r\nTo give you a hint of what we are trying to do:\r\n1. We have changed the [nodeInterleavingShardIterator](https://github.com/elastic/elasticsearch/blob/master/core/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java#L1131) to take a decision per node as well.\r\n`public Iterator<ShardRouting> nodeInterleavedShardIterator(RoutingAllocation allocation, RoutingNodes routingNodes,  Logger logger) {\r\n        // This iterator should eliminate nodes based on node throttling criteria.\r\n        final Queue<Iterator<ShardRouting>> queue = new ArrayDeque<>();\r\n\r\n        for (Map.Entry<String, RoutingNode> entry : nodesToShards.entrySet()) {\r\n            queue.add(entry.getValue().copyShards().iterator());\r\n        }\r\n        return new Iterator<ShardRouting>() {\r\n            public boolean hasNext() {\r\n                while (!queue.isEmpty()) {\r\n                    if (queue.peek().hasNext()) {\r\n                        return true;\r\n                    }\r\n                    queue.poll();\r\n                }\r\n                return false;\r\n            }\r\n\r\n            public ShardRouting next() {\r\n                if (hasNext() == false) {\r\n                    throw new NoSuchElementException();\r\n                }\r\n                long startTime = System.currentTimeMillis();\r\n                while(hasNext()){\r\n\r\n                    logger.info(\"Queue size \"+ queue.size());\r\n                    Iterator<ShardRouting> iter = queue.poll();\r\n                    ShardRouting result = iter.next();\r\n                    RoutingNode routingNode = nodesToShards.get(result.getCurrentNodeId());\r\n\r\n                    Decision decision = allocation.deciders().decideOutgoingMovePerNode(routingNode, allocation, routingNodes, logger);\r\n                    if (!(decision == Decision.NO || decision == Decision.THROTTLE)){\r\n                        logger.info(\"Keeping node iterator \" + routingNode.nodeId() +\" \"+decision.toString());\r\n\r\n                        queue.offer(iter);\r\n                        long endTime = System.currentTimeMillis();\r\n                        logger.info(\"Node level Allocation decision time \" +(endTime-startTime));\r\n                        return result;\r\n                    } else{\r\n                        logger.info(\"Removing node iterator \" + routingNode.nodeId()+ \" \"+ decision.toString());\r\n\r\n                    }\r\n                }\r\n                long endTime = System.currentTimeMillis();\r\n                logger.info(\"Node level Allocation decision time \" +(endTime-startTime));\r\n\r\n                return null;\r\n\r\n            }\r\n\r\n            public void remove() {\r\n                throw new UnsupportedOperationException();\r\n            }\r\n        };\r\n    }`\r\n2. We have added a new method decideOutgoingMovePerNode per allocation decider which contains canRemain method. An example of diskThresholdDecider\r\n`public Decision decideOutgoingMovePerNode(RoutingNode node, RoutingAllocation allocation, RoutingNodes routingNodes, Logger logger){\r\n        final ClusterInfo clusterInfo = allocation.clusterInfo();\r\n        final ImmutableOpenMap<String, DiskUsage> usages = clusterInfo.getNodeLeastAvailableDiskUsages();\r\n        final Decision decision = earlyTerminate(allocation, usages);\r\n        if (decision != null) {\r\n            return decision;\r\n        }\r\n\r\n        // subtractLeavingShards is passed as true here, since this is only for shards remaining, we will *eventually* have enough disk\r\n        // since shards are moving away. No new shards will be incoming since in canAllocate we pass false for this check.\r\n        final DiskUsage usage = getDiskUsage(node, allocation, usages, true);\r\n        // If this node is already above the high threshold, the shard cannot remain (get it off!)\r\n        final double freeDiskPercentage = usage.getFreeDiskAsPercentage();\r\n        final long freeBytes = usage.getFreeBytes();\r\n        if (logger.isTraceEnabled()) {\r\n            logger.trace(\"node [{}] has {}% free disk ({} bytes)\", node.nodeId(), freeDiskPercentage, freeBytes);\r\n        }\r\n\r\n        if (freeBytes < diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\r\n            if (logger.isDebugEnabled()) {\r\n                logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, shard cannot remain\",\r\n                    diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytes, node.nodeId());\r\n            }\r\n            return allocation.decision(Decision.NO, NAME,\r\n                \"after allocating this shard this node would be above the high watermark \" +\r\n                    \"and there would be less than required [%s] free on node, free: [%s]\",\r\n                diskThresholdSettings.getFreeBytesThresholdHigh(), new ByteSizeValue(freeBytes));\r\n        }\r\n        if (freeDiskPercentage < diskThresholdSettings.getFreeDiskThresholdHigh()) {\r\n            if (logger.isDebugEnabled()) {\r\n                logger.debug(\"less than the required {}% free disk threshold ({}% free) on node {}, shard cannot remain\",\r\n                    diskThresholdSettings.getFreeDiskThresholdHigh(), freeDiskPercentage, node.nodeId());\r\n            }\r\n            return allocation.decision(Decision.NO, NAME,\r\n                \"after allocating this shard this node would be above the high watermark \" +\r\n                    \"and there would be less than required [%s%%] free disk on node, free: [%s%%]\",\r\n                diskThresholdSettings.getFreeDiskThresholdHigh(), freeDiskPercentage);\r\n        }\r\n\r\n        return allocation.decision(Decision.YES, NAME,\r\n            \"there is enough disk on this node for the shard to remain, free: [%s]\", new ByteSizeValue(freeBytes));\r\n    }`\r\n\r\n\r\n3. Optimized [shardsWithState](https://github.com/elastic/elasticsearch/blob/master/core/src/main/java/org/elasticsearch/cluster/routing/RoutingNode.java#L129) method to use a map instead of iteration.\r\n`public List<ShardRouting> shardsWithState(ShardRoutingState... states) {\r\n\t\tList<ShardRouting> shards = new ArrayList<>();\r\n\t\tfor (ShardRoutingState state : states) {\r\n\t\t\tshards.addAll(shardPerState.get(state));\r\n\t\t}\r\n\t\treturn shards;\r\n\t}`\r\n\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/374559888","html_url":"https://github.com/elastic/elasticsearch/issues/27427#issuecomment-374559888","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/27427","id":374559888,"node_id":"MDEyOklzc3VlQ29tbWVudDM3NDU1OTg4OA==","user":{"login":"elasticmachine","id":15837671,"node_id":"MDQ6VXNlcjE1ODM3Njcx","avatar_url":"https://avatars3.githubusercontent.com/u/15837671?v=4","gravatar_id":"","url":"https://api.github.com/users/elasticmachine","html_url":"https://github.com/elasticmachine","followers_url":"https://api.github.com/users/elasticmachine/followers","following_url":"https://api.github.com/users/elasticmachine/following{/other_user}","gists_url":"https://api.github.com/users/elasticmachine/gists{/gist_id}","starred_url":"https://api.github.com/users/elasticmachine/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/elasticmachine/subscriptions","organizations_url":"https://api.github.com/users/elasticmachine/orgs","repos_url":"https://api.github.com/users/elasticmachine/repos","events_url":"https://api.github.com/users/elasticmachine/events{/privacy}","received_events_url":"https://api.github.com/users/elasticmachine/received_events","type":"User","site_admin":false},"created_at":"2018-03-20T11:11:42Z","updated_at":"2018-03-20T11:11:42Z","author_association":"COLLABORATOR","body":"Pinging @elastic/es-distributed","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/473924509","html_url":"https://github.com/elastic/elasticsearch/issues/27427#issuecomment-473924509","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/27427","id":473924509,"node_id":"MDEyOklzc3VlQ29tbWVudDQ3MzkyNDUwOQ==","user":{"login":"DaveCTurner","id":5058284,"node_id":"MDQ6VXNlcjUwNTgyODQ=","avatar_url":"https://avatars3.githubusercontent.com/u/5058284?v=4","gravatar_id":"","url":"https://api.github.com/users/DaveCTurner","html_url":"https://github.com/DaveCTurner","followers_url":"https://api.github.com/users/DaveCTurner/followers","following_url":"https://api.github.com/users/DaveCTurner/following{/other_user}","gists_url":"https://api.github.com/users/DaveCTurner/gists{/gist_id}","starred_url":"https://api.github.com/users/DaveCTurner/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/DaveCTurner/subscriptions","organizations_url":"https://api.github.com/users/DaveCTurner/orgs","repos_url":"https://api.github.com/users/DaveCTurner/repos","events_url":"https://api.github.com/users/DaveCTurner/events{/privacy}","received_events_url":"https://api.github.com/users/DaveCTurner/received_events","type":"User","site_admin":false},"created_at":"2019-03-18T14:08:26Z","updated_at":"2019-03-18T14:08:26Z","author_association":"CONTRIBUTOR","body":"This issue and the linked PRs seem to have stalled. I would like to close this to indicate that nobody is actively working on it any more. We're still happy to review PRs that improve the performance of cluster state applications involving rerouting.","performed_via_github_app":null}]