{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/36872","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/36872/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/36872/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/36872/events","html_url":"https://github.com/elastic/elasticsearch/issues/36872","id":392833345,"node_id":"MDU6SXNzdWUzOTI4MzMzNDU=","number":36872,"title":"Allow token refresh for multiple requests in a small window","user":{"login":"epixa","id":53814,"node_id":"MDQ6VXNlcjUzODE0","avatar_url":"https://avatars0.githubusercontent.com/u/53814?v=4","gravatar_id":"","url":"https://api.github.com/users/epixa","html_url":"https://github.com/epixa","followers_url":"https://api.github.com/users/epixa/followers","following_url":"https://api.github.com/users/epixa/following{/other_user}","gists_url":"https://api.github.com/users/epixa/gists{/gist_id}","starred_url":"https://api.github.com/users/epixa/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/epixa/subscriptions","organizations_url":"https://api.github.com/users/epixa/orgs","repos_url":"https://api.github.com/users/epixa/repos","events_url":"https://api.github.com/users/epixa/events{/privacy}","received_events_url":"https://api.github.com/users/epixa/received_events","type":"User","site_admin":false},"labels":[{"id":912837951,"node_id":"MDU6TGFiZWw5MTI4Mzc5NTE=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/:Security/Authentication","name":":Security/Authentication","color":"0e8a16","default":false,"description":"Logging in, Usernames/passwords, Realms (Native/LDAP/AD/SAML/PKI/etc)"},{"id":23174,"node_id":"MDU6TGFiZWwyMzE3NA==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/%3Eenhancement","name":">enhancement","color":"4a4ea8","default":false,"description":null}],"state":"closed","locked":false,"assignee":{"login":"jkakavas","id":10281256,"node_id":"MDQ6VXNlcjEwMjgxMjU2","avatar_url":"https://avatars2.githubusercontent.com/u/10281256?v=4","gravatar_id":"","url":"https://api.github.com/users/jkakavas","html_url":"https://github.com/jkakavas","followers_url":"https://api.github.com/users/jkakavas/followers","following_url":"https://api.github.com/users/jkakavas/following{/other_user}","gists_url":"https://api.github.com/users/jkakavas/gists{/gist_id}","starred_url":"https://api.github.com/users/jkakavas/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jkakavas/subscriptions","organizations_url":"https://api.github.com/users/jkakavas/orgs","repos_url":"https://api.github.com/users/jkakavas/repos","events_url":"https://api.github.com/users/jkakavas/events{/privacy}","received_events_url":"https://api.github.com/users/jkakavas/received_events","type":"User","site_admin":false},"assignees":[{"login":"jkakavas","id":10281256,"node_id":"MDQ6VXNlcjEwMjgxMjU2","avatar_url":"https://avatars2.githubusercontent.com/u/10281256?v=4","gravatar_id":"","url":"https://api.github.com/users/jkakavas","html_url":"https://github.com/jkakavas","followers_url":"https://api.github.com/users/jkakavas/followers","following_url":"https://api.github.com/users/jkakavas/following{/other_user}","gists_url":"https://api.github.com/users/jkakavas/gists{/gist_id}","starred_url":"https://api.github.com/users/jkakavas/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jkakavas/subscriptions","organizations_url":"https://api.github.com/users/jkakavas/orgs","repos_url":"https://api.github.com/users/jkakavas/repos","events_url":"https://api.github.com/users/jkakavas/events{/privacy}","received_events_url":"https://api.github.com/users/jkakavas/received_events","type":"User","site_admin":false}],"milestone":null,"comments":19,"created_at":"2018-12-20T00:20:49Z","updated_at":"2019-03-04T11:44:24Z","closed_at":"2019-03-04T11:44:24Z","author_association":"MEMBER","active_lock_reason":null,"body":"## The problem\r\n\r\nThe current behavior for refreshing a token is to immediately invalidate a refresh token when it is used the first time. In principle this is a sensible way to prevent the refresh token from being used maliciously, but in practice it can trivially break a client that is making many requests to Elasticsearch.\r\n\r\nIn Kibana, the consequence is that sessions using our token-based providers (saml and token) occasionally get destroyed as multiple requests race to refresh an expired access token. This problem will only get worse as we expand the usage of canvas expressions which can result in more requests in parallel.\r\n\r\nLet's say a user allows their session to idle for a bit and their access token expires, then they click refresh on a dashboard. Requests `A`, `B`, and `C` are fired off to Elasticsearch in parallel, all three get rejected due to an expired access token, and all three attempt to refresh the session using the same refresh token. `A` succeeds and returns a new session cookie to the client. `B` and `C` fail since the refresh token has already been used. The client sees the failures of `B` and `C` and assumes the session must be dead, so it either errors or sends the user to the login form with a cleared session.\r\n\r\nOnly processing a single refresh token in Kibana for parallel requests isn't practical because there could be multiple Kibana instances behind a load balancer handling requests for the same session.\r\n\r\n## The proposal\r\n\r\nI propose that we add an optional `nonce` property to the `refresh_token` grant type. If the first request to refresh a token contains a nonce, then subsequent refresh token requests for that same refresh token using the same nonce will return the same new access token.\r\n\r\nA client like Kibana can generate a random nonce value each time a user does a page reload on Kibana, and it'll include the nonce in any refresh token requests that occurs for that user during this time. Unlike the access token and refresh token, the nonce is never stored in the session itself.\r\n\r\nThere can be a \"refresh window\" associated with the nonce feature as well, maybe 5 minutes or something like that, where afterwords the token cannot be refreshed even with a matching nonce.\r\n\r\ncc @elastic/kibana-security ","closed_by":{"login":"jkakavas","id":10281256,"node_id":"MDQ6VXNlcjEwMjgxMjU2","avatar_url":"https://avatars2.githubusercontent.com/u/10281256?v=4","gravatar_id":"","url":"https://api.github.com/users/jkakavas","html_url":"https://github.com/jkakavas","followers_url":"https://api.github.com/users/jkakavas/followers","following_url":"https://api.github.com/users/jkakavas/following{/other_user}","gists_url":"https://api.github.com/users/jkakavas/gists{/gist_id}","starred_url":"https://api.github.com/users/jkakavas/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jkakavas/subscriptions","organizations_url":"https://api.github.com/users/jkakavas/orgs","repos_url":"https://api.github.com/users/jkakavas/repos","events_url":"https://api.github.com/users/jkakavas/events{/privacy}","received_events_url":"https://api.github.com/users/jkakavas/received_events","type":"User","site_admin":false},"performed_via_github_app":null}