{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/18146","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/18146/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/18146/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/18146/events","html_url":"https://github.com/elastic/elasticsearch/issues/18146","id":153141201,"node_id":"MDU6SXNzdWUxNTMxNDEyMDE=","number":18146,"title":"Incorrect behavior with long index names on some systems","user":{"login":"Bherzet","id":9641921,"node_id":"MDQ6VXNlcjk2NDE5MjE=","avatar_url":"https://avatars3.githubusercontent.com/u/9641921?v=4","gravatar_id":"","url":"https://api.github.com/users/Bherzet","html_url":"https://github.com/Bherzet","followers_url":"https://api.github.com/users/Bherzet/followers","following_url":"https://api.github.com/users/Bherzet/following{/other_user}","gists_url":"https://api.github.com/users/Bherzet/gists{/gist_id}","starred_url":"https://api.github.com/users/Bherzet/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Bherzet/subscriptions","organizations_url":"https://api.github.com/users/Bherzet/orgs","repos_url":"https://api.github.com/users/Bherzet/repos","events_url":"https://api.github.com/users/Bherzet/events{/privacy}","received_events_url":"https://api.github.com/users/Bherzet/received_events","type":"User","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":2,"created_at":"2016-05-04T23:49:36Z","updated_at":"2016-05-05T00:27:31Z","closed_at":"2016-05-05T00:19:57Z","author_association":"NONE","active_lock_reason":null,"body":"<!--\nIf you are filing a bug report, please remove the below feature\nrequest block and provide responses for all of the below items.\n-->\n\n**Elasticsearch version**: 1.7.1\n\n**JVM version**: OpenJDK 1.7.0_91\n\n**OS version**:\n- Linux Mint 17 Qiana (based on Ubuntu 14.04)\n- kernel 3.13.0-24\n- **ext4 filesystem with eCryptfs** (important!)\n\n**Description of the problem including expected versus actual behavior**:\nAs per #8158, maximal length for index name was changed to 255. When using eCryptfs (and probably some other filesystem-level encryptions), file names that long are not allowed.\n\nWhen creating an index with name too long for my filesystem, Elasticsearch fails on any try to search this index (because, in fact, it was never created). I would expect it to directly reject the request with index creation.\n\n**Steps to reproduce**:\n1. Configure Elasticsearch so it stores its data in folder encrypted with eCryptfs. It would probably behave the same on any other system where maximal allowed file name is less than 255.\n2. Create index with name of length 255:\n   \n   ```\n   POST /aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n   {\n       \"number_of_replicas\": 0\n   }\n   ```\n   \n   This results with:\n   \n   ```\n   {\n      \"acknowledged\": true\n   }\n   ```\n3. Index is now red, even though `number_of_replicas` is set to zero:\n   \n   ```\n   GET /_cat/indices\n   ```\n   \n   Results with:\n   \n   ```\n   red open aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa 5 0     \n   ```\n   \n   It's possible to retrieve information about index:\n   \n   ```\n   GET /aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n   ```\n   \n   Results with:\n   \n   ```\n   {\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\": {\n         \"aliases\": {},\n         \"mappings\": {},\n         \"settings\": {\n            \"index\": {\n               \"creation_date\": \"1462403349650\",\n               \"uuid\": \"LrwgZOXaSPqFlbeBqnsArQ\",\n               \"number_of_replicas\": \"0\",\n               \"number_of_shards\": \"5\",\n               \"version\": {\n                  \"created\": \"1070199\"\n               }\n            }\n         },\n         \"warmers\": {}\n      }\n   }\n   ```\n4. Try to search the index:\n   \n   ```\n   GET /aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/_search\n   ```\n   \n   Results with:\n   \n   ```\n   {\n      \"error\": \"SearchPhaseExecutionException[Failed to execute phase [query], all shards failed]\",\n      \"status\": 503\n   }\n   ```\n5. See that data directory with indices, in fact, doesn't contain the index:\n   \n   ```\n       $ ls indices # no output\n   ```\n   \n   And yes, it is the correct directory:\n   \n   ```\n   POST /foo\n   POST /bar\n   \n   $ ls indices/\n   bar  foo\n   ```\n\nWhat I would consider to be the correct behavior is a response like \"Index name is too long.\" directly to the POST request that tries to create such index. In fact, that's how it responds when index name  exceeds the length of 255:\n\n```\nPOST /aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n```\n\nResults with:\n\n```\n{\n   \"error\": \"InvalidIndexNameException[[aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa] Invalid index name [aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa], index name is too long, (256 > 255)]\",\n       \"status\": 400\n}\n```\n\n**Conclusion**:\nIf it's not possible to create the index directory at hand and verify it succeeded prior to answering to the client, I think a sufficient solution to this would be to make a maximal allowed index name configurable.\n\nBTW: This is not a real-world case. I figured this out by accident when running some tests on my workstation.\n","closed_by":{"login":"jasontedor","id":4744941,"node_id":"MDQ6VXNlcjQ3NDQ5NDE=","avatar_url":"https://avatars3.githubusercontent.com/u/4744941?v=4","gravatar_id":"","url":"https://api.github.com/users/jasontedor","html_url":"https://github.com/jasontedor","followers_url":"https://api.github.com/users/jasontedor/followers","following_url":"https://api.github.com/users/jasontedor/following{/other_user}","gists_url":"https://api.github.com/users/jasontedor/gists{/gist_id}","starred_url":"https://api.github.com/users/jasontedor/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jasontedor/subscriptions","organizations_url":"https://api.github.com/users/jasontedor/orgs","repos_url":"https://api.github.com/users/jasontedor/repos","events_url":"https://api.github.com/users/jasontedor/events{/privacy}","received_events_url":"https://api.github.com/users/jasontedor/received_events","type":"User","site_admin":false},"performed_via_github_app":null}