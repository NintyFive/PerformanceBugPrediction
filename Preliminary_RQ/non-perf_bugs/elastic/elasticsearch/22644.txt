{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/22644","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/22644/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/22644/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/22644/events","html_url":"https://github.com/elastic/elasticsearch/issues/22644","id":201108989,"node_id":"MDU6SXNzdWUyMDExMDg5ODk=","number":22644,"title":"Mapping support for treating JSON keys as data values","user":{"login":"benjismith","id":458075,"node_id":"MDQ6VXNlcjQ1ODA3NQ==","avatar_url":"https://avatars3.githubusercontent.com/u/458075?v=4","gravatar_id":"","url":"https://api.github.com/users/benjismith","html_url":"https://github.com/benjismith","followers_url":"https://api.github.com/users/benjismith/followers","following_url":"https://api.github.com/users/benjismith/following{/other_user}","gists_url":"https://api.github.com/users/benjismith/gists{/gist_id}","starred_url":"https://api.github.com/users/benjismith/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/benjismith/subscriptions","organizations_url":"https://api.github.com/users/benjismith/orgs","repos_url":"https://api.github.com/users/benjismith/repos","events_url":"https://api.github.com/users/benjismith/events{/privacy}","received_events_url":"https://api.github.com/users/benjismith/received_events","type":"User","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":2,"created_at":"2017-01-16T20:10:37Z","updated_at":"2017-01-17T09:09:12Z","closed_at":"2017-01-17T09:09:12Z","author_association":"NONE","active_lock_reason":null,"body":"**Describe the feature**: I'd like to design an Elasticsearch schema to handle cases where JSON keys are used as data values, rather than the current mechanism, which only supports treating JSON keys as a part of the schema.\r\n\r\nFor example, I'd like to load the [Hedonometer Dataset](http://hedonometer.org/words.html) (a list of ten thousand words and their crowdsourced \"happiness\" scores) into a \"dictionary\" object in my application. The JSON for the dictionary object would look like this:\r\n\r\n```\r\n{\r\n  \"name\" : \"hedonometer\",\r\n  \"source\" : \"http://hedonometer.org/words.html\",\r\n  \"words\" : {\r\n    \"laughter\" : { \"score\" : 8.5, \"stdev\" : 0.93 },\r\n    \"happiness\" : { \"score\" : 8.44, \"stdev\" : 0.97 },\r\n    \"love\" : { \"score\" : 8.42, \"stdev\" : 1.10 },\r\n    ... 9,997 more lines ...\r\n  }\r\n}\r\n```\r\n\r\nThis kind of data structure works best for my application, because it gives me O(1) hash-table lookup of entries by their dictionary word. However, I'd also like to store those dictionaries in Elasticsearch, with the list of words as a `nested object` field, but this presents me with a bit of a dilemma...\r\n\r\nElasticsearch will interpret this document as though there were ten-thousand different fields in its schema. That's not what I want.\r\n\r\nI want the JSON object keys to be implicitly treated as a field named `word` in a nested schema of dictionary words.\r\n\r\nRight now, the only way to do this is to change my JSON documents so they look like this instead:\r\n\r\n```\r\n{\r\n  \"name\" : \"hedonometer\",\r\n  \"source\" : \"http://hedonometer.org/words.html\",\r\n  \"words\" : [\r\n    { \"word\" : \"laughter\", \"score\" : 8.5, \"stdev\" : 0.93 },\r\n    { \"word\" : \"happiness\", \"score\" : 8.44, \"stdev\" : 0.97 },\r\n    { \"word\" : \"love\", \"score\" : 8.42, \"stdev\" : 1.10 },\r\n    ... 9,997 more lines ...\r\n  ]\r\n}\r\n```\r\n\r\nBut I now I can't do O(1) lookups of dictionary words in my application, and I'd rather not have to transform my JSON back and forth whenever I store it in Elasticsearch and retrieve it for my application.\r\n\r\nSo I'm proposing a new `key_transform` schema-design mechanism, whereby a JSON object's keys can be treated as values (with an implicit field name) in the body of an embedded tuple. \r\n\r\nFor example, the schema for my \"dictionary\" object would be written like this:\r\n\r\n```\r\n{\r\n  \"properties\": {\r\n    \"name\": { \"type\": \"string\" },\r\n    \"source\": { \"type\": \"string\" },\r\n    \"words\": {\r\n      \"type\" : \"nested\",\r\n      \"key_transform\" : \"word\",\r\n      \"properties\" : {\r\n        \"word\" : { \"type\": \"string\" },\r\n        \"score\" : { \"type\": \"float\" },\r\n        \"stdev\" : { \"type\": \"float\" }\r\n      }\r\n    }\r\n}\r\n```\r\n\r\nThe `key_transform` property would only apply to nested mappings, with its value providing the field name of the string field which would receive the object key as its value.\r\n\r\nI'd also like to propose the logical counterpart, a `val_transform` mechanism, so that a simple key/val object could be indexed according to a simple two-field nested mapping. For example, if I only need to index a single numeric value per dictionary word, my JSON might look like this:\r\n\r\n```\r\n{\r\n  \"name\" : \"hedonometer\",\r\n  \"source\" : \"http://hedonometer.org/words.html\",\r\n  \"words\" : {\r\n    \"laughter\" : 8.5,\r\n    \"happiness\" : 8.44,\r\n    \"love\" : 8.42,\r\n    ... 9,997 more lines ...\r\n  }\r\n}\r\n```\r\n\r\n...which would transform both the JSON keys and values, to conform with a mapping like this:\r\n\r\n```\r\n{\r\n  \"properties\": {\r\n    \"name\": { \"type\": \"string\" },\r\n    \"source\": { \"type\": \"string\" },\r\n    \"words\": {\r\n      \"type\" : \"nested\",\r\n      \"key_transform\" : \"word\",\r\n      \"val_transform\" : \"score\",\r\n      \"properties\" : {\r\n        \"word\" : { \"type\": \"string\" },\r\n        \"score\" : { \"type\": \"float\" }\r\n      }\r\n    }\r\n}\r\n```\r\n\r\nIt would be illegal to use a `val_transform` property without also using `key_transform`.\r\n\r\nIt would also be illegal to use `key_transform` to map into non-string fields.\r\n\r\nIt would be an indexing error to submit a JSON document into a `val_transform` mapping, if the document's JSON values are incompatible with the data types of the `val_transform` field.","closed_by":{"login":"clintongormley","id":56599,"node_id":"MDQ6VXNlcjU2NTk5","avatar_url":"https://avatars0.githubusercontent.com/u/56599?v=4","gravatar_id":"","url":"https://api.github.com/users/clintongormley","html_url":"https://github.com/clintongormley","followers_url":"https://api.github.com/users/clintongormley/followers","following_url":"https://api.github.com/users/clintongormley/following{/other_user}","gists_url":"https://api.github.com/users/clintongormley/gists{/gist_id}","starred_url":"https://api.github.com/users/clintongormley/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/clintongormley/subscriptions","organizations_url":"https://api.github.com/users/clintongormley/orgs","repos_url":"https://api.github.com/users/clintongormley/repos","events_url":"https://api.github.com/users/clintongormley/events{/privacy}","received_events_url":"https://api.github.com/users/clintongormley/received_events","type":"User","site_admin":false},"performed_via_github_app":null}