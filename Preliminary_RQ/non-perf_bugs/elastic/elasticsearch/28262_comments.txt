[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/358300444","html_url":"https://github.com/elastic/elasticsearch/issues/28262#issuecomment-358300444","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/28262","id":358300444,"node_id":"MDEyOklzc3VlQ29tbWVudDM1ODMwMDQ0NA==","user":{"login":"DaveCTurner","id":5058284,"node_id":"MDQ6VXNlcjUwNTgyODQ=","avatar_url":"https://avatars3.githubusercontent.com/u/5058284?v=4","gravatar_id":"","url":"https://api.github.com/users/DaveCTurner","html_url":"https://github.com/DaveCTurner","followers_url":"https://api.github.com/users/DaveCTurner/followers","following_url":"https://api.github.com/users/DaveCTurner/following{/other_user}","gists_url":"https://api.github.com/users/DaveCTurner/gists{/gist_id}","starred_url":"https://api.github.com/users/DaveCTurner/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/DaveCTurner/subscriptions","organizations_url":"https://api.github.com/users/DaveCTurner/orgs","repos_url":"https://api.github.com/users/DaveCTurner/repos","events_url":"https://api.github.com/users/DaveCTurner/events{/privacy}","received_events_url":"https://api.github.com/users/DaveCTurner/received_events","type":"User","site_admin":false},"created_at":"2018-01-17T13:14:43Z","updated_at":"2018-01-17T13:14:43Z","author_association":"CONTRIBUTOR","body":"Thanks for the detailed steps-to-reproduce, @SimonJonasGubler. In 6.1.1 I see the following:\r\n\r\n```\r\nDELETE test_aggregation_with_inner_mapping\r\n\r\nPUT test_aggregation_with_inner_mapping\r\n{\"mappings\":{\"ContainerType\":{\"properties\":{\"outerId\":{\"type\":\"long\"},\"innerModels\":{\"type\":\"nested\",\"properties\":{\"innerId\":{\"type\":\"long\"},\"filterOptions\":{\"type\":\"keyword\"}}}}}}}\r\n\r\nPOST test_aggregation_with_inner_mapping/ContainerType/_bulk\r\n{\"index\":{}}\r\n{\"outerId\":\"10\",\"innerModels\":[{\"innerId\":\"11\",\"filterOptions\":[\"opt1\"]},{\"innerId\":\"12\",\"filterOptions\":[\"opt2\"]}]}\r\n{\"index\":{}}\r\n{\"outerId\":\"20\",\"innerModels\":[{\"innerId\":\"21\",\"filterOptions\":[\"opt1\"]}]}\r\n{\"index\":{}}\r\n{\"outerId\":\"30\",\"innerModels\":[{\"innerId\":\"32\",\"filterOptions\":[\"opt2\"]}]}\r\n\r\nGET test_aggregation_with_inner_mapping/ContainerType/_search\r\n{\r\n  \"query\": {\r\n    \"bool\": {\r\n      \"filter\": [\r\n        {\r\n          \"nested\": {\r\n            \"query\": {\r\n              \"bool\": {\r\n                \"filter\": [\r\n                  {\r\n                    \"match\": {\r\n                      \"innerModels.filterOptions\": {\r\n                        \"query\": \"opt1\"\r\n                      }\r\n                    }\r\n                  }\r\n                ]\r\n              }\r\n            },\r\n            \"path\": \"innerModels\"\r\n          }\r\n        }\r\n      ]\r\n    }\r\n  },\r\n  \"aggs\": {\r\n    \"CountsOfAllFilterOptions\": {\r\n      \"nested\": {\r\n        \"path\": \"innerModels\"\r\n      },\r\n      \"aggs\": {\r\n        \"filterOptions\": {\r\n          \"terms\": {\r\n            \"field\": \"innerModels.filterOptions\"\r\n          },\r\n          \"aggs\": {\r\n            \"filterOptions\": {\r\n              \"reverse_nested\": {}\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nyields\r\n\r\n```\r\n  \"aggregations\": {\r\n    \"CountsOfAllFilterOptions\": {\r\n      \"doc_count\": 3,\r\n      \"filterOptions\": {\r\n        \"doc_count_error_upper_bound\": 0,\r\n        \"sum_other_doc_count\": 0,\r\n        \"buckets\": [\r\n          {\r\n            \"key\": \"opt1\",\r\n            \"doc_count\": 2,\r\n            \"filterOptions\": {\r\n              \"doc_count\": 2\r\n            }\r\n          },\r\n          {\r\n            \"key\": \"opt2\",\r\n            \"doc_count\": 1,\r\n            \"filterOptions\": {\r\n              \"doc_count\": 1\r\n            }\r\n          }\r\n        ]\r\n      }\r\n    }\r\n```\r\n\r\nIf I understand correctly, you expect the inner document `{\"innerId\":\"12\",\"filterOptions\":[\"opt2\"]}` to be ignored in the aggregation, so that the `{\"key\":\"opt2\",\"doc_count\":1,\"filterOptions\":{\"doc_count\":1}}` bucket isn't returned?\r\n\r\nThe issue is, I think, that the filter is finding all outer docs that have a matching inner doc, and the aggregation then runs over all the outer docs that are returned. In the example above I index a couple more documents to show that this is what's happening instead of this:\r\n\r\n> the result seems to be the count of documents with \"opt1\" **or** \"opt2\".\r\n\r\nThis is by design, but perhaps someone like @colings86 would know how to achieve what you're wanting?","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/358313163","html_url":"https://github.com/elastic/elasticsearch/issues/28262#issuecomment-358313163","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/28262","id":358313163,"node_id":"MDEyOklzc3VlQ29tbWVudDM1ODMxMzE2Mw==","user":{"login":"SimonJonasGubler","id":32632429,"node_id":"MDQ6VXNlcjMyNjMyNDI5","avatar_url":"https://avatars3.githubusercontent.com/u/32632429?v=4","gravatar_id":"","url":"https://api.github.com/users/SimonJonasGubler","html_url":"https://github.com/SimonJonasGubler","followers_url":"https://api.github.com/users/SimonJonasGubler/followers","following_url":"https://api.github.com/users/SimonJonasGubler/following{/other_user}","gists_url":"https://api.github.com/users/SimonJonasGubler/gists{/gist_id}","starred_url":"https://api.github.com/users/SimonJonasGubler/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/SimonJonasGubler/subscriptions","organizations_url":"https://api.github.com/users/SimonJonasGubler/orgs","repos_url":"https://api.github.com/users/SimonJonasGubler/repos","events_url":"https://api.github.com/users/SimonJonasGubler/events{/privacy}","received_events_url":"https://api.github.com/users/SimonJonasGubler/received_events","type":"User","site_admin":false},"created_at":"2018-01-17T14:02:09Z","updated_at":"2018-01-17T14:02:09Z","author_association":"NONE","body":"Thanks for the quick and helpful answer. I would like to get the \"opt2\" bucket returned but I expected it to have doc_count 1 in your example. The reason for that is I expected the aggregation to include the filter in the main-query. But this seems not to be the case.\r\n\r\nDo you know how the terms-aggregation could be enhanced to include certain field-values? Then we could use that and include \"opt1\" in  our example. The aggregation would then return doc_count 1 for the bucket \"opt2\" because there is only one document with both \"opt1\" and \"opt2\".","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/358631419","html_url":"https://github.com/elastic/elasticsearch/issues/28262#issuecomment-358631419","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/28262","id":358631419,"node_id":"MDEyOklzc3VlQ29tbWVudDM1ODYzMTQxOQ==","user":{"login":"colings86","id":236731,"node_id":"MDQ6VXNlcjIzNjczMQ==","avatar_url":"https://avatars0.githubusercontent.com/u/236731?v=4","gravatar_id":"","url":"https://api.github.com/users/colings86","html_url":"https://github.com/colings86","followers_url":"https://api.github.com/users/colings86/followers","following_url":"https://api.github.com/users/colings86/following{/other_user}","gists_url":"https://api.github.com/users/colings86/gists{/gist_id}","starred_url":"https://api.github.com/users/colings86/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/colings86/subscriptions","organizations_url":"https://api.github.com/users/colings86/orgs","repos_url":"https://api.github.com/users/colings86/repos","events_url":"https://api.github.com/users/colings86/events{/privacy}","received_events_url":"https://api.github.com/users/colings86/received_events","type":"User","site_admin":false},"created_at":"2018-01-18T12:25:00Z","updated_at":"2018-01-18T12:25:00Z","author_association":"MEMBER","body":"@SimonJonasGubler I'm not following completely on what you expect vs. what is returned in @DaveCTurner's example above. You said in your reply:\r\n> I would like to get the \"opt2\" bucket returned but I expected it to have doc_count 1 in your example\r\n\r\nHowever in the example the `opt2` bucket does have a doc count of 1:\r\n>```\r\n>          {\r\n>            \"key\": \"opt2\",\r\n>            \"doc_count\": 1,\r\n>            \"filterOptions\": {\r\n>              \"doc_count\": 1\r\n>            }\r\n>          }\r\n>```\r\n\r\nCould you maybe modify the response in @DaveCTurner's example so it shows what you expect to see?\r\n\r\nTo clarify a bit how the search request is being interpreted, the following describes what the search request in @DaveCTurner's example will do in Elasticsearch:\r\n\r\nThe `query` asks Elasticsearch to match any root (top-level) document that contains an `innerModels` nested document with a value of `opt1` in the `innerModels.filterOptions` field. This query will return the root document and that root document may also contain `innerModels` nested documents which do not match `opt1` in the `innerModels.filterOptions` field.\r\n\r\nAll matching root documents are passed to the Aggregations. The `CountsOfAllFilterOptions` nested aggregation is asking Elasticsearch to take each of the `innerModels` nested documents in each root document and pass each nested document to the sub-aggregations (rather than passing the root document to the sub aggregations). Note that this aggregation does not differentiate between nested documents containing `opt1` and those that don't, all nested documents for root documents matching the query are passed to the sub aggregations.\r\n\r\nThe `filterOptions` terms aggregation will take each document it is passed (in this case each innerModels nested document from the `CountsOfAllFilterOptions`), inspect the `innerModels.filterOptions` field of the document and pass it to a bucket for that value (in the example above it creates two buckets, one for `opt1` and one for `opt2`). For each bucket the documents in the bucket are passed the sub-aggregations.\r\n\r\nthe `filterOptions` reverse_nested aggregation will take each nested document passed to it and resolve the root document that contains it.\r\n\r\nSo in effect you are asking Elasticsearch: \"Find me all root documents that contain at least one inner document with the value `opt1` in the `innerModels.filterOptions` field. Then for each of those root documents consider each `innerModels` nested document individually and create buckets based on the value of `innerModels.filterOptions` of those nested documents, then in each of those buckets resolve the root documents from those nested documents and tell me how many root documents there are in each bucket.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/358677077","html_url":"https://github.com/elastic/elasticsearch/issues/28262#issuecomment-358677077","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/28262","id":358677077,"node_id":"MDEyOklzc3VlQ29tbWVudDM1ODY3NzA3Nw==","user":{"login":"SimonJonasGubler","id":32632429,"node_id":"MDQ6VXNlcjMyNjMyNDI5","avatar_url":"https://avatars3.githubusercontent.com/u/32632429?v=4","gravatar_id":"","url":"https://api.github.com/users/SimonJonasGubler","html_url":"https://github.com/SimonJonasGubler","followers_url":"https://api.github.com/users/SimonJonasGubler/followers","following_url":"https://api.github.com/users/SimonJonasGubler/following{/other_user}","gists_url":"https://api.github.com/users/SimonJonasGubler/gists{/gist_id}","starred_url":"https://api.github.com/users/SimonJonasGubler/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/SimonJonasGubler/subscriptions","organizations_url":"https://api.github.com/users/SimonJonasGubler/orgs","repos_url":"https://api.github.com/users/SimonJonasGubler/repos","events_url":"https://api.github.com/users/SimonJonasGubler/events{/privacy}","received_events_url":"https://api.github.com/users/SimonJonasGubler/received_events","type":"User","site_admin":false},"created_at":"2018-01-18T15:14:59Z","updated_at":"2018-01-18T15:14:59Z","author_association":"NONE","body":"@colings86 Sorry for the missunderstanding. I see now how the terms aggregation works. In a highlevel-view what I would like to achieve is to get a result like this:\r\n\r\n- All outer documents which contain an inner document with \"opt1\" in the filterOptions\r\n- An aggregation with the following counts\r\n-- All outer documents which contain an inner document with \"opt1\" in the filterOptions\r\n-- All outer documents which contain an inner document with \"opt1\" **and** \"opt2\" in the filterOptions\r\n\r\nBasically I would like the aggregation to tell me how many documents would be returned in the main query if another filterOption is filtered additionally. So if there would be three filteroptions \"opt1\", \"opt2\", \"opt3\" I would like to get the following result:\r\n\r\n- All outer documents which contain an inner document with \"opt1\" in the filterOptions\r\n- An aggregation with the following counts\r\n-- All outer documents which contain an inner document with \"opt1\" in the filterOptions\r\n-- All outer documents which contain an inner document with \"opt1\" **and** \"opt2\" in the filterOptions\r\n-- All outer documents which contain an inner document with \"opt1\" **and** \"opt3\" in the filterOptions\r\n\r\nIn @DaveCTurner 's example the count in the result was as expected. For bucket \"opt1\" it returned 2 and for bucket \"opt2\" it returned 1. But in my initial example there is only one outer document with two inner documents with \"opt1\" respectively \"opt2\". The query returned then 1 for both filterOptions which is not what I expected.\r\n\r\nDo you have an idea how to implement a query to get the described result?","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/358684983","html_url":"https://github.com/elastic/elasticsearch/issues/28262#issuecomment-358684983","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/28262","id":358684983,"node_id":"MDEyOklzc3VlQ29tbWVudDM1ODY4NDk4Mw==","user":{"login":"colings86","id":236731,"node_id":"MDQ6VXNlcjIzNjczMQ==","avatar_url":"https://avatars0.githubusercontent.com/u/236731?v=4","gravatar_id":"","url":"https://api.github.com/users/colings86","html_url":"https://github.com/colings86","followers_url":"https://api.github.com/users/colings86/followers","following_url":"https://api.github.com/users/colings86/following{/other_user}","gists_url":"https://api.github.com/users/colings86/gists{/gist_id}","starred_url":"https://api.github.com/users/colings86/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/colings86/subscriptions","organizations_url":"https://api.github.com/users/colings86/orgs","repos_url":"https://api.github.com/users/colings86/repos","events_url":"https://api.github.com/users/colings86/events{/privacy}","received_events_url":"https://api.github.com/users/colings86/received_events","type":"User","site_admin":false},"created_at":"2018-01-18T15:39:46Z","updated_at":"2018-01-18T15:40:23Z","author_association":"MEMBER","body":"@SimonJonasGubler Thanks for the clarification, I think I understand what you are wanting to do now.\r\n\r\nI have a couple more questions though if thats ok:\r\n1. Are the number of possible values for `filterOptions` small?\r\n2. Are the possible values for `filterOptions` known (as in do you know all the values there could be upfront)?\r\n3. Do you use the fact that `innerModel` is nested in other queries?\r\n4. If yes to 3, in those other queries are you searching across multiple fields in the `innerModel` nested documents?\r\n5. Do you have the ability to change your mappings an re-index if the solution to this requires it?","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/358701921","html_url":"https://github.com/elastic/elasticsearch/issues/28262#issuecomment-358701921","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/28262","id":358701921,"node_id":"MDEyOklzc3VlQ29tbWVudDM1ODcwMTkyMQ==","user":{"login":"SimonJonasGubler","id":32632429,"node_id":"MDQ6VXNlcjMyNjMyNDI5","avatar_url":"https://avatars3.githubusercontent.com/u/32632429?v=4","gravatar_id":"","url":"https://api.github.com/users/SimonJonasGubler","html_url":"https://github.com/SimonJonasGubler","followers_url":"https://api.github.com/users/SimonJonasGubler/followers","following_url":"https://api.github.com/users/SimonJonasGubler/following{/other_user}","gists_url":"https://api.github.com/users/SimonJonasGubler/gists{/gist_id}","starred_url":"https://api.github.com/users/SimonJonasGubler/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/SimonJonasGubler/subscriptions","organizations_url":"https://api.github.com/users/SimonJonasGubler/orgs","repos_url":"https://api.github.com/users/SimonJonasGubler/repos","events_url":"https://api.github.com/users/SimonJonasGubler/events{/privacy}","received_events_url":"https://api.github.com/users/SimonJonasGubler/received_events","type":"User","site_admin":false},"created_at":"2018-01-18T16:31:08Z","updated_at":"2018-01-18T16:31:44Z","author_association":"NONE","body":"1. Unfortunately no. In our first implementation we tried to implement it with a global aggregation for each option with a complete filter. But for some cases there were many options so the query was very slow. That's why we tried the filters-Aggregation\r\n2. The possible values are known.\r\n3. Do you mean other queries than the one I described? No, we use the index only for this query. However there are other fields in our outer- and inner-document which can also be selected\r\n5. (it's actually point 5 :-) ) Yes we can change the mappings and reindex or create an index completely if required","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/359786035","html_url":"https://github.com/elastic/elasticsearch/issues/28262#issuecomment-359786035","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/28262","id":359786035,"node_id":"MDEyOklzc3VlQ29tbWVudDM1OTc4NjAzNQ==","user":{"login":"colings86","id":236731,"node_id":"MDQ6VXNlcjIzNjczMQ==","avatar_url":"https://avatars0.githubusercontent.com/u/236731?v=4","gravatar_id":"","url":"https://api.github.com/users/colings86","html_url":"https://github.com/colings86","followers_url":"https://api.github.com/users/colings86/followers","following_url":"https://api.github.com/users/colings86/following{/other_user}","gists_url":"https://api.github.com/users/colings86/gists{/gist_id}","starred_url":"https://api.github.com/users/colings86/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/colings86/subscriptions","organizations_url":"https://api.github.com/users/colings86/orgs","repos_url":"https://api.github.com/users/colings86/repos","events_url":"https://api.github.com/users/colings86/events{/privacy}","received_events_url":"https://api.github.com/users/colings86/received_events","type":"User","site_admin":false},"created_at":"2018-01-23T13:12:46Z","updated_at":"2018-01-23T13:12:46Z","author_association":"MEMBER","body":"@SimonJonasGubler Sorry for the late response on this. I think I have a solution for your use case given your comment above. I think the following example script will work:\r\n```\r\nDELETE test_aggregation_with_inner_mapping\r\n\r\nPUT test_aggregation_with_inner_mapping\r\n{\r\n  \"mappings\": {\r\n    \"ContainerType\": {\r\n      \"properties\": {\r\n        \"outerId\": {\r\n          \"type\": \"long\"\r\n        },\r\n        \"innerModels\": {\r\n          \"type\": \"nested\",\r\n          \"properties\": {\r\n            \"innerId\": {\r\n              \"type\": \"long\"\r\n            },\r\n            \"filterOptions\": {\r\n              \"type\": \"keyword\"\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nPOST test_aggregation_with_inner_mapping/ContainerType/_bulk\r\n{\"index\":{}}\r\n{\"outerId\":\"10\",\"innerModels\":[{\"innerId\":\"11\",\"filterOptions\":[\"opt1\", \"opt2\"]},{\"innerId\":\"12\",\"filterOptions\":[\"opt3\"]}]}\r\n{\"index\":{}}\r\n{\"outerId\":\"20\",\"innerModels\":[{\"innerId\":\"21\",\"filterOptions\":[\"opt1\"]}]}\r\n{\"index\":{}}\r\n{\"outerId\":\"30\",\"innerModels\":[{\"innerId\":\"32\",\"filterOptions\":[\"opt2\"]}]}\r\n{\"index\":{}}\r\n{\"outerId\":\"10\",\"innerModels\":[{\"innerId\":\"11\",\"filterOptions\":[\"opt1\"]},{\"innerId\":\"12\",\"filterOptions\":[\"opt1\", \"opt3\"]}]}\r\n\r\nGET test_aggregation_with_inner_mapping/ContainerType/_search\r\n{\r\n  \"query\": {\r\n    \"bool\": {\r\n      \"filter\": [\r\n        {\r\n          \"nested\": {\r\n            \"query\": {\r\n              \"bool\": {\r\n                \"filter\": [\r\n                  {\r\n                    \"match\": {\r\n                      \"innerModels.filterOptions\": {\r\n                        \"query\": \"opt1\"\r\n                      }\r\n                    }\r\n                  }\r\n                ]\r\n              }\r\n            },\r\n            \"path\": \"innerModels\"\r\n          }\r\n        }\r\n      ]\r\n    }\r\n  },\r\n  \"aggs\": {\r\n    \"CountsOfAllFilterOptions\": {\r\n      \"nested\": {\r\n        \"path\": \"innerModels\"\r\n      },\r\n      \"aggs\": {\r\n        \"opt1Filter\": {\r\n          \"filter\": {\r\n            \"match\": {\r\n              \"innerModels.filterOptions\": {\r\n                \"query\": \"opt1\"\r\n              }\r\n            }\r\n          },\r\n          \"aggs\": {\r\n            \"filterOptions\": {\r\n              \"terms\": {\r\n                \"field\": \"innerModels.filterOptions\"\r\n              },\r\n              \"aggs\": {\r\n                \"filterOptions\": {\r\n                  \"reverse_nested\": {}\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nNote that the input documents are slightly different to the previous example. The key difference in the search request is adding a `filter` aggregation around the terms aggregation. This will only allow inner documents which contain \"opt1\" to be passed to the sub-aggregations. The following is the response form the search in this example:\r\n```\r\n{\r\n  ...\r\n  \"aggregations\": {\r\n    \"CountsOfAllFilterOptions\": {\r\n      \"doc_count\": 5,\r\n      \"opt1Filter\": {\r\n        \"doc_count\": 4,\r\n        \"filterOptions\": {\r\n          \"doc_count_error_upper_bound\": 0,\r\n          \"sum_other_doc_count\": 0,\r\n          \"buckets\": [\r\n            {\r\n              \"key\": \"opt1\",\r\n              \"doc_count\": 4,\r\n              \"filterOptions\": {\r\n                \"doc_count\": 3\r\n              }\r\n            },\r\n            {\r\n              \"key\": \"opt2\",\r\n              \"doc_count\": 1,\r\n              \"filterOptions\": {\r\n                \"doc_count\": 1\r\n              }\r\n            },\r\n            {\r\n              \"key\": \"opt3\",\r\n              \"doc_count\": 1,\r\n              \"filterOptions\": {\r\n                \"doc_count\": 1\r\n              }\r\n            }\r\n          ]\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nThe count to look for is the one within the inner `filterOptions` object for each terms bucket. This says that there are 3 outer documents which contain \"opt1\" in an inner document (note that the third input document does not contain \"opt1\"), there is one outer document containing both \"opt1\" and \"opt2\" (the first document) and one outer document containing both \"opt1\" and \"opt3\".\r\n\r\nDoes that fit your use case and solve your issue?\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/361193635","html_url":"https://github.com/elastic/elasticsearch/issues/28262#issuecomment-361193635","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/28262","id":361193635,"node_id":"MDEyOklzc3VlQ29tbWVudDM2MTE5MzYzNQ==","user":{"login":"SimonJonasGubler","id":32632429,"node_id":"MDQ6VXNlcjMyNjMyNDI5","avatar_url":"https://avatars3.githubusercontent.com/u/32632429?v=4","gravatar_id":"","url":"https://api.github.com/users/SimonJonasGubler","html_url":"https://github.com/SimonJonasGubler","followers_url":"https://api.github.com/users/SimonJonasGubler/followers","following_url":"https://api.github.com/users/SimonJonasGubler/following{/other_user}","gists_url":"https://api.github.com/users/SimonJonasGubler/gists{/gist_id}","starred_url":"https://api.github.com/users/SimonJonasGubler/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/SimonJonasGubler/subscriptions","organizations_url":"https://api.github.com/users/SimonJonasGubler/orgs","repos_url":"https://api.github.com/users/SimonJonasGubler/repos","events_url":"https://api.github.com/users/SimonJonasGubler/events{/privacy}","received_events_url":"https://api.github.com/users/SimonJonasGubler/received_events","type":"User","site_admin":false},"created_at":"2018-01-29T09:53:02Z","updated_at":"2018-01-29T09:53:02Z","author_association":"NONE","body":"Hi @colings86 \r\n\r\nThank you very much, the query works also with the example from the first post. Conceptionally we need to add the filter from the main-query to the aggregation so that the nested documents are filtered before being aggregated. Is that correct? With this insight we can find a solution to our problem.\r\n\r\nKind regards\r\n\r\nSimon","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/361230976","html_url":"https://github.com/elastic/elasticsearch/issues/28262#issuecomment-361230976","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/28262","id":361230976,"node_id":"MDEyOklzc3VlQ29tbWVudDM2MTIzMDk3Ng==","user":{"login":"colings86","id":236731,"node_id":"MDQ6VXNlcjIzNjczMQ==","avatar_url":"https://avatars0.githubusercontent.com/u/236731?v=4","gravatar_id":"","url":"https://api.github.com/users/colings86","html_url":"https://github.com/colings86","followers_url":"https://api.github.com/users/colings86/followers","following_url":"https://api.github.com/users/colings86/following{/other_user}","gists_url":"https://api.github.com/users/colings86/gists{/gist_id}","starred_url":"https://api.github.com/users/colings86/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/colings86/subscriptions","organizations_url":"https://api.github.com/users/colings86/orgs","repos_url":"https://api.github.com/users/colings86/repos","events_url":"https://api.github.com/users/colings86/events{/privacy}","received_events_url":"https://api.github.com/users/colings86/received_events","type":"User","site_admin":false},"created_at":"2018-01-29T12:29:48Z","updated_at":"2018-01-29T12:29:48Z","author_association":"MEMBER","body":"Yes thats correct, I'm glad you have a solution now. I'm going to close this issue since we have confirmed there is no bug here. If you have further question please ask on the forum at https://discuss.elastic.co","performed_via_github_app":null}]