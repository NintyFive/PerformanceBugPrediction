[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/380746574","html_url":"https://github.com/elastic/elasticsearch/issues/29470#issuecomment-380746574","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/29470","id":380746574,"node_id":"MDEyOklzc3VlQ29tbWVudDM4MDc0NjU3NA==","user":{"login":"atdfairfax","id":7532741,"node_id":"MDQ6VXNlcjc1MzI3NDE=","avatar_url":"https://avatars0.githubusercontent.com/u/7532741?v=4","gravatar_id":"","url":"https://api.github.com/users/atdfairfax","html_url":"https://github.com/atdfairfax","followers_url":"https://api.github.com/users/atdfairfax/followers","following_url":"https://api.github.com/users/atdfairfax/following{/other_user}","gists_url":"https://api.github.com/users/atdfairfax/gists{/gist_id}","starred_url":"https://api.github.com/users/atdfairfax/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/atdfairfax/subscriptions","organizations_url":"https://api.github.com/users/atdfairfax/orgs","repos_url":"https://api.github.com/users/atdfairfax/repos","events_url":"https://api.github.com/users/atdfairfax/events{/privacy}","received_events_url":"https://api.github.com/users/atdfairfax/received_events","type":"User","site_admin":false},"created_at":"2018-04-12T09:56:26Z","updated_at":"2018-04-12T09:56:35Z","author_association":"NONE","body":":thumbsup: +1","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/380992564","html_url":"https://github.com/elastic/elasticsearch/issues/29470#issuecomment-380992564","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/29470","id":380992564,"node_id":"MDEyOklzc3VlQ29tbWVudDM4MDk5MjU2NA==","user":{"login":"elasticmachine","id":15837671,"node_id":"MDQ6VXNlcjE1ODM3Njcx","avatar_url":"https://avatars3.githubusercontent.com/u/15837671?v=4","gravatar_id":"","url":"https://api.github.com/users/elasticmachine","html_url":"https://github.com/elasticmachine","followers_url":"https://api.github.com/users/elasticmachine/followers","following_url":"https://api.github.com/users/elasticmachine/following{/other_user}","gists_url":"https://api.github.com/users/elasticmachine/gists{/gist_id}","starred_url":"https://api.github.com/users/elasticmachine/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/elasticmachine/subscriptions","organizations_url":"https://api.github.com/users/elasticmachine/orgs","repos_url":"https://api.github.com/users/elasticmachine/repos","events_url":"https://api.github.com/users/elasticmachine/events{/privacy}","received_events_url":"https://api.github.com/users/elasticmachine/received_events","type":"User","site_admin":false},"created_at":"2018-04-13T01:27:49Z","updated_at":"2018-04-13T01:27:49Z","author_association":"COLLABORATOR","body":"Pinging @elastic/es-search-aggs","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/381653913","html_url":"https://github.com/elastic/elasticsearch/issues/29470#issuecomment-381653913","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/29470","id":381653913,"node_id":"MDEyOklzc3VlQ29tbWVudDM4MTY1MzkxMw==","user":{"login":"polyfractal","id":1224228,"node_id":"MDQ6VXNlcjEyMjQyMjg=","avatar_url":"https://avatars1.githubusercontent.com/u/1224228?v=4","gravatar_id":"","url":"https://api.github.com/users/polyfractal","html_url":"https://github.com/polyfractal","followers_url":"https://api.github.com/users/polyfractal/followers","following_url":"https://api.github.com/users/polyfractal/following{/other_user}","gists_url":"https://api.github.com/users/polyfractal/gists{/gist_id}","starred_url":"https://api.github.com/users/polyfractal/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/polyfractal/subscriptions","organizations_url":"https://api.github.com/users/polyfractal/orgs","repos_url":"https://api.github.com/users/polyfractal/repos","events_url":"https://api.github.com/users/polyfractal/events{/privacy}","received_events_url":"https://api.github.com/users/polyfractal/received_events","type":"User","site_admin":false},"created_at":"2018-04-16T15:52:11Z","updated_at":"2018-04-16T15:52:11Z","author_association":"MEMBER","body":"Heya @alepuccetti.  I think this should be doable today with the existing DSL.  Let me know if you think these will work for you.  We'd prefer not to add this functionality if possible, since it opens up a big can of worms; if we add that functionality here, the case could be made that it be added to all other aggregations too.  Which increases the complexity of the change enormously.\r\n\r\nIt would also tend to be less efficient, since the include/exclude would need to be checked on each document rather than using Lucene's more efficient search methods.\r\n\r\nThere are three scenarios that I can think of, which should be doable today with the existing DSL:\r\n\r\n**Single-valued fields, filtering applies to entire aggregation**\r\nIf the terms you want to filter apply to the entire aggregation tree, you can perform the filtering in the query.  The aggregations are computed over the set of documents that match the query, so this will give you the cardinality just for that matching group.\r\n\r\nThis is also the most efficient, since the aggregation will only run on the matched documents:\r\n\r\n```js\r\n{\r\n  \"size\": 0,\r\n    \"query\": {\r\n    \"bool\": {\r\n      \"filter\": {\r\n        \"terms\": {\r\n          \"target_ids\": [ \"000\", \"111\",\"222\"]\r\n        }\r\n      }\r\n    }\r\n  },\r\n  \"aggs\": {\r\n    \"restricted_cardinality\": {\r\n      \"cardinality\": {\r\n        \"field\": \"target_ids\"\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n**Single-valued fields, filtering applies to subset of aggregation**\r\n\r\nIf you need the filtering to only apply to part of the aggregation, because other parts should remain unfiltered, you can use the `filter`/`filters` aggregation to isolate the scope:\r\n\r\n```js\r\n{\r\n  \"size\": 0,\r\n  \"aggs\": {\r\n    \"agg_filter\": {\r\n       \"filter\": { \"terms\": { \"target_ids\": [ \"000\", \"111\", \"222\"] } },\r\n       \"aggs\": {\r\n         \"restricted_cardinality\": {\r\n            \"cardinality\": {\r\n              \"field\": \"target_ids\"\r\n            }\r\n          }\r\n       }\r\n    },\r\n    \"unrelated_max\": {\r\n      \"max\": { \"field\": \"some_other_field\" }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nNote that the cardinality aggregation will be filtered to just documents that have those three tokens, while `unrelated_max` will calculate the max over all documents because it is outside of the `filter` aggregation\r\n\r\n**Multi-valued field**\r\n\r\nThe above two solutions work great if your fields are single-valued, but can be problematic if you have multi-valued fields (multiple values in each field).  A field may match the filter criteria, but since it has multiple values, the cardinality agg will pick all of those up even though only one matched the filter.\r\n\r\nIn that case, scripting support on the cardinality agg should work:\r\n\r\n```js\r\n\"restricted_cardinality\" : {\r\n  \"cardinality\" : {\r\n    \"script\": {\r\n      \"lang\": \"painless\",\r\n      \"source\": \"doc['target_ids'][0].value\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nThis allows you to select the specific value you care about, or loop over all the values to find the one that matches your filtering criteria.  Not quite as clean, but it should work.  This approach can be combined with either query filtering or agg filtering as appropriate.\r\n\r\nLet me know if this helps!","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/381662850","html_url":"https://github.com/elastic/elasticsearch/issues/29470#issuecomment-381662850","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/29470","id":381662850,"node_id":"MDEyOklzc3VlQ29tbWVudDM4MTY2Mjg1MA==","user":{"login":"alepuccetti","id":6577391,"node_id":"MDQ6VXNlcjY1NzczOTE=","avatar_url":"https://avatars1.githubusercontent.com/u/6577391?v=4","gravatar_id":"","url":"https://api.github.com/users/alepuccetti","html_url":"https://github.com/alepuccetti","followers_url":"https://api.github.com/users/alepuccetti/followers","following_url":"https://api.github.com/users/alepuccetti/following{/other_user}","gists_url":"https://api.github.com/users/alepuccetti/gists{/gist_id}","starred_url":"https://api.github.com/users/alepuccetti/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alepuccetti/subscriptions","organizations_url":"https://api.github.com/users/alepuccetti/orgs","repos_url":"https://api.github.com/users/alepuccetti/repos","events_url":"https://api.github.com/users/alepuccetti/events{/privacy}","received_events_url":"https://api.github.com/users/alepuccetti/received_events","type":"User","site_admin":false},"created_at":"2018-04-16T16:19:26Z","updated_at":"2018-04-16T16:19:26Z","author_association":"NONE","body":"@polyfractal Thanks for the explanation. I have clear the single-valued fields use cases filtering the aggregated value is neat but it is not quite what I am looking for.\r\nI did not quite get the multi-valued field solution you proposed `doc['target_ids'][0].value` will just retunr the first id in the list.\r\nI have already been down the road of `scripted_metric` but because the list of my ids could grow quite a lot (20k or more) I violate the max character lenght of the script.\r\n\r\nAnother way to see what I am try to do is to get back the number of ids the \"intersect\" with my include list and all the `target_ids` arrays that continat at least one of it.\r\nI opened a ticket aboout restricted cardinality becuase I tried to boil it down to the basic but I believe that this funtionality will help to solve more complex use cases such as array intersect.\r\nMaybe there is a better way to do that, I am open to any suggestion.\r\n\r\n\r\nI found a temporary workaround on this by using term aggregation and bucket script aggregation. I run a filter query + a terms aggregation with the include option filled with the same value in the filter and I use bucket script aggregation to return `_bucket_count`.\r\n\r\n```\r\nGET data/_search\r\n{\r\n  \"size\": 0, \r\n  \"query\": {\r\n    \"bool\": {\r\n      \"filter\": {\r\n        \"terms\": {\r\n          \"target_ids\": [\"000\", \"111\", \"222\"]\r\n        }\r\n      }\r\n    }\r\n  },\r\n  \"aggs\": {\r\n    \"bucket\": {\r\n      \"terms\": {\r\n        \"field\": \"ref_id\",\r\n        \"size\": 10\r\n      },\r\n      \"aggs\": {\r\n        \"metric\": {\r\n          \"terms\": {\r\n            \"field\": \"target_ids\",\r\n            \"include\": [\"000\", \"111\", \"222\"], \r\n            \"size\": 3\r\n          }\r\n        },\r\n        \"intersect\": {\r\n          \"bucket_script\": {\r\n            \"buckets_path\": {\r\n              \"size\": \"metric._bucket_count\"\r\n            },\r\n            \"script\": \"params.size\"\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nFor full disclousre I am try to make a nice way to return the value to Kibana doing this via the API, I agree, it is not that complicate.\r\n\r\nI opened a thread on discuss too https://discuss.elastic.co/t/array-intersection-metric/127117/5\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/381685642","html_url":"https://github.com/elastic/elasticsearch/issues/29470#issuecomment-381685642","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/29470","id":381685642,"node_id":"MDEyOklzc3VlQ29tbWVudDM4MTY4NTY0Mg==","user":{"login":"polyfractal","id":1224228,"node_id":"MDQ6VXNlcjEyMjQyMjg=","avatar_url":"https://avatars1.githubusercontent.com/u/1224228?v=4","gravatar_id":"","url":"https://api.github.com/users/polyfractal","html_url":"https://github.com/polyfractal","followers_url":"https://api.github.com/users/polyfractal/followers","following_url":"https://api.github.com/users/polyfractal/following{/other_user}","gists_url":"https://api.github.com/users/polyfractal/gists{/gist_id}","starred_url":"https://api.github.com/users/polyfractal/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/polyfractal/subscriptions","organizations_url":"https://api.github.com/users/polyfractal/orgs","repos_url":"https://api.github.com/users/polyfractal/repos","events_url":"https://api.github.com/users/polyfractal/events{/privacy}","received_events_url":"https://api.github.com/users/polyfractal/received_events","type":"User","site_admin":false},"created_at":"2018-04-16T17:30:20Z","updated_at":"2018-04-16T17:30:20Z","author_association":"MEMBER","body":"Thanks for the discuss link, that helped with background context.\r\n\r\nBased on that workaround example you give, the value of `\"intersect\"` aggregation will be a value from 0 to 3.  Since you said `target_ids` field is single-valued, and you're filtering for certain values in the query, those are the only options, so the `metric` terms agg can have at most 3 buckets.\r\n\r\nIf that's the case, you could do this:\r\n\r\n```js\r\nGET data/_search\r\n{\r\n  \"size\": 0, \r\n  \"query\": {\r\n    \"bool\": {\r\n      \"filter\": {\r\n        \"terms\": {\r\n          \"target_ids\": [\"000\", \"111\", \"222\"]\r\n        }\r\n      }\r\n    }\r\n  },\r\n  \"aggs\": {\r\n    \"bucket\": {\r\n      \"terms\": {\r\n        \"field\": \"ref_id\",\r\n        \"size\": 10\r\n      },\r\n      \"aggs\": {\r\n        \"restricted_cardinality\": {\r\n          \"cardinality\": {\r\n            \"field\": \"target_ids\"\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nThat will give you the cardinality of `target_ids` for each `ref_id`.  And because the fields are all single-valued, and pre-filtered, you know that the cardinality will only be counting the values of a limited subset (some combination of `[\"000\", \"111\", \"222\"]`, or none at all).\r\n\r\nI think that's equivalent, but much cleaner since it's using the cardinality agg instead of counting buckets.\r\n\r\n> I did not quite get the multi-valued field solution you proposed doc['target_ids'][0].value will just retunr the first id in the list.\r\n\r\nSorry, it wasn't a complete example... I was just writing out a quick script to say that scripting is possible.  An actual script to check multi-values would be more extensive :)","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/381933691","html_url":"https://github.com/elastic/elasticsearch/issues/29470#issuecomment-381933691","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/29470","id":381933691,"node_id":"MDEyOklzc3VlQ29tbWVudDM4MTkzMzY5MQ==","user":{"login":"alepuccetti","id":6577391,"node_id":"MDQ6VXNlcjY1NzczOTE=","avatar_url":"https://avatars1.githubusercontent.com/u/6577391?v=4","gravatar_id":"","url":"https://api.github.com/users/alepuccetti","html_url":"https://github.com/alepuccetti","followers_url":"https://api.github.com/users/alepuccetti/followers","following_url":"https://api.github.com/users/alepuccetti/following{/other_user}","gists_url":"https://api.github.com/users/alepuccetti/gists{/gist_id}","starred_url":"https://api.github.com/users/alepuccetti/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alepuccetti/subscriptions","organizations_url":"https://api.github.com/users/alepuccetti/orgs","repos_url":"https://api.github.com/users/alepuccetti/repos","events_url":"https://api.github.com/users/alepuccetti/events{/privacy}","received_events_url":"https://api.github.com/users/alepuccetti/received_events","type":"User","site_admin":false},"created_at":"2018-04-17T10:10:28Z","updated_at":"2018-04-17T10:10:45Z","author_association":"NONE","body":"@polyfractal \r\n> Since you said target_ids field is single-valued\r\n\r\nProbably I did not explain me very well. `target_ids` is a multi-valued field. This is why cardinality will not work. It will count also values not in the filter.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/383544068","html_url":"https://github.com/elastic/elasticsearch/issues/29470#issuecomment-383544068","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/29470","id":383544068,"node_id":"MDEyOklzc3VlQ29tbWVudDM4MzU0NDA2OA==","user":{"login":"polyfractal","id":1224228,"node_id":"MDQ6VXNlcjEyMjQyMjg=","avatar_url":"https://avatars1.githubusercontent.com/u/1224228?v=4","gravatar_id":"","url":"https://api.github.com/users/polyfractal","html_url":"https://github.com/polyfractal","followers_url":"https://api.github.com/users/polyfractal/followers","following_url":"https://api.github.com/users/polyfractal/following{/other_user}","gists_url":"https://api.github.com/users/polyfractal/gists{/gist_id}","starred_url":"https://api.github.com/users/polyfractal/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/polyfractal/subscriptions","organizations_url":"https://api.github.com/users/polyfractal/orgs","repos_url":"https://api.github.com/users/polyfractal/repos","events_url":"https://api.github.com/users/polyfractal/events{/privacy}","received_events_url":"https://api.github.com/users/polyfractal/received_events","type":"User","site_admin":false},"created_at":"2018-04-23T11:32:46Z","updated_at":"2018-04-23T11:32:46Z","author_association":"MEMBER","body":"@alepuccetti Ah I see, that does complicate things.  I think this can still be done via a script, but not sure how gross it will be.  Let me play around a little to see the best way to do it, and maybe we can put it back up fro discussion with the search team to see about a feature enhancement if it turns out to be too difficult.\r\n\r\nRegarding your bucket_script example, that's actually a very good solution (and one I was going to suggest), with the caveat that the terms agg should remain small.  I noticed in your discuss post that you said there were thousands of `target_ids`, which will make the terms agg difficult to use.  It is optimized for smaller \"top n\" situations, not returning all the terms.  You may run into performance or memory issues with that route.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/383549979","html_url":"https://github.com/elastic/elasticsearch/issues/29470#issuecomment-383549979","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/29470","id":383549979,"node_id":"MDEyOklzc3VlQ29tbWVudDM4MzU0OTk3OQ==","user":{"login":"alepuccetti","id":6577391,"node_id":"MDQ6VXNlcjY1NzczOTE=","avatar_url":"https://avatars1.githubusercontent.com/u/6577391?v=4","gravatar_id":"","url":"https://api.github.com/users/alepuccetti","html_url":"https://github.com/alepuccetti","followers_url":"https://api.github.com/users/alepuccetti/followers","following_url":"https://api.github.com/users/alepuccetti/following{/other_user}","gists_url":"https://api.github.com/users/alepuccetti/gists{/gist_id}","starred_url":"https://api.github.com/users/alepuccetti/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alepuccetti/subscriptions","organizations_url":"https://api.github.com/users/alepuccetti/orgs","repos_url":"https://api.github.com/users/alepuccetti/repos","events_url":"https://api.github.com/users/alepuccetti/events{/privacy}","received_events_url":"https://api.github.com/users/alepuccetti/received_events","type":"User","site_admin":false},"created_at":"2018-04-23T11:58:52Z","updated_at":"2018-04-23T11:58:52Z","author_association":"NONE","body":"> maybe we can put it back up fro discussion with the search team to see about a feature enhancement if it turns out to be too difficult.\r\n\r\n@polyfractal I am happy to contribute to the discussion. Mine is just a use case, an extreme one, but I believe that this could provide some great out-of-the-box feature.\r\nhaving a way to get back the \"intersect cardinality\" with a given input array seems very interesting in general.\r\n\r\n> with the caveat that the terms agg should remain small\r\n\r\nUnfortunately, I need to set the aggregation size to the number of the ids in the include. I am running performance tests. I am open to other ideas.\r\n\r\n> I noticed in your discuss post that you said there were thousands of target_ids, which will make the terms agg difficult to use. It is optimized for smaller \"top n\" situations, not returning all the terms.\r\n\r\nThis was the workaround but I know it is not the best (or the supposed) usage of terms aggregation.\r\nIn fact, the term aggregation on `target_ids` it is a trick to get back the number of ids ( value between 0 and the number of ids in the include). Also, it has the downside that sorting cannot be performed on the bucket_script metric. I am using doc count as an approximation.\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/384785030","html_url":"https://github.com/elastic/elasticsearch/issues/29470#issuecomment-384785030","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/29470","id":384785030,"node_id":"MDEyOklzc3VlQ29tbWVudDM4NDc4NTAzMA==","user":{"login":"colings86","id":236731,"node_id":"MDQ6VXNlcjIzNjczMQ==","avatar_url":"https://avatars0.githubusercontent.com/u/236731?v=4","gravatar_id":"","url":"https://api.github.com/users/colings86","html_url":"https://github.com/colings86","followers_url":"https://api.github.com/users/colings86/followers","following_url":"https://api.github.com/users/colings86/following{/other_user}","gists_url":"https://api.github.com/users/colings86/gists{/gist_id}","starred_url":"https://api.github.com/users/colings86/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/colings86/subscriptions","organizations_url":"https://api.github.com/users/colings86/orgs","repos_url":"https://api.github.com/users/colings86/repos","events_url":"https://api.github.com/users/colings86/events{/privacy}","received_events_url":"https://api.github.com/users/colings86/received_events","type":"User","site_admin":false},"created_at":"2018-04-26T20:51:34Z","updated_at":"2018-04-26T20:51:34Z","author_association":"MEMBER","body":"@alepuccetti the problem here is that the cardinality aggregation is designed to be used with cardinalities which are not practical to be stored in a HashSet. Providing a list of items to include or exclude is at odds with this since the expectation is that the include/exclude list could be similarly large so would not fit well with a HashSet/List. For this reason we do not think this would be something we'd want to pursue. ","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/384890440","html_url":"https://github.com/elastic/elasticsearch/issues/29470#issuecomment-384890440","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/29470","id":384890440,"node_id":"MDEyOklzc3VlQ29tbWVudDM4NDg5MDQ0MA==","user":{"login":"alepuccetti","id":6577391,"node_id":"MDQ6VXNlcjY1NzczOTE=","avatar_url":"https://avatars1.githubusercontent.com/u/6577391?v=4","gravatar_id":"","url":"https://api.github.com/users/alepuccetti","html_url":"https://github.com/alepuccetti","followers_url":"https://api.github.com/users/alepuccetti/followers","following_url":"https://api.github.com/users/alepuccetti/following{/other_user}","gists_url":"https://api.github.com/users/alepuccetti/gists{/gist_id}","starred_url":"https://api.github.com/users/alepuccetti/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alepuccetti/subscriptions","organizations_url":"https://api.github.com/users/alepuccetti/orgs","repos_url":"https://api.github.com/users/alepuccetti/repos","events_url":"https://api.github.com/users/alepuccetti/events{/privacy}","received_events_url":"https://api.github.com/users/alepuccetti/received_events","type":"User","site_admin":false},"created_at":"2018-04-27T07:35:01Z","updated_at":"2018-04-27T07:35:01Z","author_association":"NONE","body":"@colings86 Thank you for the explanation.\r\nI do not know the underline implementation of cardinality operation but I thought that knowing beforehand the element on which compute the cardinality could be a good thing. The include/exclude lists would be just a filter and that the cardinality function will check before update the count.\r\n\r\nI have a workaround but it is not precise and has a lot of limitations, I will keep looking for a better solution.","performed_via_github_app":null}]