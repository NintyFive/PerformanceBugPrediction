{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/6252","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/6252/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/6252/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/6252/events","html_url":"https://github.com/elastic/elasticsearch/issues/6252","id":33960959,"node_id":"MDU6SXNzdWUzMzk2MDk1OQ==","number":6252,"title":"Benchmark API might miss not yet starting benchmark in unabortable state","user":{"login":"s1monw","id":973334,"node_id":"MDQ6VXNlcjk3MzMzNA==","avatar_url":"https://avatars0.githubusercontent.com/u/973334?v=4","gravatar_id":"","url":"https://api.github.com/users/s1monw","html_url":"https://github.com/s1monw","followers_url":"https://api.github.com/users/s1monw/followers","following_url":"https://api.github.com/users/s1monw/following{/other_user}","gists_url":"https://api.github.com/users/s1monw/gists{/gist_id}","starred_url":"https://api.github.com/users/s1monw/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/s1monw/subscriptions","organizations_url":"https://api.github.com/users/s1monw/orgs","repos_url":"https://api.github.com/users/s1monw/repos","events_url":"https://api.github.com/users/s1monw/events{/privacy}","received_events_url":"https://api.github.com/users/s1monw/received_events","type":"User","site_admin":false},"labels":[{"id":92913730,"node_id":"MDU6TGFiZWw5MjkxMzczMA==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/critical","name":"critical","color":"eb6420","default":false,"description":null},{"id":113234020,"node_id":"MDU6TGFiZWwxMTMyMzQwMjA=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/stalled","name":"stalled","color":"fef2c0","default":false,"description":null}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":1,"created_at":"2014-05-21T08:15:35Z","updated_at":"2015-08-26T14:59:48Z","closed_at":"2015-08-26T14:59:48Z","author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"Today there is a race condition in how we handle the benchmark state that allows for benchmarks to be kicked off without the ability to abort them again. The main reason for this is that the state handling is flawed since applying the state is not serializable in a way that the executing nodes knows if a benchmark that is marked as `running` has been aborted. The abort call simply tires to stop the benchmark and if it's not in the executing nodes datastructure due to some sort of a delay or an exhausted threadpool it just ignores it. At that point the benchmark state is already updated in the cluster state and can not be aborted again.  \n\nThe solution to this is a bigger change though. We should move to cluster state listeners instead of per node RPC calls just like Snapshot & Restore works\n","closed_by":{"login":"jpountz","id":299848,"node_id":"MDQ6VXNlcjI5OTg0OA==","avatar_url":"https://avatars2.githubusercontent.com/u/299848?v=4","gravatar_id":"","url":"https://api.github.com/users/jpountz","html_url":"https://github.com/jpountz","followers_url":"https://api.github.com/users/jpountz/followers","following_url":"https://api.github.com/users/jpountz/following{/other_user}","gists_url":"https://api.github.com/users/jpountz/gists{/gist_id}","starred_url":"https://api.github.com/users/jpountz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jpountz/subscriptions","organizations_url":"https://api.github.com/users/jpountz/orgs","repos_url":"https://api.github.com/users/jpountz/repos","events_url":"https://api.github.com/users/jpountz/events{/privacy}","received_events_url":"https://api.github.com/users/jpountz/received_events","type":"User","site_admin":false},"performed_via_github_app":null}