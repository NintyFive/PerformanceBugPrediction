[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/428901717","html_url":"https://github.com/elastic/elasticsearch/issues/34396#issuecomment-428901717","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/34396","id":428901717,"node_id":"MDEyOklzc3VlQ29tbWVudDQyODkwMTcxNw==","user":{"login":"elasticmachine","id":15837671,"node_id":"MDQ6VXNlcjE1ODM3Njcx","avatar_url":"https://avatars3.githubusercontent.com/u/15837671?v=4","gravatar_id":"","url":"https://api.github.com/users/elasticmachine","html_url":"https://github.com/elasticmachine","followers_url":"https://api.github.com/users/elasticmachine/followers","following_url":"https://api.github.com/users/elasticmachine/following{/other_user}","gists_url":"https://api.github.com/users/elasticmachine/gists{/gist_id}","starred_url":"https://api.github.com/users/elasticmachine/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/elasticmachine/subscriptions","organizations_url":"https://api.github.com/users/elasticmachine/orgs","repos_url":"https://api.github.com/users/elasticmachine/repos","events_url":"https://api.github.com/users/elasticmachine/events{/privacy}","received_events_url":"https://api.github.com/users/elasticmachine/received_events","type":"User","site_admin":false},"created_at":"2018-10-11T10:17:57Z","updated_at":"2018-10-11T10:17:57Z","author_association":"COLLABORATOR","body":"Pinging @elastic/es-security","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/431037632","html_url":"https://github.com/elastic/elasticsearch/issues/34396#issuecomment-431037632","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/34396","id":431037632,"node_id":"MDEyOklzc3VlQ29tbWVudDQzMTAzNzYzMg==","user":{"login":"alexbrasetvik","id":43624,"node_id":"MDQ6VXNlcjQzNjI0","avatar_url":"https://avatars0.githubusercontent.com/u/43624?v=4","gravatar_id":"","url":"https://api.github.com/users/alexbrasetvik","html_url":"https://github.com/alexbrasetvik","followers_url":"https://api.github.com/users/alexbrasetvik/followers","following_url":"https://api.github.com/users/alexbrasetvik/following{/other_user}","gists_url":"https://api.github.com/users/alexbrasetvik/gists{/gist_id}","starred_url":"https://api.github.com/users/alexbrasetvik/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alexbrasetvik/subscriptions","organizations_url":"https://api.github.com/users/alexbrasetvik/orgs","repos_url":"https://api.github.com/users/alexbrasetvik/repos","events_url":"https://api.github.com/users/alexbrasetvik/events{/privacy}","received_events_url":"https://api.github.com/users/alexbrasetvik/received_events","type":"User","site_admin":false},"created_at":"2018-10-18T14:46:32Z","updated_at":"2018-10-18T14:46:32Z","author_association":"CONTRIBUTOR","body":"Some of the material here might be of interest: https://docs.google.com/presentation/d/1ko8xveyspZsZ6RWcXwHizPnt3R1EAGFdV__a2ZTGUDM/edit?usp=sharing","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/476047057","html_url":"https://github.com/elastic/elasticsearch/issues/34396#issuecomment-476047057","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/34396","id":476047057,"node_id":"MDEyOklzc3VlQ29tbWVudDQ3NjA0NzA1Nw==","user":{"login":"tvernum","id":2244393,"node_id":"MDQ6VXNlcjIyNDQzOTM=","avatar_url":"https://avatars0.githubusercontent.com/u/2244393?v=4","gravatar_id":"","url":"https://api.github.com/users/tvernum","html_url":"https://github.com/tvernum","followers_url":"https://api.github.com/users/tvernum/followers","following_url":"https://api.github.com/users/tvernum/following{/other_user}","gists_url":"https://api.github.com/users/tvernum/gists{/gist_id}","starred_url":"https://api.github.com/users/tvernum/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/tvernum/subscriptions","organizations_url":"https://api.github.com/users/tvernum/orgs","repos_url":"https://api.github.com/users/tvernum/repos","events_url":"https://api.github.com/users/tvernum/events{/privacy}","received_events_url":"https://api.github.com/users/tvernum/received_events","type":"User","site_admin":false},"created_at":"2019-03-25T03:58:58Z","updated_at":"2019-03-25T03:58:58Z","author_association":"CONTRIBUTOR","body":"> The client connection proxying the certificate must be authenticated using PKI\r\n\r\nDo we specifically mean that it must use the PKI realm, or simply that it must have a validated client certificate? ","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/476332090","html_url":"https://github.com/elastic/elasticsearch/issues/34396#issuecomment-476332090","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/34396","id":476332090,"node_id":"MDEyOklzc3VlQ29tbWVudDQ3NjMzMjA5MA==","user":{"login":"jaymode","id":4339958,"node_id":"MDQ6VXNlcjQzMzk5NTg=","avatar_url":"https://avatars1.githubusercontent.com/u/4339958?v=4","gravatar_id":"","url":"https://api.github.com/users/jaymode","html_url":"https://github.com/jaymode","followers_url":"https://api.github.com/users/jaymode/followers","following_url":"https://api.github.com/users/jaymode/following{/other_user}","gists_url":"https://api.github.com/users/jaymode/gists{/gist_id}","starred_url":"https://api.github.com/users/jaymode/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jaymode/subscriptions","organizations_url":"https://api.github.com/users/jaymode/orgs","repos_url":"https://api.github.com/users/jaymode/repos","events_url":"https://api.github.com/users/jaymode/events{/privacy}","received_events_url":"https://api.github.com/users/jaymode/received_events","type":"User","site_admin":false},"created_at":"2019-03-25T18:54:01Z","updated_at":"2019-03-25T18:54:01Z","author_association":"MEMBER","body":"> Do we specifically mean that it must use the PKI realm, or simply that it must have a validated client certificate?\r\n\r\nMy initial thought was that we should require the connection to be authenticated with the PKI Realm and the proxied client certificate should be authenticated with the PKI realm as well. Upon further thought, I do not feel that aspect is a hard requirement. I think the following should be properties that we keep though:\r\n\r\n* the connection from the proxying app has authentication\r\n* the authenticated user from the proxying app needs to be authorized to proxy the certificate","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/498216685","html_url":"https://github.com/elastic/elasticsearch/issues/34396#issuecomment-498216685","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/34396","id":498216685,"node_id":"MDEyOklzc3VlQ29tbWVudDQ5ODIxNjY4NQ==","user":{"login":"albertzaharovits","id":4568420,"node_id":"MDQ6VXNlcjQ1Njg0MjA=","avatar_url":"https://avatars2.githubusercontent.com/u/4568420?v=4","gravatar_id":"","url":"https://api.github.com/users/albertzaharovits","html_url":"https://github.com/albertzaharovits","followers_url":"https://api.github.com/users/albertzaharovits/followers","following_url":"https://api.github.com/users/albertzaharovits/following{/other_user}","gists_url":"https://api.github.com/users/albertzaharovits/gists{/gist_id}","starred_url":"https://api.github.com/users/albertzaharovits/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/albertzaharovits/subscriptions","organizations_url":"https://api.github.com/users/albertzaharovits/orgs","repos_url":"https://api.github.com/users/albertzaharovits/repos","events_url":"https://api.github.com/users/albertzaharovits/events{/privacy}","received_events_url":"https://api.github.com/users/albertzaharovits/received_events","type":"User","site_admin":false},"created_at":"2019-06-03T11:19:28Z","updated_at":"2019-06-03T11:20:53Z","author_association":"CONTRIBUTOR","body":"The description above is of a variant of `run-as` functionality; there is one authenticated client (kibana) that authorizes as another principal. We already have the privilege model to define which principals can authorize as which one (the `run_as` privilege). The way to convey the authorization principal is through the `es-security-runas-user` HTTP header.\r\nTherefore, one option is to extend the existing `run_as` functionality to make it work in the case that the authorization principal is defined by a X509v3 certificate. There are de-facto standards to convey the client certificate (or fields of it) from the proxy (kibana) to the service provider (elasticsearch); eg the `X-SSL-CERT` family of headers of *nginx*.\r\n\r\nImplementation hurdles:\r\n* there are possibly multiple identities bound to the certificate; we need to build capabilities into ES that allow the administrator to define THE way to parse out the principal.\r\n* if we wish to allow extracting the principal in terms of the client's trusted certificate **chain** it will become very complex; not least because passing cert chains using the de-facto headers is not available.\r\n\r\nQualms:\r\n* Kibana is more than a proxy doing authentication as part of the TLS termination. Kibana does many more requests to ES for a single incoming request; there is also the notion of background jobs running *as* the user. Therefore we would be stretching the `X-SSL-CERT` outside the de-facto use case (there is no inherent security problem with that, but if we go with a standard practice let's follow the use case the practice is used for, otherwise find another standard).\r\n\r\nNote that this alternative will not add or extend any authentication realm, it will extend an authorization feature (the `run_as` impersonation).\r\n\r\n**Another alternative** is to create a new API that implements the delegation functionality of the PKI realm. In ES we broadly have two types of realms, the ones that validate secrets, such as passwords, and realms that consume authentication statements from third party services (SAML, OIDC, Kerberos). The latter do not do authentication but validate an authentication statement (claims, tickets). Upon successful validation, ES issues a token usable by kibana to authorize as the user in the claims/ticket.\r\n\r\nIn this proposal ES will be validating the certificate chain of the client that connected over TLS to kibana and afterwards will emit a token to be used by kibana to authorize as the user. Kibana then stores the token on the client as a cookie, and forwards it to ES as a header.\r\n\r\nImplementation hurdles:\r\n* The same problem with extracting a principal from a certificate chain on the ES side.\r\n* Kibana has to make sure the token in the cookie is associated with the current TLS client certificate; The underlying TLS connection can change without a proper logout ceremony. Kibana has to detect that the token in the cookie was issue for a different client certificate than the currently used one (after a new TLS handshake) and re-request a new token.\r\n\r\nQualms:\r\n* Certificate chains may look like signed assertions of identity, but they lack the crucial short time validity. Without a limited lifetime, the cert chain used as an identity assertion provides little guarantees. Therefore, this is not a true realm, offering a false sense of security (unusable outside Kibbana) and relying on Kibana to validate the association of the secret private key with the certificate (during TLS termination).\r\n\r\n**Another alternative** is to completely delegate authentication to Kibana, including parsing of the principal. This is a variant of the first alternative. In this way there is little to do on the ES side, but do the role-mapping to the principal (basically `run-as` with the option to not lookup the user). The principal can be conveyed to ES via headers (`X-SSL-CERT` friends) or fancy JWT tokens. Both of these require TLS between Kibana and ES. The only narrow advantage of JWT is the ability to communicate more complex attributes about the user that can be utilized in role mappings.\r\n\r\nRFC @elastic/es-security @elastic/kibana-security ","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/498362695","html_url":"https://github.com/elastic/elasticsearch/issues/34396#issuecomment-498362695","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/34396","id":498362695,"node_id":"MDEyOklzc3VlQ29tbWVudDQ5ODM2MjY5NQ==","user":{"login":"albertzaharovits","id":4568420,"node_id":"MDQ6VXNlcjQ1Njg0MjA=","avatar_url":"https://avatars2.githubusercontent.com/u/4568420?v=4","gravatar_id":"","url":"https://api.github.com/users/albertzaharovits","html_url":"https://github.com/albertzaharovits","followers_url":"https://api.github.com/users/albertzaharovits/followers","following_url":"https://api.github.com/users/albertzaharovits/following{/other_user}","gists_url":"https://api.github.com/users/albertzaharovits/gists{/gist_id}","starred_url":"https://api.github.com/users/albertzaharovits/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/albertzaharovits/subscriptions","organizations_url":"https://api.github.com/users/albertzaharovits/orgs","repos_url":"https://api.github.com/users/albertzaharovits/repos","events_url":"https://api.github.com/users/albertzaharovits/events{/privacy}","received_events_url":"https://api.github.com/users/albertzaharovits/received_events","type":"User","site_admin":false},"created_at":"2019-06-03T18:01:07Z","updated_at":"2019-06-03T18:01:07Z","author_association":"CONTRIBUTOR","body":"When discussing options, I propose we argue about what the considered option is bringing over simply using the existing `run-as` ES feature.\r\n\r\nI will shortly describe the setup with `run-as`, and let us consider this as the baseline implementation.\r\n\r\nKibana does TLS termination and parses the principal out of the DN in the `Subject` attribute of the client's certificate and then forwards that principal value in the `es-security-runas-user` header to ES.\r\nKibana has to make sure that the header value of every request to ES reflects truthfully the client cert on the TLS session between the client and Kibana. Similarly to ES's PKI realm, Kibana should permit the configuration of additional truststores that must validate the client cert, in addition to the HTTP layer validation. There ought to be mandatory TLS between Kibana and ES. ES is not aware that Kibana validates PKI certs (eg in audit logs) but can do the LDAP lookup of the principal by rebuilding the DN with the rules of the individual LDAP realms. ES also has to be configured to permit `run_as` for the Kibana principal\r\n\r\nI believe this satisfies most of the requirements, and I would suggest we go with this. Alternatively, let us find compelling use cases not satisfied by this setup to motivate implementation variations suggested in https://github.com/elastic/elasticsearch/issues/34396#issuecomment-498216685.\r\n\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/498388057","html_url":"https://github.com/elastic/elasticsearch/issues/34396#issuecomment-498388057","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/34396","id":498388057,"node_id":"MDEyOklzc3VlQ29tbWVudDQ5ODM4ODA1Nw==","user":{"login":"kobelb","id":627123,"node_id":"MDQ6VXNlcjYyNzEyMw==","avatar_url":"https://avatars0.githubusercontent.com/u/627123?v=4","gravatar_id":"","url":"https://api.github.com/users/kobelb","html_url":"https://github.com/kobelb","followers_url":"https://api.github.com/users/kobelb/followers","following_url":"https://api.github.com/users/kobelb/following{/other_user}","gists_url":"https://api.github.com/users/kobelb/gists{/gist_id}","starred_url":"https://api.github.com/users/kobelb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/kobelb/subscriptions","organizations_url":"https://api.github.com/users/kobelb/orgs","repos_url":"https://api.github.com/users/kobelb/repos","events_url":"https://api.github.com/users/kobelb/events{/privacy}","received_events_url":"https://api.github.com/users/kobelb/received_events","type":"User","site_admin":false},"created_at":"2019-06-03T19:13:07Z","updated_at":"2019-06-03T22:16:07Z","author_association":"CONTRIBUTOR","body":"Previous discussion about allowing Kibana to utilize the `run-as` header have ended with us deciding that we shouldn't grant this privilege to the `kibana_system` role because of the security ramifications. If I understand correctly, the other solutions which have been proposed don't require the relaxing of this consideration, and prevent Kibana from being able to \"run as\" arbitrary users.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/498409078","html_url":"https://github.com/elastic/elasticsearch/issues/34396#issuecomment-498409078","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/34396","id":498409078,"node_id":"MDEyOklzc3VlQ29tbWVudDQ5ODQwOTA3OA==","user":{"login":"albertzaharovits","id":4568420,"node_id":"MDQ6VXNlcjQ1Njg0MjA=","avatar_url":"https://avatars2.githubusercontent.com/u/4568420?v=4","gravatar_id":"","url":"https://api.github.com/users/albertzaharovits","html_url":"https://github.com/albertzaharovits","followers_url":"https://api.github.com/users/albertzaharovits/followers","following_url":"https://api.github.com/users/albertzaharovits/following{/other_user}","gists_url":"https://api.github.com/users/albertzaharovits/gists{/gist_id}","starred_url":"https://api.github.com/users/albertzaharovits/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/albertzaharovits/subscriptions","organizations_url":"https://api.github.com/users/albertzaharovits/orgs","repos_url":"https://api.github.com/users/albertzaharovits/repos","events_url":"https://api.github.com/users/albertzaharovits/events{/privacy}","received_events_url":"https://api.github.com/users/albertzaharovits/received_events","type":"User","site_admin":false},"created_at":"2019-06-03T20:15:03Z","updated_at":"2019-06-03T20:15:03Z","author_association":"CONTRIBUTOR","body":"It does not have to be the `kibana_system` the principal that `run_as`; it could be some dedicated user that is configured on ES to `run_as` as a defined set of users. The username and the ES privilege could be made part of the configuration procedure.\r\n\r\nBut, in essence, the issue remains: We have to trust Kibana with forwarding the identity of the client, because the client cannot offer ES any proofs. We trust that Kibana keeps its keypair for TLS to ES a secret. ","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/498737083","html_url":"https://github.com/elastic/elasticsearch/issues/34396#issuecomment-498737083","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/34396","id":498737083,"node_id":"MDEyOklzc3VlQ29tbWVudDQ5ODczNzA4Mw==","user":{"login":"jkakavas","id":10281256,"node_id":"MDQ6VXNlcjEwMjgxMjU2","avatar_url":"https://avatars2.githubusercontent.com/u/10281256?v=4","gravatar_id":"","url":"https://api.github.com/users/jkakavas","html_url":"https://github.com/jkakavas","followers_url":"https://api.github.com/users/jkakavas/followers","following_url":"https://api.github.com/users/jkakavas/following{/other_user}","gists_url":"https://api.github.com/users/jkakavas/gists{/gist_id}","starred_url":"https://api.github.com/users/jkakavas/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jkakavas/subscriptions","organizations_url":"https://api.github.com/users/jkakavas/orgs","repos_url":"https://api.github.com/users/jkakavas/repos","events_url":"https://api.github.com/users/jkakavas/events{/privacy}","received_events_url":"https://api.github.com/users/jkakavas/received_events","type":"User","site_admin":false},"created_at":"2019-06-04T16:06:00Z","updated_at":"2019-06-04T16:06:00Z","author_association":"CONTRIBUTOR","body":"A few comments for now to hopefully help the discussion forward, I'm not sure I've reached a conclusion yet as to what I prefer from the given options: \r\n\r\n> there are possibly multiple identities bound to the certificate; we need to build capabilities into ES that allow the administrator to define THE way to parse out the principal.\r\n\r\nCan you elaborate ? Client certificates will have 1 subject. I get the point about parsing (CN/DNs/emails) but not the multiple identities one.  \r\n\r\n> It does not have to be the kibana_system the principal that run_as; it could be some dedicated user\r\n\r\nThe actual threat would remain though. Someone with access to Kibana (and thus to this user's credentials) will be allowed to `run_as` arbitrary users. \r\n\r\n> that is configured on ES to `run_as` as a defined set of users\r\n\r\nThis is tricky. Wouldn't that mean that setting up PKI in Kibana would require you to know up front all your users that might authenticate with a client certificate/key and pre-configure ES to allow the service user with `run_as` as any of these? \r\n\r\n>  We trust that Kibana keeps its keypair for TLS to ES a secret.\r\n\r\nDo you mean that we should require TLS mutual authentication from Kibana to ES ? What would the benefit be for this to be a strict requirement ? Or could the same be said for kibana/service user credentials ? \r\n\r\n> But, in essence, the issue remains: We have to trust Kibana with forwarding the identity of the client, because the client cannot offer ES any proofs. \r\n\r\nThe difference is that in the `run_as` with `es-security-runas-user` approach, if that trust is breached, then a malicious user can impersonate any ES native user. \r\n\r\nIf, alternatively, we have Kibana only validate that the user who authenticated has access to the private key that corresponds to this certificate, and ES verify the certificate based on its configuration, a malicious user with access to Kibana would also need to forge a certificate from a CA that ES trusts ( as ES will still validate the certificate signature ) or steal the client certificate from a user. Given that client certificates are not meant to be secret, this is not a huge mitigation factor, but people don't usually publish their client certs. \r\n\r\n> Certificate chains may look like signed assertions of identity, but they lack the crucial short time validity. Without a limited lifetime, the cert chain used as an identity assertion provides little guarantees. Therefore, this is not a true realm, offering a false sense of security \r\n\r\nI'm not sure I agree with this. The lack of short time validity is potentially missing from all client certificates - not relavant to this implementation aspect only - and, still, these are widely used for authentication. There are even PKI setups/deployments that issue short lived certificates on demand when they are used for client authentication.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/498954490","html_url":"https://github.com/elastic/elasticsearch/issues/34396#issuecomment-498954490","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/34396","id":498954490,"node_id":"MDEyOklzc3VlQ29tbWVudDQ5ODk1NDQ5MA==","user":{"login":"tvernum","id":2244393,"node_id":"MDQ6VXNlcjIyNDQzOTM=","avatar_url":"https://avatars0.githubusercontent.com/u/2244393?v=4","gravatar_id":"","url":"https://api.github.com/users/tvernum","html_url":"https://github.com/tvernum","followers_url":"https://api.github.com/users/tvernum/followers","following_url":"https://api.github.com/users/tvernum/following{/other_user}","gists_url":"https://api.github.com/users/tvernum/gists{/gist_id}","starred_url":"https://api.github.com/users/tvernum/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/tvernum/subscriptions","organizations_url":"https://api.github.com/users/tvernum/orgs","repos_url":"https://api.github.com/users/tvernum/repos","events_url":"https://api.github.com/users/tvernum/events{/privacy}","received_events_url":"https://api.github.com/users/tvernum/received_events","type":"User","site_admin":false},"created_at":"2019-06-05T06:23:39Z","updated_at":"2019-06-05T06:23:39Z","author_association":"CONTRIBUTOR","body":"Thanks @albertzaharovits, that's a very clear write up.\r\n \r\nDisclosure: I still prefer the option _to create a new API that implements the delegation functionality of the PKI realm_, but I'm open to changing my mind.\r\n\r\n>there are possibly multiple identities bound to the certificate; we need to build capabilities into ES that allow the administrator to define THE way to parse out the principal\r\n\r\n> The same problem with extracting a principal from a certificate chain on the ES side.\r\n\r\nWe already have a way to do this in PKI realms (a regex on the DN). It's simple, but has not (so far) been an issue.\r\nFor me this is an argument in favour of a _delegated PKI realm_. If we want to improve our certificate-to-user implementation then we just do it in the PKI realm and it would be available for both Kibana and ES terminated TLS. I don't think we want to have multiple ways to solve the same underlying problem of extracting an ES-capable user identity from a certificate.\r\n\r\n> Note that this alternative will not add or extend any authentication realm\r\n\r\nThis for me is actually a negative (but it is a design choice that we could change).\r\nIdentity & Authentication in Elasticsearch is based on realms. Here we have a pseudo-authentication mechanism (pseudo in that it doesn't happen within Elasticsearch itself, but it does take place within the Elastic Stack) that doesn't use realms. I don't like the idea of having something that's _different_ when it doesn't need to be.\r\nAnd, in order for run-as to work the user has to exist in some realm. So this propsal _requires_ that some sort of realm exist for the users that authenticate in this way. It might be native or LDAP, but it would not support _ephemeral_ users (with role mapping) in the way Elasticsearch PKI does - unless we took the 3rd option you propose.\r\n\r\n> Kibana has to make sure the token in the cookie is associated with the current TLS client certificate\r\n\r\nThis is a good point, but is true in any of the alternatives. Kibana stores identity information in the `sid` cookie. And surprising, broken things will happen if the information in `sid` falls out of sync with the TLS client cert. I would propose putting a cryptographic hash of the cert into the cookie and, on each request, validate that it the cookie value still matches the TLS value.\r\n\r\nEven in the `run_as` approach, it might be possible to ensure that the connection to ES always reflect the client certificate, but that would not protect Kibana feature controls (menu options, etc). No matter what solution we come up with, Kibana will need to detect client-cert changes and force a logout-login cycle.\r\n\r\n> Certificate chains may look like signed assertions of identity, but they lack the crucial short time validity.\r\n\r\nSince (per @jkakavas's commen above) this is fundamentally true of certificates, I assume your concern is that we don't know _when_ Kibana performed the TLS handshake and we might be subject to replay attacks. If this is something we are particularly concerned about then we can add the necessary information into the API. The body of the \"swap this certificate for a token\" API could include a timestamp & a signature of some sort. \r\nI don't know that the risk is sufficient to require that (I'd need to think some more) but it's not an unsolvable problem. \r\n\r\n> Similarly to ES's PKI realm, Kibana should permit the configuration of additional truststores that must validate the client cert, in addition to the HTTP layer validation.\r\n\r\nThis seems like a downside for this option. It would require that Kibana duplicate functionality that Elasticsearch already has.\r\nUnder option 1, Kibana must replicate all the trust options that ES has, or else Kibana PKI would be (feature wise) an inferior offering to Elasticsearch PKI. Under the 2nd option, Kibana just needs to have enough configuration to perform a handshake. That could just be the corporate root CA, and Elasticsearch can perform additional trust checks (which could include doing different role mapping, or lookup in a different LDAP directory) depending on which CA signed the client cert. \r\n\r\n\r\n> ES also has to be configured to permit run_as for the Kibana principal\r\n\r\nIn the simplest case of using the existing `es-security-runas-user` header for this, it effectively grants Kibana superuser privileges. \r\nKibana would be able to run-as `elastic` because run-as doesn't have restrictions on the realm or the roles that the target user has.\r\nWe _could_ build additional controls into run-as to solve this (I would lean towards \"run as any user from realm X/Y/Z\"), but that is additional engineering work, and we would have to work out how you configure it. The `kibana_system` role is fixed, so we'd need to have some mechanism by which you could specify which realms were permitted when the kibana principal tried to run-as.\r\nThis would bring run-as more in line with `authorization_realm` (which specify which realms to use for lookups).\r\n\r\nAn alternative is to take the other approach of putting the whole cert into the header. At least then it is only possible for Kibana to run-as a user that can be looked up by certificate (but then this is tying the implementation to a PKI realm which it sound like you want to avoid).\r\n\r\n> We have to trust Kibana with forwarding the identity of the client, because the client cannot offer ES any proofs\r\n\r\nI think the \"trust Kibana\" terminology is proving to be too vague. It doesn't explicitly describe the risks we're trying to mitigate, and so it leads to all options appearing to be the same \"we have to trust Kibana\" even though they have different risk profiles.\r\n\r\nThe main issue that I think we should be identifying and controlling for is if an attacker manages to extract the kibana username+password from Kibana (e.g. through an RCE) and then uses that to do a privilege escalation on Elasticsearch.\r\nIf `kibana` has the ability to `run_as` _any_ user then this escalation is trivial - you just send `es-security-runas-user: elastic`. So how would we protect this? One option that you allude to is to enforce TLS from Kibana to Elasticsearch, yet that only provides any real protection if we are using Kibana's client cert as its proof of identity. TLS by itself doesn't do much there, and even requiring a client cert might not (depending on the trust anchors), it has to be locked down to a specific keypair.\r\n\r\nIt is possible to do that. It would require that we don't put any username/password into `kibana.yml`,  ideally disable the `kibana` user and then map the Kibana cert's DN to the `kibana_system` role. But, then we've switched the secret that the RCE needs to extract from being the Kibana username+password to being the Kibana cert+key. That's better, but it still means Kibana has a secret that end up being the keys-to-the-kingdom, and the right RCE will get you there.\r\n\r\nWhat I'd like for us to have is some sort of protection that the stack admin can enable that would limit the set of users/roles that Kibana can escalate too.\r\nLinking Kibana PKI to an ES realm provides an option for that. If the `proxy_pki` token grant has been configured against a `proxy_pki` realm, then that realm can be configured to never grant `superuser` (right now that means, don't create a role mapping for superuser, but we could look at putting something more explicit in if needed). While we cannot (and would not) enforce that ourselves, it does mean that the stack admin can manage this risk themselves.\r\n\r\nThere are other options that would be useful for any of the alternatives. For example IP restrictions on some part of this (e.g. the kibana user) so that the kibana credentials are not useful outside of the machine(s) on which Kibana runs.\r\n\r\n\r\n**Outstanding Issue**  \r\nWe still don't know _how_ people expect to map these certificates to a user-with-roles in ES/Kibana. But for me that's an argument for aligning this with PKI realms because:\r\n- We have something that works already and people seem OK with it.\r\n- It has (slightly) more than the minimum feature set. We support role-mapping by username and/or DN, and we support LDAP/native user lookup through `authorization_realms`.\r\n- Hooking into the realm infrastructure means that any new features we build there are automatically (or _mostly automatically_) available to Kibana PKI (e.g. when we added `authorization_realms`). This would include possible future development like considering additional data within the certificate chain (as mentioned in your earlier comment), extracting additional metadata from certificates (for role mapping) or having a mapping-function for PKI-principal to LDAP-principal (for `authorization_realms`).\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/502486748","html_url":"https://github.com/elastic/elasticsearch/issues/34396#issuecomment-502486748","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/34396","id":502486748,"node_id":"MDEyOklzc3VlQ29tbWVudDUwMjQ4Njc0OA==","user":{"login":"albertzaharovits","id":4568420,"node_id":"MDQ6VXNlcjQ1Njg0MjA=","avatar_url":"https://avatars2.githubusercontent.com/u/4568420?v=4","gravatar_id":"","url":"https://api.github.com/users/albertzaharovits","html_url":"https://github.com/albertzaharovits","followers_url":"https://api.github.com/users/albertzaharovits/followers","following_url":"https://api.github.com/users/albertzaharovits/following{/other_user}","gists_url":"https://api.github.com/users/albertzaharovits/gists{/gist_id}","starred_url":"https://api.github.com/users/albertzaharovits/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/albertzaharovits/subscriptions","organizations_url":"https://api.github.com/users/albertzaharovits/orgs","repos_url":"https://api.github.com/users/albertzaharovits/repos","events_url":"https://api.github.com/users/albertzaharovits/events{/privacy}","received_events_url":"https://api.github.com/users/albertzaharovits/received_events","type":"User","site_admin":false},"created_at":"2019-06-16T21:21:15Z","updated_at":"2019-06-16T21:21:15Z","author_association":"CONTRIBUTOR","body":"Thanks @tvernum and @jkakavas for the valuable feedback! There is a lot to unpack, so rather than individually answering each question and suggestion I will try to elaborate on the proposals.\r\n\r\nGenerally, I think we (me, Tim and Ioannis) are all OK with extending the PKI realm to delegate authentication *inside the Stack* by having Kibana pass the client cert from the TLS handshake to ES in exchange for a token, i.e. Tim's original proposal, i.e. second alternative from https://github.com/elastic/elasticsearch/issues/34396#issuecomment-498216685.\r\n\r\nI also believe that given TIm's argument in\r\n> Kibana stores identity information in the sid cookie. And surprising, broken things will happen if the information in sid falls out of sync with the TLS client cert. I would propose putting a cryptographic hash of the cert into the cookie and, on each request, validate that it the cookie value still matches the TLS value.\r\n\r\nand given that the Kibana server is more than a proxy (crafts ES requests, background jobs, etc) we can dismiss my argument that hoisting session information from the transport layer to the application layer is not required unless we go with the currently favored approach (ie it is required anyway).\r\n\r\nMoreover, I also agree with\r\n> I think the \"trust Kibana\" terminology is proving to be too vague. It doesn't explicitly describe the risks we're trying to mitigate, and so it leads to all options appearing to be the same \"we have to trust Kibana\" even though they have different risk profiles.\r\n\r\nand I believe we can all surmise that a trusted cert chain is more difficult to craft (or snoop from a compromised Kibana server) than a substring from its Subject field (ie the `run-as` principal) which would probably be scattered everywhere in the Kibana's memory since it has to go with every request to ES.\r\n\r\nWhat I still don't like is that, for a lack of a better word, we \"fake\" the delegation and try to cover for it by saying it is \"inside the Stack\" and if we have to, we can jump in and do a threat analysis. Inside ES, all the other realms that delegate authentications (SAML, OIDC, Kerberos) accept timestamped signed assertions. Upon successful validation they release a token. Client certificates are signed identity assertions but are not time bound. This is crucial. My argument is that toggling the delegated authn  on a PKI realm, as proposed herein, would be akin to disabling the timestamp validation on the SAML realm or the OIDC realm. We can put controls in place to compensate for that (TIm's IP firewall proposal) and narrow the pool of users, which leans me to OK this proposal, but this is a genuine conceptual problem with practical fixes.\r\nThe other proposals (`run-as` types), although inferior from the Stack perspective, acknowledges this weakness and passes the responsibility to the Kibana server to do the authentication. I think we discussed the technical problems of these alternatives (consistency with ES's PKI realm, Kibana is more exposed, passing cert chains in headers, ...) and I agree the `run-as` type of solution is impractical. But at least it does not have the conceptual weakness.\r\n\r\n**I wish to propose a variant of the favored approach, that I believe makes true the delegation concept.** Let us make Kibana construct a [JWT](https://jwt.io/introduction/) type of JSON, that contains the [client certificate chain from the TLS session](https://tools.ietf.org/id/draft-miller-jose-pkix-key-00.html), a timestamp and a signature with a shared secret (could be the `kibana_system` user's password, or a dedicated secret between Kibana and ES) and let it exchange that for a token. We could *probably* standardize this as a [JWT](https://jwt.io/introduction/) (it is pretty lax) but we don't really have to. What it is important is that a standalone ES server does not delegate authentication without validating signed timestamped assertions. Maybe an attacker that can capture a client certificate and the `kibana_system` password also has the capability to discover the signing secret and craft the JWT, so there is no practical improvement, but ES taken separately handles delegation by the books. I feel strongly about this, what do others think?\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n ","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/502573636","html_url":"https://github.com/elastic/elasticsearch/issues/34396#issuecomment-502573636","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/34396","id":502573636,"node_id":"MDEyOklzc3VlQ29tbWVudDUwMjU3MzYzNg==","user":{"login":"tvernum","id":2244393,"node_id":"MDQ6VXNlcjIyNDQzOTM=","avatar_url":"https://avatars0.githubusercontent.com/u/2244393?v=4","gravatar_id":"","url":"https://api.github.com/users/tvernum","html_url":"https://github.com/tvernum","followers_url":"https://api.github.com/users/tvernum/followers","following_url":"https://api.github.com/users/tvernum/following{/other_user}","gists_url":"https://api.github.com/users/tvernum/gists{/gist_id}","starred_url":"https://api.github.com/users/tvernum/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/tvernum/subscriptions","organizations_url":"https://api.github.com/users/tvernum/orgs","repos_url":"https://api.github.com/users/tvernum/repos","events_url":"https://api.github.com/users/tvernum/events{/privacy}","received_events_url":"https://api.github.com/users/tvernum/received_events","type":"User","site_admin":false},"created_at":"2019-06-17T07:51:07Z","updated_at":"2019-06-17T07:51:07Z","author_association":"CONTRIBUTOR","body":"> Inside ES, all the other realms that delegate authentications (SAML, OIDC, Kerberos) accept timestamped signed assertions ... Client certificates are signed identity assertions but are not time bound ... toggling the delegated authn on a PKI realm, as proposed herein, would be akin to disabling the timestamp validation on the SAML realm or the OIDC realm.\r\n\r\nI think this mixing different concepts.\r\n\r\nSAML assertions are typically sent via an intermediary, thus they are inherently subject to replay attacks. The design of a SAML assertion is intended to counter this risk by including time constraints that make the assertion fail if replayed at a later date, but the primary need for this is because the assertion may travel via an untrusted channel (e.g. the user's browser).\r\n\r\nIf we have a direct back channel to the authentication server (AS), then a timestramp would be technically unnecessary, as we could pass a session token to the AS and enquire whether the session is still valid. That would mitigate the same \"hold and replay\" attack without using a timestamp in the message (at the cost of being more chatty and having a runtime dependency on the AS).\r\n\r\nSimilarly if we obtain a message directly from the AS and we are confident in its integrity then signing is unnessary. SAML recognises this in making signatures mandatory for the Web profile (HTTP-POST/Redirect) but accepting that these are unneccessary when the IdP and SP are communicating on a transport that has end-to-end protection.  \r\nSigning allows us to know the a message originated from a particular party even though it has passed through untrusted intermediaries.\r\n\r\nSo, if the kibana server is communicating directly with ES, over an authenticated TLS connection, then I don't see why we _need_ signatures or timestamps.\r\n- The fact that the message was sent  _now_ is sufficient timestamp to know that the certificate is valid for a current session.\r\n- The fact that the `kibana` user authenticated is sufficient evidence that it originated from kibana\r\n- The TLS connection provide message integrity and prevents tampering.\r\n\r\nI'm not in any way opposed to having a signed & timestamped protocol, but I just don't see what risk it is mitigating that isn't already covered by a direct connection with TLS + authc.\r\n\r\nTimestamps are easy enough. If we have a reason to need one, then we can implement one. But we also need to think about clock skew, so it's not a trivial case of having Kibana set an expiry 60 seconds into the future. \r\n \r\nIf we need signing, then I'd like to consier why TLS client auth is not the correct solution for it. That will provide signatures at the transport layer and we can enforce either a pre-shared key (certificate pinning) or the more typical issuer (CA) checks. Technically, of course, requests sent over TLS are already signed using a session key, but if we think we need something more than that, then I would hope that client certificates would be sufficient for that.\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/502577583","html_url":"https://github.com/elastic/elasticsearch/issues/34396#issuecomment-502577583","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/34396","id":502577583,"node_id":"MDEyOklzc3VlQ29tbWVudDUwMjU3NzU4Mw==","user":{"login":"tvernum","id":2244393,"node_id":"MDQ6VXNlcjIyNDQzOTM=","avatar_url":"https://avatars0.githubusercontent.com/u/2244393?v=4","gravatar_id":"","url":"https://api.github.com/users/tvernum","html_url":"https://github.com/tvernum","followers_url":"https://api.github.com/users/tvernum/followers","following_url":"https://api.github.com/users/tvernum/following{/other_user}","gists_url":"https://api.github.com/users/tvernum/gists{/gist_id}","starred_url":"https://api.github.com/users/tvernum/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/tvernum/subscriptions","organizations_url":"https://api.github.com/users/tvernum/orgs","repos_url":"https://api.github.com/users/tvernum/repos","events_url":"https://api.github.com/users/tvernum/events{/privacy}","received_events_url":"https://api.github.com/users/tvernum/received_events","type":"User","site_admin":false},"created_at":"2019-06-17T08:03:20Z","updated_at":"2019-06-17T08:03:20Z","author_association":"CONTRIBUTOR","body":"That said, I think we're at the point where we can and should get into some implementataion.\r\nI think the only current points of contention are:\r\n- what metadata (timestamp) Kibana would need to send alonside the certificate chain\r\n- whether that payload requires a signature\r\n- what additional validation we would perform on\r\n   - the payload (metadata) \r\n   - signature (if any)\r\n   - connection (does it require client certificates)\r\n\r\nWe can start building the basics without having answered those questions.\r\nTo start with we'd need:\r\n- [ ] A proxy written in Java that implements what we expect of Kibana (for integ testing)\r\n- [ ] An endpoint of some sort for that to call (either a new token grant_type, or a whole new endpoint)\r\n- [ ] The actual authc against PKI realms & exchange for the token\r\n- [ ] Some sort of controls to enable/disable this feature for some/all realms and some calling user/role (e.g. `kibana_system`). I don't think we've decided what this would look like, but I'm pretty sure we do not want to ship it as \"always on\", given how it changes the trust model between Kibana & ES\r\n\r\nIf we have available engineering cycles (and I think we do), then let's get on with what we do know and see how we go.  ","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/507268489","html_url":"https://github.com/elastic/elasticsearch/issues/34396#issuecomment-507268489","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/34396","id":507268489,"node_id":"MDEyOklzc3VlQ29tbWVudDUwNzI2ODQ4OQ==","user":{"login":"jkakavas","id":10281256,"node_id":"MDQ6VXNlcjEwMjgxMjU2","avatar_url":"https://avatars2.githubusercontent.com/u/10281256?v=4","gravatar_id":"","url":"https://api.github.com/users/jkakavas","html_url":"https://github.com/jkakavas","followers_url":"https://api.github.com/users/jkakavas/followers","following_url":"https://api.github.com/users/jkakavas/following{/other_user}","gists_url":"https://api.github.com/users/jkakavas/gists{/gist_id}","starred_url":"https://api.github.com/users/jkakavas/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jkakavas/subscriptions","organizations_url":"https://api.github.com/users/jkakavas/orgs","repos_url":"https://api.github.com/users/jkakavas/repos","events_url":"https://api.github.com/users/jkakavas/events{/privacy}","received_events_url":"https://api.github.com/users/jkakavas/received_events","type":"User","site_admin":false},"created_at":"2019-07-01T13:39:03Z","updated_at":"2019-07-01T13:39:03Z","author_association":"CONTRIBUTOR","body":"I totally agree with Tim's comments on https://github.com/elastic/elasticsearch/issues/34396#issuecomment-502573636. \r\n\r\nI don't see what structuring the message from Kibana to ES in a JWT and signing this JWT buys us. Requiring authentication ( kibana - or another user with required privileges - user credentials ) on top of TLS offers the same guarantees with no need for additional implementation. \r\n\r\n> Client certificates are signed identity assertions but are not time bound. This is crucial.\r\n\r\nI still can't see what is the issue with the time validity of the client certificate in this specific case. Could you please explain the threat you see and why you consider this such high risk / or why it is not mitigated by tls and authentication ? \r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/507654955","html_url":"https://github.com/elastic/elasticsearch/issues/34396#issuecomment-507654955","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/34396","id":507654955,"node_id":"MDEyOklzc3VlQ29tbWVudDUwNzY1NDk1NQ==","user":{"login":"albertzaharovits","id":4568420,"node_id":"MDQ6VXNlcjQ1Njg0MjA=","avatar_url":"https://avatars2.githubusercontent.com/u/4568420?v=4","gravatar_id":"","url":"https://api.github.com/users/albertzaharovits","html_url":"https://github.com/albertzaharovits","followers_url":"https://api.github.com/users/albertzaharovits/followers","following_url":"https://api.github.com/users/albertzaharovits/following{/other_user}","gists_url":"https://api.github.com/users/albertzaharovits/gists{/gist_id}","starred_url":"https://api.github.com/users/albertzaharovits/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/albertzaharovits/subscriptions","organizations_url":"https://api.github.com/users/albertzaharovits/orgs","repos_url":"https://api.github.com/users/albertzaharovits/repos","events_url":"https://api.github.com/users/albertzaharovits/events{/privacy}","received_events_url":"https://api.github.com/users/albertzaharovits/received_events","type":"User","site_admin":false},"created_at":"2019-07-02T12:28:15Z","updated_at":"2019-07-02T12:28:15Z","author_association":"CONTRIBUTOR","body":"> I totally agree with Tim's comments on #34396 (comment).\r\n\r\nI also agree with Tim.\r\n\r\n> I still can't see what is the issue with the time validity of the client certificate in this specific case.\r\n Could you please explain the threat you see and why you consider this such high risk / or why it is not mitigated by tls and authentication ?\r\n\r\nA certificate chain is an assertion of identity and has a time validity. SAML and OIDC identity assertions also have time validities, but those are much more restricted compared to certificates. My observation was that in the PKI delegation flow we are using certificates more as SAML and OIDC assertions. Although the twist, which Tim pointed out, is that signatures are not _required_ (but also not forbidden) in SAML for backchannel communications.\r\n\r\nEverything on top of TLS and authentication has confidentiality, authentication (mutual?), integrity and replay protections. There is nothing more needed.\r\n\r\nBut I would also want us to consider ES outside of the Kibana context. There is a PKI realm installed on ES which allows delegation (which is implemented as we all seem to agree). Basic credentials over TLS are crack-able, the way a pure PKI realm is not. So a PKI realm which supports delegation is more exposed. How do we limit that? Tim mentioned some alternatives, all good ones.\r\n\r\nBut one alternative is also signing the \"assertion\" with another secret besides the `kibana_system` password. This secret has another scope than that password, so it could have a larger length/entropy, is not stored in the `.security` index, cannot be changed by the API, could be different for different nodes, could be different for different realms, does not complicate the Kibana setup in the way mutual TLS would...\r\n\r\n\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/509045025","html_url":"https://github.com/elastic/elasticsearch/issues/34396#issuecomment-509045025","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/34396","id":509045025,"node_id":"MDEyOklzc3VlQ29tbWVudDUwOTA0NTAyNQ==","user":{"login":"bizybot","id":902768,"node_id":"MDQ6VXNlcjkwMjc2OA==","avatar_url":"https://avatars2.githubusercontent.com/u/902768?v=4","gravatar_id":"","url":"https://api.github.com/users/bizybot","html_url":"https://github.com/bizybot","followers_url":"https://api.github.com/users/bizybot/followers","following_url":"https://api.github.com/users/bizybot/following{/other_user}","gists_url":"https://api.github.com/users/bizybot/gists{/gist_id}","starred_url":"https://api.github.com/users/bizybot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bizybot/subscriptions","organizations_url":"https://api.github.com/users/bizybot/orgs","repos_url":"https://api.github.com/users/bizybot/repos","events_url":"https://api.github.com/users/bizybot/events{/privacy}","received_events_url":"https://api.github.com/users/bizybot/received_events","type":"User","site_admin":false},"created_at":"2019-07-08T00:51:18Z","updated_at":"2019-07-08T00:51:18Z","author_association":"CONTRIBUTOR","body":"We discussed one way of mitigating leaked Kibana credentials using out of band authentication after the TLS mutual authentication between Kibana and Client. In case the Kibana credentials were leaked, those could be used with any user's public certificate and use them to exchange token with ES. In case of out of band authentication, ES will communicate OTP to the client via some channel (for ex. extract email address from the certificate and then send OTP via email just one way to do this) which the client will need to use to create assertion stating Kibana is allowed to act on its behalf.\r\n\r\nWe have decided not to do this for the following reasons:-\r\n- complicates the UX for the login scenario\r\n- in some environments, the other channel may not be available","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/510102761","html_url":"https://github.com/elastic/elasticsearch/issues/34396#issuecomment-510102761","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/34396","id":510102761,"node_id":"MDEyOklzc3VlQ29tbWVudDUxMDEwMjc2MQ==","user":{"login":"albertzaharovits","id":4568420,"node_id":"MDQ6VXNlcjQ1Njg0MjA=","avatar_url":"https://avatars2.githubusercontent.com/u/4568420?v=4","gravatar_id":"","url":"https://api.github.com/users/albertzaharovits","html_url":"https://github.com/albertzaharovits","followers_url":"https://api.github.com/users/albertzaharovits/followers","following_url":"https://api.github.com/users/albertzaharovits/following{/other_user}","gists_url":"https://api.github.com/users/albertzaharovits/gists{/gist_id}","starred_url":"https://api.github.com/users/albertzaharovits/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/albertzaharovits/subscriptions","organizations_url":"https://api.github.com/users/albertzaharovits/orgs","repos_url":"https://api.github.com/users/albertzaharovits/repos","events_url":"https://api.github.com/users/albertzaharovits/events{/privacy}","received_events_url":"https://api.github.com/users/albertzaharovits/received_events","type":"User","site_admin":false},"created_at":"2019-07-10T15:09:30Z","updated_at":"2019-07-10T15:09:30Z","author_association":"CONTRIBUTOR","body":"**TL;DR I reckon we do NOT need any restricted authn schemes for the proxying subject, for the delegate-PKI feature. But we need to investigate further authz options as part of our permission model refactoring in #44048. But this is not critically important for this feature.**\r\n\r\nCiting Jay from https://github.com/elastic/elasticsearch/issues/34396#issuecomment-476332090 with \r\n> I think the following should be properties that we keep though:\r\n> * the connection from the proxying app has authentication\r\n> * the authenticated user from the proxying app needs to be authorized to proxy the certificate\r\n\r\nI think we need to start discussing the authentication and authorization aspect of the PKI delegation feature. This also ties in with Tim's \r\n> Some sort of controls to enable/disable this feature for some/all realms and some calling user/role (e.g. kibana_system). I don't think we've decided what this would look like, but I'm pretty sure we do not want to ship it as \"always on\", given how it changes the trust model between Kibana & ES\r\n\r\nfrom https://github.com/elastic/elasticsearch/issues/34396#issuecomment-502577583 .\r\n\r\nOn the **authentication** side I believe we have to make a decision whether we feel the need to enforce any authentication scheme (the prominent option being client authn TLS) and restrict the BASIC method (which `kibana_system` normally uses). The rationale for this is that some schemes are more secure than others (eg. the `kibana_system` password can be brute forced, but a private key cannot). TLS with client authn is presumably the prominent option because, in this case, there is definitely a PKI realm configured on ES so this strong authn scheme does entail lesser configuration burdens (on the ES server at least). But this is not generally true because there are policies around certificate handling, and this does not even consider the configuration burden for the proxying app which could be load balanced. Also for the authentication aspect, I had previously been peddling a form of HMAC at the application logic level. It is also a form of authentication because it implies a shared secret between ES and the proxying app. But it is a form of authentication at the \"feature-level\" because it does not use the authn framework in ES Security, and it would have to happen after that one (given the request processing order). There are a few benefits, all originating because the scope of the secret is at the feature level. For example, if the secret is a new realm secret setting, then realms and nodes can have different values for it allowing finer grained control over the proxying identity. Moreover it does not encumber the `kibana_system` with more privileges, and it allows for different password/secret policies (the PKI delegation secret cannot be changed by the password API). However, all these benefits exist only when specifically comparing to `kibana_system`. But in the general case, this form of \"feature-level\" authentication is redundant. For example, there could be a separate file-based user that the proxying app uses solely for this feature, and this would have all the advantages as any other authn layer at the \"feature-level\".\r\n\r\n**Overall, I do not think we need any specific forms of restricted authentication for the PKI delegation feature.** This is because, and this refers to the next point, the es-admin can create role-mapping rules such as only certain users will be authorized to use this feature. And the es-admin has all the capacity to tune the authentication strength. Given the previous examples, the privileges could be granted only to a certain `delegate-pki` user which is part of some PKI or file-based realm. Moreover, if we are concerned about over encumbering `kibana_system` with privileges, we should recommend a different system user for this feature on the Kibana's side.\r\n\r\nIn terms of **authorization** the more fine grained the better. Hence _the best_ is a way for the es-admin to be able to grant the \"delegate-pki\" privilege to some specific principals such that they can *\"delegate-authenticate\"* as some specific principals. Given that https://github.com/elastic/elasticsearch/pull/44106 introduces a new transport action, and using the usual role mapping rules, it is easy for the es-admin to restrict the principal doing the delegation (the proxying app), but it is not possible, given the current state of the authorization framework, to define permissions that restrict the *\"delegated-authenticated\"* user. We could \"bake\" this part of the authorization at the realm level. In this case there would be a PKI realm setting namespaces, used to define these permissions (who can authenticate as who, in the case of this realm, using the delegation feature). This is ugly from the es-admin pov because it splits authorization configuration in two places, and it is kludgy from an engineering perspective because it mixes authorization with application logic. We might also improve our permission model to work outside the request \"boundary\", such as allowing to authorize and inspect on the response as well. I think it would be wonderful if we can achieve something like that as part of the effort in https://github.com/elastic/elasticsearch/issues/44048 . **My stance is that we can ship this feature without a complete authz scheme, without allowing to specify the *\"authenticated-as\"* principals in the permission model.** But work on this item separately, as a follow-up, after we settled on  https://github.com/elastic/elasticsearch/issues/44048 .","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/512900969","html_url":"https://github.com/elastic/elasticsearch/issues/34396#issuecomment-512900969","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/34396","id":512900969,"node_id":"MDEyOklzc3VlQ29tbWVudDUxMjkwMDk2OQ==","user":{"login":"albertzaharovits","id":4568420,"node_id":"MDQ6VXNlcjQ1Njg0MjA=","avatar_url":"https://avatars2.githubusercontent.com/u/4568420?v=4","gravatar_id":"","url":"https://api.github.com/users/albertzaharovits","html_url":"https://github.com/albertzaharovits","followers_url":"https://api.github.com/users/albertzaharovits/followers","following_url":"https://api.github.com/users/albertzaharovits/following{/other_user}","gists_url":"https://api.github.com/users/albertzaharovits/gists{/gist_id}","starred_url":"https://api.github.com/users/albertzaharovits/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/albertzaharovits/subscriptions","organizations_url":"https://api.github.com/users/albertzaharovits/orgs","repos_url":"https://api.github.com/users/albertzaharovits/repos","events_url":"https://api.github.com/users/albertzaharovits/events{/privacy}","received_events_url":"https://api.github.com/users/albertzaharovits/received_events","type":"User","site_admin":false},"created_at":"2019-07-18T16:57:54Z","updated_at":"2019-07-18T16:57:54Z","author_association":"CONTRIBUTOR","body":"We have discussed the matter of restricting the delegation feature in our weekly team meeting.\r\n\r\nThere would be a cluster privilege granting the authentication delegatee user (ie `kibana_system`) the ability to get access tokens for *any* user that the PKI realms normally authenticate. This privilege will most likely stand on its own, not be included with the others apart from `all`.\r\nFor the es-admin to restrict the users that can be authenticated by the delegatee, there would be user metadata fields populated exclusively when authn has been performed in this way, so that role mapping rules can differentiate such users. Hence, role mapping rules can exclude particular users to be authenticated by the proxy by not mapping any roles to them.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/514099193","html_url":"https://github.com/elastic/elasticsearch/issues/34396#issuecomment-514099193","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/34396","id":514099193,"node_id":"MDEyOklzc3VlQ29tbWVudDUxNDA5OTE5Mw==","user":{"login":"ShazCho","id":53212698,"node_id":"MDQ6VXNlcjUzMjEyNjk4","avatar_url":"https://avatars1.githubusercontent.com/u/53212698?v=4","gravatar_id":"","url":"https://api.github.com/users/ShazCho","html_url":"https://github.com/ShazCho","followers_url":"https://api.github.com/users/ShazCho/followers","following_url":"https://api.github.com/users/ShazCho/following{/other_user}","gists_url":"https://api.github.com/users/ShazCho/gists{/gist_id}","starred_url":"https://api.github.com/users/ShazCho/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ShazCho/subscriptions","organizations_url":"https://api.github.com/users/ShazCho/orgs","repos_url":"https://api.github.com/users/ShazCho/repos","events_url":"https://api.github.com/users/ShazCho/events{/privacy}","received_events_url":"https://api.github.com/users/ShazCho/received_events","type":"User","site_admin":false},"created_at":"2019-07-23T08:00:40Z","updated_at":"2019-07-23T08:00:40Z","author_association":"NONE","body":"Hi, I’d like to contribute some thoughts on this. \r\n\r\n1. Is the suggestion here that there would be a master certificate that connects to ElasticSearch via the TPS handshake? If so is there a requirement for that master certificate to be authenticated via the pki realm? \r\n2. Can we authenticate via another realm? Then the TLS handshake incorporates the certificate for the client connecting to Kiran’s.\r\n\r\nThanks","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/514099608","html_url":"https://github.com/elastic/elasticsearch/issues/34396#issuecomment-514099608","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/34396","id":514099608,"node_id":"MDEyOklzc3VlQ29tbWVudDUxNDA5OTYwOA==","user":{"login":"ShazCho","id":53212698,"node_id":"MDQ6VXNlcjUzMjEyNjk4","avatar_url":"https://avatars1.githubusercontent.com/u/53212698?v=4","gravatar_id":"","url":"https://api.github.com/users/ShazCho","html_url":"https://github.com/ShazCho","followers_url":"https://api.github.com/users/ShazCho/followers","following_url":"https://api.github.com/users/ShazCho/following{/other_user}","gists_url":"https://api.github.com/users/ShazCho/gists{/gist_id}","starred_url":"https://api.github.com/users/ShazCho/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ShazCho/subscriptions","organizations_url":"https://api.github.com/users/ShazCho/orgs","repos_url":"https://api.github.com/users/ShazCho/repos","events_url":"https://api.github.com/users/ShazCho/events{/privacy}","received_events_url":"https://api.github.com/users/ShazCho/received_events","type":"User","site_admin":false},"created_at":"2019-07-23T08:01:53Z","updated_at":"2019-07-23T08:01:53Z","author_association":"NONE","body":"Specifically I meant to mention the master account being authenticated via Kerberos then TLS used for certificate pki authentication during the proxy engagement.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/514104612","html_url":"https://github.com/elastic/elasticsearch/issues/34396#issuecomment-514104612","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/34396","id":514104612,"node_id":"MDEyOklzc3VlQ29tbWVudDUxNDEwNDYxMg==","user":{"login":"albertzaharovits","id":4568420,"node_id":"MDQ6VXNlcjQ1Njg0MjA=","avatar_url":"https://avatars2.githubusercontent.com/u/4568420?v=4","gravatar_id":"","url":"https://api.github.com/users/albertzaharovits","html_url":"https://github.com/albertzaharovits","followers_url":"https://api.github.com/users/albertzaharovits/followers","following_url":"https://api.github.com/users/albertzaharovits/following{/other_user}","gists_url":"https://api.github.com/users/albertzaharovits/gists{/gist_id}","starred_url":"https://api.github.com/users/albertzaharovits/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/albertzaharovits/subscriptions","organizations_url":"https://api.github.com/users/albertzaharovits/orgs","repos_url":"https://api.github.com/users/albertzaharovits/repos","events_url":"https://api.github.com/users/albertzaharovits/events{/privacy}","received_events_url":"https://api.github.com/users/albertzaharovits/received_events","type":"User","site_admin":false},"created_at":"2019-07-23T08:16:50Z","updated_at":"2019-07-23T08:16:50Z","author_association":"CONTRIBUTOR","body":"Hi @ShazCho,\r\n\r\nYes, in the current proposal, the proxy user doing the delegation can be authenticated by \"any\" realm, Kerberos included, not only PKI (\"any\" is quoted because some realms require browser interaction (SAML, OIDC), whereas the user doing the delegation works as a _system user_, therefore the scheme to achieve delegation in those cases is probably wrong).\r\n \r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/514176961","html_url":"https://github.com/elastic/elasticsearch/issues/34396#issuecomment-514176961","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/34396","id":514176961,"node_id":"MDEyOklzc3VlQ29tbWVudDUxNDE3Njk2MQ==","user":{"login":"ShazCho","id":53212698,"node_id":"MDQ6VXNlcjUzMjEyNjk4","avatar_url":"https://avatars1.githubusercontent.com/u/53212698?v=4","gravatar_id":"","url":"https://api.github.com/users/ShazCho","html_url":"https://github.com/ShazCho","followers_url":"https://api.github.com/users/ShazCho/followers","following_url":"https://api.github.com/users/ShazCho/following{/other_user}","gists_url":"https://api.github.com/users/ShazCho/gists{/gist_id}","starred_url":"https://api.github.com/users/ShazCho/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ShazCho/subscriptions","organizations_url":"https://api.github.com/users/ShazCho/orgs","repos_url":"https://api.github.com/users/ShazCho/repos","events_url":"https://api.github.com/users/ShazCho/events{/privacy}","received_events_url":"https://api.github.com/users/ShazCho/received_events","type":"User","site_admin":false},"created_at":"2019-07-23T11:50:33Z","updated_at":"2019-07-23T11:50:33Z","author_association":"NONE","body":"Ahh thanks. So I’ve been waiting for Kibana PKI for a while however the system_user from my perspective needs to be approved by a variety of different mechanisms depending on each implementation I do eg pki, Kerberos, saml, oauth. Does this mean that system_user can only be authenticated via pki?","performed_via_github_app":null}]