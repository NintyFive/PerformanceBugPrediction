{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/53100","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/53100/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/53100/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/53100/events","html_url":"https://github.com/elastic/elasticsearch/issues/53100","id":575347657,"node_id":"MDU6SXNzdWU1NzUzNDc2NTc=","number":53100,"title":"Data Streams","user":{"login":"martijnvg","id":580421,"node_id":"MDQ6VXNlcjU4MDQyMQ==","avatar_url":"https://avatars3.githubusercontent.com/u/580421?v=4","gravatar_id":"","url":"https://api.github.com/users/martijnvg","html_url":"https://github.com/martijnvg","followers_url":"https://api.github.com/users/martijnvg/followers","following_url":"https://api.github.com/users/martijnvg/following{/other_user}","gists_url":"https://api.github.com/users/martijnvg/gists{/gist_id}","starred_url":"https://api.github.com/users/martijnvg/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/martijnvg/subscriptions","organizations_url":"https://api.github.com/users/martijnvg/orgs","repos_url":"https://api.github.com/users/martijnvg/repos","events_url":"https://api.github.com/users/martijnvg/events{/privacy}","received_events_url":"https://api.github.com/users/martijnvg/received_events","type":"User","site_admin":false},"labels":[{"id":163824881,"node_id":"MDU6TGFiZWwxNjM4MjQ4ODE=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/:Core/Features/Indices%20APIs","name":":Core/Features/Indices APIs","color":"0e8a16","default":false,"description":"APIs to create and manage indices"},{"id":1920722285,"node_id":"MDU6TGFiZWwxOTIwNzIyMjg1","url":"https://api.github.com/repos/elastic/elasticsearch/labels/Dependency:Endpoint","name":"Dependency:Endpoint","color":"63db51","default":false,"description":""},{"id":158399402,"node_id":"MDU6TGFiZWwxNTgzOTk0MDI=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/Meta","name":"Meta","color":"e11d21","default":false,"description":null},{"id":1967496097,"node_id":"MDU6TGFiZWwxOTY3NDk2MDk3","url":"https://api.github.com/repos/elastic/elasticsearch/labels/Team:Core/Features","name":"Team:Core/Features","color":"fef2c0","default":false,"description":"Meta label for core/features team"},{"id":1903451964,"node_id":"MDU6TGFiZWwxOTAzNDUxOTY0","url":"https://api.github.com/repos/elastic/elasticsearch/labels/Top%20Ask","name":"Top Ask","color":"fef2c0","default":false,"description":""},{"id":108108556,"node_id":"MDU6TGFiZWwxMDgxMDg1NTY=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/release%20highlight","name":"release highlight","color":"fbca04","default":false,"description":null},{"id":2040343033,"node_id":"MDU6TGFiZWwyMDQwMzQzMDMz","url":"https://api.github.com/repos/elastic/elasticsearch/labels/v7.9.0","name":"v7.9.0","color":"dddddd","default":false,"description":""}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":7,"created_at":"2020-03-04T12:02:28Z","updated_at":"2020-07-15T15:20:12Z","closed_at":"2020-07-14T20:12:31Z","author_association":"MEMBER","active_lock_reason":null,"body":"**Update:** the description is out dated, for more information take a look at [the unreleased data streams docs](https://www.elastic.co/guide/en/elasticsearch/reference/7.x/data-streams.html).\r\n\r\nThe meta issue will track the development of a new feature named data streams.\r\n\r\n# Background\r\n\r\nData streams are targeted towards time-based data sources and enable us to solve bootstrap problems when indexing via a write alias (logstash-plugins/logstash-output-elasticsearch#858). Today aliases have some deficiencies in how they are implemented in Elasticsearch; namely they are not first-class concepts, making them confusing to use. Aliases have a broad type of usages, whereas data streams will be a solution focused for time-based data sources. Data streams should be a first-class concept, but should also be non intrusive. \r\n\r\n# Concept\r\n\r\nA data stream formalizes the notion of a stream of data for time based data sources. Data streams groups indices from the same time-based data source together as an opaque container. A data stream keeps track of a list of indices ordered by generation. A generation starts at 0 and each time the stream is rolled over the generation is incremented by one. Writes are forwarded to the index with the highest generation (last index). Searches and other multi-index APIs forward requests to all indices that are part of a data stream (this is similar to how aliases are resolved in these APIs).\r\n\r\nBecause data streams are aimed at time-series data sources, a date field is required and must be identified as the \"timestamp\" for the documents in the data stream. This will enable Kibana to detect that is dealing with time-series data automatically, and we can internally apply some optimizations (e.g., automatically sorting on the timestamp field).\r\n\r\nIndices that are contained with a data stream are hidden. The idea is that users interact with the data stream as much as possible and not directly with the indices that are contained within a data stream.\r\n\r\nData streams only accept append-only writes (index requests with op_type=create). Deletes and updates are rejected. If specific documents need to be updated or deleted then these operations should happen via the index these documents reside in. The reason that these write operations are rejected via a data stream is that these operations work as expected until a data stream is rolled over and then these operations result in 404 errors. Therefore it is better to reject these operations consistently.\r\n\r\nThe rollover API needs to understand how to handle a data stream. The data stream’s generation needs to be incremented and a new hidden index needs to be created atomically. The name of the index is based on the name of the data stream and its current generation, which looks like this: [datastream-name]-[datastream-generation].\r\n\r\nA data stream can be created with the create data stream API and remove via the delete data stream API.\r\n\r\nIt should also be possible to reserve a namespace to be a data stream before actually creating the data stream. For this data streams will depend on index templates v2. Index templates will get an additional setting, named data_stream, which will create a data stream with the name of what should be the concrete index and a hidden index:\r\n* A user creates an index template (in v2 format) with a desired index pattern, mappings, index settings and sets the data_stream setting to true.\r\n* This user starts ingesting data and the auto create index functionality kicks in. The previously created template matches, but instead of creating an index the following is created:\r\n  * A data stream with the targeted index name as name.\r\n  * A hidden index with the following name: [data-stream-name]-0.\r\n  * The hidden index is added to the list of indices of the data stream and the current generation is set to 0.\r\n\r\nAdditionally, data streams will be integrated into Kibana. For example, Kibana can automatically generate index patterns based on data streams, and identity the timestamp field.\r\n\r\n# Data Streams and ILM\r\n\r\nThe main change will be that it will no longer be required to configure index.lifecycle.rollover_alias setting for ilm. ILM can automatically figure out if an index is part of a datastream and act accordingly. An index can only be part of a single data stream, the user doesn’t create the index and the index is hidden, because of this clear structure ILM can make assumptions and doesn’t need additional configuration. Compared to using aliases (even with alias templates) this wouldn’t be true and this is a big upside of using datastreams.\r\n\r\nILM should also be able to update data streams atomically. For example in the context of ILM’s shrink action, the data stream should be updated to not refer to the un-shrunken index and refer to the shrunken index. For the rest, ILM should be able work as it is today. \r\n\r\n# Integration with security\r\n\r\nTBD\r\n\r\n# APIs\r\n\r\nThe APIs and they way data streams are used from other APIs is not final and may change in the future.\r\n\r\n## Index expressions and data streams in APIs\r\n\r\nData streams should be taken into account when resolving an index expression. Also the API that resolves an index expressions is important. If a multi-index API tries to resolve the name of a data stream then all the indices of a stream should be resolved and if a write API tries to resolve the name of a data stream then only the latest index should be resolved. \r\n\r\nThe following write APIs will resolve a data stream to the latest index: bulk API and index API.\r\nThe following multi index APIs should resolve a data stream to all indices it contains: search, msearch, field caps and eql search.\r\n\r\nSingle document read APIs should fail when being used via a data stream. The following APIs fall into this category: explain, get, mget, termvector.\r\n\r\nThere are many admin APIs that are multi index. These apis should be able to resolve data streams and resolve to the latest hidden index backed by a data stream. Examples of these APIs are: put mapping, get mapping, get settings or get index. \r\n\r\nThe rollover API both accepts a write alias and a data stream.\r\n\r\n## Get index API\r\n\r\nThe get index api should if an index is part of a data stream include what data stream it is part of.\r\n\r\n## Create data stream API\r\n\r\nRequest:\r\n\r\n```\r\nPUT /_data_stream/[name]\r\n{\r\n    \"timestamp_field\": ...\r\n}\r\n```\r\n\r\nThe create data stream API allows to create new data stream and the first backing index. This API creates a new data stream with the provided name and the provided timestamp field. The generation is set to 0. The backing index is created with the following name: '[data-stream-name]-000000'. The settings & mappings originate from any index template that match.\r\n\r\nIf an existing data stream, index or alias already exists with the same name as the provided data stream name then the create data stream will return with an error. Also if indices or aliases exist with the same prefix in the name as the provided data stream name then an error is returned as well.\r\n\r\n## Get data streams API\r\n\r\nRequest:\r\n\r\n```\r\nGET /_data_streams/[name]\r\n```\r\n\r\nReturns the list of data streams based on the specified name and for each data stream additional meta data is included. (for example list of backing indices and current generation). If no name is provided then all data streams are returned. Also wildcard expressions are supported.\r\n\r\n## Delete data stream API\r\n\r\nRequest:\r\n\r\n```\r\nDELETE /_data_stream/[name]\r\n```\r\n\r\nDeletes the specified data stream. Also the indices that are part of the data stream are removed.\r\n\r\n## Updating a data stream\r\n\r\nTBD\r\n\r\nA data stream can not be updated to include allow system or indices that are already part of data stream.","closed_by":{"login":"martijnvg","id":580421,"node_id":"MDQ6VXNlcjU4MDQyMQ==","avatar_url":"https://avatars3.githubusercontent.com/u/580421?v=4","gravatar_id":"","url":"https://api.github.com/users/martijnvg","html_url":"https://github.com/martijnvg","followers_url":"https://api.github.com/users/martijnvg/followers","following_url":"https://api.github.com/users/martijnvg/following{/other_user}","gists_url":"https://api.github.com/users/martijnvg/gists{/gist_id}","starred_url":"https://api.github.com/users/martijnvg/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/martijnvg/subscriptions","organizations_url":"https://api.github.com/users/martijnvg/orgs","repos_url":"https://api.github.com/users/martijnvg/repos","events_url":"https://api.github.com/users/martijnvg/events{/privacy}","received_events_url":"https://api.github.com/users/martijnvg/received_events","type":"User","site_admin":false},"performed_via_github_app":null}