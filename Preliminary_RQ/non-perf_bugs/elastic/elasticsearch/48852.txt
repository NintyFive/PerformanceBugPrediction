{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/48852","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/48852/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/48852/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/48852/events","html_url":"https://github.com/elastic/elasticsearch/issues/48852","id":517329929,"node_id":"MDU6SXNzdWU1MTczMjk5Mjk=","number":48852,"title":"Faster wildcard search","user":{"login":"jpountz","id":299848,"node_id":"MDQ6VXNlcjI5OTg0OA==","avatar_url":"https://avatars2.githubusercontent.com/u/299848?v=4","gravatar_id":"","url":"https://api.github.com/users/jpountz","html_url":"https://github.com/jpountz","followers_url":"https://api.github.com/users/jpountz/followers","following_url":"https://api.github.com/users/jpountz/following{/other_user}","gists_url":"https://api.github.com/users/jpountz/gists{/gist_id}","starred_url":"https://api.github.com/users/jpountz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jpountz/subscriptions","organizations_url":"https://api.github.com/users/jpountz/orgs","repos_url":"https://api.github.com/users/jpountz/repos","events_url":"https://api.github.com/users/jpountz/events{/privacy}","received_events_url":"https://api.github.com/users/jpountz/received_events","type":"User","site_admin":false},"labels":[{"id":146832564,"node_id":"MDU6TGFiZWwxNDY4MzI1NjQ=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/:Search/Search","name":":Search/Search","color":"0e8a16","default":false,"description":"Search-related issues that do not fall into other categories"},{"id":23172,"node_id":"MDU6TGFiZWwyMzE3Mg==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/%3Efeature","name":">feature","color":"006b75","default":false,"description":null},{"id":1714829748,"node_id":"MDU6TGFiZWwxNzE0ODI5NzQ4","url":"https://api.github.com/repos/elastic/elasticsearch/labels/Dependency:SIEM","name":"Dependency:SIEM","color":"efe039","default":false,"description":""},{"id":1903451964,"node_id":"MDU6TGFiZWwxOTAzNDUxOTY0","url":"https://api.github.com/repos/elastic/elasticsearch/labels/Top%20Ask","name":"Top Ask","color":"fef2c0","default":false,"description":""},{"id":2040343033,"node_id":"MDU6TGFiZWwyMDQwMzQzMDMz","url":"https://api.github.com/repos/elastic/elasticsearch/labels/v7.9.0","name":"v7.9.0","color":"dddddd","default":false,"description":""},{"id":1194435738,"node_id":"MDU6TGFiZWwxMTk0NDM1NzM4","url":"https://api.github.com/repos/elastic/elasticsearch/labels/v8.0.0","name":"v8.0.0","color":"dddddd","default":false,"description":""}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":20,"created_at":"2019-11-04T18:37:11Z","updated_at":"2020-07-02T07:36:32Z","closed_at":"2020-03-16T09:54:11Z","author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"While wildcard queries are often a symptom that content hasn't been properly analyzed, there are also cases when users really need the flexibility of wildcard queries. Could we leverage ngrams to make this kind of queries faster, similarly to how we made `prefix` queries faster on `text` fields by indexing edge ngrams?\r\n\r\nI tried to think about how this could work and here is an idea:\r\n - Null bytes would be used as start/end markers in order to make suffix queries possible (`*foobar`) and prefix queries faster (`foobar*`).\r\n - Content would be indexed with a ngram tokenizer that has a fixed gram size, e.g. 5 (could be configurable). It would be used to return a good approximation of the matches of the wildcard query.\r\n - Doc values would store the original value and could be used for a two-phase verification.\r\n\r\nHere are some example queries and how they would run internally with this setup:\r\n\r\n| Query | Approximation | Two-phase verification | Note |\r\n| --- | --- | --- | --- |\r\n| `*foobar*` | `fooba AND oobar` | Check positions | Like a phrase query |\r\n| `foobar*` | `\\0foob AND fooba AND oobar` | Check positions | We could skip the middle term like Lucene's NGramPhraseQuery |\r\n| `*foobar` | `fooba AND oobar AND obar\\0` | Check positions | We could skip the middle term like Lucene's NGramPhraseQuery |\r\n| `*foo*` | `*foo*` | Always returns true | Need a wildcard query because the substring is shorter than the gram size |\r\n| `foo*` | `\\0foo*` | Always returns true | Need a wildcard query because the substring is shorter than the gram size |\r\n| `*foo` | `*foo\\0` | Always returns true | Need a wildcard query because the substring is shorter than the gram size |\r\n| `foobar` | `\\0foob AND fooba AND oobar AND obar\\0` | Check positions | We could skip the middle terms like Lucene's NGramPhraseQuery |\r\n| `*foobar*quux*` | `fooba AND oobar` | Check doc values | We don't want to run a wildcard query on `*quux*`, the approximation we have might be selective enough already |\r\n\r\nNotes:\r\n - This might be quite space-intensive on long fields.\r\n\r\nQuestions:\r\n - Are there other ways it could work?\r\n - What is a good default gram size?\r\n - How much more space does it require compared to `keyword` indexing?\r\n - Should it be an option on `text`/`keyword` fields or a new field? This way of indexing allows to run exact queries too so we wouldn't need to index as a keyword too in addition to these ngrams.\r\n - Should we index positions? Whenever we check positions above, we could also check doc values instead.\r\n - Should we use BINARY or SORTED doc values? BINARY feels more appropriate for the access pattern described above, but compression would be terrible.","closed_by":{"login":"markharwood","id":170925,"node_id":"MDQ6VXNlcjE3MDkyNQ==","avatar_url":"https://avatars0.githubusercontent.com/u/170925?v=4","gravatar_id":"","url":"https://api.github.com/users/markharwood","html_url":"https://github.com/markharwood","followers_url":"https://api.github.com/users/markharwood/followers","following_url":"https://api.github.com/users/markharwood/following{/other_user}","gists_url":"https://api.github.com/users/markharwood/gists{/gist_id}","starred_url":"https://api.github.com/users/markharwood/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/markharwood/subscriptions","organizations_url":"https://api.github.com/users/markharwood/orgs","repos_url":"https://api.github.com/users/markharwood/repos","events_url":"https://api.github.com/users/markharwood/events{/privacy}","received_events_url":"https://api.github.com/users/markharwood/received_events","type":"User","site_admin":false},"performed_via_github_app":null}