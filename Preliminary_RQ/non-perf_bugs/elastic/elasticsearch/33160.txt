{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/33160","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/33160/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/33160/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/33160/events","html_url":"https://github.com/elastic/elasticsearch/issues/33160","id":354229053,"node_id":"MDU6SXNzdWUzNTQyMjkwNTM=","number":33160,"title":"Postings based completion suggester","user":{"login":"jimczi","id":15977469,"node_id":"MDQ6VXNlcjE1OTc3NDY5","avatar_url":"https://avatars0.githubusercontent.com/u/15977469?v=4","gravatar_id":"","url":"https://api.github.com/users/jimczi","html_url":"https://github.com/jimczi","followers_url":"https://api.github.com/users/jimczi/followers","following_url":"https://api.github.com/users/jimczi/following{/other_user}","gists_url":"https://api.github.com/users/jimczi/gists{/gist_id}","starred_url":"https://api.github.com/users/jimczi/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jimczi/subscriptions","organizations_url":"https://api.github.com/users/jimczi/orgs","repos_url":"https://api.github.com/users/jimczi/repos","events_url":"https://api.github.com/users/jimczi/events{/privacy}","received_events_url":"https://api.github.com/users/jimczi/received_events","type":"User","site_admin":false},"labels":[{"id":146833729,"node_id":"MDU6TGFiZWwxNDY4MzM3Mjk=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/:Search/Suggesters","name":":Search/Suggesters","color":"0e8a16","default":false,"description":"\"Did you mean\" and suggestions as you type"},{"id":23172,"node_id":"MDU6TGFiZWwyMzE3Mg==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/%3Efeature","name":">feature","color":"006b75","default":false,"description":null}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":2,"created_at":"2018-08-27T08:33:55Z","updated_at":"2019-04-03T07:50:56Z","closed_at":"2019-04-03T07:50:56Z","author_association":"MEMBER","active_lock_reason":null,"body":"### Context\r\n\r\nThe `completion` suggester is a good fit for applications that have a strong a-priori weighting for each suggestion.\r\nIt is optimized for speed to provide a search experience based on what the user has already typed in. However searching for suggestions cannot be mixed with filters on other fields. Users can configure `context`s to add some filtering on top of this suggester but this functionality is limited and does not provide the flexibility of a real index. Since suggestions (and contexts) are compiled in an FST at flush time the memory required by this suggester at query time depends on the size of the resulting FST. When indexing a lot of suggestions the memory needed to load theses FSTs (one per segment) can limit the available memory in a node (FST are loaded in the Java heap).\r\nBecause of these restrictions we often advise users to create a custom suggester based on the inverted lists and  `edge_ngram`. Using the inverted lists reduces the memory but it can impact speed. The `completion` suggester is able to \"early terminate\" a search since \r\nit can collect suggestions in the order of their weights, hence it much faster than a regular search that uses the inverted lists.\r\n\r\n### Proposal\r\n\r\nLucene 8 introduces new optimizations to search top documents sorted by score more efficiently when the total hit count is not required. \r\nBy knowing the max possible score of a block (or a segment) of documents, scorers are now able to skip non-competitive hits efficiently. \r\nBenchmarks showed some impressive speed up for scored queries: for instance\r\n[`term`](http://people.apache.org/~mikemccand/lucenebench/Term.html). \r\nSearch as you type requires speed since each keystroke generates a query so the idea here is to provide an out of the box field mapper that is configured for completion suggestions.\r\nThe score of each suggestion can be materialized in the index by replacing the frequency of terms with the a-priori weighting of the suggestions (set by the user at index time). Since we're looking for a fast search-as-you-type experience, we can index all prefixes of the suggestions in order to ensure that a single inverted list is used at query time. Using the inverted list instead of a custom FST brings\r\ntwo advantages:\r\n* Other fields can be used to filter suggestions.\r\n* The memory used by this suggester is controlled by the file system cache.\r\n\r\n#### Mapping\r\n\r\nThe current `completion` suggester is prefix-based. We could provide the same functionality by using an `edge_ngram` filter  under the hood like the `index_prefixes` option does on the `text` field:\r\n\r\n````\r\n{\r\n  \"my_suggester\": {\r\n    \"type\": \"completion_postings\" # Name to be defined ;)\r\n    \"prefix\": {}\r\n  }\r\n}\r\n````\r\n\r\nHowever this mode would limit the scope of this suggester so we could also provide a confiuration option to index suggestions with infixes.\r\nSo instead of all prefixes we'd tokenize the input and index the prefixes of each term. To improve precision we could also index shingles (size 2 or 3?) and computes the `edge_ngram` of each shingle:\r\n\r\n````\r\n{\r\n  \"my_suggester\": {\r\n    \"type\": \"completion_postings\" # Name to be defined ;)\r\n    \"infix\": {\r\n      \"shingle_size\": 2\r\n    }\r\n  }\r\n}\r\n````\r\n\r\n#### Indexing\r\n\r\nIndexing documents with suggestions would be equivalent to the current `completion` suggester:\r\n\r\n````\r\n{\r\n  \"my_suggester\": {\r\n    \"input\": \"It's a wonderful world\",\r\n    \"weight\": 42\r\n  }\r\n}\r\n````\r\n\r\nEach term (prefix or infix) is indexed with the provided weight which can be used at query time to rank the suggestions.\r\n\r\n#### Querying\r\n\r\nThis field mapper uses the same structure than any other `text` field so any query that work with `text` field would be compatible. Moreover any other field can be used to filter the documents that the suggest field would match:\r\n\r\n````\r\n{\r\n  \"bool\": {\r\n    \"must\": {\r\n      \"match_phrase_prefix\": {\r\n        \"my_suggester\": \"It's a \"\r\n      }\r\n    },\r\n    \"filter\": {\r\n      \"match\": {\r\n        \"category\": \"music\"\r\n      }\r\n    }\r\n}\r\n````\r\n\r\n`match_phrase_prefix` could be used to search for suggestions but we could also introduce a new query: \"match_prefix\" that would remove the phrasing search and would only consider the last term as a prefix. This query would help to simplify the writing of suggestion query since `prefix` queries are not analyzed.\r\n\r\n\r\n#### Scoring\r\n\r\nThe scoring at query time is more flexible than the current `completion` suggester thanks to the [`feature`](https://www.elastic.co/guide/en/elasticsearch/reference/master/feature.html) field.\r\nEach suggestion is indexed with an associated weight that is used at query time for scoring but another factor can be used to modify these static scores. For example if each document is indexed with a `popularity` feature field:\r\n\r\n````\r\n\"bool\": {\r\n  \"must\": {\r\n    \"match_phrase_prefix\": {\r\n      \"my_suggester\": \"It's a \",\r\n      \"boost\": 0.1\r\n    }\r\n  },\r\n  \"should\": {\r\n    \"feature\": {\r\n      \"field\": \"popularity\"\r\n    }\r\n  }\r\n}\r\n````\r\n\r\nThe optimization for fast top docs retrieval would still apply because the `feature` query can skip block of non-competitive hits.\r\n\r\n\r\n### Miscellaneous\r\n\r\nIn order to validate this proposal we'd need to perform some tests to ensure that this new field mapper can handle search-as-you-type efficiently.\r\nA benchmark against the current `completion` suggester is needed to compare the performance. Even though we expect this new suggester to be slower than  the FST-based, the new optimizations in Lucene 8 should make it fast enough to be a good candidate for a search-as-you-type experience. he other downside of this approach is the size on disk that is required to index all prefixes (infixes) so we also need to compare (and evaluate) the requirements and performance of the indexation. Since these questions could impact the development of this feature we'll start with a small POC to test these assumptions.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","closed_by":{"login":"jimczi","id":15977469,"node_id":"MDQ6VXNlcjE1OTc3NDY5","avatar_url":"https://avatars0.githubusercontent.com/u/15977469?v=4","gravatar_id":"","url":"https://api.github.com/users/jimczi","html_url":"https://github.com/jimczi","followers_url":"https://api.github.com/users/jimczi/followers","following_url":"https://api.github.com/users/jimczi/following{/other_user}","gists_url":"https://api.github.com/users/jimczi/gists{/gist_id}","starred_url":"https://api.github.com/users/jimczi/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jimczi/subscriptions","organizations_url":"https://api.github.com/users/jimczi/orgs","repos_url":"https://api.github.com/users/jimczi/repos","events_url":"https://api.github.com/users/jimczi/events{/privacy}","received_events_url":"https://api.github.com/users/jimczi/received_events","type":"User","site_admin":false},"performed_via_github_app":null}