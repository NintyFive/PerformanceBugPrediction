{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/30355","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/30355/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/30355/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/30355/events","html_url":"https://github.com/elastic/elasticsearch/issues/30355","id":319826658,"node_id":"MDU6SXNzdWUzMTk4MjY2NTg=","number":30355,"title":"Limit number of concurrent authentication requests when the cache expires  ","user":{"login":"tvernum","id":2244393,"node_id":"MDQ6VXNlcjIyNDQzOTM=","avatar_url":"https://avatars0.githubusercontent.com/u/2244393?v=4","gravatar_id":"","url":"https://api.github.com/users/tvernum","html_url":"https://github.com/tvernum","followers_url":"https://api.github.com/users/tvernum/followers","following_url":"https://api.github.com/users/tvernum/following{/other_user}","gists_url":"https://api.github.com/users/tvernum/gists{/gist_id}","starred_url":"https://api.github.com/users/tvernum/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/tvernum/subscriptions","organizations_url":"https://api.github.com/users/tvernum/orgs","repos_url":"https://api.github.com/users/tvernum/repos","events_url":"https://api.github.com/users/tvernum/events{/privacy}","received_events_url":"https://api.github.com/users/tvernum/received_events","type":"User","site_admin":false},"labels":[{"id":912837951,"node_id":"MDU6TGFiZWw5MTI4Mzc5NTE=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/:Security/Authentication","name":":Security/Authentication","color":"0e8a16","default":false,"description":"Logging in, Usernames/passwords, Realms (Native/LDAP/AD/SAML/PKI/etc)"},{"id":23174,"node_id":"MDU6TGFiZWwyMzE3NA==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/%3Eenhancement","name":">enhancement","color":"4a4ea8","default":false,"description":null}],"state":"closed","locked":false,"assignee":{"login":"jaymode","id":4339958,"node_id":"MDQ6VXNlcjQzMzk5NTg=","avatar_url":"https://avatars1.githubusercontent.com/u/4339958?v=4","gravatar_id":"","url":"https://api.github.com/users/jaymode","html_url":"https://github.com/jaymode","followers_url":"https://api.github.com/users/jaymode/followers","following_url":"https://api.github.com/users/jaymode/following{/other_user}","gists_url":"https://api.github.com/users/jaymode/gists{/gist_id}","starred_url":"https://api.github.com/users/jaymode/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jaymode/subscriptions","organizations_url":"https://api.github.com/users/jaymode/orgs","repos_url":"https://api.github.com/users/jaymode/repos","events_url":"https://api.github.com/users/jaymode/events{/privacy}","received_events_url":"https://api.github.com/users/jaymode/received_events","type":"User","site_admin":false},"assignees":[{"login":"jaymode","id":4339958,"node_id":"MDQ6VXNlcjQzMzk5NTg=","avatar_url":"https://avatars1.githubusercontent.com/u/4339958?v=4","gravatar_id":"","url":"https://api.github.com/users/jaymode","html_url":"https://github.com/jaymode","followers_url":"https://api.github.com/users/jaymode/followers","following_url":"https://api.github.com/users/jaymode/following{/other_user}","gists_url":"https://api.github.com/users/jaymode/gists{/gist_id}","starred_url":"https://api.github.com/users/jaymode/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jaymode/subscriptions","organizations_url":"https://api.github.com/users/jaymode/orgs","repos_url":"https://api.github.com/users/jaymode/repos","events_url":"https://api.github.com/users/jaymode/events{/privacy}","received_events_url":"https://api.github.com/users/jaymode/received_events","type":"User","site_admin":false}],"milestone":null,"comments":6,"created_at":"2018-05-03T08:21:33Z","updated_at":"2018-05-24T16:43:10Z","closed_at":"2018-05-24T16:43:10Z","author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"Many of our realms extend CachingUsernamePasswordRealm which maintains a local (per node) cache of users and credentials so that we do not need to do a lookup on the underlying datastore for every request.\r\n\r\nThis is particularly important when the datastore is external, e.g. an LDAP directory. If the cache was not there we would need to do an LDAP bind (and potentially also group/metadata lookups) for every REST request.\r\n\r\nThis cache has a per-entry expiry, where an entry is a \"user\". That means that when the cache entry for a user expires, all authentication requests for that user will lookup the original datasource until the cache is populated again (when the first authentication succeeds).\r\n\r\nAdditionally, various other factors can cause a cache entry to be evicted (e.g. we invalidate on incorrect password so that we can check for an updated password in the datastore, and there is an API to clear the cache by realm/user).\r\n\r\nConsequently, for a single user on a single node, there is a period where we do not make requests to the datastore, and then a short period where we make potentially multiple requests.\r\n\r\ne.g. If somone has a number of beats running on various source systems, and those beats connect directly to Elasticsearch using a single user defined in LDAP, then every 30 minutes or so, every one of those beats could trigger an LDAP bind causing cyclic spikes in load on the LDAP server.\r\n\r\nThis behaviour is problematic, but the solution is not obvious.\r\n\r\n- We can limit the impact of this through connection pooling (and have done so), but this doesn't reduce the total number of requests to the LDAP directory, it just flattens & stretches the spikes as that there are less simultaneous requests, but no change in the total number of requests.\r\n\r\n- We could implement a \"cache loader\" approach, where only 1 task can be attempting to load a cache entry for a given key. That is, if we find that the cache does not have an entry for a specific user, then we perform a lookup on the original datasource, and any other lookups for that same user will wait for the first lookup to complete.  \r\nThis sort of concurrency behaviour is difficult to do well and can easily be a source of subtle bugs, particularly as we need the \"wait for cache to populate\" to be asynchronous.\r\n\r\n- An alternative that I have a prototype for, is to simply limit the number of concurrent authentication requests that a single realm can perform simulatenously (with a BlockingQueue to hold pending requests). This limit is global and does not care about the identity of the authenticating user. It sits before the cache, so the first _N_ requests will execute and populate the cache as needed, and then subsequent requests will be released from the queue and find the cache is ready and the relevant user entries are populated.  \r\nThis works quite well when a realm is authenticating a small number of distinct users, but those users perform multiple simultaneous requests to Elasticsearch. When there are multiple users involved, it can also help, but the result is very similar to using a connection pool.\r\n","closed_by":{"login":"jaymode","id":4339958,"node_id":"MDQ6VXNlcjQzMzk5NTg=","avatar_url":"https://avatars1.githubusercontent.com/u/4339958?v=4","gravatar_id":"","url":"https://api.github.com/users/jaymode","html_url":"https://github.com/jaymode","followers_url":"https://api.github.com/users/jaymode/followers","following_url":"https://api.github.com/users/jaymode/following{/other_user}","gists_url":"https://api.github.com/users/jaymode/gists{/gist_id}","starred_url":"https://api.github.com/users/jaymode/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jaymode/subscriptions","organizations_url":"https://api.github.com/users/jaymode/orgs","repos_url":"https://api.github.com/users/jaymode/repos","events_url":"https://api.github.com/users/jaymode/events{/privacy}","received_events_url":"https://api.github.com/users/jaymode/received_events","type":"User","site_admin":false},"performed_via_github_app":null}