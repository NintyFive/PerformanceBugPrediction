[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/504071916","html_url":"https://github.com/elastic/elasticsearch/issues/43438#issuecomment-504071916","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/43438","id":504071916,"node_id":"MDEyOklzc3VlQ29tbWVudDUwNDA3MTkxNg==","user":{"login":"elasticmachine","id":15837671,"node_id":"MDQ6VXNlcjE1ODM3Njcx","avatar_url":"https://avatars3.githubusercontent.com/u/15837671?v=4","gravatar_id":"","url":"https://api.github.com/users/elasticmachine","html_url":"https://github.com/elasticmachine","followers_url":"https://api.github.com/users/elasticmachine/followers","following_url":"https://api.github.com/users/elasticmachine/following{/other_user}","gists_url":"https://api.github.com/users/elasticmachine/gists{/gist_id}","starred_url":"https://api.github.com/users/elasticmachine/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/elasticmachine/subscriptions","organizations_url":"https://api.github.com/users/elasticmachine/orgs","repos_url":"https://api.github.com/users/elasticmachine/repos","events_url":"https://api.github.com/users/elasticmachine/events{/privacy}","received_events_url":"https://api.github.com/users/elasticmachine/received_events","type":"User","site_admin":false},"created_at":"2019-06-20T15:28:52Z","updated_at":"2019-06-20T15:28:52Z","author_association":"COLLABORATOR","body":"Pinging @elastic/ml-core","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/504135997","html_url":"https://github.com/elastic/elasticsearch/issues/43438#issuecomment-504135997","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/43438","id":504135997,"node_id":"MDEyOklzc3VlQ29tbWVudDUwNDEzNTk5Nw==","user":{"login":"benwtrent","id":4357155,"node_id":"MDQ6VXNlcjQzNTcxNTU=","avatar_url":"https://avatars3.githubusercontent.com/u/4357155?v=4","gravatar_id":"","url":"https://api.github.com/users/benwtrent","html_url":"https://github.com/benwtrent","followers_url":"https://api.github.com/users/benwtrent/followers","following_url":"https://api.github.com/users/benwtrent/following{/other_user}","gists_url":"https://api.github.com/users/benwtrent/gists{/gist_id}","starred_url":"https://api.github.com/users/benwtrent/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/benwtrent/subscriptions","organizations_url":"https://api.github.com/users/benwtrent/orgs","repos_url":"https://api.github.com/users/benwtrent/repos","events_url":"https://api.github.com/users/benwtrent/events{/privacy}","received_events_url":"https://api.github.com/users/benwtrent/received_events","type":"User","site_admin":false},"created_at":"2019-06-20T18:36:26Z","updated_at":"2019-06-20T18:36:26Z","author_association":"MEMBER","body":"I do agree that we should have better facilities for updating data frame transforms. What fields are able to be updated is up for debate. \r\n\r\n* Should we allow updating the `group_by` even though that changes the document ID generation? \r\n* Should we allow the aggregations to be updated?\r\n* Updating aggs or the `group_by` also implies that the mapping of the destination index is now wrong. Should we attempt to create the appropriate mapping and add fields?\r\n\r\nFields that I think are pretty safe to update:\r\n* `source` <- including the `query` and `index`\r\n* `dest` <- including `index` and the newly added `pipeline` field\r\n* `description`\r\n* `pivot.max_page_search_size`\r\n\r\nI do not think that the update action should stop and then start the transform again. We should probably only allow updating a `stopped` data frame. Calling `_stop` against an already `stopped` data frame is a no-op. ","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/504155614","html_url":"https://github.com/elastic/elasticsearch/issues/43438#issuecomment-504155614","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/43438","id":504155614,"node_id":"MDEyOklzc3VlQ29tbWVudDUwNDE1NTYxNA==","user":{"login":"andrewvc","id":131427,"node_id":"MDQ6VXNlcjEzMTQyNw==","avatar_url":"https://avatars2.githubusercontent.com/u/131427?v=4","gravatar_id":"","url":"https://api.github.com/users/andrewvc","html_url":"https://github.com/andrewvc","followers_url":"https://api.github.com/users/andrewvc/followers","following_url":"https://api.github.com/users/andrewvc/following{/other_user}","gists_url":"https://api.github.com/users/andrewvc/gists{/gist_id}","starred_url":"https://api.github.com/users/andrewvc/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/andrewvc/subscriptions","organizations_url":"https://api.github.com/users/andrewvc/orgs","repos_url":"https://api.github.com/users/andrewvc/repos","events_url":"https://api.github.com/users/andrewvc/events{/privacy}","received_events_url":"https://api.github.com/users/andrewvc/received_events","type":"User","site_admin":false},"created_at":"2019-06-20T19:38:42Z","updated_at":"2019-06-20T19:38:55Z","author_association":"CONTRIBUTOR","body":"I don't anticipate for our use case needing to update any fields other than perhaps `pivot.aggregations` and `description`.\r\n\r\nThat said, let's imagine a future where we wanted to update the `group_by` definition to add a field. We could do it seamlessly by simply adding a `version` field to the documents in the destination index, and only querying documents from the latest run (or, alternatively, deleting_by_query all the previous versions).\r\n\r\nSpeaking of versioning, I'm considering using the description field to version our dataframe. On each beat startup we want to ensure the last dataframe is running, and that's the only real metadata field available. The alternative is just to recreate the frame each time, but at scale that's a problem.","performed_via_github_app":null}]