[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/64771849","html_url":"https://github.com/elastic/elasticsearch/issues/8681#issuecomment-64771849","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/8681","id":64771849,"node_id":"MDEyOklzc3VlQ29tbWVudDY0NzcxODQ5","user":{"login":"clintongormley","id":56599,"node_id":"MDQ6VXNlcjU2NTk5","avatar_url":"https://avatars0.githubusercontent.com/u/56599?v=4","gravatar_id":"","url":"https://api.github.com/users/clintongormley","html_url":"https://github.com/clintongormley","followers_url":"https://api.github.com/users/clintongormley/followers","following_url":"https://api.github.com/users/clintongormley/following{/other_user}","gists_url":"https://api.github.com/users/clintongormley/gists{/gist_id}","starred_url":"https://api.github.com/users/clintongormley/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/clintongormley/subscriptions","organizations_url":"https://api.github.com/users/clintongormley/orgs","repos_url":"https://api.github.com/users/clintongormley/repos","events_url":"https://api.github.com/users/clintongormley/events{/privacy}","received_events_url":"https://api.github.com/users/clintongormley/received_events","type":"User","site_admin":false},"created_at":"2014-11-27T10:25:18Z","updated_at":"2014-11-27T10:25:18Z","author_association":"CONTRIBUTOR","body":"Hi @NodexTech \n\nDo you mean aggregations rather than facets? Facets are deprecated.\n\nOf course, supporting `key: true` for terms aggs means that you will lose any sort order, which is usually important for terms aggs.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/64772911","html_url":"https://github.com/elastic/elasticsearch/issues/8681#issuecomment-64772911","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/8681","id":64772911,"node_id":"MDEyOklzc3VlQ29tbWVudDY0NzcyOTEx","user":{"login":"NodexTech","id":6095811,"node_id":"MDQ6VXNlcjYwOTU4MTE=","avatar_url":"https://avatars1.githubusercontent.com/u/6095811?v=4","gravatar_id":"","url":"https://api.github.com/users/NodexTech","html_url":"https://github.com/NodexTech","followers_url":"https://api.github.com/users/NodexTech/followers","following_url":"https://api.github.com/users/NodexTech/following{/other_user}","gists_url":"https://api.github.com/users/NodexTech/gists{/gist_id}","starred_url":"https://api.github.com/users/NodexTech/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/NodexTech/subscriptions","organizations_url":"https://api.github.com/users/NodexTech/orgs","repos_url":"https://api.github.com/users/NodexTech/repos","events_url":"https://api.github.com/users/NodexTech/events{/privacy}","received_events_url":"https://api.github.com/users/NodexTech/received_events","type":"User","site_admin":false},"created_at":"2014-11-27T10:33:53Z","updated_at":"2014-11-27T10:33:53Z","author_association":"NONE","body":"Yes, aggregations sorry.\n\nWe lose sort order in ranges anyway, it simply sorts them by what is fed to it. I don't see any real reason why sort order would be lost but I don't know the inner workings of how the aggregation buckets are built. Some psuedo code (if you wanted to keep order and at a performance loss) would be to build the buckets first then loop back over them swapping the numeric key for the bucket key - this way they keep their original sort order as defined by the client / ES\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/64773919","html_url":"https://github.com/elastic/elasticsearch/issues/8681#issuecomment-64773919","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/8681","id":64773919,"node_id":"MDEyOklzc3VlQ29tbWVudDY0NzczOTE5","user":{"login":"clintongormley","id":56599,"node_id":"MDQ6VXNlcjU2NTk5","avatar_url":"https://avatars0.githubusercontent.com/u/56599?v=4","gravatar_id":"","url":"https://api.github.com/users/clintongormley","html_url":"https://github.com/clintongormley","followers_url":"https://api.github.com/users/clintongormley/followers","following_url":"https://api.github.com/users/clintongormley/following{/other_user}","gists_url":"https://api.github.com/users/clintongormley/gists{/gist_id}","starred_url":"https://api.github.com/users/clintongormley/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/clintongormley/subscriptions","organizations_url":"https://api.github.com/users/clintongormley/orgs","repos_url":"https://api.github.com/users/clintongormley/repos","events_url":"https://api.github.com/users/clintongormley/events{/privacy}","received_events_url":"https://api.github.com/users/clintongormley/received_events","type":"User","site_admin":false},"created_at":"2014-11-27T10:41:07Z","updated_at":"2014-11-27T10:41:07Z","author_association":"CONTRIBUTOR","body":"Sort order would be lost because, with a keyed response, buckets are returned as an unordered map instead of as an ordered array.\n\nI don't understand what you mean by the terms buckets being numbered.  This is what you get back from a terms agg:\n\n```\n     \"buckets\": [\n        {\n           \"key\": \"one\",\n           \"doc_count\": 1\n        },\n        {\n           \"key\": \"two\",\n           \"doc_count\": 1\n        }\n     ]\n```\n\nSo the key (the term) is already available to you.  Perhaps some JSON examples demonstrating the problem would help?\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/64774898","html_url":"https://github.com/elastic/elasticsearch/issues/8681#issuecomment-64774898","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/8681","id":64774898,"node_id":"MDEyOklzc3VlQ29tbWVudDY0Nzc0ODk4","user":{"login":"NodexTech","id":6095811,"node_id":"MDQ6VXNlcjYwOTU4MTE=","avatar_url":"https://avatars1.githubusercontent.com/u/6095811?v=4","gravatar_id":"","url":"https://api.github.com/users/NodexTech","html_url":"https://github.com/NodexTech","followers_url":"https://api.github.com/users/NodexTech/followers","following_url":"https://api.github.com/users/NodexTech/following{/other_user}","gists_url":"https://api.github.com/users/NodexTech/gists{/gist_id}","starred_url":"https://api.github.com/users/NodexTech/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/NodexTech/subscriptions","organizations_url":"https://api.github.com/users/NodexTech/orgs","repos_url":"https://api.github.com/users/NodexTech/repos","events_url":"https://api.github.com/users/NodexTech/events{/privacy}","received_events_url":"https://api.github.com/users/NodexTech/received_events","type":"User","site_admin":false},"created_at":"2014-11-27T10:50:08Z","updated_at":"2014-11-27T10:50:08Z","author_association":"NONE","body":"```\n\"buckets\": [\n        {\n           \"key\": \"one\",\n           \"doc_count\": 1\n        },\n        {\n           \"key\": \"two\",\n           \"doc_count\": 1\n        }\n     ]\n```\n\nThose buckets in Json can be thought of as 0,1 in terms of keys. When some languages decode JSON back into hashes/arrays they automatically number the keys which would essentially make the  look like this (I know it's a bad example to number JSON arrays)\n\n```\n\"buckets\": \n        {\n            \"0\": {\n                \"key\": \"one\",\n                \"doc_count\": 1\n            }\n        },\n        {\n            \"1\": {\n                \"key\": \"two\",\n                \"doc_count\": 1\n            }\n        }\n\n```\n\nWhat I'm saying is that the order is pre-determined by ES and added to the ordered array ergo the order is already set. Looping that ordered array and replacing each array member with a new key (the \"key\" member of the array) and /value (a copy of the original member) might look like this (when replaced:\n\n```\n\"buckets\": \n        {\n            \"one\": {\n                \"key\": \"one\",\n                \"doc_count\": 1\n            }\n        },\n        {\n            \"two\": {\n                \"key\": \"two\",\n                \"doc_count\": 1\n            }\n        }\n\n```\n\nThe option is already there in ranges / date ranges which specifically de-normalises bucket responses but the (original) order is still kept (highest first).\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/64776257","html_url":"https://github.com/elastic/elasticsearch/issues/8681#issuecomment-64776257","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/8681","id":64776257,"node_id":"MDEyOklzc3VlQ29tbWVudDY0Nzc2MjU3","user":{"login":"clintongormley","id":56599,"node_id":"MDQ6VXNlcjU2NTk5","avatar_url":"https://avatars0.githubusercontent.com/u/56599?v=4","gravatar_id":"","url":"https://api.github.com/users/clintongormley","html_url":"https://github.com/clintongormley","followers_url":"https://api.github.com/users/clintongormley/followers","following_url":"https://api.github.com/users/clintongormley/following{/other_user}","gists_url":"https://api.github.com/users/clintongormley/gists{/gist_id}","starred_url":"https://api.github.com/users/clintongormley/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/clintongormley/subscriptions","organizations_url":"https://api.github.com/users/clintongormley/orgs","repos_url":"https://api.github.com/users/clintongormley/repos","events_url":"https://api.github.com/users/clintongormley/events{/privacy}","received_events_url":"https://api.github.com/users/clintongormley/received_events","type":"User","site_admin":false},"created_at":"2014-11-27T11:02:18Z","updated_at":"2014-11-27T11:02:18Z","author_association":"CONTRIBUTOR","body":"Your last example is an unordered map/object. Any order is lost - having the \"two\" key before the \"one\" key would have exactly the same meaning as \"one\" before \"two\".\n\n> When some languages decode JSON back into hashes/arrays they automatically number the keys which would essentially make the look like this (I know it's a bad example to number JSON arrays)\n\nWhat language does that? I presume the structure that it returns is actually like this:\n\n```\n{\n  \"buckets\": {\n    \"0\": {\n      \"key\": \"one\",\n      \"doc_count\": 1\n    },\n    \"1\": {\n      \"key\": \"two\",\n      \"doc_count\": 1\n    }\n  }\n}\n```\n\nDoes this language not have support for arrays? Is it PHP, where a map is implemented as an associative array?\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/64777269","html_url":"https://github.com/elastic/elasticsearch/issues/8681#issuecomment-64777269","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/8681","id":64777269,"node_id":"MDEyOklzc3VlQ29tbWVudDY0Nzc3MjY5","user":{"login":"NodexTech","id":6095811,"node_id":"MDQ6VXNlcjYwOTU4MTE=","avatar_url":"https://avatars1.githubusercontent.com/u/6095811?v=4","gravatar_id":"","url":"https://api.github.com/users/NodexTech","html_url":"https://github.com/NodexTech","followers_url":"https://api.github.com/users/NodexTech/followers","following_url":"https://api.github.com/users/NodexTech/following{/other_user}","gists_url":"https://api.github.com/users/NodexTech/gists{/gist_id}","starred_url":"https://api.github.com/users/NodexTech/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/NodexTech/subscriptions","organizations_url":"https://api.github.com/users/NodexTech/orgs","repos_url":"https://api.github.com/users/NodexTech/repos","events_url":"https://api.github.com/users/NodexTech/events{/privacy}","received_events_url":"https://api.github.com/users/NodexTech/received_events","type":"User","site_admin":false},"created_at":"2014-11-27T11:12:34Z","updated_at":"2014-11-27T11:12:34Z","author_association":"NONE","body":"The map might be returned ordered but it can be looped and given back in it's original determined order -but- with new keys (this is how ranges are returned when \"keyed\" is true) - I presume that they're built in the same way?, the order is defined by ES before the map is built so that original order/map can be in fact looped and just have the keys changed.\n\nThe language that decodes the JSON (I don't feel) is relevant, it would be nice to see the functionality inside ES so to be able to normalise the responses of Aggregations if one wanted to, currently there is a lot of checking client side for \"if type = range then rename the key to this.....\" which with a simple configuration option on a per aggregation basis would be eliminated\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/64786188","html_url":"https://github.com/elastic/elasticsearch/issues/8681#issuecomment-64786188","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/8681","id":64786188,"node_id":"MDEyOklzc3VlQ29tbWVudDY0Nzg2MTg4","user":{"login":"clintongormley","id":56599,"node_id":"MDQ6VXNlcjU2NTk5","avatar_url":"https://avatars0.githubusercontent.com/u/56599?v=4","gravatar_id":"","url":"https://api.github.com/users/clintongormley","html_url":"https://github.com/clintongormley","followers_url":"https://api.github.com/users/clintongormley/followers","following_url":"https://api.github.com/users/clintongormley/following{/other_user}","gists_url":"https://api.github.com/users/clintongormley/gists{/gist_id}","starred_url":"https://api.github.com/users/clintongormley/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/clintongormley/subscriptions","organizations_url":"https://api.github.com/users/clintongormley/orgs","repos_url":"https://api.github.com/users/clintongormley/repos","events_url":"https://api.github.com/users/clintongormley/events{/privacy}","received_events_url":"https://api.github.com/users/clintongormley/received_events","type":"User","site_admin":false},"created_at":"2014-11-27T12:47:26Z","updated_at":"2014-11-27T12:47:26Z","author_association":"CONTRIBUTOR","body":"> The map might be returned ordered but it can be looped and given back in it's original determined order -but- with new keys (this is how ranges are returned when \"keyed\" is true) - I presume that they're built in the same way?, the order is defined by ES before the map is built so that original order/map can be in fact looped and just have the keys changed.\n\nJSON objects are unordered by definition.  They may be produced in an ordered manner by Elasticsearch but that is besides the point.  They can equally be returned in a different order, or be decoded then reencoded in a different order.\n\nAny JSON decoder which adds numeric keys to a JSON structure like that is just wrong.  I can only assume that it is working around a deficiency in the language.\n\nIf we were to support the `keyed` option on the `terms` agg, then I'm not sure it would return the structure that you're after.  Your last example isn't valid JSON - it should either be:\n\n```\n{\n  \"buckets\": {\n    \"one\": {\n      \"key\": \"one\",\n      \"doc_count\": 1\n    },\n    \"two\": {\n      \"key\": \"two\",\n      \"doc_count\": 1\n    }\n  }\n}\n```\n\nor:\n\n```\n{\n  \"buckets\": [\n    {\n      \"one\": {\n        \"key\": \"one\",\n        \"doc_count\": 1\n      }\n    },\n    {\n      \"two\": {\n        \"key\": \"two\",\n        \"doc_count\": 1\n      }\n    }\n  ]\n}\n```\n\nThe first one is the equivalent of the output from a keyed  `range` aggregation, and loses order (because it returns a JSON object, not an array).\n\nThe second one maintains order, but adds a level of indirection (the key) that is of no benefit. Also, if I understand your description of how your JSON decoder works, it would just end up producing:\n\n```\n{\n  \"buckets\": [\n    {\n      \"0\": {\n        \"one\": {\n          \"key\": \"one\",\n          \"doc_count\": 1\n        }\n      }\n    },\n    {\n      \"1\": {\n        \"two\": {\n          \"key\": \"two\",\n          \"doc_count\": 1\n        }\n      }\n    }\n  ]\n}\n```\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/64789191","html_url":"https://github.com/elastic/elasticsearch/issues/8681#issuecomment-64789191","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/8681","id":64789191,"node_id":"MDEyOklzc3VlQ29tbWVudDY0Nzg5MTkx","user":{"login":"NodexTech","id":6095811,"node_id":"MDQ6VXNlcjYwOTU4MTE=","avatar_url":"https://avatars1.githubusercontent.com/u/6095811?v=4","gravatar_id":"","url":"https://api.github.com/users/NodexTech","html_url":"https://github.com/NodexTech","followers_url":"https://api.github.com/users/NodexTech/followers","following_url":"https://api.github.com/users/NodexTech/following{/other_user}","gists_url":"https://api.github.com/users/NodexTech/gists{/gist_id}","starred_url":"https://api.github.com/users/NodexTech/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/NodexTech/subscriptions","organizations_url":"https://api.github.com/users/NodexTech/orgs","repos_url":"https://api.github.com/users/NodexTech/repos","events_url":"https://api.github.com/users/NodexTech/events{/privacy}","received_events_url":"https://api.github.com/users/NodexTech/received_events","type":"User","site_admin":false},"created_at":"2014-11-27T13:17:35Z","updated_at":"2014-11-27T13:19:47Z","author_association":"NONE","body":"OK I think we're getting off point here. My feature suggestion is not to argue the language semantic differences between maps, hashes, arrays etc. I don't think I've explained how to achieve desired results very well. I do not know any Java so I will have to make do with Javascript and hope that my psuedo code comes across okay.\n\n```\n/*\n for the sake of the code I am assuming that with no sorting or ordering on an aggregation that ES gives me this back for a specific aggregation (this is a JSON object in Javascript)\n*/\n    var buckets=[\n            {\n            \"key\" : \"one\",\n            \"doc_count\" : 5,\n            },\n            {\n            \"key\" : \"three\",\n            \"doc_count\" : 3\n            },\n            {\n            \"key\" : \"two\",\n            \"doc_count\" : 1\n            }\n];\n\n/*  \n Now internaly we know the order because it's right above us in a variable called \"buckets\"\n we can now create a NEW bucket array USING the above order to create the CORRECT mapping BUT adding a key...\n*/\n    var buckets_keyed=[];\n    buckets.forEach(function($value,$key){\n        buckets_keyed[$value['key']]=buckets[$key];\n    });\n/*\n    give us...\n[\n    {\n        \"one\": {\n            \"key\": \"one\",\n            \"doc_count\": 5\n        },\n        \"three\": {\n            \"key\": \"three\",\n            \"doc_count\": 3\n        },\n        \"two\": {\n            \"key\": \"two\",\n            \"doc_count\": 1\n        }\n    }\n]\n/*\nas the variable \"buckets_keyed\" which maintained it's ORIGINAL order\nvar buckets=buckets_keyed; <--- now has the chosen order that ES or the client decided upon\nand also has key names for normalisation (obvisouly as an OPTION not by default.... \n\n*/\n```\n\nSo I cannot see how the mapping and ordering is not maintained, obviously it's an extra step which is why it will carry optional performance penalties (as with most optional things)\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/64790265","html_url":"https://github.com/elastic/elasticsearch/issues/8681#issuecomment-64790265","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/8681","id":64790265,"node_id":"MDEyOklzc3VlQ29tbWVudDY0NzkwMjY1","user":{"login":"clintongormley","id":56599,"node_id":"MDQ6VXNlcjU2NTk5","avatar_url":"https://avatars0.githubusercontent.com/u/56599?v=4","gravatar_id":"","url":"https://api.github.com/users/clintongormley","html_url":"https://github.com/clintongormley","followers_url":"https://api.github.com/users/clintongormley/followers","following_url":"https://api.github.com/users/clintongormley/following{/other_user}","gists_url":"https://api.github.com/users/clintongormley/gists{/gist_id}","starred_url":"https://api.github.com/users/clintongormley/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/clintongormley/subscriptions","organizations_url":"https://api.github.com/users/clintongormley/orgs","repos_url":"https://api.github.com/users/clintongormley/repos","events_url":"https://api.github.com/users/clintongormley/events{/privacy}","received_events_url":"https://api.github.com/users/clintongormley/received_events","type":"User","site_admin":false},"created_at":"2014-11-27T13:28:13Z","updated_at":"2014-11-27T13:28:13Z","author_association":"CONTRIBUTOR","body":"> /*\n>  for the sake of the code I am assuming that with no sorting or ordering on an aggregation that ES gives me this back for a specific aggregation (this is a JSON object in Javascript)\n> */\n>     var buckets=[\n\nThis is not a JSON object.  This is an array.  A JSON object would look like this:\n\n```\nvar buckets = {...}\n```\n\n> ```\n> give us...\n> ```\n> \n> [\n>    {\n>        \"one\": {\n>            \"key\": \"one\",\n>            \"doc_count\": 5\n>        },\n>        \"three\": {\n>            \"key\": \"three\",\n>            \"doc_count\": 3\n>        },\n>        \"two\": {\n>            \"key\": \"two\",\n>            \"doc_count\": 1\n>        }\n>    }\n> ]\n\nYou now have an array with one element, containing an **unordered** JSON object.  JSON objects do not preserve order.  The first line on http://www.json.org/javadoc/org/json/JSONObject.html says: \n\n```\nA JSONObject is an unordered collection of name/value pairs.\n```\n\nYou cannot have a JSON object that is ordered.  It is part of the definition.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/64792444","html_url":"https://github.com/elastic/elasticsearch/issues/8681#issuecomment-64792444","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/8681","id":64792444,"node_id":"MDEyOklzc3VlQ29tbWVudDY0NzkyNDQ0","user":{"login":"NodexTech","id":6095811,"node_id":"MDQ6VXNlcjYwOTU4MTE=","avatar_url":"https://avatars1.githubusercontent.com/u/6095811?v=4","gravatar_id":"","url":"https://api.github.com/users/NodexTech","html_url":"https://github.com/NodexTech","followers_url":"https://api.github.com/users/NodexTech/followers","following_url":"https://api.github.com/users/NodexTech/following{/other_user}","gists_url":"https://api.github.com/users/NodexTech/gists{/gist_id}","starred_url":"https://api.github.com/users/NodexTech/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/NodexTech/subscriptions","organizations_url":"https://api.github.com/users/NodexTech/orgs","repos_url":"https://api.github.com/users/NodexTech/repos","events_url":"https://api.github.com/users/NodexTech/events{/privacy}","received_events_url":"https://api.github.com/users/NodexTech/received_events","type":"User","site_admin":false},"created_at":"2014-11-27T13:50:25Z","updated_at":"2014-11-27T13:59:13Z","author_association":"NONE","body":"Yes UN-Ordered by the language specifics but we've given it an order ourselves else ES would never be able to order something and then send it out in some form of order and there would be chaos.\n\nMy code was showing how it can be done in Javascript, the semantics of the language are not relevant. In this case, the relevance is that ES can and does allow \"key-ing\" (for lack of a better word!) of array members for ranges and NOT for terms (and perhaps others) so I know it can be done in ES but for some reason it's not an option to have it done. \n\nAgain I don't think I'm explaining things very well but here goes again.\n\nRanges (normal and date) allow for this kind of response (ordered by however ES defaultly orders them - which is by \"doc_count\"), this is triggered by an option called \"keyed\"\n\n```\n{\n        \"foo\": {\n            \"key\": \"foo\",\n            \"doc_count\": 50\n        }\n    },\n    {\n        \"bar\": {\n            \"key\": \"bar\",\n            \"doc_count\": \"45\"\n        }\n    }\n```\n\n...... Whereas \"terms\" aggregations don't allow the option \"keyed\". What I am suggesting is to allow the option and it will simply be a second cycle to re-key the output to more represent what a \"keyed\" range output looks like - the order is maintained because it's already been set by creating the original array/map/bucket set, all that would happen is a simple walk through the original array/map/bucket set (which maintains the order as set by ES / the client/user) and build a NEW bucket set, then copy it over the top of the old one (replace the old one). Keys are now normalised and predictable so one can say a key is always a key not just a pointer to the current array iteration and the order is maintained and predictable (because it's not been changed).\n\nJSON arrays are on-ordered for a very good reason; which, is predictability This is so a client doesn't have to search an array each time to find a key to then extract said part of the array, i/e what gets fed into a JSON string even after serialization/de-serialization in any language (as long as the language doesn't apply some form of array sorting) you will ALWAYS get back out the same order you put in. Sometimes in ES the order (in terms of ranges) is determined by ES and you can only sort / order by things asc/desc - this doesn't always make sense to do because sometimes people want to set the order themselves which has no corresponding sorting algorithm (asc/desc or whatever in ES), fortunately when aggregating ranges we can key things which allows us to do the arbitrary sort on the client side.\n\nAs an example, SOLR (also Lucene based) gives you aggregations (they're called facets in SOLR) back in the order that you gave them in by DEFAULT and also allows you to sort them in various ways - this is a lot more flexible but also a little off the topic.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/158684796","html_url":"https://github.com/elastic/elasticsearch/issues/8681#issuecomment-158684796","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/8681","id":158684796,"node_id":"MDEyOklzc3VlQ29tbWVudDE1ODY4NDc5Ng==","user":{"login":"clintongormley","id":56599,"node_id":"MDQ6VXNlcjU2NTk5","avatar_url":"https://avatars0.githubusercontent.com/u/56599?v=4","gravatar_id":"","url":"https://api.github.com/users/clintongormley","html_url":"https://github.com/clintongormley","followers_url":"https://api.github.com/users/clintongormley/followers","following_url":"https://api.github.com/users/clintongormley/following{/other_user}","gists_url":"https://api.github.com/users/clintongormley/gists{/gist_id}","starred_url":"https://api.github.com/users/clintongormley/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/clintongormley/subscriptions","organizations_url":"https://api.github.com/users/clintongormley/orgs","repos_url":"https://api.github.com/users/clintongormley/repos","events_url":"https://api.github.com/users/clintongormley/events{/privacy}","received_events_url":"https://api.github.com/users/clintongormley/received_events","type":"User","site_admin":false},"created_at":"2015-11-21T21:55:45Z","updated_at":"2015-11-21T21:55:45Z","author_association":"CONTRIBUTOR","body":"Reread this ticket and I still don't get the point.  There has been no further interest in the last year, so I'm going to close this\n","performed_via_github_app":null}]