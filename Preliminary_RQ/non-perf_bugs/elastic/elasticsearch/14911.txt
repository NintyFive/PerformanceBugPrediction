{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/14911","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/14911/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/14911/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/14911/events","html_url":"https://github.com/elastic/elasticsearch/issues/14911","id":118201788,"node_id":"MDU6SXNzdWUxMTgyMDE3ODg=","number":14911,"title":"rejected task exception with ES Java BulkProcessor","user":{"login":"rrphotosoft","id":4465221,"node_id":"MDQ6VXNlcjQ0NjUyMjE=","avatar_url":"https://avatars3.githubusercontent.com/u/4465221?v=4","gravatar_id":"","url":"https://api.github.com/users/rrphotosoft","html_url":"https://github.com/rrphotosoft","followers_url":"https://api.github.com/users/rrphotosoft/followers","following_url":"https://api.github.com/users/rrphotosoft/following{/other_user}","gists_url":"https://api.github.com/users/rrphotosoft/gists{/gist_id}","starred_url":"https://api.github.com/users/rrphotosoft/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/rrphotosoft/subscriptions","organizations_url":"https://api.github.com/users/rrphotosoft/orgs","repos_url":"https://api.github.com/users/rrphotosoft/repos","events_url":"https://api.github.com/users/rrphotosoft/events{/privacy}","received_events_url":"https://api.github.com/users/rrphotosoft/received_events","type":"User","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":5,"created_at":"2015-11-21T15:02:20Z","updated_at":"2015-11-22T11:22:08Z","closed_at":"2015-11-22T10:47:22Z","author_association":"NONE","active_lock_reason":null,"body":"Hi,\nI am using Elasticsearch 1.4.4.and processing several documents using a BlockingThreadPoolExecutor.\nThe last step in the process(on each thread) is to index the document into elasticsearch. For this I'm using the BulkProcessor API.\nI instantiate a bulkprocessor in the main thread, and pass it into the thread pool, and it is used by all the threads. I did this because I noticed that it internally uses a 'synchronized' add method, and the class description mentions \"thread safe\".\n\nMy problem is that I'm seeing a RejectedTaskExecution exception. Sometimes it shows up after just a couple of hundred requests at other times after several thousand. Irrespective, it shows up each and every time. \n\nMy blockingthreadpoolexecutor uses a semaphore internally to throttle requests. And it is backed by an ArrayBlockingQueue. \n\nTo ensure that the issue was related  with the call to BulkProcessor, I replaced the call to BulkProcessor.add(....) with a simple Thread.sleep(10,TimeUnit.seconds). My threadpoolexecutor works as expected.\n\nI am including the relevant code below.\nI hope I'm not doing something wrong, but I'm new to ES on the java api, any help is appreciated.\n\n```\nBlockingThreadPoolExecutor.java\n\npublic class BlockingThreadPoolExecutor extends ThreadPoolExecutor {\nprivate final Semaphore semaphore;\n\npublic BlockingThreadPoolExecutor(int corePoolSize, int maximumPoolSize,\n        long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue) {\n    super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);\n    semaphore = new Semaphore(corePoolSize + 50);\n}\n\n@Override\nprotected void beforeExecute(Thread t, Runnable r) {\n    super.beforeExecute(t, r);\n}\n\n@Override\npublic void execute(final Runnable task) {\n    boolean acquired = false;\n\n    do {\n        try {\n            semaphore.acquire();\n\n            acquired = true;\n\n        } catch (final InterruptedException e) {\n\n        }\n    } while (!acquired);\n    try {\n\n        super.execute(task);\n    } catch (final RejectedExecutionException e) {\n        semaphore.release();\n        throw e;\n    }\n\n}\n\n@Override\nprotected void afterExecute(Runnable r, Throwable t) {\n    super.afterExecute(r, t);\n    if (t != null) {\n        t.printStackTrace();\n    }\n    semaphore.release();\n}\n}\n```\n\nThis is the main class from where everything is executed.\n\n```\nMain.java\n\npublic class Main{\npublic static void main(String[] args){\n\n          BulkProcessor processor = BulkProcessor\n            .builder(ElasticClientHolder.getInstance(), new Listener() {\n\n                @Override\n                public void beforeBulk(long executionId, BulkRequest request) {\n                    // TODO Auto-generated method stub\n\n                }\n\n                @Override\n                public void afterBulk(long executionId,\n                        BulkRequest request, Throwable failure) {\n                    // TODO Auto-generated method stub\n\n                }\n\n                @Override\n                public void afterBulk(long executionId,\n                        BulkRequest request, BulkResponse response) {\n                    // TODO Auto-generated method stub\n                }\n            }).setBulkActions(500).build();\n\n\n\n         BlockingQueue<Runnable> blockingQueue = new ArrayBlockingQueue<Runnable>(\n            50);\n     BlockingThreadPoolExecutor executor = new BlockingThreadPoolExecutor(\n            1, 2, 5000, TimeUnit.MILLISECONDS, blockingQueue);\n\n        for(int i=0; i < 10000; i++){\n\n                  MyBulkRunnable runnable = new MyBulkRunnable(processor);\n                 executor.execute(runnable);\n\n        }\n\n       executor.shutDown();\n       while(!executor.isTerminated){\n       }\n       try{\n       processor.awaitClose(30l,TimeUnit.Seconds);\n       }\n       catch(Exception e){\n       }\n}\n\npublic static class MyBulkRunnable implements Runnable {\n\n    private final BulkProcessor processor;\n\n    public MyBulkRunnable(BulkProcessor processor){\n        this.processor = processor;\n    }\n\n    @Override\n    public void run() {\n        // TODO Auto-generated method stub\n\n        this.processor.add(new IndexRequest(\"test_index\",\n                \"test_type\").source(new HashMap<String, Object>() {\n            {\n                put(\"test_thread\", Thread.currentThread().getId());\n            }\n        }));\n\n    }\n\n}\n\n}\n```\n","closed_by":{"login":"danielmitterdorfer","id":1699576,"node_id":"MDQ6VXNlcjE2OTk1NzY=","avatar_url":"https://avatars3.githubusercontent.com/u/1699576?v=4","gravatar_id":"","url":"https://api.github.com/users/danielmitterdorfer","html_url":"https://github.com/danielmitterdorfer","followers_url":"https://api.github.com/users/danielmitterdorfer/followers","following_url":"https://api.github.com/users/danielmitterdorfer/following{/other_user}","gists_url":"https://api.github.com/users/danielmitterdorfer/gists{/gist_id}","starred_url":"https://api.github.com/users/danielmitterdorfer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/danielmitterdorfer/subscriptions","organizations_url":"https://api.github.com/users/danielmitterdorfer/orgs","repos_url":"https://api.github.com/users/danielmitterdorfer/repos","events_url":"https://api.github.com/users/danielmitterdorfer/events{/privacy}","received_events_url":"https://api.github.com/users/danielmitterdorfer/received_events","type":"User","site_admin":false},"performed_via_github_app":null}