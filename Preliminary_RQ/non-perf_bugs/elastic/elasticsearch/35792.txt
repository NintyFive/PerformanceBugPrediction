{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/35792","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/35792/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/35792/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/35792/events","html_url":"https://github.com/elastic/elasticsearch/issues/35792","id":383189885,"node_id":"MDU6SXNzdWUzODMxODk4ODU=","number":35792,"title":"Periodically retry persistent task allocation","user":{"login":"droberts195","id":7405510,"node_id":"MDQ6VXNlcjc0MDU1MTA=","avatar_url":"https://avatars0.githubusercontent.com/u/7405510?v=4","gravatar_id":"","url":"https://api.github.com/users/droberts195","html_url":"https://github.com/droberts195","followers_url":"https://api.github.com/users/droberts195/followers","following_url":"https://api.github.com/users/droberts195/following{/other_user}","gists_url":"https://api.github.com/users/droberts195/gists{/gist_id}","starred_url":"https://api.github.com/users/droberts195/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/droberts195/subscriptions","organizations_url":"https://api.github.com/users/droberts195/orgs","repos_url":"https://api.github.com/users/droberts195/repos","events_url":"https://api.github.com/users/droberts195/events{/privacy}","received_events_url":"https://api.github.com/users/droberts195/received_events","type":"User","site_admin":false},"labels":[{"id":289830280,"node_id":"MDU6TGFiZWwyODk4MzAyODA=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/:Distributed/Task%20Management","name":":Distributed/Task Management","color":"0e8a16","default":false,"description":"Issues for anything around the Tasks API - both persistent and node level."},{"id":912833043,"node_id":"MDU6TGFiZWw5MTI4MzMwNDM=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/:ml","name":":ml","color":"0e8a16","default":false,"description":"Machine learning"},{"id":23174,"node_id":"MDU6TGFiZWwyMzE3NA==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/%3Eenhancement","name":">enhancement","color":"4a4ea8","default":false,"description":null},{"id":929267538,"node_id":"MDU6TGFiZWw5MjkyNjc1Mzg=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/team-discuss","name":"team-discuss","color":"fbca04","default":false,"description":""}],"state":"closed","locked":false,"assignee":{"login":"droberts195","id":7405510,"node_id":"MDQ6VXNlcjc0MDU1MTA=","avatar_url":"https://avatars0.githubusercontent.com/u/7405510?v=4","gravatar_id":"","url":"https://api.github.com/users/droberts195","html_url":"https://github.com/droberts195","followers_url":"https://api.github.com/users/droberts195/followers","following_url":"https://api.github.com/users/droberts195/following{/other_user}","gists_url":"https://api.github.com/users/droberts195/gists{/gist_id}","starred_url":"https://api.github.com/users/droberts195/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/droberts195/subscriptions","organizations_url":"https://api.github.com/users/droberts195/orgs","repos_url":"https://api.github.com/users/droberts195/repos","events_url":"https://api.github.com/users/droberts195/events{/privacy}","received_events_url":"https://api.github.com/users/droberts195/received_events","type":"User","site_admin":false},"assignees":[{"login":"droberts195","id":7405510,"node_id":"MDQ6VXNlcjc0MDU1MTA=","avatar_url":"https://avatars0.githubusercontent.com/u/7405510?v=4","gravatar_id":"","url":"https://api.github.com/users/droberts195","html_url":"https://github.com/droberts195","followers_url":"https://api.github.com/users/droberts195/followers","following_url":"https://api.github.com/users/droberts195/following{/other_user}","gists_url":"https://api.github.com/users/droberts195/gists{/gist_id}","starred_url":"https://api.github.com/users/droberts195/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/droberts195/subscriptions","organizations_url":"https://api.github.com/users/droberts195/orgs","repos_url":"https://api.github.com/users/droberts195/repos","events_url":"https://api.github.com/users/droberts195/events{/privacy}","received_events_url":"https://api.github.com/users/droberts195/received_events","type":"User","site_admin":false}],"milestone":null,"comments":3,"created_at":"2018-11-21T16:09:44Z","updated_at":"2018-12-13T09:15:28Z","closed_at":"2018-12-13T09:15:28Z","author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"Currently the persistent tasks framework attempts to allocate unallocated persistent tasks in the following situations:\r\n\r\n* Persistent tasks are changed\r\n* A node joins or leaves the cluster\r\n* The routing table is changed\r\n* Custom metadata in the cluster state is changed\r\n* A new master node is elected\r\n\r\nWhen an ML node fails we need to reallocate ML jobs according to their memory requirements, taking into account the memory requirements of other open ML jobs.  The \"A node joins or leaves the cluster\" triggers an attempt to do this, but the master node doing the reallocation may not have all the up-to-date memory usage statistics needed to make sensible reallocation decisions.  One way to solve this problem is to defer the allocation - return `null` in response to the call to the `getAssignment()` function that the failure immediately causes and instead trigger an asynchronous request to gather the necessary information.  The problem comes when the asynchronous request returns with the necessary information - at this point we need to try to reallocate the persistent tasks whose allocation was deferred again.\r\n\r\nWe discussed this in the distributed area weekly meeting and decided that the simplest and safest way to achieve this would be to have persistent tasks recheck allocations periodically, say every 30 seconds.\r\n\r\nAn alternative would be to add an endpoint to allow clients to request a recheck of unallocated persistent tasks.  But this would run the risk that a client that called the endpoint too often could cause an excessive amount of rechecking.\r\n\r\nThe proposed change is therefore:\r\n\r\n* Add a new dynamic cluster setting `cluster.persistent_tasks.allocation.recheck_interval` (default 30s) to control how frequently to recheck allocation of unallocated persistent tasks.\r\n* Change `PersistentTasksClusterService` so that the loop currently in `shouldReassignPersistentTasks()` is factored out into a new method and is also run by the timer callback, and if it returns `true` then a cluster state update is triggered that calls `PersistentTasksClusterService.reassignTasks()` to change the state.\r\n* `PersistentTasksClusterService.shouldReassignPersistentTasks()` will reset the timer so that if some cluster state update triggers an allocation check then the timer doesn't do another one shortly afterwards.","closed_by":{"login":"droberts195","id":7405510,"node_id":"MDQ6VXNlcjc0MDU1MTA=","avatar_url":"https://avatars0.githubusercontent.com/u/7405510?v=4","gravatar_id":"","url":"https://api.github.com/users/droberts195","html_url":"https://github.com/droberts195","followers_url":"https://api.github.com/users/droberts195/followers","following_url":"https://api.github.com/users/droberts195/following{/other_user}","gists_url":"https://api.github.com/users/droberts195/gists{/gist_id}","starred_url":"https://api.github.com/users/droberts195/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/droberts195/subscriptions","organizations_url":"https://api.github.com/users/droberts195/orgs","repos_url":"https://api.github.com/users/droberts195/repos","events_url":"https://api.github.com/users/droberts195/events{/privacy}","received_events_url":"https://api.github.com/users/droberts195/received_events","type":"User","site_admin":false},"performed_via_github_app":null}