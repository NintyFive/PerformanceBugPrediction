{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/28087","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/28087/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/28087/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/28087/events","html_url":"https://github.com/elastic/elasticsearch/issues/28087","id":286122587,"node_id":"MDU6SXNzdWUyODYxMjI1ODc=","number":28087,"title":"Support index specific parameters when multi-index searching","user":{"login":"scottsom","id":23276852,"node_id":"MDQ6VXNlcjIzMjc2ODUy","avatar_url":"https://avatars1.githubusercontent.com/u/23276852?v=4","gravatar_id":"","url":"https://api.github.com/users/scottsom","html_url":"https://github.com/scottsom","followers_url":"https://api.github.com/users/scottsom/followers","following_url":"https://api.github.com/users/scottsom/following{/other_user}","gists_url":"https://api.github.com/users/scottsom/gists{/gist_id}","starred_url":"https://api.github.com/users/scottsom/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/scottsom/subscriptions","organizations_url":"https://api.github.com/users/scottsom/orgs","repos_url":"https://api.github.com/users/scottsom/repos","events_url":"https://api.github.com/users/scottsom/events{/privacy}","received_events_url":"https://api.github.com/users/scottsom/received_events","type":"User","site_admin":false},"labels":[{"id":146832564,"node_id":"MDU6TGFiZWwxNDY4MzI1NjQ=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/:Search/Search","name":":Search/Search","color":"0e8a16","default":false,"description":"Search-related issues that do not fall into other categories"},{"id":111416437,"node_id":"MDU6TGFiZWwxMTE0MTY0Mzc=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/discuss","name":"discuss","color":"fbca04","default":false,"description":null}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":1,"created_at":"2018-01-04T21:45:02Z","updated_at":"2018-01-05T14:17:03Z","closed_at":"2018-01-05T14:17:03Z","author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"Today, most of the _search parameters can only be specified at the request level. However, in some situations, it may be desirable to have different values per index for the same search request.\r\n\r\nFor example, suppose I have two indexes - `index_with_routing` and `index_without_routing`. On the client side, I know which routing values go with which index. Let's say I am routing documents by user and all of the data for user_id=1 is going into `index_without_routing` and all the other users are going into `index_with_routing`. This is similar idea to the [One Big User](https://www.elastic.co/guide/en/elasticsearch/guide/current/one-big-user.html).\r\n\r\nNow I want to get the top results for a query against user_id=1 and user_id=2. The search for user_id=1 should go to `index_without_routing` without the routing parameter and the search for user_id=2 should go to `index_with_routing` with the routing parameter. To do this, I can either run each search independently and perform the reduce phase from the client side (greatly increasing my client complexity) or run the search without custom routing (negating the benefits of custom routing). Neither approach is desirable.\r\n\r\nOne way to avoid this is to add support for index -> routing mappings in the request like this:\r\n\r\n```javascript\r\nPOST /index_with_routing,index_without_routing/_search\r\n{\r\n  \"query\": {\r\n    \"terms\": {\r\n      \"user_id\": [1,2]\r\n    }\r\n  },\r\n  \"routing\": [\r\n    { \"index_with_routing\": \"2\" }\r\n  ]\r\n}\r\n```\r\n\r\nNow the request will execute against all shards in `index_without_routing` and against the shard(s) that `2` is associated with in `index_with_routing`.\r\n\r\nHowever, this is very similar to how [index boosting](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-index-boost.html) looks, so another approach and the feature I'd like to propose is to generalize this pattern into a new parameter like `index_overrides`. As is the case with boosting, this can use aliases and wildcards.\r\n\r\n```javascript\r\nPOST /index_with_routing,index_without_routing/_search\r\n{\r\n  \"query\": {\r\n    \"terms\": {\r\n      \"user_id\": [1,2]\r\n    }\r\n  },\r\n  \"index_overrides\": [\r\n    {\r\n      \"index_with_routing\": {\r\n        \"routing\": \"2\",\r\n        \"boost\": 1.4,\r\n        // ... other parameters\r\n      }\r\n    },\r\n    {\r\n      \"index_without_routing\": {\r\n        \"boost\": 1.3,\r\n        // ... other parameters\r\n      }\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\nAs future extensions, other parameters that have use cases for index specific values could also be exposed here (e.g. preference, timeouts, etc.).","closed_by":{"login":"jpountz","id":299848,"node_id":"MDQ6VXNlcjI5OTg0OA==","avatar_url":"https://avatars2.githubusercontent.com/u/299848?v=4","gravatar_id":"","url":"https://api.github.com/users/jpountz","html_url":"https://github.com/jpountz","followers_url":"https://api.github.com/users/jpountz/followers","following_url":"https://api.github.com/users/jpountz/following{/other_user}","gists_url":"https://api.github.com/users/jpountz/gists{/gist_id}","starred_url":"https://api.github.com/users/jpountz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jpountz/subscriptions","organizations_url":"https://api.github.com/users/jpountz/orgs","repos_url":"https://api.github.com/users/jpountz/repos","events_url":"https://api.github.com/users/jpountz/events{/privacy}","received_events_url":"https://api.github.com/users/jpountz/received_events","type":"User","site_admin":false},"performed_via_github_app":null}