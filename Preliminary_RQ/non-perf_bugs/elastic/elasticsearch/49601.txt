{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/49601","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/49601/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/49601/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/49601/events","html_url":"https://github.com/elastic/elasticsearch/issues/49601","id":528785264,"node_id":"MDU6SXNzdWU1Mjg3ODUyNjQ=","number":49601,"title":"Optimize distributed numeric sort for time-based indices","user":{"login":"jimczi","id":15977469,"node_id":"MDQ6VXNlcjE1OTc3NDY5","avatar_url":"https://avatars0.githubusercontent.com/u/15977469?v=4","gravatar_id":"","url":"https://api.github.com/users/jimczi","html_url":"https://github.com/jimczi","followers_url":"https://api.github.com/users/jimczi/followers","following_url":"https://api.github.com/users/jimczi/following{/other_user}","gists_url":"https://api.github.com/users/jimczi/gists{/gist_id}","starred_url":"https://api.github.com/users/jimczi/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jimczi/subscriptions","organizations_url":"https://api.github.com/users/jimczi/orgs","repos_url":"https://api.github.com/users/jimczi/repos","events_url":"https://api.github.com/users/jimczi/events{/privacy}","received_events_url":"https://api.github.com/users/jimczi/received_events","type":"User","site_admin":false},"labels":[{"id":836504707,"node_id":"MDU6TGFiZWw4MzY1MDQ3MDc=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/:Distributed/Distributed","name":":Distributed/Distributed","color":"0e8a16","default":false,"description":"A catch all label for anything in the Distributed Area. If you aren't sure, use this one."},{"id":146832564,"node_id":"MDU6TGFiZWwxNDY4MzI1NjQ=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/:Search/Search","name":":Search/Search","color":"0e8a16","default":false,"description":"Search-related issues that do not fall into other categories"},{"id":23174,"node_id":"MDU6TGFiZWwyMzE3NA==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/%3Eenhancement","name":">enhancement","color":"4a4ea8","default":false,"description":null}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":2,"created_at":"2019-11-26T15:06:25Z","updated_at":"2020-03-17T09:54:45Z","closed_at":"2020-03-17T09:54:45Z","author_association":"MEMBER","active_lock_reason":null,"body":"Today sorting by timestamp on a top-hits query that targets time-based indices doesn't take into account that the ranges of timestamp in each index don't overlap. The query phase computes the top N in each shard, independently of the results returned by shards that contain data before/after it. Considering that searches are now throttled by default and that we perform partial merges efficiently, it should be possible to record the bottom hit of the top hits after a partial merge and use it as a hint for any subsequent shard search. Each shard could then compare the bottom hit sort values with the range of values that it contains using the indexed BKD-tree and shortcut the query if the global bottom values are greater/smaller than the values contained in the shard. \r\nIn a sense that is the opposite of `search_after`.\r\nThere are multiple benefits if we apply this strategy:\r\n\r\n- Most/Least recent top hit queries on time-based indices would be considerably faster if they don't need to compute aggregations especially now that shards are [pre-sorted](https://github.com/elastic/elasticsearch/pull/49092) by the primary sort field.\r\n\r\n- Shards that contain non-competitive document would not need to keep their context open since we'd early detect that the `fetch` phase is not needed. This would also work if aggregations are needed since aggregations and top_hits can run independently.\r\n\r\n- We could automatically set the `max_concurrent_shard_requests` and `batched_reduce_size` to a low value if we detect that shards have sorted values that don't overlap. This would reduce the impact on the cluster while still providing much faster sorted queries.\r\n\r\n- We could impose a default sort on timestamp for time-based indices in order to ensure that we don't run costly queries on this type of pattern by default.\r\n\r\n","closed_by":{"login":"jimczi","id":15977469,"node_id":"MDQ6VXNlcjE1OTc3NDY5","avatar_url":"https://avatars0.githubusercontent.com/u/15977469?v=4","gravatar_id":"","url":"https://api.github.com/users/jimczi","html_url":"https://github.com/jimczi","followers_url":"https://api.github.com/users/jimczi/followers","following_url":"https://api.github.com/users/jimczi/following{/other_user}","gists_url":"https://api.github.com/users/jimczi/gists{/gist_id}","starred_url":"https://api.github.com/users/jimczi/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jimczi/subscriptions","organizations_url":"https://api.github.com/users/jimczi/orgs","repos_url":"https://api.github.com/users/jimczi/repos","events_url":"https://api.github.com/users/jimczi/events{/privacy}","received_events_url":"https://api.github.com/users/jimczi/received_events","type":"User","site_admin":false},"performed_via_github_app":null}