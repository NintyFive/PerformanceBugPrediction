{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/55564","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/55564/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/55564/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/55564/events","html_url":"https://github.com/elastic/elasticsearch/issues/55564","id":604378824,"node_id":"MDU6SXNzdWU2MDQzNzg4MjQ=","number":55564,"title":"Perform a full cluster restart , and recovery will be performed twice","user":{"login":"chengyang14","id":64069615,"node_id":"MDQ6VXNlcjY0MDY5NjE1","avatar_url":"https://avatars0.githubusercontent.com/u/64069615?v=4","gravatar_id":"","url":"https://api.github.com/users/chengyang14","html_url":"https://github.com/chengyang14","followers_url":"https://api.github.com/users/chengyang14/followers","following_url":"https://api.github.com/users/chengyang14/following{/other_user}","gists_url":"https://api.github.com/users/chengyang14/gists{/gist_id}","starred_url":"https://api.github.com/users/chengyang14/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/chengyang14/subscriptions","organizations_url":"https://api.github.com/users/chengyang14/orgs","repos_url":"https://api.github.com/users/chengyang14/repos","events_url":"https://api.github.com/users/chengyang14/events{/privacy}","received_events_url":"https://api.github.com/users/chengyang14/received_events","type":"User","site_admin":false},"labels":[{"id":881394071,"node_id":"MDU6TGFiZWw4ODEzOTQwNzE=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/:Distributed/Cluster%20Coordination","name":":Distributed/Cluster Coordination","color":"0e8a16","default":false,"description":"Cluster formation and cluster state publication, including cluster membership and fault detection."},{"id":23173,"node_id":"MDU6TGFiZWwyMzE3Mw==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/%3Ebug","name":">bug","color":"b60205","default":false,"description":null}],"state":"closed","locked":false,"assignee":{"login":"DaveCTurner","id":5058284,"node_id":"MDQ6VXNlcjUwNTgyODQ=","avatar_url":"https://avatars3.githubusercontent.com/u/5058284?v=4","gravatar_id":"","url":"https://api.github.com/users/DaveCTurner","html_url":"https://github.com/DaveCTurner","followers_url":"https://api.github.com/users/DaveCTurner/followers","following_url":"https://api.github.com/users/DaveCTurner/following{/other_user}","gists_url":"https://api.github.com/users/DaveCTurner/gists{/gist_id}","starred_url":"https://api.github.com/users/DaveCTurner/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/DaveCTurner/subscriptions","organizations_url":"https://api.github.com/users/DaveCTurner/orgs","repos_url":"https://api.github.com/users/DaveCTurner/repos","events_url":"https://api.github.com/users/DaveCTurner/events{/privacy}","received_events_url":"https://api.github.com/users/DaveCTurner/received_events","type":"User","site_admin":false},"assignees":[{"login":"DaveCTurner","id":5058284,"node_id":"MDQ6VXNlcjUwNTgyODQ=","avatar_url":"https://avatars3.githubusercontent.com/u/5058284?v=4","gravatar_id":"","url":"https://api.github.com/users/DaveCTurner","html_url":"https://github.com/DaveCTurner","followers_url":"https://api.github.com/users/DaveCTurner/followers","following_url":"https://api.github.com/users/DaveCTurner/following{/other_user}","gists_url":"https://api.github.com/users/DaveCTurner/gists{/gist_id}","starred_url":"https://api.github.com/users/DaveCTurner/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/DaveCTurner/subscriptions","organizations_url":"https://api.github.com/users/DaveCTurner/orgs","repos_url":"https://api.github.com/users/DaveCTurner/repos","events_url":"https://api.github.com/users/DaveCTurner/events{/privacy}","received_events_url":"https://api.github.com/users/DaveCTurner/received_events","type":"User","site_admin":false}],"milestone":null,"comments":3,"created_at":"2020-04-22T01:06:48Z","updated_at":"2020-04-29T10:55:13Z","closed_at":"2020-04-29T10:55:13Z","author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"**Elasticsearch version** (`bin/elasticsearch --version`): 7.6.0\r\n\r\nIn[#42576](https://github.com/elastic/elasticsearch/pull/42576) , the state recovery will be reset after successful recovery, and it will have the side effect of triggering the recovery twice.\r\n\r\nI configured the following parameters：\r\n```\r\ngateway.expected_nodes :  80% of the number of nodes\r\ngateway.expected_data_nodes: 80% of the number of date nodes\r\ngateway.expected_master_nodes : 3\r\ngateway.recover_after_time  : 15min\r\n```\r\n\r\nStep1:\r\nThe master start a scheduled tasks for scheduled recovery ,and tthe task will execute  `recoveryRunnable.run()` method after `gateway.recover_after_time`(15min).\r\n```\r\nscheduledRecovery:true\r\nrecoveryInProgress:false\r\n```\r\n```java\r\nprivate void performStateRecovery(final boolean enforceRecoverAfterTime, final String reason) {\r\n      if (enforceRecoverAfterTime && recoverAfterTime != null) {\r\n          if (scheduledRecovery.compareAndSet(false, true)) {\r\n              logger.info(\"delaying initial state recovery for [{}]. {}\", recoverAfterTime, reason);\r\n              threadPool.schedule(new AbstractRunnable() {\r\n                  @Override\r\n                  public void onFailure(Exception e) {\r\n                      logger.warn(\"delayed state recovery failed\", e);\r\n                      resetRecoveredFlags();\r\n                  }\r\n\r\n                  @Override\r\n                  protected void doRun() {\r\n                      if (recoveryInProgress.compareAndSet(false, true)) {\r\n                          logger.info(\"recover_after_time [{}] elapsed. performing state recovery...\", recoverAfterTime);\r\n                          recoveryRunnable.run();\r\n                      }\r\n                  }\r\n              }, recoverAfterTime, ThreadPool.Names.GENERIC);\r\n          }\r\n```\r\n\r\nStep2:\r\nAfter the parameters `gateway.expected_nodes` ,`gateway.expected_data_nodes`，`gateway.expected_master_nodes`  meet requirements all meet the requirements, the recovery is started.\r\n```\r\nscheduledRecovery:true\r\nrecoveryInProgress:true\r\n```\r\n\r\n```java\r\nif (recoveryInProgress.compareAndSet(false, true)) {\r\n                threadPool.generic().execute(new AbstractRunnable() {\r\n                    @Override\r\n                    public void onFailure(final Exception e) {\r\n                        logger.warn(\"state recovery failed\", e);\r\n                        resetRecoveredFlags();\r\n                    }\r\n\r\n                    @Override\r\n                    protected void doRun() {\r\n                        recoveryRunnable.run();\r\n                    }\r\n                });\r\n            }\r\n```\r\nStep3:\r\nReset state recovery after successful recovery.\r\n```\r\nscheduledRecovery:false\r\nrecoveryInProgress:false\r\n```\r\n```java\r\n@Override\r\npublic void clusterStateProcessed(final String source, final ClusterState oldState, final ClusterState newState) {\r\n    logger.info(\"recovered [{}] indices into cluster_state\", newState.metadata().indices().size());\r\n    // reset flag even though state recovery completed, to ensure that if we subsequently become leader again based on a\r\n    // not-recovered state, that we again do another state recovery.\r\n    resetRecoveredFlags();\r\n}\r\n```\r\nStep4:\r\n***Because `RecoveryInProgress: false`, 15 minutes after step1 is executed, recovery starts again.***\r\n```java\r\nprivate void performStateRecovery(final boolean enforceRecoverAfterTime, final String reason) {\r\n       if (enforceRecoverAfterTime && recoverAfterTime != null) {\r\n           if (scheduledRecovery.compareAndSet(false, true)) {\r\n               logger.info(\"delaying initial state recovery for [{}]. {}\", recoverAfterTime, reason);\r\n               threadPool.schedule(new AbstractRunnable() {\r\n                   @Override\r\n                   public void onFailure(Exception e) {\r\n                       logger.warn(\"delayed state recovery failed\", e);\r\n                       resetRecoveredFlags();\r\n                   }\r\n\r\n                   @Override\r\n                   protected void doRun() {\r\n                       if (recoveryInProgress.compareAndSet(false, true)) {\r\n                           logger.info(\"recover_after_time [{}] elapsed. performing state recovery...\", recoverAfterTime);\r\n                           recoveryRunnable.run();\r\n                       }\r\n                   }\r\n               }, recoverAfterTime, ThreadPool.Names.GENERIC);\r\n           }\r\n       } else {\r\n```\r\n","closed_by":{"login":"DaveCTurner","id":5058284,"node_id":"MDQ6VXNlcjUwNTgyODQ=","avatar_url":"https://avatars3.githubusercontent.com/u/5058284?v=4","gravatar_id":"","url":"https://api.github.com/users/DaveCTurner","html_url":"https://github.com/DaveCTurner","followers_url":"https://api.github.com/users/DaveCTurner/followers","following_url":"https://api.github.com/users/DaveCTurner/following{/other_user}","gists_url":"https://api.github.com/users/DaveCTurner/gists{/gist_id}","starred_url":"https://api.github.com/users/DaveCTurner/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/DaveCTurner/subscriptions","organizations_url":"https://api.github.com/users/DaveCTurner/orgs","repos_url":"https://api.github.com/users/DaveCTurner/repos","events_url":"https://api.github.com/users/DaveCTurner/events{/privacy}","received_events_url":"https://api.github.com/users/DaveCTurner/received_events","type":"User","site_admin":false},"performed_via_github_app":null}