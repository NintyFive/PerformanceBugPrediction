{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/54069","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/54069/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/54069/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/54069/events","html_url":"https://github.com/elastic/elasticsearch/issues/54069","id":586884043,"node_id":"MDU6SXNzdWU1ODY4ODQwNDM=","number":54069,"title":"Clarify async search REST parameters","user":{"login":"javanna","id":832460,"node_id":"MDQ6VXNlcjgzMjQ2MA==","avatar_url":"https://avatars1.githubusercontent.com/u/832460?v=4","gravatar_id":"","url":"https://api.github.com/users/javanna","html_url":"https://github.com/javanna","followers_url":"https://api.github.com/users/javanna/followers","following_url":"https://api.github.com/users/javanna/following{/other_user}","gists_url":"https://api.github.com/users/javanna/gists{/gist_id}","starred_url":"https://api.github.com/users/javanna/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/javanna/subscriptions","organizations_url":"https://api.github.com/users/javanna/orgs","repos_url":"https://api.github.com/users/javanna/repos","events_url":"https://api.github.com/users/javanna/events{/privacy}","received_events_url":"https://api.github.com/users/javanna/received_events","type":"User","site_admin":false},"labels":[{"id":146832564,"node_id":"MDU6TGFiZWwxNDY4MzI1NjQ=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/:Search/Search","name":":Search/Search","color":"0e8a16","default":false,"description":"Search-related issues that do not fall into other categories"},{"id":23174,"node_id":"MDU6TGFiZWwyMzE3NA==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/%3Eenhancement","name":">enhancement","color":"4a4ea8","default":false,"description":null},{"id":929267538,"node_id":"MDU6TGFiZWw5MjkyNjc1Mzg=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/team-discuss","name":"team-discuss","color":"fbca04","default":false,"description":""}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":15,"created_at":"2020-03-24T11:18:19Z","updated_at":"2020-03-26T08:40:06Z","closed_at":"2020-03-26T08:40:06Z","author_association":"MEMBER","active_lock_reason":null,"body":"When playing with the new async search API I noticed a couple of inconsistencies and potential naming problems that I would like to discuss. Note that it's important to address these now as the API haven't been released yet and they are declared stable in our REST spec.\r\n\r\nI asked @karmi for his input to validate my concerns and come up with some proposal. The following are the problems and the changes that we are proposing:\r\n\r\n- `wait_for_completion`: it indicates how long you are willing to block and wait for results when submitting an async search, effectively turning async search to sync.\r\n`wait_for_completion` is used in other API but with type `boolean`, while it is exposed as a `number`, effectively a timeout, in submit async search. This introduces inconsistency in our REST API, and it will cause issues for some of the language clients.\r\n**Proposal**: rename it to `wait_for_results_timeout`: this way we include the timeout terminology and we don't reuse the existing `wait_for_completion`. Also `results` better explains what it is that users are waiting for compared to `completion`.\r\n\r\n- `keep_alive`: it indicates how long the async search is available within the cluster. That means that when such timeout expires, the search will be stopped if still running or its results will be purged if it has already completed. \r\nThe `keep_alive` naming comes from http terminology where it has to do with connections, while here the semantics is around how long state will be available/stored in the cluster, which could lead to misinterpreting what the parameter does.\r\n**Proposal**: rename it to `keep_results_timeout`: this way we move away from reusing http terminology, and we make it clear that it's also a timeout around how long results will be available. Maybe what is not super clear about this is that the counting starts when the async search is submitted, not when it is completed. Suggestions are welcome.\r\n\r\n- `clean_on_completion`: it indicates whether results should not be stored once they are returned within the above described timeout. \r\nThere is some double negation in its description that makes it hard to understand it. Also, the notion of `completion` can be confusing as it's not about whether the search was completed but whether the results were returned within the provided (currently `wait_for_completion`) timeout. By default, results are not stored when they are returned directly by submit async search. Being it a `boolean` it may make users think that they can disable storing results at all times, but storing results can not be disabled, rightly so, when submit async search did not return them within the timeout. \r\nI considered removing this parameter, because when results have been returned, they could be stored externally. It turns out though that this parameter is useful to make testing deterministic and it makes sense to keep it.\r\n**Proposal**: rename it to `keep_results` and make it an `enum` rather than a `boolean` with two possible values: `auto` (the default behaviour: store results unless submit async search returned them within `keep_results_timeout`) and `always` (store results for later retrieval even if they have been returned by submit async search within the provided timeout). I find that this better reflects the behaviour of the API and aligns well with the above proposed rename of `keep_alive` to `keep_results_timeout` as they are somehow related. Note that `always` does not mean forever, the results will always be cleaned when their validity expires.\r\n\r\n- The rename of `wait_for_completion` to `wait_for_results_timeout` should also be applied to the get async search API, but maybe we should consider whether this parameter is useful when retrieving results? Users that are calling get async search are taking advantage of the async nature of async search, hence while I see why one would block and wait when submitting, I don't see why one would block and wait when retrieving results. Is avoiding an additional call when the search is almost complete a good enough reason to expose this parameter?\r\n\r\n\r\n\r\n","closed_by":{"login":"javanna","id":832460,"node_id":"MDQ6VXNlcjgzMjQ2MA==","avatar_url":"https://avatars1.githubusercontent.com/u/832460?v=4","gravatar_id":"","url":"https://api.github.com/users/javanna","html_url":"https://github.com/javanna","followers_url":"https://api.github.com/users/javanna/followers","following_url":"https://api.github.com/users/javanna/following{/other_user}","gists_url":"https://api.github.com/users/javanna/gists{/gist_id}","starred_url":"https://api.github.com/users/javanna/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/javanna/subscriptions","organizations_url":"https://api.github.com/users/javanna/orgs","repos_url":"https://api.github.com/users/javanna/repos","events_url":"https://api.github.com/users/javanna/events{/privacy}","received_events_url":"https://api.github.com/users/javanna/received_events","type":"User","site_admin":false},"performed_via_github_app":null}