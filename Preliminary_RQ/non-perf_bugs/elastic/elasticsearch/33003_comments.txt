[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/414583370","html_url":"https://github.com/elastic/elasticsearch/issues/33003#issuecomment-414583370","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/33003","id":414583370,"node_id":"MDEyOklzc3VlQ29tbWVudDQxNDU4MzM3MA==","user":{"login":"elasticmachine","id":15837671,"node_id":"MDQ6VXNlcjE1ODM3Njcx","avatar_url":"https://avatars3.githubusercontent.com/u/15837671?v=4","gravatar_id":"","url":"https://api.github.com/users/elasticmachine","html_url":"https://github.com/elasticmachine","followers_url":"https://api.github.com/users/elasticmachine/followers","following_url":"https://api.github.com/users/elasticmachine/following{/other_user}","gists_url":"https://api.github.com/users/elasticmachine/gists{/gist_id}","starred_url":"https://api.github.com/users/elasticmachine/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/elasticmachine/subscriptions","organizations_url":"https://api.github.com/users/elasticmachine/orgs","repos_url":"https://api.github.com/users/elasticmachine/repos","events_url":"https://api.github.com/users/elasticmachine/events{/privacy}","received_events_url":"https://api.github.com/users/elasticmachine/received_events","type":"User","site_admin":false},"created_at":"2018-08-21T07:50:44Z","updated_at":"2018-08-21T07:50:44Z","author_association":"COLLABORATOR","body":"Pinging @elastic/es-search-aggs","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/414625357","html_url":"https://github.com/elastic/elasticsearch/issues/33003#issuecomment-414625357","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/33003","id":414625357,"node_id":"MDEyOklzc3VlQ29tbWVudDQxNDYyNTM1Nw==","user":{"login":"jpountz","id":299848,"node_id":"MDQ6VXNlcjI5OTg0OA==","avatar_url":"https://avatars2.githubusercontent.com/u/299848?v=4","gravatar_id":"","url":"https://api.github.com/users/jpountz","html_url":"https://github.com/jpountz","followers_url":"https://api.github.com/users/jpountz/followers","following_url":"https://api.github.com/users/jpountz/following{/other_user}","gists_url":"https://api.github.com/users/jpountz/gists{/gist_id}","starred_url":"https://api.github.com/users/jpountz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jpountz/subscriptions","organizations_url":"https://api.github.com/users/jpountz/orgs","repos_url":"https://api.github.com/users/jpountz/repos","events_url":"https://api.github.com/users/jpountz/events{/privacy}","received_events_url":"https://api.github.com/users/jpountz/received_events","type":"User","site_admin":false},"created_at":"2018-08-21T10:17:23Z","updated_at":"2018-08-21T10:17:23Z","author_association":"CONTRIBUTOR","body":"The initial example on #25312 suggests that object fields would be indexed like text since it indexes `city: \"New York\"` as `[ \"city:new\", \"city:york\" ]` but your plan here doesn't mention analysis and gives examples with fields that are usually indexed as keywords like `referer` and `content-type`. Which route do we want to follow? Keyword-like indexing could be achieved with a `keyword` analyzer, but I feel like there is more ask for actual keywords which might enable support for aggregations in the future like you mentioned.\r\n\r\n> Additionally, tokens are created for each value alone: text/html, https://google.com\r\n\r\nWhy do we plan to index individual tokens alone? I suspect most users won't want/need to search the entire object, meaning that this feature will double the size of the inverted index for a feature they don't need? Since you already mentioned having some sort of `copy_to` support, it could be a way that users who need this feature could copy the content of all fields to another catch-all field?\r\n\r\n> As a first pass, the following query types will be allowed: term, terms, terms_set, range (without special support for numerics), prefix, match family (insofar as they work for keyword fields), common, query_string, simple_query_string, exists. Highlighting will be supported.\r\n\r\nIf we go with keyword-style indexing, then we should probably skip highlighting, which is only useful with text fields? (matched queries are typically used instead for structured content)\r\n\r\n> Explore adding support for aggregations + sorting. This idea needs a lot more research, but could maybe be accomplished by creating additional 'doc value fields', then adding a filtering layer when fetching doc values that checks for the field prefix.\r\n\r\n+1 I suspect it will be quite easy actually.\r\n\r\n> Create benchmarks for searching based on object keys.\r\n\r\nThat would be nice of course, but I'm not worried about it being slow since term queries on an indexed object would translate to a term query at the lucene level.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/414835137","html_url":"https://github.com/elastic/elasticsearch/issues/33003#issuecomment-414835137","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/33003","id":414835137,"node_id":"MDEyOklzc3VlQ29tbWVudDQxNDgzNTEzNw==","user":{"login":"jtibshirani","id":7461306,"node_id":"MDQ6VXNlcjc0NjEzMDY=","avatar_url":"https://avatars3.githubusercontent.com/u/7461306?v=4","gravatar_id":"","url":"https://api.github.com/users/jtibshirani","html_url":"https://github.com/jtibshirani","followers_url":"https://api.github.com/users/jtibshirani/followers","following_url":"https://api.github.com/users/jtibshirani/following{/other_user}","gists_url":"https://api.github.com/users/jtibshirani/gists{/gist_id}","starred_url":"https://api.github.com/users/jtibshirani/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jtibshirani/subscriptions","organizations_url":"https://api.github.com/users/jtibshirani/orgs","repos_url":"https://api.github.com/users/jtibshirani/repos","events_url":"https://api.github.com/users/jtibshirani/events{/privacy}","received_events_url":"https://api.github.com/users/jtibshirani/received_events","type":"User","site_admin":false},"created_at":"2018-08-21T21:57:08Z","updated_at":"2018-08-22T00:32:59Z","author_association":"MEMBER","body":"Thanks @jpountz for your thoughts.\r\n\r\n> I feel like there is more ask for actual keywords which might enable support for aggregations in the future like you mentioned.\r\n\r\nI agree — in the potential use cases we’ve seen, the data is better modelled as keywords than text. The most critical feature is the ability to filter by an exact match on key-value pairs, and performing aggregations and sorting on the values would also be nice. A couple examples of these use cases:\r\n-  A user can have a number of metricbeats, each of which contains a large set of unique metrics. Only a small number of these fields are regularly used for filters, aggregations, etc. while the rest are only useful for reference when looking at a document, or in a rare case when filtering down to dig into an unusual issue.\r\n- Swiftype indexes logs of HTTP requests + responses, which contain a large number of arbitrary HTTP headers.\r\n\r\nMy sense is that we should focus on keywords for now, but in the future we could consider support for some simple analysis/ normalization, pending feedback on the feature.\r\n\r\n> Why do we plan to index individual tokens alone? \r\n\r\nIt could be nice if users were able search an entire object field (e.g. `{\"headers\": \"en.wikipedia.org\"}`), since the object's keys might be unknown or non-standardized. This is admittedly quite speculative, and partially just based on our thoughts on the original issue — I’ll try to collect more feedback here.\r\n\r\n> I'm not worried about it being slow since term queries on an indexed object would translate to a term query at the lucene level.\r\n\r\nRight, that makes sense! I’ll just plan on a sanity check here.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/414850399","html_url":"https://github.com/elastic/elasticsearch/issues/33003#issuecomment-414850399","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/33003","id":414850399,"node_id":"MDEyOklzc3VlQ29tbWVudDQxNDg1MDM5OQ==","user":{"login":"jtibshirani","id":7461306,"node_id":"MDQ6VXNlcjc0NjEzMDY=","avatar_url":"https://avatars3.githubusercontent.com/u/7461306?v=4","gravatar_id":"","url":"https://api.github.com/users/jtibshirani","html_url":"https://github.com/jtibshirani","followers_url":"https://api.github.com/users/jtibshirani/followers","following_url":"https://api.github.com/users/jtibshirani/following{/other_user}","gists_url":"https://api.github.com/users/jtibshirani/gists{/gist_id}","starred_url":"https://api.github.com/users/jtibshirani/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jtibshirani/subscriptions","organizations_url":"https://api.github.com/users/jtibshirani/orgs","repos_url":"https://api.github.com/users/jtibshirani/repos","events_url":"https://api.github.com/users/jtibshirani/events{/privacy}","received_events_url":"https://api.github.com/users/jtibshirani/received_events","type":"User","site_admin":false},"created_at":"2018-08-21T23:08:19Z","updated_at":"2018-09-05T23:57:23Z","author_association":"MEMBER","body":"I also wanted to clarify a point that was a bit fuzzy to me until I did a prototype. Under the proposed implementation, we are planning to index the entire JSON blob as a lucene field, and apply a special analyzer to create tokens that resemble keywords. This is in contrast to an approach where we create a new field mapping for each key in the object (which I think would be messy and negate some of the benefit of the feature).\r\n\r\nTaking this approach means that in kibana and other clients, the field will be displayed as a single block of JSON. I created a quick example using the prototype implementation:\r\n- the data consists of a filebeat for a docker container, with `id`, `name`, and `image` mapped as keywords, and `labels` as an 'indexed object'\r\n- we apply the search filter `{\"term\": {\"docker.container.labels.io.kubernetes.pod.name\": \"kafka-0\"}}`\r\n\r\n![screen shot 2018-08-21 at 5 07 47 pm](https://user-images.githubusercontent.com/7461306/44435463-f4f7e700-a564-11e8-8781-b1e429d41e5b.png)\r\n\r\nAs these JSON blobs can be quite large, highlighting seemed useful in showing where the match actually occurred. I also wonder if we should support highlighting for consistency with keyword fields, as some clients (like kibana) do depend on highlighting for displaying these matches?","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/415076287","html_url":"https://github.com/elastic/elasticsearch/issues/33003#issuecomment-415076287","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/33003","id":415076287,"node_id":"MDEyOklzc3VlQ29tbWVudDQxNTA3NjI4Nw==","user":{"login":"jpountz","id":299848,"node_id":"MDQ6VXNlcjI5OTg0OA==","avatar_url":"https://avatars2.githubusercontent.com/u/299848?v=4","gravatar_id":"","url":"https://api.github.com/users/jpountz","html_url":"https://github.com/jpountz","followers_url":"https://api.github.com/users/jpountz/followers","following_url":"https://api.github.com/users/jpountz/following{/other_user}","gists_url":"https://api.github.com/users/jpountz/gists{/gist_id}","starred_url":"https://api.github.com/users/jpountz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jpountz/subscriptions","organizations_url":"https://api.github.com/users/jpountz/orgs","repos_url":"https://api.github.com/users/jpountz/repos","events_url":"https://api.github.com/users/jpountz/events{/privacy}","received_events_url":"https://api.github.com/users/jpountz/received_events","type":"User","site_admin":false},"created_at":"2018-08-22T15:35:38Z","updated_at":"2018-08-22T22:19:20Z","author_association":"CONTRIBUTOR","body":"I'm curious how this will work in practice as mixing up pre/post tags with a JSON structure sounds challenging? The other thing that worries me a bit is that if we want to support any highligter that is able to use indexed offsets or term vectors, then when we extract the JSON object from the source document at search time, we must make sure that it produces exactly the same string as what was passed to the object mapper so that offsets are comparable, and any new/removed spaces and line breaks or reordering of keys would break highlighting?","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/415200788","html_url":"https://github.com/elastic/elasticsearch/issues/33003#issuecomment-415200788","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/33003","id":415200788,"node_id":"MDEyOklzc3VlQ29tbWVudDQxNTIwMDc4OA==","user":{"login":"jpountz","id":299848,"node_id":"MDQ6VXNlcjI5OTg0OA==","avatar_url":"https://avatars2.githubusercontent.com/u/299848?v=4","gravatar_id":"","url":"https://api.github.com/users/jpountz","html_url":"https://github.com/jpountz","followers_url":"https://api.github.com/users/jpountz/followers","following_url":"https://api.github.com/users/jpountz/following{/other_user}","gists_url":"https://api.github.com/users/jpountz/gists{/gist_id}","starred_url":"https://api.github.com/users/jpountz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jpountz/subscriptions","organizations_url":"https://api.github.com/users/jpountz/orgs","repos_url":"https://api.github.com/users/jpountz/repos","events_url":"https://api.github.com/users/jpountz/events{/privacy}","received_events_url":"https://api.github.com/users/jpountz/received_events","type":"User","site_admin":false},"created_at":"2018-08-22T22:20:47Z","updated_at":"2018-08-22T22:20:47Z","author_association":"CONTRIBUTOR","body":"Now that I read my comment again, the latter doesn't make sense as we will not allow enabling term vectors or indexing offsets anyway, so the highlighter will have to recompute the matched offsets anyway.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/415220251","html_url":"https://github.com/elastic/elasticsearch/issues/33003#issuecomment-415220251","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/33003","id":415220251,"node_id":"MDEyOklzc3VlQ29tbWVudDQxNTIyMDI1MQ==","user":{"login":"jtibshirani","id":7461306,"node_id":"MDQ6VXNlcjc0NjEzMDY=","avatar_url":"https://avatars3.githubusercontent.com/u/7461306?v=4","gravatar_id":"","url":"https://api.github.com/users/jtibshirani","html_url":"https://github.com/jtibshirani","followers_url":"https://api.github.com/users/jtibshirani/followers","following_url":"https://api.github.com/users/jtibshirani/following{/other_user}","gists_url":"https://api.github.com/users/jtibshirani/gists{/gist_id}","starred_url":"https://api.github.com/users/jtibshirani/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jtibshirani/subscriptions","organizations_url":"https://api.github.com/users/jtibshirani/orgs","repos_url":"https://api.github.com/users/jtibshirani/repos","events_url":"https://api.github.com/users/jtibshirani/events{/privacy}","received_events_url":"https://api.github.com/users/jtibshirani/received_events","type":"User","site_admin":false},"created_at":"2018-08-22T23:27:50Z","updated_at":"2018-08-23T00:27:39Z","author_association":"MEMBER","body":"I don't think I've dug enough into the details of highlighting to understand the concerns, but my takeaway is that it may be tricky to find a robust approach (and we should be open to punting on highlighting for v1).\r\n\r\nAs for the question around non-prefixed tokens, what do you think about this plan? Whether or not to index non-prefixed tokens can be controlled through a flag, to give users the opportunity to try it out without forcing them to double their inverted index size. From my initial experiment, indexing the raw tokens doesn't add much more work/ complexity. We can mark the feature 'experimental' at first, to allow time to collect feedback about this flag, and also about analysis, a `copy_to` mechanism, etc. Different people I've spoken with have had different intuitions on this point, and it's been hard to come to a good decision a priori.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/415327036","html_url":"https://github.com/elastic/elasticsearch/issues/33003#issuecomment-415327036","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/33003","id":415327036,"node_id":"MDEyOklzc3VlQ29tbWVudDQxNTMyNzAzNg==","user":{"login":"jpountz","id":299848,"node_id":"MDQ6VXNlcjI5OTg0OA==","avatar_url":"https://avatars2.githubusercontent.com/u/299848?v=4","gravatar_id":"","url":"https://api.github.com/users/jpountz","html_url":"https://github.com/jpountz","followers_url":"https://api.github.com/users/jpountz/followers","following_url":"https://api.github.com/users/jpountz/following{/other_user}","gists_url":"https://api.github.com/users/jpountz/gists{/gist_id}","starred_url":"https://api.github.com/users/jpountz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jpountz/subscriptions","organizations_url":"https://api.github.com/users/jpountz/orgs","repos_url":"https://api.github.com/users/jpountz/repos","events_url":"https://api.github.com/users/jpountz/events{/privacy}","received_events_url":"https://api.github.com/users/jpountz/received_events","type":"User","site_admin":false},"created_at":"2018-08-23T07:58:21Z","updated_at":"2018-08-23T07:58:21Z","author_association":"CONTRIBUTOR","body":"> Whether or not to index non-prefixed tokens can be controlled through a flag, to give users the opportunity to try it out without forcing them to double their inverted index size. From my initial experiment, indexing the raw tokens doesn't add much more work/ complexity.\r\n\r\nI agree that complexity of the implementation is fine, I'm more concerned about the API as we should strive to have as few switches as possible, especially for a v1. To me the question of this switch boils down to the problem that we are trying to solve: either we want to allow users to actually index objects, in which case indexing raw values makes sense, or we want to allow users to avoid the overhead of mappings and Lucene fields when indexing keywords and then it makes less sense?\r\n\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/415618439","html_url":"https://github.com/elastic/elasticsearch/issues/33003#issuecomment-415618439","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/33003","id":415618439,"node_id":"MDEyOklzc3VlQ29tbWVudDQxNTYxODQzOQ==","user":{"login":"jtibshirani","id":7461306,"node_id":"MDQ6VXNlcjc0NjEzMDY=","avatar_url":"https://avatars3.githubusercontent.com/u/7461306?v=4","gravatar_id":"","url":"https://api.github.com/users/jtibshirani","html_url":"https://github.com/jtibshirani","followers_url":"https://api.github.com/users/jtibshirani/followers","following_url":"https://api.github.com/users/jtibshirani/following{/other_user}","gists_url":"https://api.github.com/users/jtibshirani/gists{/gist_id}","starred_url":"https://api.github.com/users/jtibshirani/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jtibshirani/subscriptions","organizations_url":"https://api.github.com/users/jtibshirani/orgs","repos_url":"https://api.github.com/users/jtibshirani/repos","events_url":"https://api.github.com/users/jtibshirani/events{/privacy}","received_events_url":"https://api.github.com/users/jtibshirani/received_events","type":"User","site_admin":false},"created_at":"2018-08-24T00:59:50Z","updated_at":"2018-08-24T00:59:50Z","author_association":"MEMBER","body":"That is a nice way to frame it! I am thinking of it as the former (providing a true 'object' field). I think it fits better with the use cases/ data we’ve seen, which center on indexing opaque JSON objects (metric beats, user-provided blobs of data, etc.). To me, the most compelling use for this feature is in being able to work with object data that is difficult to model otherwise, and not just saving on indexing cost when working with keywords. I will try to get some more consensus/ clarity on this point, and then loop back.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/419535274","html_url":"https://github.com/elastic/elasticsearch/issues/33003#issuecomment-419535274","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/33003","id":419535274,"node_id":"MDEyOklzc3VlQ29tbWVudDQxOTUzNTI3NA==","user":{"login":"jtibshirani","id":7461306,"node_id":"MDQ6VXNlcjc0NjEzMDY=","avatar_url":"https://avatars3.githubusercontent.com/u/7461306?v=4","gravatar_id":"","url":"https://api.github.com/users/jtibshirani","html_url":"https://github.com/jtibshirani","followers_url":"https://api.github.com/users/jtibshirani/followers","following_url":"https://api.github.com/users/jtibshirani/following{/other_user}","gists_url":"https://api.github.com/users/jtibshirani/gists{/gist_id}","starred_url":"https://api.github.com/users/jtibshirani/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jtibshirani/subscriptions","organizations_url":"https://api.github.com/users/jtibshirani/orgs","repos_url":"https://api.github.com/users/jtibshirani/repos","events_url":"https://api.github.com/users/jtibshirani/events{/privacy}","received_events_url":"https://api.github.com/users/jtibshirani/received_events","type":"User","site_admin":false},"created_at":"2018-09-07T19:01:51Z","updated_at":"2018-09-07T19:01:51Z","author_association":"MEMBER","body":"We had a discussion offline, and came to the following conclusions:\r\n- In this first version, we’ll create a new leaf field type instead of incorporating the functionality into the `object` mapping. It will be important to allow for certain keys to be 'promoted' into their own dedicated fields, and we need to find a good mechanism to do so. One approach which we liked was to extend `copy_to` to work on entire objects, so that the same JSON blob could be added both as a 'queryable object' field, and also as normal `object` with explicit subfield definitions.\r\n- Raw values will be indexed in addition to key-value pairs. This will ensure consistent behavior for queryable object fields when the user performs a query across all mapped fields, or performs a wildcard search of the form `header.*`.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/434513449","html_url":"https://github.com/elastic/elasticsearch/issues/33003#issuecomment-434513449","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/33003","id":434513449,"node_id":"MDEyOklzc3VlQ29tbWVudDQzNDUxMzQ0OQ==","user":{"login":"jtibshirani","id":7461306,"node_id":"MDQ6VXNlcjc0NjEzMDY=","avatar_url":"https://avatars3.githubusercontent.com/u/7461306?v=4","gravatar_id":"","url":"https://api.github.com/users/jtibshirani","html_url":"https://github.com/jtibshirani","followers_url":"https://api.github.com/users/jtibshirani/followers","following_url":"https://api.github.com/users/jtibshirani/following{/other_user}","gists_url":"https://api.github.com/users/jtibshirani/gists{/gist_id}","starred_url":"https://api.github.com/users/jtibshirani/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jtibshirani/subscriptions","organizations_url":"https://api.github.com/users/jtibshirani/orgs","repos_url":"https://api.github.com/users/jtibshirani/repos","events_url":"https://api.github.com/users/jtibshirani/events{/privacy}","received_events_url":"https://api.github.com/users/jtibshirani/received_events","type":"User","site_admin":false},"created_at":"2018-10-30T23:56:47Z","updated_at":"2018-10-30T23:57:01Z","author_association":"MEMBER","body":"@colings86 @romseygeek I’ve given some thought to naming and have laid out some options. It would be great to get your opinions as well.\r\n\r\nOptions I don’t think are very strong:\r\n- `object`: clashes with the way we refer to traditional object mappings, and is actively causing confusion (see https://github.com/elastic/elasticsearch/pull/35063#issuecomment-434303654 for example).\r\n- `indexed_object`: seems verbose, and for me is not very intuitive. Could also cause confusion around how it relates to the current `object` type.\r\n- `key_value`: this doesn’t accurately describe the input data, since it is a JSON blob and not a list of key-value pairs. At first I thought this name could fit, because it could refer to how we choose to model the data in Lucene. But it doesn’t really work, since we index 'keyless' leaf values and also create a single stored field for the whole JSON blob. One piece of evidence is that the names `RootKeyValueFieldType` and `KeyedKeyValueFieldType` are quite awkward.\r\n- `map`: this doesn’t describe the input data that accurately either, since it could imply a flat key-value structure. May be confusing given our use of the term `mapping`.\r\n\r\nCurrent favorites:\r\n- `json`: accurately describes the structure of the input data. One downside is that since the whole document is JSON, users may see this field and think they should always use it. I think we can mitigate this concern through clear documentation.\r\n- `blob`: kind of generic, but I like that it suggests the field contents are opaque and don’t need a pre-defined schema.\r\n- `dictionary`: has similar issues to `map` about not accurately describing the structure of the input. However, it’s not easily confused with other terms.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/434715563","html_url":"https://github.com/elastic/elasticsearch/issues/33003#issuecomment-434715563","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/33003","id":434715563,"node_id":"MDEyOklzc3VlQ29tbWVudDQzNDcxNTU2Mw==","user":{"login":"colings86","id":236731,"node_id":"MDQ6VXNlcjIzNjczMQ==","avatar_url":"https://avatars0.githubusercontent.com/u/236731?v=4","gravatar_id":"","url":"https://api.github.com/users/colings86","html_url":"https://github.com/colings86","followers_url":"https://api.github.com/users/colings86/followers","following_url":"https://api.github.com/users/colings86/following{/other_user}","gists_url":"https://api.github.com/users/colings86/gists{/gist_id}","starred_url":"https://api.github.com/users/colings86/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/colings86/subscriptions","organizations_url":"https://api.github.com/users/colings86/orgs","repos_url":"https://api.github.com/users/colings86/repos","events_url":"https://api.github.com/users/colings86/events{/privacy}","received_events_url":"https://api.github.com/users/colings86/received_events","type":"User","site_admin":false},"created_at":"2018-10-31T14:47:33Z","updated_at":"2018-10-31T14:47:33Z","author_association":"MEMBER","body":"@jtibshirani I agree with you on the ones you list as \"Options I don’t think are very strong\".\r\n\r\nOn the \"current favourites\" I have the following thoughts:\r\n* `json`: This is the one I am leaning towards at the moment, the downsides are definitely a factor but I agree that documentation should help here\r\n* `blob`: I'm not so keen on this one as a `blob` sounds like something we don't touch and is stored/indexed and retrieved as is which is what the `binary` field type does so I think the name feels wrong to me\r\n* `dictionary`: I agree that it has the same problems as `map`, I'm not against this one but I don't love it either","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/435046773","html_url":"https://github.com/elastic/elasticsearch/issues/33003#issuecomment-435046773","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/33003","id":435046773,"node_id":"MDEyOklzc3VlQ29tbWVudDQzNTA0Njc3Mw==","user":{"login":"polyfractal","id":1224228,"node_id":"MDQ6VXNlcjEyMjQyMjg=","avatar_url":"https://avatars1.githubusercontent.com/u/1224228?v=4","gravatar_id":"","url":"https://api.github.com/users/polyfractal","html_url":"https://github.com/polyfractal","followers_url":"https://api.github.com/users/polyfractal/followers","following_url":"https://api.github.com/users/polyfractal/following{/other_user}","gists_url":"https://api.github.com/users/polyfractal/gists{/gist_id}","starred_url":"https://api.github.com/users/polyfractal/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/polyfractal/subscriptions","organizations_url":"https://api.github.com/users/polyfractal/orgs","repos_url":"https://api.github.com/users/polyfractal/repos","events_url":"https://api.github.com/users/polyfractal/events{/privacy}","received_events_url":"https://api.github.com/users/polyfractal/received_events","type":"User","site_admin":false},"created_at":"2018-11-01T13:51:01Z","updated_at":"2018-11-01T13:51:01Z","author_association":"MEMBER","body":"Just throwing out a few ideas.  Don't really think any of them are winners, but may spark an idea elsewhere. :)\r\n\r\n- `structure` / `structured`: field has some kind of structure to it that we minimally parse.  Sorta like `object` but without the overloaded use.  \r\n- `deconstructed` / `dissected` / `extracted`: we deconstruct/dissect/cut open the json to find it's internal structure\r\n- `implicit` / `implied` / `latent`: the field has some kind of implicit or hidden structure that we attempt to analyze into tokens\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/439486787","html_url":"https://github.com/elastic/elasticsearch/issues/33003#issuecomment-439486787","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/33003","id":439486787,"node_id":"MDEyOklzc3VlQ29tbWVudDQzOTQ4Njc4Nw==","user":{"login":"Bargs","id":6239176,"node_id":"MDQ6VXNlcjYyMzkxNzY=","avatar_url":"https://avatars3.githubusercontent.com/u/6239176?v=4","gravatar_id":"","url":"https://api.github.com/users/Bargs","html_url":"https://github.com/Bargs","followers_url":"https://api.github.com/users/Bargs/followers","following_url":"https://api.github.com/users/Bargs/following{/other_user}","gists_url":"https://api.github.com/users/Bargs/gists{/gist_id}","starred_url":"https://api.github.com/users/Bargs/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Bargs/subscriptions","organizations_url":"https://api.github.com/users/Bargs/orgs","repos_url":"https://api.github.com/users/Bargs/repos","events_url":"https://api.github.com/users/Bargs/events{/privacy}","received_events_url":"https://api.github.com/users/Bargs/received_events","type":"User","site_admin":false},"created_at":"2018-11-16T18:38:38Z","updated_at":"2018-11-16T18:38:38Z","author_association":"NONE","body":"@jtibshirani thanks again for letting me know the feature branch was ready to look at! I created [an issue](https://github.com/elastic/kibana/issues/25820) on the Kibana repo to start tracking our research. \r\n\r\nAt the moment the biggest issue I'm seeing is that Kibana has no way to know what sub fields might be present in the objects. This prevents us from autocompleting those field names in the query bar and it also prevents the user from creating filters (the pills below the query bar) on those fields because we currently present them with a dropdown to select the field, populated from our index pattern's field list. I realize this is sort of the point of the new type, but I'm wondering if ES could somehow track which sub field names it has seen and expose that information to Kibana? I think it would dramatically improve the user experience for querying on these fields. \r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/442070512","html_url":"https://github.com/elastic/elasticsearch/issues/33003#issuecomment-442070512","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/33003","id":442070512,"node_id":"MDEyOklzc3VlQ29tbWVudDQ0MjA3MDUxMg==","user":{"login":"jsoriano","id":15763,"node_id":"MDQ6VXNlcjE1NzYz","avatar_url":"https://avatars2.githubusercontent.com/u/15763?v=4","gravatar_id":"","url":"https://api.github.com/users/jsoriano","html_url":"https://github.com/jsoriano","followers_url":"https://api.github.com/users/jsoriano/followers","following_url":"https://api.github.com/users/jsoriano/following{/other_user}","gists_url":"https://api.github.com/users/jsoriano/gists{/gist_id}","starred_url":"https://api.github.com/users/jsoriano/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jsoriano/subscriptions","organizations_url":"https://api.github.com/users/jsoriano/orgs","repos_url":"https://api.github.com/users/jsoriano/repos","events_url":"https://api.github.com/users/jsoriano/events{/privacy}","received_events_url":"https://api.github.com/users/jsoriano/received_events","type":"User","site_admin":false},"created_at":"2018-11-27T14:08:04Z","updated_at":"2018-11-28T10:03:20Z","author_association":"MEMBER","body":"_(Moved to https://github.com/elastic/elasticsearch/issues/25312#issuecomment-442389905)_","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/442228055","html_url":"https://github.com/elastic/elasticsearch/issues/33003#issuecomment-442228055","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/33003","id":442228055,"node_id":"MDEyOklzc3VlQ29tbWVudDQ0MjIyODA1NQ==","user":{"login":"jtibshirani","id":7461306,"node_id":"MDQ6VXNlcjc0NjEzMDY=","avatar_url":"https://avatars3.githubusercontent.com/u/7461306?v=4","gravatar_id":"","url":"https://api.github.com/users/jtibshirani","html_url":"https://github.com/jtibshirani","followers_url":"https://api.github.com/users/jtibshirani/followers","following_url":"https://api.github.com/users/jtibshirani/following{/other_user}","gists_url":"https://api.github.com/users/jtibshirani/gists{/gist_id}","starred_url":"https://api.github.com/users/jtibshirani/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jtibshirani/subscriptions","organizations_url":"https://api.github.com/users/jtibshirani/orgs","repos_url":"https://api.github.com/users/jtibshirani/repos","events_url":"https://api.github.com/users/jtibshirani/events{/privacy}","received_events_url":"https://api.github.com/users/jtibshirani/received_events","type":"User","site_admin":false},"created_at":"2018-11-27T21:42:34Z","updated_at":"2018-11-27T21:42:34Z","author_association":"MEMBER","body":"Thanks @Bargs for taking a look, I have some questions that I will ping you about offline.\r\n\r\n@jsoriano would you mind if we moved your question over to the original issue? I was hoping to keep the discussion here focused on implementation details as opposed to use cases.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/442390422","html_url":"https://github.com/elastic/elasticsearch/issues/33003#issuecomment-442390422","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/33003","id":442390422,"node_id":"MDEyOklzc3VlQ29tbWVudDQ0MjM5MDQyMg==","user":{"login":"jsoriano","id":15763,"node_id":"MDQ6VXNlcjE1NzYz","avatar_url":"https://avatars2.githubusercontent.com/u/15763?v=4","gravatar_id":"","url":"https://api.github.com/users/jsoriano","html_url":"https://github.com/jsoriano","followers_url":"https://api.github.com/users/jsoriano/followers","following_url":"https://api.github.com/users/jsoriano/following{/other_user}","gists_url":"https://api.github.com/users/jsoriano/gists{/gist_id}","starred_url":"https://api.github.com/users/jsoriano/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jsoriano/subscriptions","organizations_url":"https://api.github.com/users/jsoriano/orgs","repos_url":"https://api.github.com/users/jsoriano/repos","events_url":"https://api.github.com/users/jsoriano/events{/privacy}","received_events_url":"https://api.github.com/users/jsoriano/received_events","type":"User","site_admin":false},"created_at":"2018-11-28T10:04:27Z","updated_at":"2018-11-28T10:04:27Z","author_association":"MEMBER","body":"@jtibshirani sure, [moved](https://github.com/elastic/elasticsearch/issues/25312#issuecomment-442389905).","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/490283380","html_url":"https://github.com/elastic/elasticsearch/issues/33003#issuecomment-490283380","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/33003","id":490283380,"node_id":"MDEyOklzc3VlQ29tbWVudDQ5MDI4MzM4MA==","user":{"login":"jtibshirani","id":7461306,"node_id":"MDQ6VXNlcjc0NjEzMDY=","avatar_url":"https://avatars3.githubusercontent.com/u/7461306?v=4","gravatar_id":"","url":"https://api.github.com/users/jtibshirani","html_url":"https://github.com/jtibshirani","followers_url":"https://api.github.com/users/jtibshirani/followers","following_url":"https://api.github.com/users/jtibshirani/following{/other_user}","gists_url":"https://api.github.com/users/jtibshirani/gists{/gist_id}","starred_url":"https://api.github.com/users/jtibshirani/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jtibshirani/subscriptions","organizations_url":"https://api.github.com/users/jtibshirani/orgs","repos_url":"https://api.github.com/users/jtibshirani/repos","events_url":"https://api.github.com/users/jtibshirani/events{/privacy}","received_events_url":"https://api.github.com/users/jtibshirani/received_events","type":"User","site_admin":false},"created_at":"2019-05-07T22:53:47Z","updated_at":"2019-05-07T23:17:28Z","author_association":"MEMBER","body":"A note to document the results of performance benchmarks. In summary, the results looked good overall, the only surprise was the small increase in index size when using an `embedded_json` field.\r\n\r\nFor the testing set-up, I ran the [metricbeat track](https://github.com/elastic/rally-tracks/tree/master/metricbeat) on an n1-standard-8 GCP instance. In the baseline, the track is run without modifications, and all fields are mapped individually.\r\n\r\nTo test the performance of JSON fields, the object field `system.process.cgroup` was changed to `embedded_json` in the mappings. Some statistics about the field:\r\n- appears in ~42,000 out of 1,079,600 total documents\r\n- in total, the field has ~130,000 unique key-value pairs\r\n- each instance of the field in a document contains ~80 distinct key-value pairs.\r\n\r\nIn the context of metricbeat data, `system.process.cgroup` is not a perfect candidate for an `embedded_json` field. If these benchmarks are added to our standard rally tracks, it would be good to extend the metricbeat data with a field like `docker.container.labels`, which is a more natural fit for the field type.\r\n\r\n**Term Query**\r\n\r\nTo test query performance, the following operation was added:\r\n\r\n```\r\n{\r\n  \"name\": \"term_query\",\r\n  \"operation-type\": \"search\",\r\n  \"cache\": false,\r\n  \"body\": {\r\n    \"size\": 50,\r\n    \"query\": {\r\n      \"term\": {\r\n        \"system.process.cgroup.blkio.id\": \"runsvdir.service\"\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nAs expected, queries perform very similarly to the baseline, where the subfield had been mapped individually as a `keyword`.\r\n```\r\n|                        Metric |         Task |   Baseline |   Contender |     Diff |   Unit |\r\n|  50th percentile service time |   term_query |    20.0905 |     20.9434 |   0.8529 |     ms |\r\n|  90th percentile service time |   term_query |    22.0021 |     24.3978 |  2.39568 |     ms |\r\n|  99th percentile service time |   term_query |    60.7888 |     55.5902 | -5.19856 |     ms |\r\n| 100th percentile service time |   term_query |    64.9998 |      56.051 |  -8.9488 |     ms |\r\n```\r\n**Terms Aggregation**\r\n\r\nThe following terms aggregation was also tested:\r\n\r\n```\r\n{\r\n  \"name\": \"terms_agg\",\r\n  \"operation-type\": \"search\",\r\n  \"cache\": false,\r\n  \"body\": {\r\n    \"size\": 0,\r\n    \"query\": {\r\n      \"match_all\": {}\r\n    },\r\n    \"aggs\": {\r\n      \"blkio_ids\": {\r\n        \"terms\": { \"field\": \"system.process.cgroup.blkio.id\" }\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nTerms aggregations were slower than the baseline, but the performance was still acceptable. From the profiling output, the bulk of the time is spent in `KeyedJsonAtomicFieldData#advanceExact`, calling into `GlobalOrdinalMapping#nextOrd`. This makes sense given the set-up, since each embedded JSON field `system.process.cgroup` contains a large number of distinct key-value pairs that must be traversed before landing on the right key.\r\n\r\n```\r\n|                        Metric |         Task |   Baseline |   Contender |     Diff |   Unit |\r\n|  50th percentile service time |    terms_agg |     31.028 |     45.4184 |  14.3904 |     ms |\r\n|  90th percentile service time |    terms_agg |    33.0771 |     46.7582 |  13.6811 |     ms |\r\n|  99th percentile service time |    terms_agg |    34.1942 |     50.3088 |  16.1146 |     ms |\r\n| 100th percentile service time |    terms_agg |      40.26 |     50.9181 |   10.658 |     ms |\r\n```\r\n**Indexing Performance**\r\n\r\nIndexing throughput and service time looked good, the tests showed no decline in performance. To confirm the effect, I also repeated these indexing tests with an (unrealistic) set-up where all top-level fields were mapped as `embedded_json`.\r\n\r\n```\r\n|                        Metric |         Task |   Baseline |   Contender |     Diff |   Unit |\r\n|                Min Throughput | index-append |    966.739 |     952.316 | -14.4233 | docs/s |\r\n|             Median Throughput | index-append |    12036.5 |     13927.7 |  1891.22 | docs/s |\r\n|                Max Throughput | index-append |    14785.7 |     17560.6 |  2774.91 | docs/s |\r\n|  50th percentile service time | index-append |    4553.08 |     3702.44 | -850.649 |     ms |\r\n|  90th percentile service time | index-append |     8235.1 |     7104.33 | -1130.77 |     ms |\r\n|  99th percentile service time | index-append |      12366 |     12074.3 | -291.721 |     ms |\r\n| 100th percentile service time | index-append |    12615.3 |     12994.3 |   378.96 |     ms |\r\n```\r\n\r\n**Index Size**\r\n\r\nIn all tests I ran, index size actually increased by a small amount. This was a bit counterintuitive for me, as I had assumed that using `embedded_json` could help save space by using a single field instead of multiple distinct ones. I'm guessing that the difference is due to the fact that in the baseline, many of the subfields are mapped as numbers, whereas with `embedded_json` they are treated as keywords. As above, the effect was confirmed by repeating the tests with in a set-up where all top-level fields were mapped as `embedded_json`.\r\n\r\n```\r\n|                        Metric |         Task |   Baseline |   Contender |     Diff |   Unit |\r\n|                    Index size |              |    1.14885 |     1.22382 |  0.07497 |     GB |\r\n```","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/491183790","html_url":"https://github.com/elastic/elasticsearch/issues/33003#issuecomment-491183790","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/33003","id":491183790,"node_id":"MDEyOklzc3VlQ29tbWVudDQ5MTE4Mzc5MA==","user":{"login":"jpountz","id":299848,"node_id":"MDQ6VXNlcjI5OTg0OA==","avatar_url":"https://avatars2.githubusercontent.com/u/299848?v=4","gravatar_id":"","url":"https://api.github.com/users/jpountz","html_url":"https://github.com/jpountz","followers_url":"https://api.github.com/users/jpountz/followers","following_url":"https://api.github.com/users/jpountz/following{/other_user}","gists_url":"https://api.github.com/users/jpountz/gists{/gist_id}","starred_url":"https://api.github.com/users/jpountz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jpountz/subscriptions","organizations_url":"https://api.github.com/users/jpountz/orgs","repos_url":"https://api.github.com/users/jpountz/repos","events_url":"https://api.github.com/users/jpountz/events{/privacy}","received_events_url":"https://api.github.com/users/jpountz/received_events","type":"User","site_admin":false},"created_at":"2019-05-10T07:12:38Z","updated_at":"2019-05-10T07:12:38Z","author_association":"CONTRIBUTOR","body":"Thanks for testing, this looks great.\r\n\r\n> bulk of the time is spent in KeyedJsonAtomicFieldData#advanceExact, calling into GlobalOrdinalMapping#nextOrd\r\n\r\nThis suggests that we first map segment ordinals to global ordinals before checking whether the global ordinal is in the expected range. We could probably speed it up by computing the range of valid segment ordinals and then calling nextOrd on the segment-level `SortedSetDocValues` rather than `GlobalOrdinalMapping`.\r\n\r\nIf you still have the index handy, I'd be curious to know what the difference is in terms of Lucene memory usage. I'm expecting a bit more, but I'd be curious to know how much more.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/491381831","html_url":"https://github.com/elastic/elasticsearch/issues/33003#issuecomment-491381831","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/33003","id":491381831,"node_id":"MDEyOklzc3VlQ29tbWVudDQ5MTM4MTgzMQ==","user":{"login":"jtibshirani","id":7461306,"node_id":"MDQ6VXNlcjc0NjEzMDY=","avatar_url":"https://avatars3.githubusercontent.com/u/7461306?v=4","gravatar_id":"","url":"https://api.github.com/users/jtibshirani","html_url":"https://github.com/jtibshirani","followers_url":"https://api.github.com/users/jtibshirani/followers","following_url":"https://api.github.com/users/jtibshirani/following{/other_user}","gists_url":"https://api.github.com/users/jtibshirani/gists{/gist_id}","starred_url":"https://api.github.com/users/jtibshirani/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jtibshirani/subscriptions","organizations_url":"https://api.github.com/users/jtibshirani/orgs","repos_url":"https://api.github.com/users/jtibshirani/repos","events_url":"https://api.github.com/users/jtibshirani/events{/privacy}","received_events_url":"https://api.github.com/users/jtibshirani/received_events","type":"User","site_admin":false},"created_at":"2019-05-10T18:10:00Z","updated_at":"2019-05-10T18:10:40Z","author_association":"MEMBER","body":"> This suggests that we first map segment ordinals to global ordinals before checking whether the global ordinal is in the expected range. We could probably speed it up by computing the range of valid segment ordinals...\r\n\r\nThat makes sense, I will take a look if it's possible to do this in a clean way. I think this benchmark presents a tough case for aggregations, in that each `embedded_json` field contains many unique key-value pairs (in many use cases the field could contain far fewer).\r\n\r\nAs for lucene memory usage, here is the relevant output from the rally benchmarks. Let me know if there are any other measurements that would be interesting:\r\n```\r\n|                        Metric |         Task |   Baseline |   Contender |     Diff |   Unit |\r\n|        Heap used for segments |              |    2.03671 |      1.8357 | -0.20101 |     MB |\r\n|      Heap used for doc values |              |    1.02371 |    0.573326 | -0.45038 |     MB |\r\n|           Heap used for terms |              |   0.648928 |    0.921001 |  0.27207 |     MB |\r\n|          Heap used for points |              |   0.125407 |    0.104141 | -0.02127 |     MB |\r\n```","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/493929051","html_url":"https://github.com/elastic/elasticsearch/issues/33003#issuecomment-493929051","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/33003","id":493929051,"node_id":"MDEyOklzc3VlQ29tbWVudDQ5MzkyOTA1MQ==","user":{"login":"jpountz","id":299848,"node_id":"MDQ6VXNlcjI5OTg0OA==","avatar_url":"https://avatars2.githubusercontent.com/u/299848?v=4","gravatar_id":"","url":"https://api.github.com/users/jpountz","html_url":"https://github.com/jpountz","followers_url":"https://api.github.com/users/jpountz/followers","following_url":"https://api.github.com/users/jpountz/following{/other_user}","gists_url":"https://api.github.com/users/jpountz/gists{/gist_id}","starred_url":"https://api.github.com/users/jpountz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jpountz/subscriptions","organizations_url":"https://api.github.com/users/jpountz/orgs","repos_url":"https://api.github.com/users/jpountz/repos","events_url":"https://api.github.com/users/jpountz/events{/privacy}","received_events_url":"https://api.github.com/users/jpountz/received_events","type":"User","site_admin":false},"created_at":"2019-05-20T10:27:06Z","updated_at":"2019-05-20T10:27:06Z","author_association":"CONTRIBUTOR","body":"Thanks for running this test, I expected memory usage to be higher for `embedded_json`, I'm happy to be proven wrong!","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/507183494","html_url":"https://github.com/elastic/elasticsearch/issues/33003#issuecomment-507183494","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/33003","id":507183494,"node_id":"MDEyOklzc3VlQ29tbWVudDUwNzE4MzQ5NA==","user":{"login":"jtibshirani","id":7461306,"node_id":"MDQ6VXNlcjc0NjEzMDY=","avatar_url":"https://avatars3.githubusercontent.com/u/7461306?v=4","gravatar_id":"","url":"https://api.github.com/users/jtibshirani","html_url":"https://github.com/jtibshirani","followers_url":"https://api.github.com/users/jtibshirani/followers","following_url":"https://api.github.com/users/jtibshirani/following{/other_user}","gists_url":"https://api.github.com/users/jtibshirani/gists{/gist_id}","starred_url":"https://api.github.com/users/jtibshirani/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jtibshirani/subscriptions","organizations_url":"https://api.github.com/users/jtibshirani/orgs","repos_url":"https://api.github.com/users/jtibshirani/repos","events_url":"https://api.github.com/users/jtibshirani/events{/privacy}","received_events_url":"https://api.github.com/users/jtibshirani/received_events","type":"User","site_admin":false},"created_at":"2019-07-01T09:11:22Z","updated_at":"2019-07-01T09:21:49Z","author_association":"MEMBER","body":"The initial version of the feature was merged in #42541 and backported to 7.3. I filed #43805 to track follow-up improvements.","performed_via_github_app":null}]