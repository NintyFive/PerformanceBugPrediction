[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/519111453","html_url":"https://github.com/elastic/elasticsearch/issues/45284#issuecomment-519111453","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/45284","id":519111453,"node_id":"MDEyOklzc3VlQ29tbWVudDUxOTExMTQ1Mw==","user":{"login":"elasticmachine","id":15837671,"node_id":"MDQ6VXNlcjE1ODM3Njcx","avatar_url":"https://avatars3.githubusercontent.com/u/15837671?v=4","gravatar_id":"","url":"https://api.github.com/users/elasticmachine","html_url":"https://github.com/elasticmachine","followers_url":"https://api.github.com/users/elasticmachine/followers","following_url":"https://api.github.com/users/elasticmachine/following{/other_user}","gists_url":"https://api.github.com/users/elasticmachine/gists{/gist_id}","starred_url":"https://api.github.com/users/elasticmachine/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/elasticmachine/subscriptions","organizations_url":"https://api.github.com/users/elasticmachine/orgs","repos_url":"https://api.github.com/users/elasticmachine/repos","events_url":"https://api.github.com/users/elasticmachine/events{/privacy}","received_events_url":"https://api.github.com/users/elasticmachine/received_events","type":"User","site_admin":false},"created_at":"2019-08-07T14:02:10Z","updated_at":"2019-08-07T14:02:10Z","author_association":"COLLABORATOR","body":"Pinging @elastic/es-core-infra","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/519354122","html_url":"https://github.com/elastic/elasticsearch/issues/45284#issuecomment-519354122","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/45284","id":519354122,"node_id":"MDEyOklzc3VlQ29tbWVudDUxOTM1NDEyMg==","user":{"login":"rjernst","id":289412,"node_id":"MDQ6VXNlcjI4OTQxMg==","avatar_url":"https://avatars3.githubusercontent.com/u/289412?v=4","gravatar_id":"","url":"https://api.github.com/users/rjernst","html_url":"https://github.com/rjernst","followers_url":"https://api.github.com/users/rjernst/followers","following_url":"https://api.github.com/users/rjernst/following{/other_user}","gists_url":"https://api.github.com/users/rjernst/gists{/gist_id}","starred_url":"https://api.github.com/users/rjernst/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/rjernst/subscriptions","organizations_url":"https://api.github.com/users/rjernst/orgs","repos_url":"https://api.github.com/users/rjernst/repos","events_url":"https://api.github.com/users/rjernst/events{/privacy}","received_events_url":"https://api.github.com/users/rjernst/received_events","type":"User","site_admin":false},"created_at":"2019-08-08T04:04:59Z","updated_at":"2019-08-08T04:04:59Z","author_association":"MEMBER","body":"The default parser for date fields is `strict_date_optional_time` (and a fallback to epoch millis, but that is unimportant for this discussion). It looks like confusing terminology in Joda has caused us to be too strict in several places with our conversion to java time.  It looks like myself and others who worked on the java time migration viewed the \"strict\" term here as correlated with the \"optional\" portion, meaning the above format would have a required date, but an optional time. But upon further inspection it appears strict has to do with validation of the fields of the date, eg allowing 13 as the month.  Unfortunately the \"dueling\" tests that we have comparing java time to joda did not compare these partial dates to joda.\r\n\r\nJava time's facility for allowing lenient parsing is the ResolverStyle, which can be `LENIENT`, `SMART` or `STRICT`. `SMART` is actually the default, which will try to carry over field values out of the expected range (for example, july 32 would be translated to aug 1).  Switching the strict parsers we have to allow optional portions of dates, and changing the resolver style to strict should match the old joda behavior.\r\n\r\nWe should also be consistent about not using `SMART`, and maybe discuss whether we need the `LENIENT` resolved versions of date formatters at all? It is unclear how these would be used in Elasticsearch since in many places we necessarily convert date/times to epoch millis or nanos, and I don't think a lenient parsed field can be converted in this way without a custom field resolver.\r\n\r\n/cc @spinscale @pgomulka ","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/527380683","html_url":"https://github.com/elastic/elasticsearch/issues/45284#issuecomment-527380683","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/45284","id":527380683,"node_id":"MDEyOklzc3VlQ29tbWVudDUyNzM4MDY4Mw==","user":{"login":"pgomulka","id":11137008,"node_id":"MDQ6VXNlcjExMTM3MDA4","avatar_url":"https://avatars0.githubusercontent.com/u/11137008?v=4","gravatar_id":"","url":"https://api.github.com/users/pgomulka","html_url":"https://github.com/pgomulka","followers_url":"https://api.github.com/users/pgomulka/followers","following_url":"https://api.github.com/users/pgomulka/following{/other_user}","gists_url":"https://api.github.com/users/pgomulka/gists{/gist_id}","starred_url":"https://api.github.com/users/pgomulka/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/pgomulka/subscriptions","organizations_url":"https://api.github.com/users/pgomulka/orgs","repos_url":"https://api.github.com/users/pgomulka/repos","events_url":"https://api.github.com/users/pgomulka/events{/privacy}","received_events_url":"https://api.github.com/users/pgomulka/received_events","type":"User","site_admin":false},"created_at":"2019-09-03T09:28:21Z","updated_at":"2019-09-03T09:28:46Z","author_association":"CONTRIBUTOR","body":"So we can fix 4 things here:\r\n1. To enable partial parsing of dates. So that `date_optional_time` can parse 2018, 2018-01, 2018-01-01\r\n2. To make the strict_* parsers validate the length of date parts. This would make `date_optional_time` parse 99999-01-01 but `strict_date_optional_time` would fail.  This is the difference between `StrictISODateTimeFormat` and `ISODateTimeFormat` in Joda implementation. I would however skip this one, as we already relaxed this in ES v7, some people might have started to use it.\r\n3. Enable `ResolverStyle.Strict` for all parsers. This is how it worked in Joda (there was no option to change this). By default Java is using `ResolverStyle.SMART` which would allow parsing 2018-02-30 but Joda would throw an exception.\r\n4. Consider renaming our formatters. `strict_date_optional_time` makes it unclear what is strict here (in fact it is the strict length parsing, not the presence of full date part or resolver style - which is always strict). Maybe we could start with adding aliases for these unclear. Like `strict_length_date_time` ? Or any other ideas?\r\n","performed_via_github_app":null}]