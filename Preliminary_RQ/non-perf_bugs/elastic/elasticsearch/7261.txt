{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/7261","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/7261/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/7261/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/7261/events","html_url":"https://github.com/elastic/elasticsearch/issues/7261","id":40181638,"node_id":"MDU6SXNzdWU0MDE4MTYzOA==","number":7261,"title":"Optionally include 'Set Difference' for filter aggregation.","user":{"login":"Kallin","id":158169,"node_id":"MDQ6VXNlcjE1ODE2OQ==","avatar_url":"https://avatars3.githubusercontent.com/u/158169?v=4","gravatar_id":"","url":"https://api.github.com/users/Kallin","html_url":"https://github.com/Kallin","followers_url":"https://api.github.com/users/Kallin/followers","following_url":"https://api.github.com/users/Kallin/following{/other_user}","gists_url":"https://api.github.com/users/Kallin/gists{/gist_id}","starred_url":"https://api.github.com/users/Kallin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Kallin/subscriptions","organizations_url":"https://api.github.com/users/Kallin/orgs","repos_url":"https://api.github.com/users/Kallin/repos","events_url":"https://api.github.com/users/Kallin/events{/privacy}","received_events_url":"https://api.github.com/users/Kallin/received_events","type":"User","site_admin":false},"labels":[{"id":110815527,"node_id":"MDU6TGFiZWwxMTA4MTU1Mjc=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/help%20wanted","name":"help wanted","color":"207de5","default":true,"description":"adoptme"}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":7,"created_at":"2014-08-13T18:03:04Z","updated_at":"2014-10-31T14:14:49Z","closed_at":"2014-10-31T14:14:49Z","author_association":"NONE","active_lock_reason":null,"body":"A project that I'm working on involves breaking down an index via many nested filter aggregations. Imagine it being for something like a website visitor funnel: \n1. Of all the visitors, bucket the ones who created an account\n2. Of account creators, bucket those over age 30\n3. etc.. \n\nWhat I also end up doing are creating the Difference filters, albeit manually.\n\n1b. Of all the visitors, bucket the ones who didn't create an account.\n2b. Of those account creators under 30, show me those who liked dogs.\n3b. etc..\n\nThis has proven very powerful for segmenting data, but it is very verbose and error prone to create all these 'difference' filters manually. What would be great is if I could optionally have the difference filter created for me whenever I create a filter.\n\nFor example, in the filter agg doc it suggests:\n\n```\n{\n    \"aggs\" : {\n        \"in_stock_products\" : {\n            \"filter\" : { \"range\" : { \"stock\" : { \"gt\" : 0 } } },\n            \"aggs\" : {\n                \"avg_price\" : { \"avg\" : { \"field\" : \"price\" } }\n            }\n        }\n    }\n}\n```\n\nWhat if we allowed a parameter on the filter agg like:\n\n```\n\"filter\" : { \"range\" : { \"stock\" : { \"gt\" : 0 } }, includeDifference: true },\n```\n\nAnd that would automatically create a bucket that includes all the docs not included in the main filter, perhaps  automatically naming it in this case 'not_in_stock_products'.\n\nThe response might then look like:\n\n```\n{\n    ...\n\n    \"aggs\" : {\n        \"in_stock_products\" : {\n            \"doc_count\" : 100,\n            \"avg_price\" : { \"value\" : 56.3 }\n        },\n        \"not_in_stock_products\" : {\n            \"doc_count\" : 50\n        }\n    }\n}\n```\n\ncreating further sub-aggs on the auto-created agg could be done either inline with the original agg:\n\n```\n            \"filter\" : { \"range\" : { \"stock\" : { \"gt\" : 0 } } ,\n            includeDifference:true, differenceAggs: {\n                \"avg_price\" : { \"avg\" : { \"field\" : \"price\" } }\n            } \n            },\n            \"aggs\" : {\n                \"avg_price\" : { \"avg\" : { \"field\" : \"price\" } }\n            }\n```\n\nor perhaps simply by specifying the name of the agg it would map it to the original by convention:\n\n```\n{\n    \"aggs\" : {\n        \"in_stock_products\" : {\n            \"filter\" : { \"range\" : { \"stock\" : { \"gt\" : 0 } }  includeDifference:true},\n            \"aggs\" : {\n                \"avg_price\" : { \"avg\" : { \"field\" : \"price\" } }\n            }\n        },\n        \"not_in_stock_products\" : {\n            \"avg_price\" : { \"avg\" : { \"field\" : \"price\" } }\n        }\n    }\n}\n```\n\nWhat do people think about something like this? I'm sure I'm not the only one who tries to segment their data like this.\n","closed_by":{"login":"Kallin","id":158169,"node_id":"MDQ6VXNlcjE1ODE2OQ==","avatar_url":"https://avatars3.githubusercontent.com/u/158169?v=4","gravatar_id":"","url":"https://api.github.com/users/Kallin","html_url":"https://github.com/Kallin","followers_url":"https://api.github.com/users/Kallin/followers","following_url":"https://api.github.com/users/Kallin/following{/other_user}","gists_url":"https://api.github.com/users/Kallin/gists{/gist_id}","starred_url":"https://api.github.com/users/Kallin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Kallin/subscriptions","organizations_url":"https://api.github.com/users/Kallin/orgs","repos_url":"https://api.github.com/users/Kallin/repos","events_url":"https://api.github.com/users/Kallin/events{/privacy}","received_events_url":"https://api.github.com/users/Kallin/received_events","type":"User","site_admin":false},"performed_via_github_app":null}