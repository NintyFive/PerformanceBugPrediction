{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/10005","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/10005/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/10005/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/10005/events","html_url":"https://github.com/elastic/elasticsearch/issues/10005","id":60026809,"node_id":"MDU6SXNzdWU2MDAyNjgwOQ==","number":10005,"title":"Date type has not enough precision for the logging use case.","user":{"login":"jordansissel","id":131818,"node_id":"MDQ6VXNlcjEzMTgxOA==","avatar_url":"https://avatars1.githubusercontent.com/u/131818?v=4","gravatar_id":"","url":"https://api.github.com/users/jordansissel","html_url":"https://github.com/jordansissel","followers_url":"https://api.github.com/users/jordansissel/followers","following_url":"https://api.github.com/users/jordansissel/following{/other_user}","gists_url":"https://api.github.com/users/jordansissel/gists{/gist_id}","starred_url":"https://api.github.com/users/jordansissel/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jordansissel/subscriptions","organizations_url":"https://api.github.com/users/jordansissel/orgs","repos_url":"https://api.github.com/users/jordansissel/repos","events_url":"https://api.github.com/users/jordansissel/events{/privacy}","received_events_url":"https://api.github.com/users/jordansissel/received_events","type":"User","site_admin":false},"labels":[{"id":141145460,"node_id":"MDU6TGFiZWwxNDExNDU0NjA=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/:Search/Mapping","name":":Search/Mapping","color":"0e8a16","default":false,"description":"How fields should be indexed"},{"id":23172,"node_id":"MDU6TGFiZWwyMzE3Mg==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/%3Efeature","name":">feature","color":"006b75","default":false,"description":null},{"id":110557212,"node_id":"MDU6TGFiZWwxMTA1NTcyMTI=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/high%20hanging%20fruit","name":"high hanging fruit","color":"fc6149","default":false,"description":null},{"id":113234020,"node_id":"MDU6TGFiZWwxMTMyMzQwMjA=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/stalled","name":"stalled","color":"fef2c0","default":false,"description":null}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":69,"created_at":"2015-03-05T22:28:11Z","updated_at":"2019-02-11T11:22:56Z","closed_at":"2019-02-11T11:22:56Z","author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"At present, the 'date' type is millisecond precision. For many log use cases, higher precision time is valuable - microsecond, nanosecond, etc.\n\nThe biggest impact of this is during sorting of search results. If you sort chronologically, newest-first, by a date field, documents with the same date will probably be sorted incorrectly (because they match). This is often reported by users seeing events \"out of order\" when they have the same timestamp. Specific example being sorting by date and seeing events in newest-first order, unless there is a tie, in which case oldest-first (or first-written?) appears. This causes a bit of confusion for the ELK use case.\n\nRelated: https://github.com/logstash-plugins/logstash-filter-date/pull/8\n\nI don't have any firm proposals, but I have two different implementation ideas:\n- Proposal 1, use a separate field: Store our own custom-precision time in a separate field as a _long_. This allows us to do correct sorting (because we have higher precision), but it makes any date-related functionality in Elasticsearch not usable (searching `now-1h` or doing date_histogram, etc)\n- Proposal 2, date type has tunable precision: Have the `date` type have configurable precision, with the default (backwards compatible) precision being milliseconds. This would let us choose, for example, nanosecond precision for the logging use case, and year precision for an archaeological use case (billions of years ago, or something). Benefit here is date histogram and other date-related features could still work. Further, having the precision configurable would allow us to keep the underlying data structure a 64bit long and users could choose their most appropriate precision.\n","closed_by":{"login":"jimczi","id":15977469,"node_id":"MDQ6VXNlcjE1OTc3NDY5","avatar_url":"https://avatars0.githubusercontent.com/u/15977469?v=4","gravatar_id":"","url":"https://api.github.com/users/jimczi","html_url":"https://github.com/jimczi","followers_url":"https://api.github.com/users/jimczi/followers","following_url":"https://api.github.com/users/jimczi/following{/other_user}","gists_url":"https://api.github.com/users/jimczi/gists{/gist_id}","starred_url":"https://api.github.com/users/jimczi/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jimczi/subscriptions","organizations_url":"https://api.github.com/users/jimczi/orgs","repos_url":"https://api.github.com/users/jimczi/repos","events_url":"https://api.github.com/users/jimczi/events{/privacy}","received_events_url":"https://api.github.com/users/jimczi/received_events","type":"User","site_admin":false},"performed_via_github_app":null}