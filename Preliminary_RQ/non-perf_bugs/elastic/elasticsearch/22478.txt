{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/22478","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/22478/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/22478/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/22478/events","html_url":"https://github.com/elastic/elasticsearch/issues/22478","id":199280935,"node_id":"MDU6SXNzdWUxOTkyODA5MzU=","number":22478,"title":"Ngram/Edgengram filters don't work with keyword repeat filters","user":{"login":"gibrown","id":820871,"node_id":"MDQ6VXNlcjgyMDg3MQ==","avatar_url":"https://avatars2.githubusercontent.com/u/820871?v=4","gravatar_id":"","url":"https://api.github.com/users/gibrown","html_url":"https://github.com/gibrown","followers_url":"https://api.github.com/users/gibrown/followers","following_url":"https://api.github.com/users/gibrown/following{/other_user}","gists_url":"https://api.github.com/users/gibrown/gists{/gist_id}","starred_url":"https://api.github.com/users/gibrown/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/gibrown/subscriptions","organizations_url":"https://api.github.com/users/gibrown/orgs","repos_url":"https://api.github.com/users/gibrown/repos","events_url":"https://api.github.com/users/gibrown/events{/privacy}","received_events_url":"https://api.github.com/users/gibrown/received_events","type":"User","site_admin":false},"labels":[{"id":142001965,"node_id":"MDU6TGFiZWwxNDIwMDE5NjU=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/:Search/Analysis","name":":Search/Analysis","color":"0e8a16","default":false,"description":"How text is split into tokens"},{"id":23174,"node_id":"MDU6TGFiZWwyMzE3NA==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/%3Eenhancement","name":">enhancement","color":"4a4ea8","default":false,"description":null}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":15,"created_at":"2017-01-06T20:28:19Z","updated_at":"2018-06-25T22:01:45Z","closed_at":"2018-06-20T09:32:15Z","author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"**Elasticsearch version**: 2.3.3\r\n\r\n**Plugins installed**: [analysis-icu analysis-smartcn delete-by-query lang-javascript whatson analysis-kuromoji analysis-stempel elasticsearch-inquisitor head langdetect statsd/]\r\n\r\n**Description of the problem including expected versus actual behavior**:\r\n\r\nI want to index edgengrams from 3 to 15 chars, but also keep the original token in the field as well. This is being used for search as you type functionality. For both speed and relevancy reasons we've settled on 3 being the min num of chars that makes sense, but it leaves some gaps for non-whitespace separated languages and for words like 'pi'.\r\n\r\nI thought I could do this using keyword_repeat and unique filters in my analyzer, but that doesn't seem to work with edgengram filters. Maybe I'm doing it wrong, but I haven't come up with a workaround yet.\r\n\r\n**Steps to reproduce**:\r\n\r\n```\r\nPUT test_analyzer\r\n{\r\n  \"settings\": {\r\n    \"analysis\": {\r\n      \"analyzer\": {\r\n        \"edgengram_analyzer\": {\r\n          \"filter\": [\r\n            \"icu_normalizer\",\r\n            \"icu_folding\",\r\n            \"keyword_repeat\",\r\n            \"edgengram_filter\",\r\n            \"unique_filter\"\r\n          ],\r\n          \"type\": \"custom\",\r\n          \"tokenizer\": \"icu_tokenizer\"\r\n        },\r\n        \"default\": {\r\n          \"filter\": [\r\n            \"icu_normalizer\",\r\n            \"icu_folding\"\r\n          ],\r\n          \"type\": \"custom\",\r\n          \"tokenizer\": \"icu_tokenizer\"\r\n        }\r\n      },\r\n      \"filter\": {\r\n        \"unique_filter\": {\r\n          \"type\": \"unique\",\r\n          \"only_on_same_position\": \"true\"\r\n        },\r\n        \"edgengram_filter\": {\r\n          \"type\": \"edgeNGram\",\r\n          \"min_gram\": \"3\",\r\n          \"max_gram\": \"15\"\r\n        }\r\n      }\r\n    }\r\n  },\r\n  \"mappings\": {\r\n    \"my_type\": {\r\n      \"properties\": {\r\n        \"my_text\": {\r\n          \"type\": \"string\",\r\n          \"similarity\": \"BM25\",\r\n          \"analyzer\": \"default\",\r\n          \"fields\": {\r\n            \"ngram\": {\r\n              \"type\": \"string\",\r\n              \"term_vector\": \"with_positions_offsets\",\r\n              \"similarity\": \"BM25\",\r\n              \"analyzer\": \"edgengram_analyzer\",\r\n              \"search_analyzer\": \"default\"\r\n            },\r\n            \"word_count\": {\r\n              \"type\": \"token_count\",\r\n              \"analyzer\": \"default\"\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nGET test_analyzer/_analyze \r\n{\r\n  \"analyzer\": \"edgengram_analyzer\", \r\n  \"text\":     \"Is this déjà vu?\"\r\n}\r\n```\r\n\r\nOutput:\r\n```\r\n{\r\n  \"tokens\": [\r\n    {\r\n      \"token\": \"thi\",\r\n      \"start_offset\": 3,\r\n      \"end_offset\": 7,\r\n      \"type\": \"word\",\r\n      \"position\": 1\r\n    },\r\n    {\r\n      \"token\": \"this\",\r\n      \"start_offset\": 3,\r\n      \"end_offset\": 7,\r\n      \"type\": \"word\",\r\n      \"position\": 1\r\n    },\r\n    {\r\n      \"token\": \"dej\",\r\n      \"start_offset\": 8,\r\n      \"end_offset\": 12,\r\n      \"type\": \"word\",\r\n      \"position\": 2\r\n    },\r\n    {\r\n      \"token\": \"deja\",\r\n      \"start_offset\": 8,\r\n      \"end_offset\": 12,\r\n      \"type\": \"word\",\r\n      \"position\": 2\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\nI'd expect to get the tokens: is, thi, this, dej, deja, vu\r\n\r\nThe problem gets worse when looking at non-whitespace languages where many characters are tokenized into one character per token.\r\n\r\nI could search across multiple fields, but that prevents me from matching on phrases and using those phrase matches to boost results. For instance if the user types in \"hi ther\" we should be able to match instances where the content had \"hi there\" and use that to boost those exact matches. We do this by adding a simple should clause:\r\n\r\n```\r\n            \"bool\": {\r\n              \"must\": [\r\n                {\r\n                  \"multi_match\": {\r\n                    \"fields\": [\r\n                      \"mlt_content.default.ngram\"\r\n                    ],\r\n                    \"query\": \"hi ther\",\r\n                    \"operator\": \"and\",\r\n                    \"type\": \"cross_fields\"\r\n                  }\r\n                }\r\n              ],\r\n              \"should\": [\r\n                {\r\n                  \"multi_match\": {\r\n                    \"type\": \"phrase\",\r\n                    \"fields\": [\r\n                      \"mlt_content.default.ngram\"\r\n                    ],\r\n                    \"query\": \"hi ther\"\r\n                  }\r\n                }\r\n              ]\r\n            }\r\n          },\r\n```\r\n\r\n","closed_by":{"login":"romseygeek","id":1347065,"node_id":"MDQ6VXNlcjEzNDcwNjU=","avatar_url":"https://avatars0.githubusercontent.com/u/1347065?v=4","gravatar_id":"","url":"https://api.github.com/users/romseygeek","html_url":"https://github.com/romseygeek","followers_url":"https://api.github.com/users/romseygeek/followers","following_url":"https://api.github.com/users/romseygeek/following{/other_user}","gists_url":"https://api.github.com/users/romseygeek/gists{/gist_id}","starred_url":"https://api.github.com/users/romseygeek/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/romseygeek/subscriptions","organizations_url":"https://api.github.com/users/romseygeek/orgs","repos_url":"https://api.github.com/users/romseygeek/repos","events_url":"https://api.github.com/users/romseygeek/events{/privacy}","received_events_url":"https://api.github.com/users/romseygeek/received_events","type":"User","site_admin":false},"performed_via_github_app":null}