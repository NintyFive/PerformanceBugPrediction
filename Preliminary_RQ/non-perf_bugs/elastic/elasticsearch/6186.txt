{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/6186","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/6186/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/6186/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/6186/events","html_url":"https://github.com/elastic/elasticsearch/issues/6186","id":33583415,"node_id":"MDU6SXNzdWUzMzU4MzQxNQ==","number":6186,"title":"Scalable cluster state propagation (zen discovery)","user":{"login":"miccon","id":455015,"node_id":"MDQ6VXNlcjQ1NTAxNQ==","avatar_url":"https://avatars3.githubusercontent.com/u/455015?v=4","gravatar_id":"","url":"https://api.github.com/users/miccon","html_url":"https://github.com/miccon","followers_url":"https://api.github.com/users/miccon/followers","following_url":"https://api.github.com/users/miccon/following{/other_user}","gists_url":"https://api.github.com/users/miccon/gists{/gist_id}","starred_url":"https://api.github.com/users/miccon/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/miccon/subscriptions","organizations_url":"https://api.github.com/users/miccon/orgs","repos_url":"https://api.github.com/users/miccon/repos","events_url":"https://api.github.com/users/miccon/events{/privacy}","received_events_url":"https://api.github.com/users/miccon/received_events","type":"User","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":1,"created_at":"2014-05-15T13:10:05Z","updated_at":"2014-12-30T18:54:52Z","closed_at":"2014-12-30T18:54:52Z","author_association":"NONE","active_lock_reason":null,"body":"In the current implementation of zen discovery the cluster state broadcasting by the master does not scale too well as every change in the cluster state results in the cluster state being sent to every single node by the master.\n\nThis can lead to quite some traffic, in an cluster with 500 nodes and 15000 shards, even when the cluster state by itself has only 1MB, the master node will sent a total of 500MB per cluster state update.\n\nSo it should be possible to only send a diff of the changes to the nodes instead of the full cluster state. In case the nodes recognize that they missed an update, they could query the master node to resend the full cluster state to them.\n\nAnother possibility would be a tiered distribution of the state, where the master node does not directly send the updates to every single node, but through other nodes which forward the state to the other nodes in the cluster. A gossipping protocol could here be used.\n\nIf the clusterstate does not need to be distributed in realtime, one could also throttle the propagation of the state, so that when changes come in rapid succession, the changes can be merged before the state has been sent out to every node.\n\nAny ideas?\n","closed_by":{"login":"clintongormley","id":56599,"node_id":"MDQ6VXNlcjU2NTk5","avatar_url":"https://avatars0.githubusercontent.com/u/56599?v=4","gravatar_id":"","url":"https://api.github.com/users/clintongormley","html_url":"https://github.com/clintongormley","followers_url":"https://api.github.com/users/clintongormley/followers","following_url":"https://api.github.com/users/clintongormley/following{/other_user}","gists_url":"https://api.github.com/users/clintongormley/gists{/gist_id}","starred_url":"https://api.github.com/users/clintongormley/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/clintongormley/subscriptions","organizations_url":"https://api.github.com/users/clintongormley/orgs","repos_url":"https://api.github.com/users/clintongormley/repos","events_url":"https://api.github.com/users/clintongormley/events{/privacy}","received_events_url":"https://api.github.com/users/clintongormley/received_events","type":"User","site_admin":false},"performed_via_github_app":null}