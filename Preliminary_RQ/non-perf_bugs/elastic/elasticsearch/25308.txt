{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/25308","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/25308/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/25308/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/25308/events","html_url":"https://github.com/elastic/elasticsearch/issues/25308","id":237094923,"node_id":"MDU6SXNzdWUyMzcwOTQ5MjM=","number":25308,"title":"Harmful paging in Percolator results","user":{"login":"dennisgorelik","id":4333866,"node_id":"MDQ6VXNlcjQzMzM4NjY=","avatar_url":"https://avatars2.githubusercontent.com/u/4333866?v=4","gravatar_id":"","url":"https://api.github.com/users/dennisgorelik","html_url":"https://github.com/dennisgorelik","followers_url":"https://api.github.com/users/dennisgorelik/followers","following_url":"https://api.github.com/users/dennisgorelik/following{/other_user}","gists_url":"https://api.github.com/users/dennisgorelik/gists{/gist_id}","starred_url":"https://api.github.com/users/dennisgorelik/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dennisgorelik/subscriptions","organizations_url":"https://api.github.com/users/dennisgorelik/orgs","repos_url":"https://api.github.com/users/dennisgorelik/repos","events_url":"https://api.github.com/users/dennisgorelik/events{/privacy}","received_events_url":"https://api.github.com/users/dennisgorelik/received_events","type":"User","site_admin":false},"labels":[{"id":156502592,"node_id":"MDU6TGFiZWwxNTY1MDI1OTI=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/:Search/Percolator","name":":Search/Percolator","color":"0e8a16","default":false,"description":"Reverse search: find queries that match a document"}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":7,"created_at":"2017-06-20T05:16:18Z","updated_at":"2017-09-22T14:14:13Z","closed_at":"2017-09-22T14:14:13Z","author_association":"NONE","active_lock_reason":null,"body":"When [percolator index structure was \"standardized\"](https://www.elastic.co/blog/elasticsearch-percolator-continues-to-evolve) - it gained unwanted features from standard search index:\r\n1)\tPage size limit.\r\n2)\tMatch score and other unneeded information.\r\n\r\nThere are no practical advantages of having these misfeatures, but there are significant problems associated with them.\r\nIn particular, from business perspective, limiting page size on percolator results just does not make sense: if I have 1 million subscribers (percolator queries) to a specific keyword in a document, why would I want to receive matches only to a small subset (one page) of these subscribers? Quite the contrary: from the business perspective I would always want to receive matches to all percolator subscribers.\r\nWhy would I want to rank and order my subscribers when I output results? I simply want to notify all my subscribers about new document that is matching their percolator queries.\r\n\r\nCurrent \"standardized index\" implementation of percolator index – makes it very easy to make a mistake by outputting only a small subset of matching percolator queries. This subset size is only 10 (sic!) by default.\r\nBut if I want to specify higher page size – it can NOT be more than 10,000 without index redesign.\r\nSuch implementation is clearly counterproductive to the percolator business logic.\r\n\r\nSo why had ElasticSearch team decided to break backward compatibility and merge Percolator into a standard search index format?\r\n\r\nThis is the excuse:\r\n\r\n> https://www.elastic.co/blog/elasticsearch-percolator-continues-to-evolve\r\n> Prior to 5.0, all percolator queries need to be executed on this in-memory index in order to verify whether the query matches. So the idea is that the less queries that need to be verified by the in-memory index the faster the percolator executes.\r\n\r\nIn my first reading of that ambiguous claim I thought that ElasticSearch would be able to automatically detect what percolator queries is ok to skip, so it would, effectively, improve percolator performance.\r\nHowever the correct interpretation actually is that application developer in ElasticSearch 5.4 has an option to tag percolator queries (alerts), and then write code that would help percolator to skip alerts that have no chance to being triggered by a document we percolate.\r\nBut the problem is that it is very hard to come up with such \"alerts skipping\" algorithm. Percolator is so valuable in the first place exactly because of that ability to determine what alerts match and what alerts do not!\r\n\r\nIn addition to getting these bugs and misfeatures, with ES 5.4 we got [3 times slower percolator](https://github.com/elastic/elasticsearch/issues/25278).\r\n\r\nI do not see any practical positive result in squeezing percolator structure into the standard ElasticSearch index structure. Main search and percolator search are simply different features that should be treated differently.","closed_by":{"login":"martijnvg","id":580421,"node_id":"MDQ6VXNlcjU4MDQyMQ==","avatar_url":"https://avatars3.githubusercontent.com/u/580421?v=4","gravatar_id":"","url":"https://api.github.com/users/martijnvg","html_url":"https://github.com/martijnvg","followers_url":"https://api.github.com/users/martijnvg/followers","following_url":"https://api.github.com/users/martijnvg/following{/other_user}","gists_url":"https://api.github.com/users/martijnvg/gists{/gist_id}","starred_url":"https://api.github.com/users/martijnvg/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/martijnvg/subscriptions","organizations_url":"https://api.github.com/users/martijnvg/orgs","repos_url":"https://api.github.com/users/martijnvg/repos","events_url":"https://api.github.com/users/martijnvg/events{/privacy}","received_events_url":"https://api.github.com/users/martijnvg/received_events","type":"User","site_admin":false},"performed_via_github_app":null}