{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/39405","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/39405/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/39405/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/39405/events","html_url":"https://github.com/elastic/elasticsearch/issues/39405","id":414710675,"node_id":"MDU6SXNzdWU0MTQ3MTA2NzU=","number":39405,"title":"Feature Request: Adjust score based on number of matching documents","user":{"login":"pySilver","id":1113925,"node_id":"MDQ6VXNlcjExMTM5MjU=","avatar_url":"https://avatars1.githubusercontent.com/u/1113925?v=4","gravatar_id":"","url":"https://api.github.com/users/pySilver","html_url":"https://github.com/pySilver","followers_url":"https://api.github.com/users/pySilver/followers","following_url":"https://api.github.com/users/pySilver/following{/other_user}","gists_url":"https://api.github.com/users/pySilver/gists{/gist_id}","starred_url":"https://api.github.com/users/pySilver/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/pySilver/subscriptions","organizations_url":"https://api.github.com/users/pySilver/orgs","repos_url":"https://api.github.com/users/pySilver/repos","events_url":"https://api.github.com/users/pySilver/events{/privacy}","received_events_url":"https://api.github.com/users/pySilver/received_events","type":"User","site_admin":false},"labels":[{"id":418189364,"node_id":"MDU6TGFiZWw0MTgxODkzNjQ=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/:Search/Ranking","name":":Search/Ranking","color":"0e8a16","default":false,"description":"Scoring, rescoring, rank evaluation."}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":2,"created_at":"2019-02-26T16:46:50Z","updated_at":"2019-02-26T20:03:07Z","closed_at":"2019-02-26T20:02:19Z","author_association":"NONE","active_lock_reason":null,"body":"Hi!\r\n\r\nIt might sound like SO question, but I haven't found anything remotely similar to my case in docs (and I checked it really well). So its kinda last resort to post it here :) \r\n\r\nI'm looking for the way to adjust score based on number of matching documents (through the function score or term score boosting or anything else)\r\n\r\nHere is an example. You have 1000 sport shoes of different brands with the following distribution:\r\n\r\nAdidas: 500\r\nNike: 300\r\nReebok: 150\r\nPuma: 50\r\n\r\nYou'd like to show just 100 products per page and you definitely want to show products of a different brands, to avoid the situation that brand with biggest amount of products takes all space of a page, at least 1st page.\r\n\r\n*Random/Function score* score will not work here simply because it does not take population size out of picture.\r\n\r\nI was thinking about term query boost where each brand have different boost value based on its frequency, but that makes big brands products shifted to next pages all together if their boost val is too low, or it wont have any effect is too close to average value.\r\n\r\nMaybe its possible to randomize boost from negative to some positive values per brand based on population (what value/why?) so some of products of biggest brand will be boosted and some not, while keeping positive boost range for smaller brands. It produces unpredictable output, but at least its better than \"pure random\". But still to make pagination and filtering work that boost should be constant for same product, so it wont appear on page 2,3 etc.\r\n\r\nWhat I miss here actually is ability to stop boosting after X products of _that_ brand being boosted. Non-optimal solution would be (probably) to memorize product ids per brand that needs to be boosted and use it in term query/function score with context, but that raises questions of pagination and further filtering support. Sounds complex but fully automated solution would require:\r\n\r\n1. aggregation query to determine competitive brands & number of matching products  in that product category\r\n2. normalization by picking X products for each brand exceeding median value\r\n3. boost all products except picked ones with negative value for biggest brands (or vice versa â€“ boost all products of all brands equally, but for biggest brand limit boost to picked products only)\r\n\r\nI will also be fine if I can somehow influence a position of a brand. Let's say by mod: Adidas takes every % 2 position, Nike ever 3rd and so on.\r\n\r\nP.S. Does function_score is executed on every document that matches query (filter query in my case) or just a paginated subset returned by a query?","closed_by":{"login":"mayya-sharipova","id":5738841,"node_id":"MDQ6VXNlcjU3Mzg4NDE=","avatar_url":"https://avatars1.githubusercontent.com/u/5738841?v=4","gravatar_id":"","url":"https://api.github.com/users/mayya-sharipova","html_url":"https://github.com/mayya-sharipova","followers_url":"https://api.github.com/users/mayya-sharipova/followers","following_url":"https://api.github.com/users/mayya-sharipova/following{/other_user}","gists_url":"https://api.github.com/users/mayya-sharipova/gists{/gist_id}","starred_url":"https://api.github.com/users/mayya-sharipova/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mayya-sharipova/subscriptions","organizations_url":"https://api.github.com/users/mayya-sharipova/orgs","repos_url":"https://api.github.com/users/mayya-sharipova/repos","events_url":"https://api.github.com/users/mayya-sharipova/events{/privacy}","received_events_url":"https://api.github.com/users/mayya-sharipova/received_events","type":"User","site_admin":false},"performed_via_github_app":null}