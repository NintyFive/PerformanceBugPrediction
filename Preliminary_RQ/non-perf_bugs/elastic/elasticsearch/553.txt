{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/553","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/553/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/553/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/553/events","html_url":"https://github.com/elastic/elasticsearch/issues/553","id":461696,"node_id":"MDU6SXNzdWU0NjE2OTY=","number":553,"title":"Parent / Child Support","user":{"login":"kimchy","id":41300,"node_id":"MDQ6VXNlcjQxMzAw","avatar_url":"https://avatars1.githubusercontent.com/u/41300?v=4","gravatar_id":"","url":"https://api.github.com/users/kimchy","html_url":"https://github.com/kimchy","followers_url":"https://api.github.com/users/kimchy/followers","following_url":"https://api.github.com/users/kimchy/following{/other_user}","gists_url":"https://api.github.com/users/kimchy/gists{/gist_id}","starred_url":"https://api.github.com/users/kimchy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/kimchy/subscriptions","organizations_url":"https://api.github.com/users/kimchy/orgs","repos_url":"https://api.github.com/users/kimchy/repos","events_url":"https://api.github.com/users/kimchy/events{/privacy}","received_events_url":"https://api.github.com/users/kimchy/received_events","type":"User","site_admin":false},"labels":[{"id":23172,"node_id":"MDU6TGFiZWwyMzE3Mg==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/%3Efeature","name":">feature","color":"006b75","default":false,"description":null},{"id":58413,"node_id":"MDU6TGFiZWw1ODQxMw==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/v0.14.0","name":"v0.14.0","color":"DDDDDD","default":false,"description":null}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":6,"created_at":"2010-12-07T22:15:20Z","updated_at":"2015-06-29T12:41:24Z","closed_at":"2010-12-08T06:17:01Z","author_association":"MEMBER","active_lock_reason":null,"body":"The parent/child documents support allows to define a parent relationship from a child type to a parent type. \n## Mapping\n\nThe relationship is defined using a simple mapping definition at the child level mapping. For example, in case of a `blog` type and a `blog_tag` type child document, the mapping for `blog_tag` should be:\n\n```\n{\n    \"blog_tag\" : {\n        \"_parent\" : {\n            \"type\" : \"blog\"\n        }\n    }\n}\n```\n\nThe above defines a parent mapping, and the type of the parent.\n## Indexing\n\nWhen indexing a child document, it is important that it will be routed to the same shard as the parent. This uses the routing capability. When indexing a doc with a parent id, it is automatically set as the routing value (unless the routing value is explicitly defined). Indexing a document with a parent id is simple:\n\n```\ncurl -XPUT localhost:9200/blogs/blog_tag/1122?parent=1111 -d '\n{\n    \"tag\" : \"something\"\n}\n'\n```\n\nThere is an option to set `_parent` in each bulk index item as well.\n## Querying\n\nThere are several mechanisms to query child documents.  The idea of child filter / query is that its inner query is run against the child documents, and the result of it are parent docs matching those child documents.\n\nThe way it is implemented is that the child queries are first run on their own, with the results \"joining\" the parent documents. Then, the main query runs with the results of the child query, which includes the parent docs.\n# `has_child`\n\nThe first is the `has_child` filter and `has_child` query (which is a simple `constant_score` query wrapping the `has_child` filter):\n\n```\n{\n    \"has_child\" : {\n        \"type\" : \"blog_tag\"\n        \"query\" : {\n            \"term\" : {\n                \"tag\" : \"something\"\n            }\n        }\n    }\n}\n```\n\nThe `type` is the child type to query against. The parent type to return is automatically detected based on the mappings.\n\nThe query (and filter), do no scoring, and the \"join\" process of matching which parent doc the child doc matches is done _on each matching child doc_.\n# `top_children`\n\nThe `top_children` query basically runs the child query with an estimated hits size, and out of this hit docs, aggregates it into parent docs. If there aren't enough parent docs matching the requested from/size search request, then it is run again with a wider (more hits) search.\n\nThe `top_children` also provide scoring capabilities, with the ability to specify `max`, `sum` or `avg` as the `score` type.\n\nOne downside of using the `top_children` is that if there are more child docs matching the required hits when executing the child query, then the `total_hits` result of the search response will be incorrect.\n\nHow many hits are asked for in the first child query run is controlled using the `factor` parameter (defaults to `5`). For example, when asking for 10 docs with from 0, then the child query will execute with 50 hits expected. If not enough parents are found (in our example, 10), and there are still more child docs to query, then the search hits are expanded my multiplying by the `incremental_factor` (defaults to `2`).\n\nThe required parameters are the `query` and `type` (the child type to execute the query on). Here is an example with all different parameters, including the default values:\n\n```\n{\n    \"top_children\" : {\n        \"type\": \"blog_tag\",\n        \"query\" : {\n            \"term\" : {\n                \"tag\" : \"something\"\n            }\n        }\n        \"score\" : \"max\",\n        \"factor\" : 5,\n        \"incremental_factor\" : 2\n    }\n}\n```\n## Faceting\n\nFaceting on the child query phase (on the results of the query executed) can be done by specifying a `scope` with a custom name in the query / filter. All facets now accept a `scope` to run on (similar to global set to `true`), and can now be executed on docs matching the child query.\n## Query Performance\n\nIn general, the `top_children` performance will be much better than the `has_child` performance. This is because joining the child to its parent is done in the `top_children` case against the expected number of hits returned, while in the `has_child` case, it is executed against _all_ child docs matching the child query.\n## Memory Considerations\n\nWith the current implementation, all `_id` values are loaded to memory (heap) in order to support fast lookups, so make sure there is enough mem for it.\n","closed_by":null,"performed_via_github_app":null}