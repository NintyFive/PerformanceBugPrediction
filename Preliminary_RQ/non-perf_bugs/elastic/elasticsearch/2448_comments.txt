[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/10831916","html_url":"https://github.com/elastic/elasticsearch/issues/2448#issuecomment-10831916","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/2448","id":10831916,"node_id":"MDEyOklzc3VlQ29tbWVudDEwODMxOTE2","user":{"login":"jprante","id":635745,"node_id":"MDQ6VXNlcjYzNTc0NQ==","avatar_url":"https://avatars1.githubusercontent.com/u/635745?v=4","gravatar_id":"","url":"https://api.github.com/users/jprante","html_url":"https://github.com/jprante","followers_url":"https://api.github.com/users/jprante/followers","following_url":"https://api.github.com/users/jprante/following{/other_user}","gists_url":"https://api.github.com/users/jprante/gists{/gist_id}","starred_url":"https://api.github.com/users/jprante/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jprante/subscriptions","organizations_url":"https://api.github.com/users/jprante/orgs","repos_url":"https://api.github.com/users/jprante/repos","events_url":"https://api.github.com/users/jprante/events{/privacy}","received_events_url":"https://api.github.com/users/jprante/received_events","type":"User","site_admin":false},"created_at":"2012-11-29T01:51:18Z","updated_at":"2012-11-29T01:51:18Z","author_association":"CONTRIBUTOR","body":"You can setup nodes with HTTP for the networking load blancing from outside, while the other nodes don't need to have HTTP.\n\nOther nodes without HTTP and no data can act as pass-through nodes. If you connect a transport client to such a node, you force Elasticsearch to route all the requests and response for the transport client via the pass-through node. The pass-through node will have to reduce/gather the results for the transport client. With a number of parallel http-less and data-less nodes, you are close to what you want.\n\nFrom what I understand, the reduce/gathering should be performed as close as possible to the requesting client, otherwise responses can't be delivered back straight to the requester. Otherwise, it is open to me what the advantage is when nodes must be elected to perform reduce/gathering for other nodes just to pass the result back to them.\n\nAs a long term perspective, it could be viable to introduce a chunked stream response protocol between the nodes and the requesting client. This would ease some of the memory peaks of gathered large responses.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/10832892","html_url":"https://github.com/elastic/elasticsearch/issues/2448#issuecomment-10832892","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/2448","id":10832892,"node_id":"MDEyOklzc3VlQ29tbWVudDEwODMyODky","user":{"login":"chendo","id":2661,"node_id":"MDQ6VXNlcjI2NjE=","avatar_url":"https://avatars3.githubusercontent.com/u/2661?v=4","gravatar_id":"","url":"https://api.github.com/users/chendo","html_url":"https://github.com/chendo","followers_url":"https://api.github.com/users/chendo/followers","following_url":"https://api.github.com/users/chendo/following{/other_user}","gists_url":"https://api.github.com/users/chendo/gists{/gist_id}","starred_url":"https://api.github.com/users/chendo/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/chendo/subscriptions","organizations_url":"https://api.github.com/users/chendo/orgs","repos_url":"https://api.github.com/users/chendo/repos","events_url":"https://api.github.com/users/chendo/events{/privacy}","received_events_url":"https://api.github.com/users/chendo/received_events","type":"User","site_admin":false},"created_at":"2012-11-29T02:40:09Z","updated_at":"2012-11-29T02:40:09Z","author_association":"NONE","body":"I'm not sure if I understand how this will actually work or if it applies to our scenario. How would I force the HTTP enabled nodes to route through the pass-through/client nodes?\n\nOur goal is to avoid SPOF with regards to ES as well as try to keep non-app server specific load off our app servers, and we don't want to either use a HTTP load balancer because it's not as smart as an cluster-aware client. We have seen memory pressure from our client nodes previously and didn't understand why until I found out they were also doing the reduction step.\n\nI'm open to suggestions that satisfy our goals, but I can see a need for cluster-aware routing with minimal CPU/memory usage.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/10838723","html_url":"https://github.com/elastic/elasticsearch/issues/2448#issuecomment-10838723","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/2448","id":10838723,"node_id":"MDEyOklzc3VlQ29tbWVudDEwODM4NzIz","user":{"login":"jprante","id":635745,"node_id":"MDQ6VXNlcjYzNTc0NQ==","avatar_url":"https://avatars1.githubusercontent.com/u/635745?v=4","gravatar_id":"","url":"https://api.github.com/users/jprante","html_url":"https://github.com/jprante","followers_url":"https://api.github.com/users/jprante/followers","following_url":"https://api.github.com/users/jprante/following{/other_user}","gists_url":"https://api.github.com/users/jprante/gists{/gist_id}","starred_url":"https://api.github.com/users/jprante/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jprante/subscriptions","organizations_url":"https://api.github.com/users/jprante/orgs","repos_url":"https://api.github.com/users/jprante/repos","events_url":"https://api.github.com/users/jprante/events{/privacy}","received_events_url":"https://api.github.com/users/jprante/received_events","type":"User","site_admin":false},"created_at":"2012-11-29T08:20:50Z","updated_at":"2012-11-29T08:20:50Z","author_association":"CONTRIBUTOR","body":"I'm not completely sure if my suggestions fit to your environment, but I assume you are using Java app servers. With Java app servers, you have the TransportClient available. Other app servers would rely on the HTTP REST API.\n\nThe Java app server scenario is as follows. Configure some pass-thru nodes (without HTTP and without data, they also need a parameter they not become master). In each of your Java app instance, fire up a singleton TransportClient with a list of the pass-through node IPs. As a result, they only connect to those nodes and execute remotely on those nodes the Elasticsearch actions with gather/reduce load. The TransportClient manages the failover between the pass-through nodes. At least one of them must always be up, so monitor them.\n\nThe non-Java app server scenario is a little bit more challenging, since there is no automatic failover provided by Elasticsearch. A best practice is to start HTTP-enabled and data-less Elasticsearch nodes on each non-Java app server. The non-Java app connects to the Elasticsearch node at localhost, and delegates the gather/reduce and ES failover management to it. \n\nI assume this is the case you do not prefer, the sharing of a Java Elasticsearch node and the non-Java app node on the same machine. In case of this, you would have to assign each non-Java app server node to another corresponding Elasticsearch HTTP data-less node somewhere on the local network it can connect to, and you should monitor all those pairs for connection failures. Another option is to prepare a round-robin fashion selection or a kind of a random selection of one of  the HTTP-enabled data-less Elasticsearch nodes from your non-Java app instances for yourself, from a pre-configured IP list. I know, the Perl client for example comes with such an ability.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/10842175","html_url":"https://github.com/elastic/elasticsearch/issues/2448#issuecomment-10842175","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/2448","id":10842175,"node_id":"MDEyOklzc3VlQ29tbWVudDEwODQyMTc1","user":{"login":"chendo","id":2661,"node_id":"MDQ6VXNlcjI2NjE=","avatar_url":"https://avatars3.githubusercontent.com/u/2661?v=4","gravatar_id":"","url":"https://api.github.com/users/chendo","html_url":"https://github.com/chendo","followers_url":"https://api.github.com/users/chendo/followers","following_url":"https://api.github.com/users/chendo/following{/other_user}","gists_url":"https://api.github.com/users/chendo/gists{/gist_id}","starred_url":"https://api.github.com/users/chendo/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/chendo/subscriptions","organizations_url":"https://api.github.com/users/chendo/orgs","repos_url":"https://api.github.com/users/chendo/repos","events_url":"https://api.github.com/users/chendo/events{/privacy}","received_events_url":"https://api.github.com/users/chendo/received_events","type":"User","site_admin":false},"created_at":"2012-11-29T10:33:16Z","updated_at":"2012-11-29T10:33:16Z","author_association":"NONE","body":"Our stack is Ruby on Rails, so we access ES over the HTTP REST interface. We're already running client nodes locally on each app server, and we're okay with that because having a client node on another host is not something we want to have to do because it's not flexible.\n\nRound-robin is also something we wouldn't want as that involves static IP lists, and if a node goes down, the entire stack would eventually hit the missing node, and then we have to deal with HTTP timeout and mark it as down etc, so not as intelligent as a client node.\n\nWe're okay with running a local client node on the box assuming it did the least amount of work as possible, and this is why we would like the option to disable a client node from performing the reduce step.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/50122907","html_url":"https://github.com/elastic/elasticsearch/issues/2448#issuecomment-50122907","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/2448","id":50122907,"node_id":"MDEyOklzc3VlQ29tbWVudDUwMTIyOTA3","user":{"login":"clintongormley","id":56599,"node_id":"MDQ6VXNlcjU2NTk5","avatar_url":"https://avatars0.githubusercontent.com/u/56599?v=4","gravatar_id":"","url":"https://api.github.com/users/clintongormley","html_url":"https://github.com/clintongormley","followers_url":"https://api.github.com/users/clintongormley/followers","following_url":"https://api.github.com/users/clintongormley/following{/other_user}","gists_url":"https://api.github.com/users/clintongormley/gists{/gist_id}","starred_url":"https://api.github.com/users/clintongormley/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/clintongormley/subscriptions","organizations_url":"https://api.github.com/users/clintongormley/orgs","repos_url":"https://api.github.com/users/clintongormley/repos","events_url":"https://api.github.com/users/clintongormley/events{/privacy}","received_events_url":"https://api.github.com/users/clintongormley/received_events","type":"User","site_admin":false},"created_at":"2014-07-25T08:41:55Z","updated_at":"2014-07-25T08:41:55Z","author_association":"CONTRIBUTOR","body":"The transport client doesn't do reduce, but does do sniffing and round robin, as does the ruby client.  Closing\n","performed_via_github_app":null}]