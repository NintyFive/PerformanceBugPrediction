{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/32372","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/32372/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/32372/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/32372/events","html_url":"https://github.com/elastic/elasticsearch/issues/32372","id":344539324,"node_id":"MDU6SXNzdWUzNDQ1MzkzMjQ=","number":32372,"title":"[Rollup] Replace ID generation scheme to avoid collisions","user":{"login":"polyfractal","id":1224228,"node_id":"MDQ6VXNlcjEyMjQyMjg=","avatar_url":"https://avatars1.githubusercontent.com/u/1224228?v=4","gravatar_id":"","url":"https://api.github.com/users/polyfractal","html_url":"https://github.com/polyfractal","followers_url":"https://api.github.com/users/polyfractal/followers","following_url":"https://api.github.com/users/polyfractal/following{/other_user}","gists_url":"https://api.github.com/users/polyfractal/gists{/gist_id}","starred_url":"https://api.github.com/users/polyfractal/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/polyfractal/subscriptions","organizations_url":"https://api.github.com/users/polyfractal/orgs","repos_url":"https://api.github.com/users/polyfractal/repos","events_url":"https://api.github.com/users/polyfractal/events{/privacy}","received_events_url":"https://api.github.com/users/polyfractal/received_events","type":"User","site_admin":false},"labels":[{"id":912843355,"node_id":"MDU6TGFiZWw5MTI4NDMzNTU=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/:Analytics/Rollup","name":":Analytics/Rollup","color":"0e8a16","default":false,"description":"Turn fine-grained time-based data into coarser-grained data"},{"id":23173,"node_id":"MDU6TGFiZWwyMzE3Mw==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/%3Ebug","name":">bug","color":"b60205","default":false,"description":null}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":4,"created_at":"2018-07-25T17:36:01Z","updated_at":"2018-08-08T08:52:21Z","closed_at":"2018-08-03T15:13:26Z","author_association":"MEMBER","active_lock_reason":null,"body":"In pre-release versions of Rollup we used to concatenate all the rollup doc keys together to form the doc's ID, but at some point this was changed to a rolling CRC32.  I don't recall the specifics about why we did this, probably just to save space and avoid giant IDs.\r\n\r\nUnfortunately, this was poorly thought out.  32bit IDs lead to collisions very quickly as the doc count grows.  Existing Rollup indices over 200k docs have a very high chance of at least one collision, meaning a leaf node of a rollup interval overwrote a previous leaf node.  Ultimately, this leads to data loss and subtly incorrect results.  It also limits the total number of docs in the rollup index.\r\n\r\nOur current plan to fix is:\r\n\r\n1. Move back to concatenating job ID and composite keys together to form a unique ID\r\n   1. Insert a delimiter after the Job ID to guarantee that collisions can't be created (accidentally or otherwise) based on the job name.\r\n   2. Guarantee that the date histo key is immediately after the job ID.  Due to date format restrictions, this means we don't need to blacklist the delimiter in job names... just ensure it can't appear in a valid date pattern.\r\n   3. If the ID is >= 32k bytes (the hard limit for Lucene) fall back to hashing with a sufficiently large hash.\r\n\r\n2. Add a flag to the persistent task's state that indicates if the job is running on the old or new ID\r\n   1. If the indexer is still running, continue to use the old ID scheme.\r\n   2. Whenever the job checkpoints (on stop, failure or periodically), toggle the flag and switch to new scheme.  Since the flag is also persisted, any future triggers of the job will continue to use the new ID\r\n   3. All new jobs start with flag toggled and use the new ID scheme\r\n\r\n3. Bump the internal Rollup version, so that we have some diagnosing power for reports of problems in the future.\r\n\r\n4. Benchmark the size of concatenated IDs to make sure it doesn't bloat the index too much.  Prefix-compression should be strong for these IDs, but good to double check.  If it's really bad we can just hash the values directly instead and skip the part where we cutover at 32k\r\n\r\nChanging the ID scheme in the middle of a job is acceptable as long as we have checkpointed our position.  Deterministic IDs are only required so that, if we are interrupted before we get to the next checkpoint, we can roll back to the last checkpoint and just overwrite existing docs.  So as long as we change the ID scheme on checkpoint, we know there are no \"partial results\" that may need overwriting.\r\n\r\nWe'll deal with 7.0 upgrade issues in a followup.\r\n\r\n/cc @jimczi @colings86 @pcsanwald @clintongormley ","closed_by":{"login":"polyfractal","id":1224228,"node_id":"MDQ6VXNlcjEyMjQyMjg=","avatar_url":"https://avatars1.githubusercontent.com/u/1224228?v=4","gravatar_id":"","url":"https://api.github.com/users/polyfractal","html_url":"https://github.com/polyfractal","followers_url":"https://api.github.com/users/polyfractal/followers","following_url":"https://api.github.com/users/polyfractal/following{/other_user}","gists_url":"https://api.github.com/users/polyfractal/gists{/gist_id}","starred_url":"https://api.github.com/users/polyfractal/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/polyfractal/subscriptions","organizations_url":"https://api.github.com/users/polyfractal/orgs","repos_url":"https://api.github.com/users/polyfractal/repos","events_url":"https://api.github.com/users/polyfractal/events{/privacy}","received_events_url":"https://api.github.com/users/polyfractal/received_events","type":"User","site_admin":false},"performed_via_github_app":null}