{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/2117","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/2117/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/2117/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/2117/events","html_url":"https://github.com/elastic/elasticsearch/issues/2117","id":5824122,"node_id":"MDU6SXNzdWU1ODI0MTIy","number":2117,"title":"split brain condition after second network disconnect - even with minimum_master_nodes set","user":{"login":"owenbutler","id":179979,"node_id":"MDQ6VXNlcjE3OTk3OQ==","avatar_url":"https://avatars1.githubusercontent.com/u/179979?v=4","gravatar_id":"","url":"https://api.github.com/users/owenbutler","html_url":"https://github.com/owenbutler","followers_url":"https://api.github.com/users/owenbutler/followers","following_url":"https://api.github.com/users/owenbutler/following{/other_user}","gists_url":"https://api.github.com/users/owenbutler/gists{/gist_id}","starred_url":"https://api.github.com/users/owenbutler/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/owenbutler/subscriptions","organizations_url":"https://api.github.com/users/owenbutler/orgs","repos_url":"https://api.github.com/users/owenbutler/repos","events_url":"https://api.github.com/users/owenbutler/events{/privacy}","received_events_url":"https://api.github.com/users/owenbutler/received_events","type":"User","site_admin":false},"labels":[{"id":23173,"node_id":"MDU6TGFiZWwyMzE3Mw==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/%3Ebug","name":">bug","color":"b60205","default":false,"description":null}],"state":"closed","locked":false,"assignee":{"login":"kimchy","id":41300,"node_id":"MDQ6VXNlcjQxMzAw","avatar_url":"https://avatars1.githubusercontent.com/u/41300?v=4","gravatar_id":"","url":"https://api.github.com/users/kimchy","html_url":"https://github.com/kimchy","followers_url":"https://api.github.com/users/kimchy/followers","following_url":"https://api.github.com/users/kimchy/following{/other_user}","gists_url":"https://api.github.com/users/kimchy/gists{/gist_id}","starred_url":"https://api.github.com/users/kimchy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/kimchy/subscriptions","organizations_url":"https://api.github.com/users/kimchy/orgs","repos_url":"https://api.github.com/users/kimchy/repos","events_url":"https://api.github.com/users/kimchy/events{/privacy}","received_events_url":"https://api.github.com/users/kimchy/received_events","type":"User","site_admin":false},"assignees":[{"login":"kimchy","id":41300,"node_id":"MDQ6VXNlcjQxMzAw","avatar_url":"https://avatars1.githubusercontent.com/u/41300?v=4","gravatar_id":"","url":"https://api.github.com/users/kimchy","html_url":"https://github.com/kimchy","followers_url":"https://api.github.com/users/kimchy/followers","following_url":"https://api.github.com/users/kimchy/following{/other_user}","gists_url":"https://api.github.com/users/kimchy/gists{/gist_id}","starred_url":"https://api.github.com/users/kimchy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/kimchy/subscriptions","organizations_url":"https://api.github.com/users/kimchy/orgs","repos_url":"https://api.github.com/users/kimchy/repos","events_url":"https://api.github.com/users/kimchy/events{/privacy}","received_events_url":"https://api.github.com/users/kimchy/received_events","type":"User","site_admin":false}],"milestone":null,"comments":18,"created_at":"2012-07-25T06:52:36Z","updated_at":"2014-06-16T02:09:38Z","closed_at":"2014-06-16T02:09:38Z","author_association":"NONE","active_lock_reason":null,"body":"## Summary:\n\nSplit brain can occur on the second network disconnect of a node, when the minimum_master_nodes is configured correctly(n/2+1).  The split brain occurs if the nodeId(UUID) of the disconnected node is such that the disconnected node picks itself as the next logical master while pinging the other nodes(NodeFaultDetection).  The split brain only occurs on the second time that the node is disconnected/isolated.\n## Detail:\n\nUsing ZenDiscovery, Node Id's are randomly generated(A UUID):  ZenDiscovery:169.\n\nWhen the node is disconnected/isolated it the ElectMasterService uses an ordered list of the Nodes (Ordered by nodeId) to determine a new potential master.  It picks the first of the ordered list: ElectMasterService:95\n\nBecause the nodeId's are random, it's possible for the disconnected/isolated node to be first in the ordered list, electing itself as a possible master.\n\nThe first time network is disconnected, the minimum_master_nodes property is honored and the disconnected/isolated node goes into a \"ping\" mode, where it simply tries to ping for other nodes.  Once the network is re-connected, the node re-joins the cluster successfully.\n\nThe Second time the network is disconnected, the minimum_master_nodes intent is not honored.  The disconnected/isolated node fails to realise that it's not connected to the remaining node in the 3 node cluster and elects itself as master, still thinking it's connected.\n\nIt feels like there is a failure in the transition between MasterFaultDetection and NodeFaultDetection, because it works the first time!\n\nThe fault only occurs if the nodeId is ordered such that the disconnected node picks itself as the master while isolated.  If the nodeId's are ordered such that it picks one of the other 2 nodes to be potential master then the isolated node honors the minimum_master_nodes intent every time.\n\nBecause the nodeId's are randomly(UUID) generated, the probability of this occuring drops as the number of nodes in the cluster goes up.  For our 3 node cluster it's ~50% (with one node detected as gone, it's up to the ordering of the remaining two nodeId's)\n\nNote, While we were trying track this down we found that the cluster.service TRACE level logging (which outputs the cluster state) does not list the nodes in election order.  IE, the first node in that printed list is not necessarily going to elected as master by the isolated node.\n## Detail Steps to reproduce:\n\nBecause the ordering of the nodeId's is random(UUID) we were having trouble getting a consitantly reproducable test case.  To fix the ordering, we made a patch to ZenDiscovery to allow us to optionally configure a nodeId.  This allowed us to set the nodeId of the disconnected/isolated node to guarantee it's ordering, allowing us to consistently reproduce.\n\nWe've tested this scenario on the 0.19.4, 0.19.7, 0.19.8 distributions and see the error when the nodeId's were ordered just right.\n\nWe also tested this scenario on the current git master with the supplied patch.\n\nIn this scenario, node3 will the be the node we disconnect/isolate.  So we start the nodes up in numerical order to ensure node3 doesn't _start_ as master.\n1. Configure nodes with attached configs (one is provided for each node)\n2. Start up nodes 1 and 2.  After they are attached and one is master, start node 3\n3. Create a blank index with default shard/replica(5/1) settings\n4. Pull network cable from node 3\n5. Node 3 detects master has gone (MasterFaultDetection)\n6. Node 3 elects itself as master (Because the nodeId's are ordered just right)\n7. Node 3 detects the remaining node has gone, enters ZenDiscovery minimum_master_nodes mode, prints a message indicating not enough nodes\n8. Node 3 goes into a ping state looking for nodes\n9. At this point, node 1 and node 2 report a valid cluster, they know about each other but not about node 3.\n10. Reconnect network to node 3\n11. Node 3 rejoins the cluster correctly, seeing that there is already a master in the cluster.\n\nAt this point, everything is working as expected.\n1.  Pull network cable from node 3 again\n2.  Node 3 detects master has gone (MasterFaultDetection)\n3.  Node 3 elects as itself as master (Because the nodeId's are ordered just right)\n4.  Node 3 now fails to detect that the remaining node in the cluster is not accessible.  It starts throwing a number of Netty NoRouteToHostExceptions about the remaining node.\n5.  According to node 3, cluster health is yellow and cluster state shows 2 data nodes\n6.  Reconnect network to node 3\n7.  Node 3 appears to connect to the node that it thinks it's still connected to.  (can see that via the cluster state api).  The other nodes log nothing and do not show the disconnected node as connected in any way.\n8.  Node 3 at this point accepts indexing and search requests, a classic split brain.\n\nHere's a gist with the patch to ZenDiscovery and the 3 node configs.\n\nhttps://gist.github.com/3174651\n","closed_by":{"login":"kimchy","id":41300,"node_id":"MDQ6VXNlcjQxMzAw","avatar_url":"https://avatars1.githubusercontent.com/u/41300?v=4","gravatar_id":"","url":"https://api.github.com/users/kimchy","html_url":"https://github.com/kimchy","followers_url":"https://api.github.com/users/kimchy/followers","following_url":"https://api.github.com/users/kimchy/following{/other_user}","gists_url":"https://api.github.com/users/kimchy/gists{/gist_id}","starred_url":"https://api.github.com/users/kimchy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/kimchy/subscriptions","organizations_url":"https://api.github.com/users/kimchy/orgs","repos_url":"https://api.github.com/users/kimchy/repos","events_url":"https://api.github.com/users/kimchy/events{/privacy}","received_events_url":"https://api.github.com/users/kimchy/received_events","type":"User","site_admin":false},"performed_via_github_app":null}