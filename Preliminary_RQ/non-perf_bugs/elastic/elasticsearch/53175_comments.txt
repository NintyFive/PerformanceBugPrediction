[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/595288389","html_url":"https://github.com/elastic/elasticsearch/issues/53175#issuecomment-595288389","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/53175","id":595288389,"node_id":"MDEyOklzc3VlQ29tbWVudDU5NTI4ODM4OQ==","user":{"login":"elasticmachine","id":15837671,"node_id":"MDQ6VXNlcjE1ODM3Njcx","avatar_url":"https://avatars3.githubusercontent.com/u/15837671?v=4","gravatar_id":"","url":"https://api.github.com/users/elasticmachine","html_url":"https://github.com/elasticmachine","followers_url":"https://api.github.com/users/elasticmachine/followers","following_url":"https://api.github.com/users/elasticmachine/following{/other_user}","gists_url":"https://api.github.com/users/elasticmachine/gists{/gist_id}","starred_url":"https://api.github.com/users/elasticmachine/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/elasticmachine/subscriptions","organizations_url":"https://api.github.com/users/elasticmachine/orgs","repos_url":"https://api.github.com/users/elasticmachine/repos","events_url":"https://api.github.com/users/elasticmachine/events{/privacy}","received_events_url":"https://api.github.com/users/elasticmachine/received_events","type":"User","site_admin":false},"created_at":"2020-03-05T15:26:39Z","updated_at":"2020-03-05T15:26:39Z","author_association":"COLLABORATOR","body":"Pinging @elastic/es-search (:Search/Mapping)","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/595313762","html_url":"https://github.com/elastic/elasticsearch/issues/53175#issuecomment-595313762","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/53175","id":595313762,"node_id":"MDEyOklzc3VlQ29tbWVudDU5NTMxMzc2Mg==","user":{"login":"costin","id":76245,"node_id":"MDQ6VXNlcjc2MjQ1","avatar_url":"https://avatars3.githubusercontent.com/u/76245?v=4","gravatar_id":"","url":"https://api.github.com/users/costin","html_url":"https://github.com/costin","followers_url":"https://api.github.com/users/costin/followers","following_url":"https://api.github.com/users/costin/following{/other_user}","gists_url":"https://api.github.com/users/costin/gists{/gist_id}","starred_url":"https://api.github.com/users/costin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/costin/subscriptions","organizations_url":"https://api.github.com/users/costin/orgs","repos_url":"https://api.github.com/users/costin/repos","events_url":"https://api.github.com/users/costin/events{/privacy}","received_events_url":"https://api.github.com/users/costin/received_events","type":"User","site_admin":false},"created_at":"2020-03-05T16:15:42Z","updated_at":"2020-03-05T16:15:42Z","author_association":"MEMBER","body":"Having some type of \"category\" would be useful however I'm not sure whether in the end it would be useful across all consumers.\r\nFor example for SQL there's a big difference in reporting a `long` vs a `double` as they have different size, precision ,etc...\r\nCurrently in case of a merge we do consider the field conflicting since it would be a merge between similar but yet different types. This is something that can be changed as we chose a different merging strategy however it's valuable to have the consumer decide on that instead of pushing that into `field_caps`.\r\n\r\nFor example, if a field is mapped as a `byte`, `short`, `integer`, `long` and `double` in case of merging what would be winning type and why?","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/595371072","html_url":"https://github.com/elastic/elasticsearch/issues/53175#issuecomment-595371072","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/53175","id":595371072,"node_id":"MDEyOklzc3VlQ29tbWVudDU5NTM3MTA3Mg==","user":{"login":"jpountz","id":299848,"node_id":"MDQ6VXNlcjI5OTg0OA==","avatar_url":"https://avatars2.githubusercontent.com/u/299848?v=4","gravatar_id":"","url":"https://api.github.com/users/jpountz","html_url":"https://github.com/jpountz","followers_url":"https://api.github.com/users/jpountz/followers","following_url":"https://api.github.com/users/jpountz/following{/other_user}","gists_url":"https://api.github.com/users/jpountz/gists{/gist_id}","starred_url":"https://api.github.com/users/jpountz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jpountz/subscriptions","organizations_url":"https://api.github.com/users/jpountz/orgs","repos_url":"https://api.github.com/users/jpountz/repos","events_url":"https://api.github.com/users/jpountz/events{/privacy}","received_events_url":"https://api.github.com/users/jpountz/received_events","type":"User","site_admin":false},"created_at":"2020-03-05T18:12:53Z","updated_at":"2020-03-05T18:12:53Z","author_association":"CONTRIBUTOR","body":"> This is something that can be changed as we chose a different merging strategy however it's valuable to have the consumer decide on that instead of pushing that into field_caps.\r\n\r\nI have mixed feelings on this. We're doing everything so that field types are as transparent as possible, e.g. `long` fields accept range queries that have floating-point bounds and do the right thing. Yet introducing new numeric fields requires changes in our SQL layer requires changes, which feels wrong to me.\r\n\r\n> For example, if a field is mapped as a byte, short, integer, long and double in case of merging what would be winning type and why?\r\n\r\nHow do you do it in SQL today?","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/595644522","html_url":"https://github.com/elastic/elasticsearch/issues/53175#issuecomment-595644522","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/53175","id":595644522,"node_id":"MDEyOklzc3VlQ29tbWVudDU5NTY0NDUyMg==","user":{"login":"astefan","id":893749,"node_id":"MDQ6VXNlcjg5Mzc0OQ==","avatar_url":"https://avatars2.githubusercontent.com/u/893749?v=4","gravatar_id":"","url":"https://api.github.com/users/astefan","html_url":"https://github.com/astefan","followers_url":"https://api.github.com/users/astefan/followers","following_url":"https://api.github.com/users/astefan/following{/other_user}","gists_url":"https://api.github.com/users/astefan/gists{/gist_id}","starred_url":"https://api.github.com/users/astefan/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/astefan/subscriptions","organizations_url":"https://api.github.com/users/astefan/orgs","repos_url":"https://api.github.com/users/astefan/repos","events_url":"https://api.github.com/users/astefan/events{/privacy}","received_events_url":"https://api.github.com/users/astefan/received_events","type":"User","site_admin":false},"created_at":"2020-03-06T07:46:33Z","updated_at":"2020-03-06T07:46:33Z","author_association":"CONTRIBUTOR","body":"In SQL, we depend on field_caps almost entirely and while `keyword` and `constant_keyword` can be regarded as \"equivalent\" **when merging mappings**, there are scenarios that need to know what a field type truly is. Think about `DESCRIBE index_alias` and `DESCRIBE single_index`. The first one will consider the equivalence between `keyword` and `constant_keyword` and the field with the same name will be displayed as `keyword`, while the second command will show `constant_keyword` field type.\r\n\r\nNote: `keyword` and `constant_keyword` is the only pair of field types that are considered equal in the merging mappings scenario.\r\n\r\nWith numeric fields, apart from the scenario above where we do not make them \"equal\" in any case, knowing which type is which is important when we take the `_source` and re-parse that numeric field to be displayed back to the user. A small note here: a `scaled_float` is not extracted from `_source`.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/620667007","html_url":"https://github.com/elastic/elasticsearch/issues/53175#issuecomment-620667007","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/53175","id":620667007,"node_id":"MDEyOklzc3VlQ29tbWVudDYyMDY2NzAwNw==","user":{"login":"mattkime","id":216176,"node_id":"MDQ6VXNlcjIxNjE3Ng==","avatar_url":"https://avatars2.githubusercontent.com/u/216176?v=4","gravatar_id":"","url":"https://api.github.com/users/mattkime","html_url":"https://github.com/mattkime","followers_url":"https://api.github.com/users/mattkime/followers","following_url":"https://api.github.com/users/mattkime/following{/other_user}","gists_url":"https://api.github.com/users/mattkime/gists{/gist_id}","starred_url":"https://api.github.com/users/mattkime/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mattkime/subscriptions","organizations_url":"https://api.github.com/users/mattkime/orgs","repos_url":"https://api.github.com/users/mattkime/repos","events_url":"https://api.github.com/users/mattkime/events{/privacy}","received_events_url":"https://api.github.com/users/mattkime/received_events","type":"User","site_admin":false},"created_at":"2020-04-28T15:09:34Z","updated_at":"2020-04-28T15:09:34Z","author_association":"NONE","body":"When you say that kibana performs this kind of merge, I think you're talking about kibana index patterns. I'm curious if there are other parts of kibana in which the specific field types are important.\r\n\r\nHere's the related kibana code - https://github.com/elastic/kibana/blob/master/src/plugins/data/common/kbn_field_types/kbn_field_types_factory.ts\r\n\r\nWould this change merge collapsible fields in such as way that we would no longer know the types comprising them?","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/620727049","html_url":"https://github.com/elastic/elasticsearch/issues/53175#issuecomment-620727049","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/53175","id":620727049,"node_id":"MDEyOklzc3VlQ29tbWVudDYyMDcyNzA0OQ==","user":{"login":"jpountz","id":299848,"node_id":"MDQ6VXNlcjI5OTg0OA==","avatar_url":"https://avatars2.githubusercontent.com/u/299848?v=4","gravatar_id":"","url":"https://api.github.com/users/jpountz","html_url":"https://github.com/jpountz","followers_url":"https://api.github.com/users/jpountz/followers","following_url":"https://api.github.com/users/jpountz/following{/other_user}","gists_url":"https://api.github.com/users/jpountz/gists{/gist_id}","starred_url":"https://api.github.com/users/jpountz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jpountz/subscriptions","organizations_url":"https://api.github.com/users/jpountz/orgs","repos_url":"https://api.github.com/users/jpountz/repos","events_url":"https://api.github.com/users/jpountz/events{/privacy}","received_events_url":"https://api.github.com/users/jpountz/received_events","type":"User","site_admin":false},"created_at":"2020-04-28T16:48:48Z","updated_at":"2020-04-28T16:48:48Z","author_association":"CONTRIBUTOR","body":"@mattkime If knowing the actual types is a requirement for you, it would be doable. Are there places where you need to know about the actual types today?","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/623385964","html_url":"https://github.com/elastic/elasticsearch/issues/53175#issuecomment-623385964","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/53175","id":623385964,"node_id":"MDEyOklzc3VlQ29tbWVudDYyMzM4NTk2NA==","user":{"login":"ppisljar","id":13629809,"node_id":"MDQ6VXNlcjEzNjI5ODA5","avatar_url":"https://avatars2.githubusercontent.com/u/13629809?v=4","gravatar_id":"","url":"https://api.github.com/users/ppisljar","html_url":"https://github.com/ppisljar","followers_url":"https://api.github.com/users/ppisljar/followers","following_url":"https://api.github.com/users/ppisljar/following{/other_user}","gists_url":"https://api.github.com/users/ppisljar/gists{/gist_id}","starred_url":"https://api.github.com/users/ppisljar/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ppisljar/subscriptions","organizations_url":"https://api.github.com/users/ppisljar/orgs","repos_url":"https://api.github.com/users/ppisljar/repos","events_url":"https://api.github.com/users/ppisljar/events{/privacy}","received_events_url":"https://api.github.com/users/ppisljar/received_events","type":"User","site_admin":false},"created_at":"2020-05-04T10:31:32Z","updated_at":"2020-05-04T10:31:32Z","author_association":"MEMBER","body":"i don't think we are interested in the actual elastic search type in kibana. am i missing something @timroes ?","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/623441038","html_url":"https://github.com/elastic/elasticsearch/issues/53175#issuecomment-623441038","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/53175","id":623441038,"node_id":"MDEyOklzc3VlQ29tbWVudDYyMzQ0MTAzOA==","user":{"login":"timroes","id":877229,"node_id":"MDQ6VXNlcjg3NzIyOQ==","avatar_url":"https://avatars0.githubusercontent.com/u/877229?v=4","gravatar_id":"","url":"https://api.github.com/users/timroes","html_url":"https://github.com/timroes","followers_url":"https://api.github.com/users/timroes/followers","following_url":"https://api.github.com/users/timroes/following{/other_user}","gists_url":"https://api.github.com/users/timroes/gists{/gist_id}","starred_url":"https://api.github.com/users/timroes/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/timroes/subscriptions","organizations_url":"https://api.github.com/users/timroes/orgs","repos_url":"https://api.github.com/users/timroes/repos","events_url":"https://api.github.com/users/timroes/events{/privacy}","received_events_url":"https://api.github.com/users/timroes/received_events","type":"User","site_admin":false},"created_at":"2020-05-04T12:43:39Z","updated_at":"2020-05-04T12:43:39Z","author_association":"CONTRIBUTOR","body":"We're storing the actual ES types and so removing that would also be a breaking change. In terms of what we're using them for: I don't have a complete list, but I think it was mainly introduced for KQL, since we needed to make some decision between text and keyword fields for the way we build the query, but I can't find that specific code right now. Another example seems to be field formatters where we are using it.\r\n\r\nEven if we could solve those without, I think we'll always have the need. One example that would come to my mind is e.g. support for significant text aggregation (https://github.com/elastic/kibana/issues/31614). We can only achieve that if we have the real ES types available, since our grouped \"String\" type is not enough and we also explicitly need to bypass `text` fields not being `aggregatable` by default for allowing them for this aggregation.\r\n\r\nI don't think removal of `esTypes` is something we want to do at the moment and we'll run in the future into more problems and features we cannot build with it (again). Also if we would decide to remove it, I think this should be some kind of breaking change.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/624497735","html_url":"https://github.com/elastic/elasticsearch/issues/53175#issuecomment-624497735","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/53175","id":624497735,"node_id":"MDEyOklzc3VlQ29tbWVudDYyNDQ5NzczNQ==","user":{"login":"jpountz","id":299848,"node_id":"MDQ6VXNlcjI5OTg0OA==","avatar_url":"https://avatars2.githubusercontent.com/u/299848?v=4","gravatar_id":"","url":"https://api.github.com/users/jpountz","html_url":"https://github.com/jpountz","followers_url":"https://api.github.com/users/jpountz/followers","following_url":"https://api.github.com/users/jpountz/following{/other_user}","gists_url":"https://api.github.com/users/jpountz/gists{/gist_id}","starred_url":"https://api.github.com/users/jpountz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jpountz/subscriptions","organizations_url":"https://api.github.com/users/jpountz/orgs","repos_url":"https://api.github.com/users/jpountz/repos","events_url":"https://api.github.com/users/jpountz/events{/privacy}","received_events_url":"https://api.github.com/users/jpountz/received_events","type":"User","site_admin":false},"created_at":"2020-05-06T07:53:47Z","updated_at":"2020-05-06T07:53:47Z","author_association":"CONTRIBUTOR","body":"@timroes I don't think we could ever collapse `text` and `keyword` together. We are only considering doing it for fields that would have a behavior that is so close that Kibana should never worry about knowing the exact type. For instance `float`, `scaled_float` and `double`, `integer` and `long`, `date` and `date_nanos`, or `keyword`, `constant_keyword` and `wildcard`.\r\n\r\nThis would be a breaking change indeed when we change it for existing types, and this won't happen until Elasticsearch 8.0. But we could potentially start doing it for fields that are not released yet such as `wildcard` in 7.x.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/624504129","html_url":"https://github.com/elastic/elasticsearch/issues/53175#issuecomment-624504129","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/53175","id":624504129,"node_id":"MDEyOklzc3VlQ29tbWVudDYyNDUwNDEyOQ==","user":{"login":"astefan","id":893749,"node_id":"MDQ6VXNlcjg5Mzc0OQ==","avatar_url":"https://avatars2.githubusercontent.com/u/893749?v=4","gravatar_id":"","url":"https://api.github.com/users/astefan","html_url":"https://github.com/astefan","followers_url":"https://api.github.com/users/astefan/followers","following_url":"https://api.github.com/users/astefan/following{/other_user}","gists_url":"https://api.github.com/users/astefan/gists{/gist_id}","starred_url":"https://api.github.com/users/astefan/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/astefan/subscriptions","organizations_url":"https://api.github.com/users/astefan/orgs","repos_url":"https://api.github.com/users/astefan/repos","events_url":"https://api.github.com/users/astefan/events{/privacy}","received_events_url":"https://api.github.com/users/astefan/received_events","type":"User","site_admin":false},"created_at":"2020-05-06T08:09:19Z","updated_at":"2020-05-06T08:09:19Z","author_association":"CONTRIBUTOR","body":"Just to reiterate that SQL will still need to know the exact field types.\r\nIt is true that at search/query time, this is not relevant for SQL in general, but reporting the data types of the fields in a table is a vital part of SQL. `DESCRIBE TABLE`, `SHOW COLUMNS` and the drivers do use the actual field types. The JDBC driver has specific methods for different field types, for retrieval and conversion purposes.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/624533025","html_url":"https://github.com/elastic/elasticsearch/issues/53175#issuecomment-624533025","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/53175","id":624533025,"node_id":"MDEyOklzc3VlQ29tbWVudDYyNDUzMzAyNQ==","user":{"login":"jpountz","id":299848,"node_id":"MDQ6VXNlcjI5OTg0OA==","avatar_url":"https://avatars2.githubusercontent.com/u/299848?v=4","gravatar_id":"","url":"https://api.github.com/users/jpountz","html_url":"https://github.com/jpountz","followers_url":"https://api.github.com/users/jpountz/followers","following_url":"https://api.github.com/users/jpountz/following{/other_user}","gists_url":"https://api.github.com/users/jpountz/gists{/gist_id}","starred_url":"https://api.github.com/users/jpountz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jpountz/subscriptions","organizations_url":"https://api.github.com/users/jpountz/orgs","repos_url":"https://api.github.com/users/jpountz/repos","events_url":"https://api.github.com/users/jpountz/events{/privacy}","received_events_url":"https://api.github.com/users/jpountz/received_events","type":"User","site_admin":false},"created_at":"2020-05-06T09:13:01Z","updated_at":"2020-05-06T09:13:01Z","author_association":"CONTRIBUTOR","body":"@astefan For my understanding, what would be the problem with always returning `constant_keyword` field as `keyword` and floats as doubles in SQL? If we are already doing it in the case of aliases sometimes, what would be wrong with doing it all the time?","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/625138869","html_url":"https://github.com/elastic/elasticsearch/issues/53175#issuecomment-625138869","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/53175","id":625138869,"node_id":"MDEyOklzc3VlQ29tbWVudDYyNTEzODg2OQ==","user":{"login":"timroes","id":877229,"node_id":"MDQ6VXNlcjg3NzIyOQ==","avatar_url":"https://avatars0.githubusercontent.com/u/877229?v=4","gravatar_id":"","url":"https://api.github.com/users/timroes","html_url":"https://github.com/timroes","followers_url":"https://api.github.com/users/timroes/followers","following_url":"https://api.github.com/users/timroes/following{/other_user}","gists_url":"https://api.github.com/users/timroes/gists{/gist_id}","starred_url":"https://api.github.com/users/timroes/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/timroes/subscriptions","organizations_url":"https://api.github.com/users/timroes/orgs","repos_url":"https://api.github.com/users/timroes/repos","events_url":"https://api.github.com/users/timroes/events{/privacy}","received_events_url":"https://api.github.com/users/timroes/received_events","type":"User","site_admin":false},"created_at":"2020-05-07T09:26:19Z","updated_at":"2020-05-07T09:26:19Z","author_association":"CONTRIBUTOR","body":"> @timroes I don't think we could ever collapse text and keyword together. We are only considering doing it for fields that would have a behavior that is so close that Kibana should never worry about knowing the exact type. For instance float, scaled_float and double, integer and long, date and date_nanos, or keyword, constant_keyword and wildcard.\r\n\r\nAnd I have the feeling with that we already run into the problem I mentioned when we discussed that last time. If Elasticsearch makes those groupings we kind of put internal Kibana knowledge that you might not have into your decision. So let's use exactly those pairs you mentioned as an example. JavaScript doesn't have 64bit integers, so we cannot represent `long` currently properly. The language will most likely get support for that, so at that point we have a way to treat `long` properly, but might need some differentiation between what's a `long` and what's an `integer` field for that. So by grouping them together here, we would take away that possibility for us to support that properly. I still think it's a high value for us knowing the exact ES type behind.\r\n\r\nAnother example is `date` vs `date_nanos`. `date_nanos` run in 100% into that \"JavaScript can't represent the current date nano 64bit timestamp properly\" situation. So we need to have a lot of special handling around `date_nanos`, that we don't need for `dates`. So it's crucial we know the difference between a `date` field and a `date_nano` field.\r\n\r\nMeaning if we want to get rid of exact ES types in _field_caps I think we would need to have a shared sync for every field to know the impact on Kibana before we decide on families. And even that I don't think will work, since there might simply be future features for which we will need to know that difference, that we currently are not aware of, and might block us with our decision on. It happened in the past, that was the whole reason we needed to introduce storing the specific ES types, since we saw our family grouping blocked some things, and I don't see how it would be different if we put the family grouping into ES. So my strong recommendation would be, keep the actual field type information around for Kibana to store and use.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/625178558","html_url":"https://github.com/elastic/elasticsearch/issues/53175#issuecomment-625178558","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/53175","id":625178558,"node_id":"MDEyOklzc3VlQ29tbWVudDYyNTE3ODU1OA==","user":{"login":"jpountz","id":299848,"node_id":"MDQ6VXNlcjI5OTg0OA==","avatar_url":"https://avatars2.githubusercontent.com/u/299848?v=4","gravatar_id":"","url":"https://api.github.com/users/jpountz","html_url":"https://github.com/jpountz","followers_url":"https://api.github.com/users/jpountz/followers","following_url":"https://api.github.com/users/jpountz/following{/other_user}","gists_url":"https://api.github.com/users/jpountz/gists{/gist_id}","starred_url":"https://api.github.com/users/jpountz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jpountz/subscriptions","organizations_url":"https://api.github.com/users/jpountz/orgs","repos_url":"https://api.github.com/users/jpountz/repos","events_url":"https://api.github.com/users/jpountz/events{/privacy}","received_events_url":"https://api.github.com/users/jpountz/received_events","type":"User","site_admin":false},"created_at":"2020-05-07T10:48:16Z","updated_at":"2020-05-07T10:48:16Z","author_association":"CONTRIBUTOR","body":"@timroes I'm still unclear why this matters. For instance today, does it make any difference to Kibana if someone indexed integers in a long field vs. an integer field? I have a similar question regarding this special handling that you have for `date_nanos`, what would be wrong with applying the same handling to regular `date` fields? Sorry for being pushy but I'm genuinely interested in understanding better, especially as I wonder that there might be workarounds in Kibana for things that we should consider bugs in Elasticsearch and that we're not aware of.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/625236829","html_url":"https://github.com/elastic/elasticsearch/issues/53175#issuecomment-625236829","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/53175","id":625236829,"node_id":"MDEyOklzc3VlQ29tbWVudDYyNTIzNjgyOQ==","user":{"login":"timroes","id":877229,"node_id":"MDQ6VXNlcjg3NzIyOQ==","avatar_url":"https://avatars0.githubusercontent.com/u/877229?v=4","gravatar_id":"","url":"https://api.github.com/users/timroes","html_url":"https://github.com/timroes","followers_url":"https://api.github.com/users/timroes/followers","following_url":"https://api.github.com/users/timroes/following{/other_user}","gists_url":"https://api.github.com/users/timroes/gists{/gist_id}","starred_url":"https://api.github.com/users/timroes/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/timroes/subscriptions","organizations_url":"https://api.github.com/users/timroes/orgs","repos_url":"https://api.github.com/users/timroes/repos","events_url":"https://api.github.com/users/timroes/events{/privacy}","received_events_url":"https://api.github.com/users/timroes/received_events","type":"User","site_admin":false},"created_at":"2020-05-07T12:53:17Z","updated_at":"2020-05-07T12:53:17Z","author_association":"CONTRIBUTOR","body":"Currently for `long` and `integer` we don't have specific different logic, so no today it doesn't matter. But that's kind of my point, we can't rule it out, since as soon as we have language support for 64bit integers we might want to parse `long` values later differently then `integer` values in Kibana to actually support them. That is not set in stone, it's just an example of some future feature we might run into problems, when we don't have the type, and was a more or less realistic example I could come up with.\r\n\r\nWith regards to `date` vs. `date_nanos` I don't think there's anything you can do differently. The problem is simply, we are not able to parse the current time in nanoseconds and represent that in JavaScript (since it's outside the range you can safely store inside a 64 bit floating point number without precision loss). Also our used date library `moment.js` can neither handle them (mainly due to the same reasons of not being able to represent the timestamp as a number). That means we e.g. have a specific `date_nanos` field formatter, which will parse the ISO string of the date by cutting away the nanos parts of the string and store them for later, then parse the rest regularily via the date library and later append the nano seconds again. Therefore this field formatter unfortunately doesn't allow configuring the template of the formatted string as freely as the regular `date` formatter. A couple of related issues on that:\r\n\r\n* 64bit number support in Kibana (https://github.com/elastic/kibana/issues/40183)\r\n* date_nanos issue (https://github.com/elastic/kibana/issues/31424)\r\n\r\nI think none of them is anything that could be solveable in Elasticsearch.\r\n\r\nI btw fully support your base statement here: If any of those things where we need to make differences in Kibana based on the specific field type is solvable in ES, we should solve it in ES and not in Kibana. I def want to keep those places as low as possible, so far it just have shown not be 0, and as long as I can still \"easily\" make up exampled like integer vs long I feel worried that we'll always have cases where we need those specific types.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/626891807","html_url":"https://github.com/elastic/elasticsearch/issues/53175#issuecomment-626891807","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/53175","id":626891807,"node_id":"MDEyOklzc3VlQ29tbWVudDYyNjg5MTgwNw==","user":{"login":"jtibshirani","id":7461306,"node_id":"MDQ6VXNlcjc0NjEzMDY=","avatar_url":"https://avatars3.githubusercontent.com/u/7461306?v=4","gravatar_id":"","url":"https://api.github.com/users/jtibshirani","html_url":"https://github.com/jtibshirani","followers_url":"https://api.github.com/users/jtibshirani/followers","following_url":"https://api.github.com/users/jtibshirani/following{/other_user}","gists_url":"https://api.github.com/users/jtibshirani/gists{/gist_id}","starred_url":"https://api.github.com/users/jtibshirani/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jtibshirani/subscriptions","organizations_url":"https://api.github.com/users/jtibshirani/orgs","repos_url":"https://api.github.com/users/jtibshirani/repos","events_url":"https://api.github.com/users/jtibshirani/events{/privacy}","received_events_url":"https://api.github.com/users/jtibshirani/received_events","type":"User","site_admin":false},"created_at":"2020-05-11T18:56:02Z","updated_at":"2020-05-11T18:56:28Z","author_association":"MEMBER","body":"My understanding is that we'd like to collapse field types together that have nearly identical read-time behavior -- and this includes not only searching but also loading/ displaying field values. But there's a question of what 'nearly identical behavior' actually means for the different field types.\r\n\r\nTo me there are two different cases. First, it seems like we're hesitant to collapse together fields like `long` and `integer`, or  `date` and `date_nanos`, because they have different precision and the client may want to handle them differently. For example, in the case of the JDBC driver, we want to match the data types in the spec as closely as possible. That way a field mapped as a `float` will be returned as a Java float.\r\n\r\nIn the second case, a small number of field types are designed to have the same external behavior as a 'standard' type, but give different performance trade-offs in terms of disk usage or speed. These field types could be presented as if they were the 'standard' field type:\r\n* `constant_keyword` and `wildcard` are presented as `keyword`\r\n* `scaled_float` could be presented as `float` (?)\r\n\r\nRelated to this case, we plan to introduce 'runtime fields' that are defined in the mappings, but calculate their values on-the-fly. For example there could be a runtime field that takes two concrete `integer` fields and adds them together. Regardless of how we choose to design the runtime fields (maybe it's a new mapping type), in field caps it should be presented as an `integer`.\r\n\r\nWould we at least be interested in collapsing field types in the second case?","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/627421076","html_url":"https://github.com/elastic/elasticsearch/issues/53175#issuecomment-627421076","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/53175","id":627421076,"node_id":"MDEyOklzc3VlQ29tbWVudDYyNzQyMTA3Ng==","user":{"login":"timroes","id":877229,"node_id":"MDQ6VXNlcjg3NzIyOQ==","avatar_url":"https://avatars0.githubusercontent.com/u/877229?v=4","gravatar_id":"","url":"https://api.github.com/users/timroes","html_url":"https://github.com/timroes","followers_url":"https://api.github.com/users/timroes/followers","following_url":"https://api.github.com/users/timroes/following{/other_user}","gists_url":"https://api.github.com/users/timroes/gists{/gist_id}","starred_url":"https://api.github.com/users/timroes/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/timroes/subscriptions","organizations_url":"https://api.github.com/users/timroes/orgs","repos_url":"https://api.github.com/users/timroes/repos","events_url":"https://api.github.com/users/timroes/events{/privacy}","received_events_url":"https://api.github.com/users/timroes/received_events","type":"User","site_admin":false},"created_at":"2020-05-12T15:34:47Z","updated_at":"2020-05-12T15:34:47Z","author_association":"CONTRIBUTOR","body":"I think for the second case it could make sense collapsing them. So if it's really just performance optimizations behind the scenes, but otherwise behaving exactly the same, we could imho collapse them. I am just having concerns collapsing fields as long as they are not behaving exactly the same from an API point of view, and that could mean: different datatypes returned, they are not be able to be used in exactly the same APIs (and already having one very specific aggregation not being able to work with both, means for me we should not collapse them - or at least need the raw field information in that case), differences in getting access to them via docvalues, scripts, etc.\r\n\r\nIf they are really behaving exactly the same in all those cases I don't see a problem (from Kibana side) to collapse them together, and even without us having the original field information. As soon as they are only 99.9% the same in regards to their API behavior, I'd not collapse them together, since I'll very likely be able to come up with an example where we would need the differentiation.\r\n\r\nSo in your example, it sounds like we could merge `constant_keyword` to `keyword`, but from [Mark's comment](https://github.com/elastic/kibana/issues/60933#issuecomment-603781222) it doesn't look like we could/should merge `wildcard` to `keyword`, since `wildcard` is not being able to used e.g. in regex queries, range queries or fuzzy queries, so it's def not behaving the same in terms of API.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/627432196","html_url":"https://github.com/elastic/elasticsearch/issues/53175#issuecomment-627432196","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/53175","id":627432196,"node_id":"MDEyOklzc3VlQ29tbWVudDYyNzQzMjE5Ng==","user":{"login":"jpountz","id":299848,"node_id":"MDQ6VXNlcjI5OTg0OA==","avatar_url":"https://avatars2.githubusercontent.com/u/299848?v=4","gravatar_id":"","url":"https://api.github.com/users/jpountz","html_url":"https://github.com/jpountz","followers_url":"https://api.github.com/users/jpountz/followers","following_url":"https://api.github.com/users/jpountz/following{/other_user}","gists_url":"https://api.github.com/users/jpountz/gists{/gist_id}","starred_url":"https://api.github.com/users/jpountz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jpountz/subscriptions","organizations_url":"https://api.github.com/users/jpountz/orgs","repos_url":"https://api.github.com/users/jpountz/repos","events_url":"https://api.github.com/users/jpountz/events{/privacy}","received_events_url":"https://api.github.com/users/jpountz/received_events","type":"User","site_admin":false},"created_at":"2020-05-12T15:53:43Z","updated_at":"2020-05-12T15:53:43Z","author_association":"CONTRIBUTOR","body":">  from Mark's comment it doesn't look like we could/should merge wildcard to keyword, since wildcard is not being able to used e.g. in regex queries, range queries or fuzzy queries, so it's def not behaving the same in terms of API.\r\n\r\nFYI this is getting worked an these days in order to make both fields support exactly the same operations.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/627462413","html_url":"https://github.com/elastic/elasticsearch/issues/53175#issuecomment-627462413","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/53175","id":627462413,"node_id":"MDEyOklzc3VlQ29tbWVudDYyNzQ2MjQxMw==","user":{"login":"jtibshirani","id":7461306,"node_id":"MDQ6VXNlcjc0NjEzMDY=","avatar_url":"https://avatars3.githubusercontent.com/u/7461306?v=4","gravatar_id":"","url":"https://api.github.com/users/jtibshirani","html_url":"https://github.com/jtibshirani","followers_url":"https://api.github.com/users/jtibshirani/followers","following_url":"https://api.github.com/users/jtibshirani/following{/other_user}","gists_url":"https://api.github.com/users/jtibshirani/gists{/gist_id}","starred_url":"https://api.github.com/users/jtibshirani/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jtibshirani/subscriptions","organizations_url":"https://api.github.com/users/jtibshirani/orgs","repos_url":"https://api.github.com/users/jtibshirani/repos","events_url":"https://api.github.com/users/jtibshirani/events{/privacy}","received_events_url":"https://api.github.com/users/jtibshirani/received_events","type":"User","site_admin":false},"created_at":"2020-05-12T16:47:09Z","updated_at":"2020-05-12T16:56:44Z","author_association":"MEMBER","body":"> As soon as they are only 99.9% the same in regards to their API behavior, I'd not collapse them together, since I'll very likely be able to come up with an example where we would need the differentiation.\r\n\r\nMaybe we could think about this more as a trade-off instead of a rule 'as soon as they are different at all, we shouldn't collapse the types'. For example, a field alias on a `keyword` supports almost all the same functionality `keyword`, but there are still [unsupported APIs](https://www.elastic.co/guide/en/elasticsearch/reference/7.6/alias.html#unsupported-apis) like using an alias in a terms lookup query. We still decided to present field aliases as if they were the concrete type, and this let us support aliases in Kibana quickly and with minimal changes. There's less future flexibility on Kibana's end, but perhaps the trade-off in terms of simplicity + effort was worth it. ","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/643444444","html_url":"https://github.com/elastic/elasticsearch/issues/53175#issuecomment-643444444","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/53175","id":643444444,"node_id":"MDEyOklzc3VlQ29tbWVudDY0MzQ0NDQ0NA==","user":{"login":"jtibshirani","id":7461306,"node_id":"MDQ6VXNlcjc0NjEzMDY=","avatar_url":"https://avatars3.githubusercontent.com/u/7461306?v=4","gravatar_id":"","url":"https://api.github.com/users/jtibshirani","html_url":"https://github.com/jtibshirani","followers_url":"https://api.github.com/users/jtibshirani/followers","following_url":"https://api.github.com/users/jtibshirani/following{/other_user}","gists_url":"https://api.github.com/users/jtibshirani/gists{/gist_id}","starred_url":"https://api.github.com/users/jtibshirani/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jtibshirani/subscriptions","organizations_url":"https://api.github.com/users/jtibshirani/orgs","repos_url":"https://api.github.com/users/jtibshirani/repos","events_url":"https://api.github.com/users/jtibshirani/events{/privacy}","received_events_url":"https://api.github.com/users/jtibshirani/received_events","type":"User","site_admin":false},"created_at":"2020-06-12T19:21:36Z","updated_at":"2020-06-12T21:35:23Z","author_association":"MEMBER","body":"@timroes @astefan with the `wildcard` field coming out soon, it would be nice to settle on the behavior. Would you be okay with the following changes?\r\n* `wildcard` presented as `keyword` (for 7.x when this new type is released)\r\n* `constant_keyword` presented as `keyword` (8.0)\r\n* `scaled_float` presented as `float` (8.0)\r\n\r\nThe `scaled_float` change might need to wait until the [`fields` API](https://github.com/elastic/elasticsearch/issues/55363) is introduced, because I think SQL now needs to load scaled floats from doc values, whereas other numeric fields are pulled from _source.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/643492925","html_url":"https://github.com/elastic/elasticsearch/issues/53175#issuecomment-643492925","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/53175","id":643492925,"node_id":"MDEyOklzc3VlQ29tbWVudDY0MzQ5MjkyNQ==","user":{"login":"jtibshirani","id":7461306,"node_id":"MDQ6VXNlcjc0NjEzMDY=","avatar_url":"https://avatars3.githubusercontent.com/u/7461306?v=4","gravatar_id":"","url":"https://api.github.com/users/jtibshirani","html_url":"https://github.com/jtibshirani","followers_url":"https://api.github.com/users/jtibshirani/followers","following_url":"https://api.github.com/users/jtibshirani/following{/other_user}","gists_url":"https://api.github.com/users/jtibshirani/gists{/gist_id}","starred_url":"https://api.github.com/users/jtibshirani/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jtibshirani/subscriptions","organizations_url":"https://api.github.com/users/jtibshirani/orgs","repos_url":"https://api.github.com/users/jtibshirani/repos","events_url":"https://api.github.com/users/jtibshirani/events{/privacy}","received_events_url":"https://api.github.com/users/jtibshirani/received_events","type":"User","site_admin":false},"created_at":"2020-06-12T21:35:44Z","updated_at":"2020-06-12T21:35:44Z","author_association":"MEMBER","body":"Also tagging @markharwood for awareness on the above.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/643982352","html_url":"https://github.com/elastic/elasticsearch/issues/53175#issuecomment-643982352","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/53175","id":643982352,"node_id":"MDEyOklzc3VlQ29tbWVudDY0Mzk4MjM1Mg==","user":{"login":"timroes","id":877229,"node_id":"MDQ6VXNlcjg3NzIyOQ==","avatar_url":"https://avatars0.githubusercontent.com/u/877229?v=4","gravatar_id":"","url":"https://api.github.com/users/timroes","html_url":"https://github.com/timroes","followers_url":"https://api.github.com/users/timroes/followers","following_url":"https://api.github.com/users/timroes/following{/other_user}","gists_url":"https://api.github.com/users/timroes/gists{/gist_id}","starred_url":"https://api.github.com/users/timroes/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/timroes/subscriptions","organizations_url":"https://api.github.com/users/timroes/orgs","repos_url":"https://api.github.com/users/timroes/repos","events_url":"https://api.github.com/users/timroes/events{/privacy}","received_events_url":"https://api.github.com/users/timroes/received_events","type":"User","site_admin":false},"created_at":"2020-06-15T08:26:24Z","updated_at":"2020-06-15T08:26:24Z","author_association":"CONTRIBUTOR","body":"> constant_keyword presented as keyword (8.0)\r\n\r\nThat sounded fine to me, given that it behaves exactly the same, right?\r\n\r\n> wildcard presented as keyword (for 7.x when this new type is released)\r\n\r\nJust for clarification from that issue in Kibana. Are there now differences in how it can be used in queries, and APIs (not performance differences, but APIs where it's simply not working if you use a `wildcard` field). Because if so I'd stand with my statement above: we should not collapse fields if they are not behaving exactly the same within the API. While I see your wish for being easy to add those new field types to Kibana by yourself, if they are not supporting the exact same APIs, you potentially simply create bugs in Kibana, by doing so, since suddenly maybe the KQL we compile or the filters we create are no longer working. I think it's really not a good idea, adding even slightly functional different fields automatically to Kibana, without having someone from the Kibana team who knows all the potential side effects, etc. have a look on that, and have adding that field type going through our regular PR review process.\r\n\r\n> We still decided to present field aliases as if they were the concrete type, and this let us support aliases in Kibana quickly and with minimal changes. \r\n\r\nThat might not be that good example as you think it is, since Aliases are supported really not well in Kibana, and we get very often negative feedback on how Aliases work (or don't) in Kibana (just haven't had the capacity yet to address this) :D","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/643999150","html_url":"https://github.com/elastic/elasticsearch/issues/53175#issuecomment-643999150","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/53175","id":643999150,"node_id":"MDEyOklzc3VlQ29tbWVudDY0Mzk5OTE1MA==","user":{"login":"astefan","id":893749,"node_id":"MDQ6VXNlcjg5Mzc0OQ==","avatar_url":"https://avatars2.githubusercontent.com/u/893749?v=4","gravatar_id":"","url":"https://api.github.com/users/astefan","html_url":"https://github.com/astefan","followers_url":"https://api.github.com/users/astefan/followers","following_url":"https://api.github.com/users/astefan/following{/other_user}","gists_url":"https://api.github.com/users/astefan/gists{/gist_id}","starred_url":"https://api.github.com/users/astefan/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/astefan/subscriptions","organizations_url":"https://api.github.com/users/astefan/orgs","repos_url":"https://api.github.com/users/astefan/repos","events_url":"https://api.github.com/users/astefan/events{/privacy}","received_events_url":"https://api.github.com/users/astefan/received_events","type":"User","site_admin":false},"created_at":"2020-06-15T08:58:23Z","updated_at":"2020-06-15T08:58:23Z","author_association":"CONTRIBUTOR","body":"@jtibshirani for \"runtime\" reporting of field data types in `_field_caps`, I don't see the collapsing as an issue, but there is also the other use case where we show the users the field types with commands like `SYS COLUMNS`. Think of `_field_caps` as trimmed down version of the GET `_mapping` API: we extrapolate from its content the mapping of all the fields in a bunch of indices.\r\n\r\nCollapsing those field types together means we'll tell users or to BI tools (via `SYS COLUMNS`) that a column `X` is of type `keyword` while, in fact, it's of type `wildcard`.\r\nCCing @costin to get his input on this, as well.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/644124647","html_url":"https://github.com/elastic/elasticsearch/issues/53175#issuecomment-644124647","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/53175","id":644124647,"node_id":"MDEyOklzc3VlQ29tbWVudDY0NDEyNDY0Nw==","user":{"login":"jimczi","id":15977469,"node_id":"MDQ6VXNlcjE1OTc3NDY5","avatar_url":"https://avatars0.githubusercontent.com/u/15977469?v=4","gravatar_id":"","url":"https://api.github.com/users/jimczi","html_url":"https://github.com/jimczi","followers_url":"https://api.github.com/users/jimczi/followers","following_url":"https://api.github.com/users/jimczi/following{/other_user}","gists_url":"https://api.github.com/users/jimczi/gists{/gist_id}","starred_url":"https://api.github.com/users/jimczi/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jimczi/subscriptions","organizations_url":"https://api.github.com/users/jimczi/orgs","repos_url":"https://api.github.com/users/jimczi/repos","events_url":"https://api.github.com/users/jimczi/events{/privacy}","received_events_url":"https://api.github.com/users/jimczi/received_events","type":"User","site_admin":false},"created_at":"2020-06-15T13:09:26Z","updated_at":"2020-06-15T13:09:26Z","author_association":"MEMBER","body":"> Just for clarification from that issue in Kibana. Are there now differences in how it can be used in queries, and APIs (not performance differences, but APIs where it's simply not working if you use a wildcard field).\r\n\r\nNo there is not. Although, I think we should approach this differently. The intent for the `wildcard` field is to provide the same functionality than a keyword field so any difference should be treated as a bug. #58044  is a good example, we found a discrepancy and fixed it so that `keyword` and `wildcard` fields behave the same in scripts. That would hold for any family that we create for ` _field_caps`,  fields within a family should behave the same.\r\n\r\n> Collapsing those field types together means we'll tell users or to BI tools (via SYS COLUMNS) that a column X is of type keyword while, in fact, it's of type wildcard\r\n\r\nI wonder why you consider this as an issue ? Why would BI users care about ES mapping internals if they can rely on family types ? Knowing that the field is of family `keyword` should be enough to  design an SQL query ?\r\n\r\n\r\n\r\n\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/644132565","html_url":"https://github.com/elastic/elasticsearch/issues/53175#issuecomment-644132565","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/53175","id":644132565,"node_id":"MDEyOklzc3VlQ29tbWVudDY0NDEzMjU2NQ==","user":{"login":"astefan","id":893749,"node_id":"MDQ6VXNlcjg5Mzc0OQ==","avatar_url":"https://avatars2.githubusercontent.com/u/893749?v=4","gravatar_id":"","url":"https://api.github.com/users/astefan","html_url":"https://github.com/astefan","followers_url":"https://api.github.com/users/astefan/followers","following_url":"https://api.github.com/users/astefan/following{/other_user}","gists_url":"https://api.github.com/users/astefan/gists{/gist_id}","starred_url":"https://api.github.com/users/astefan/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/astefan/subscriptions","organizations_url":"https://api.github.com/users/astefan/orgs","repos_url":"https://api.github.com/users/astefan/repos","events_url":"https://api.github.com/users/astefan/events{/privacy}","received_events_url":"https://api.github.com/users/astefan/received_events","type":"User","site_admin":false},"created_at":"2020-06-15T13:23:49Z","updated_at":"2020-06-15T13:23:49Z","author_association":"CONTRIBUTOR","body":"> I wonder why you consider this as an issue ? Why would BI users care about ES mapping internals if they can rely on family types ? Knowing that the field is of family keyword should be enough to design an SQL query ?\r\n\r\nFloat and scaled_float data types have different precisions (display column size). For the other three in question the precision is the same. And it's about the BI tools themselves which, in theory, look at the display size for numbers to know how many digits to display.\r\n\r\nFor the text based data types in question, I think it's more of a conceptual decision (as to why I CCed @costin to get his input on this) to have inconsistent (or incorrect) information displayed as a result of a `SYS COLUMNS` query.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/644423884","html_url":"https://github.com/elastic/elasticsearch/issues/53175#issuecomment-644423884","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/53175","id":644423884,"node_id":"MDEyOklzc3VlQ29tbWVudDY0NDQyMzg4NA==","user":{"login":"costin","id":76245,"node_id":"MDQ6VXNlcjc2MjQ1","avatar_url":"https://avatars3.githubusercontent.com/u/76245?v=4","gravatar_id":"","url":"https://api.github.com/users/costin","html_url":"https://github.com/costin","followers_url":"https://api.github.com/users/costin/followers","following_url":"https://api.github.com/users/costin/following{/other_user}","gists_url":"https://api.github.com/users/costin/gists{/gist_id}","starred_url":"https://api.github.com/users/costin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/costin/subscriptions","organizations_url":"https://api.github.com/users/costin/orgs","repos_url":"https://api.github.com/users/costin/repos","events_url":"https://api.github.com/users/costin/events{/privacy}","received_events_url":"https://api.github.com/users/costin/received_events","type":"User","site_admin":false},"created_at":"2020-06-15T22:33:29Z","updated_at":"2020-06-15T22:33:29Z","author_association":"MEMBER","body":"I can't think of a big disadvantage of this change in SQL.\r\nThe main change will be describing an index (`DESCRIBE TABLE`) will not show the exact mapping of a index (`keyword` vs `constant_keyword`).\r\nI think that's fine since when dealing with aliases/merging we would have merge the fields anyway which some might find confusing.\r\nI'm not clear whether numeric types would be always widen, namely `float` to `double` or `int` to `long`. If that is the case, this creates issue is that without explicit casting, SQL will never return `int` or `double` which would be unexpected.\r\nWhile `keyword`, `constant_keyword` and `wildcard` are in the end _strings_ (the char family), `int` in particular is common, popular type that we would end up not supporting. \r\nAnd fairly different from `long`.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/644874070","html_url":"https://github.com/elastic/elasticsearch/issues/53175#issuecomment-644874070","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/53175","id":644874070,"node_id":"MDEyOklzc3VlQ29tbWVudDY0NDg3NDA3MA==","user":{"login":"jtibshirani","id":7461306,"node_id":"MDQ6VXNlcjc0NjEzMDY=","avatar_url":"https://avatars3.githubusercontent.com/u/7461306?v=4","gravatar_id":"","url":"https://api.github.com/users/jtibshirani","html_url":"https://github.com/jtibshirani","followers_url":"https://api.github.com/users/jtibshirani/followers","following_url":"https://api.github.com/users/jtibshirani/following{/other_user}","gists_url":"https://api.github.com/users/jtibshirani/gists{/gist_id}","starred_url":"https://api.github.com/users/jtibshirani/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jtibshirani/subscriptions","organizations_url":"https://api.github.com/users/jtibshirani/orgs","repos_url":"https://api.github.com/users/jtibshirani/repos","events_url":"https://api.github.com/users/jtibshirani/events{/privacy}","received_events_url":"https://api.github.com/users/jtibshirani/received_events","type":"User","site_admin":false},"created_at":"2020-06-16T16:32:34Z","updated_at":"2020-06-16T16:32:34Z","author_association":"MEMBER","body":" > The intent for the wildcard field is to provide the same functionality than a keyword field so any difference should be treated as a bug... That would hold for any family that we create for _field_caps, fields within a family should behave the same.\r\n\r\nI think @jimczi's point is a really important one -- if we collapsed two field types into a 'family', then we would consider any significant difference in functionality to be a high-priority bug ES.\r\n\r\nEven beyond the field caps API, it's really nice to have this concept of a field type 'family' that's guaranteed to have the same behavior. I think it will help users understand all the new field types we're adding -- they can think of constant_keyword and wildcard as being variants on 'keyword' and be assured they support the same functionality.\r\n\r\nIt sounds like there are concerns around collapsing `scaled_float` and `float`, but agreement on the other types. I suggest we hold off on numeric types for now and focus on these changes:\r\n* `wildcard` presented as `keyword` (for 7.x when this new type is released)\r\n* `constant_keyword` presented as `keyword` (8.0)\r\n\r\nIf there is still hesitation, please feel free to reply (or ping me directly) -- I think the next step would be to have a short discussion as a group.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/645985235","html_url":"https://github.com/elastic/elasticsearch/issues/53175#issuecomment-645985235","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/53175","id":645985235,"node_id":"MDEyOklzc3VlQ29tbWVudDY0NTk4NTIzNQ==","user":{"login":"astefan","id":893749,"node_id":"MDQ6VXNlcjg5Mzc0OQ==","avatar_url":"https://avatars2.githubusercontent.com/u/893749?v=4","gravatar_id":"","url":"https://api.github.com/users/astefan","html_url":"https://github.com/astefan","followers_url":"https://api.github.com/users/astefan/followers","following_url":"https://api.github.com/users/astefan/following{/other_user}","gists_url":"https://api.github.com/users/astefan/gists{/gist_id}","starred_url":"https://api.github.com/users/astefan/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/astefan/subscriptions","organizations_url":"https://api.github.com/users/astefan/orgs","repos_url":"https://api.github.com/users/astefan/repos","events_url":"https://api.github.com/users/astefan/events{/privacy}","received_events_url":"https://api.github.com/users/astefan/received_events","type":"User","site_admin":false},"created_at":"2020-06-18T12:26:38Z","updated_at":"2020-06-18T12:26:38Z","author_association":"CONTRIBUTOR","body":"@jtibshirani one small apparently obvious aspect, just to make sure this is also covered: collapsing fields together into a \"common\" type should only be applied when merging fields, and not also when a single index is involved in the _field_caps request, right?\r\nAs an example, if in the case of two indices - one with a `test` field of type `wildcard` and the other with the type of the same field `test` as `constant_keyword` - `_field_caps` will report the `test` field as `keyword`. But, if `_field_caps` is called for the first index only, the result will report `test` as `wildcard`.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/645986691","html_url":"https://github.com/elastic/elasticsearch/issues/53175#issuecomment-645986691","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/53175","id":645986691,"node_id":"MDEyOklzc3VlQ29tbWVudDY0NTk4NjY5MQ==","user":{"login":"jimczi","id":15977469,"node_id":"MDQ6VXNlcjE1OTc3NDY5","avatar_url":"https://avatars0.githubusercontent.com/u/15977469?v=4","gravatar_id":"","url":"https://api.github.com/users/jimczi","html_url":"https://github.com/jimczi","followers_url":"https://api.github.com/users/jimczi/followers","following_url":"https://api.github.com/users/jimczi/following{/other_user}","gists_url":"https://api.github.com/users/jimczi/gists{/gist_id}","starred_url":"https://api.github.com/users/jimczi/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jimczi/subscriptions","organizations_url":"https://api.github.com/users/jimczi/orgs","repos_url":"https://api.github.com/users/jimczi/repos","events_url":"https://api.github.com/users/jimczi/events{/privacy}","received_events_url":"https://api.github.com/users/jimczi/received_events","type":"User","site_admin":false},"created_at":"2020-06-18T12:29:42Z","updated_at":"2020-06-18T12:29:42Z","author_association":"MEMBER","body":"@astefan, no the plan is to always return `keyword` for these fields, `constant_keyword` and `wildcard` will not be part of the types that field_caps can return.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/645989672","html_url":"https://github.com/elastic/elasticsearch/issues/53175#issuecomment-645989672","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/53175","id":645989672,"node_id":"MDEyOklzc3VlQ29tbWVudDY0NTk4OTY3Mg==","user":{"login":"astefan","id":893749,"node_id":"MDQ6VXNlcjg5Mzc0OQ==","avatar_url":"https://avatars2.githubusercontent.com/u/893749?v=4","gravatar_id":"","url":"https://api.github.com/users/astefan","html_url":"https://github.com/astefan","followers_url":"https://api.github.com/users/astefan/followers","following_url":"https://api.github.com/users/astefan/following{/other_user}","gists_url":"https://api.github.com/users/astefan/gists{/gist_id}","starred_url":"https://api.github.com/users/astefan/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/astefan/subscriptions","organizations_url":"https://api.github.com/users/astefan/orgs","repos_url":"https://api.github.com/users/astefan/repos","events_url":"https://api.github.com/users/astefan/events{/privacy}","received_events_url":"https://api.github.com/users/astefan/received_events","type":"User","site_admin":false},"created_at":"2020-06-18T12:36:22Z","updated_at":"2020-06-18T12:36:22Z","author_association":"CONTRIBUTOR","body":"Thank you for clarifying. After all, it wasn't so obvious as I thought :-).","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/648766693","html_url":"https://github.com/elastic/elasticsearch/issues/53175#issuecomment-648766693","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/53175","id":648766693,"node_id":"MDEyOklzc3VlQ29tbWVudDY0ODc2NjY5Mw==","user":{"login":"markharwood","id":170925,"node_id":"MDQ6VXNlcjE3MDkyNQ==","avatar_url":"https://avatars0.githubusercontent.com/u/170925?v=4","gravatar_id":"","url":"https://api.github.com/users/markharwood","html_url":"https://github.com/markharwood","followers_url":"https://api.github.com/users/markharwood/followers","following_url":"https://api.github.com/users/markharwood/following{/other_user}","gists_url":"https://api.github.com/users/markharwood/gists{/gist_id}","starred_url":"https://api.github.com/users/markharwood/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/markharwood/subscriptions","organizations_url":"https://api.github.com/users/markharwood/orgs","repos_url":"https://api.github.com/users/markharwood/repos","events_url":"https://api.github.com/users/markharwood/events{/privacy}","received_events_url":"https://api.github.com/users/markharwood/received_events","type":"User","site_admin":false},"created_at":"2020-06-24T11:35:30Z","updated_at":"2020-06-24T11:35:30Z","author_association":"CONTRIBUTOR","body":"I've [updated](https://github.com/elastic/elasticsearch/pull/58483) master and 7x branches with support for the `keyword` family. This also added a new method in `MappedFieldType` which can be overridden by other fields to declare family membership","performed_via_github_app":null}]