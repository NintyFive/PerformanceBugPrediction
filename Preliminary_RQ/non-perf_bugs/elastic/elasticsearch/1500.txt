{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/1500","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/1500/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/1500/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/1500/events","html_url":"https://github.com/elastic/elasticsearch/issues/1500","id":2352299,"node_id":"MDU6SXNzdWUyMzUyMjk5","number":1500,"title":"Convenient rolling index method","user":{"login":"karussell","id":129644,"node_id":"MDQ6VXNlcjEyOTY0NA==","avatar_url":"https://avatars0.githubusercontent.com/u/129644?v=4","gravatar_id":"","url":"https://api.github.com/users/karussell","html_url":"https://github.com/karussell","followers_url":"https://api.github.com/users/karussell/followers","following_url":"https://api.github.com/users/karussell/following{/other_user}","gists_url":"https://api.github.com/users/karussell/gists{/gist_id}","starred_url":"https://api.github.com/users/karussell/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/karussell/subscriptions","organizations_url":"https://api.github.com/users/karussell/orgs","repos_url":"https://api.github.com/users/karussell/repos","events_url":"https://api.github.com/users/karussell/events{/privacy}","received_events_url":"https://api.github.com/users/karussell/received_events","type":"User","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":5,"created_at":"2011-11-25T21:24:58Z","updated_at":"2014-05-26T15:51:28Z","closed_at":"2014-05-26T15:51:28Z","author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"Here is some code where a rolling index pattern is implemented. Imagine you have a logical index named 'tweets', now you want to create every day a new index to keep the indices small (Its a better scalable 'sharding', but only if you have time dependent data). Now, in the proposed code you will have to call rollIndex(maximumIndices) once a day.\n\nThen the new indices are all 'tagged' with a 'tweets_roll' alias (for later retrieval -> imrovable?), there is a group of indices for searching (tweets_search) and feeding (tweets_feed). Per default it creates a search alias on all indices and a feed alias only for the very latest. It separates the search and the roll alias as it could be the case that one wants to keep some older indices but do not want to search on it.\n\nWhat do you think? Its rather simple but it works - a simple test below the code.\n\n```\nprivate static final String simpleDateString = \"yyyy-MM-dd-HH-mm-ss\";\npublic String rollIndex(int maxRollIndices) {\n    return rollIndex(getIndexName(), maxRollIndices, maxRollIndices);\n}\n\npublic String rollIndex(String indexName, int maxRollIndices, int maxSearchIndices) {\n    String rollAlias = indexName + \"_roll\";\n    SimpleDateFormat formatter = new SimpleDateFormat(simpleDateString);\n\n    if (maxRollIndices < 1 || maxSearchIndices < 1)\n        throw new RuntimeException(\"remaining indices, search indices and feeding indices must be at least 1\");\n\n    // get old aliases\n    Map<String, AliasMetaData> allRollingAliases = getAliases(rollAlias);\n\n    // always create new index and append aliases\n    String searchAlias = getSearchIndexName();\n    String feedAlias = getFeedIndexName();\n    String newIndexName = indexName + \"_\" + formatter.format(new Date());\n\n    createIndex(newIndexName);        \n    addAlias(newIndexName, searchAlias);\n    addAlias(newIndexName, rollAlias);\n    String oldFeedIndexName = null;\n\n    if (allRollingAliases.isEmpty()) {\n        // do nothing for now\n    } else {\n        TreeMap<Long, String> sortedIndices = new TreeMap<Long, String>(reverseSorter);\n        String[] concreteIndices = getConcreteIndices(allRollingAliases.keySet());\n        //logger.info(\"aliases:\" + allRollingAliases + \", indices:\" + Arrays.toString(concreteIndices));\n        for (String index : concreteIndices) {\n            int pos = index.indexOf(\"_\");\n            if (pos < 0)\n                throw new IllegalStateException(\"index \" + index + \" is not in the format \" + simpleDateString);\n\n            String indexDateStr = index.substring(pos + 1);\n            Long timeLong;\n            try {\n                timeLong = formatter.parse(indexDateStr).getTime();\n            } catch (Exception ex) {\n                throw new IllegalStateException(\"index \" + index + \" is not in the format \" + simpleDateString + \" error:\" + ex.getMessage());\n            }\n            String old = sortedIndices.put(timeLong, index);\n            if (old != null)\n                throw new IllegalStateException(\"indices with the identical date are not supported \" + old + \" vs. \" + index);\n        }\n        int counter = 1;\n        Iterator<String> indexIter = sortedIndices.values().iterator();\n\n        while (indexIter.hasNext()) {\n            String currentIndexName = indexIter.next();\n            if (counter >= maxRollIndices) {\n                deleteIndex(currentIndexName);\n                // delete all the older indices\n                continue;\n            }\n\n            if (counter == 1)\n                oldFeedIndexName = currentIndexName;\n\n            if (counter >= maxSearchIndices)\n                removeAlias(currentIndexName, searchAlias);\n\n            counter++;\n        }\n    }\n    if(oldFeedIndexName != null)\n        moveAlias(oldFeedIndexName, newIndexName, feedAlias);\n    else\n        addAlias(newIndexName, feedAlias);\n\n    return newIndexName;\n}\n\npublic String getSearchIndexName() {\n    return getIndexName() + \"_search\";\n}\n\npublic String getFeedIndexName() {\n    return getIndexName() + \"_feed\";\n}\n\npublic void createIndex(String indexName) {\n    client.admin().indices().create(new CreateIndexRequest(indexName).settings(createIndexSettings())).actionGet(timeout);\n}\n\npublic XContentBuilder createIndexSettings() {\n    if (createIndexSettings == null) {\n        try {\n            createIndexSettings = JsonXContent.contentBuilder().startObject().\n                    field(\"index.number_of_shards\", createIndexShards).\n                    field(\"index.number_of_replicas\", createIndexReplicas).\n                    field(\"index.refresh_interval\", \"10s\").\n                    field(\"index.merge.policy.merge_factor\", 10).endObject();\n        } catch (IOException ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n    return createIndexSettings;\n}\n\npublic void deleteIndex(String indexName) {\n    client.admin().indices().delete(new DeleteIndexRequest(indexName)).actionGet();\n}\n\npublic void addAlias(String indexName, String alias) {\n    client.admin().indices().aliases(new IndicesAliasesRequest().addAlias(indexName, alias)).actionGet();\n}\n\npublic void removeAlias(String indexName, String alias) {\n    client.admin().indices().aliases(new IndicesAliasesRequest().removeAlias(indexName, alias)).actionGet();\n}\n\npublic void moveAlias(String oldIndexName, String newIndexName, String alias) {\n    client.admin().indices().aliases(new IndicesAliasesRequest().addAlias(newIndexName, alias).\n            removeAlias(oldIndexName, alias)).actionGet();\n}\n\npublic Map<String, AliasMetaData> getAliases(String index) {\n    Map<String, AliasMetaData> md = client.admin().cluster().state(new ClusterStateRequest()).\n            actionGet().getState().getMetaData().aliases().get(index);\n    if (md == null)\n        return Collections.emptyMap();\n\n    return md;\n}\nprivate static Comparator<Long> reverseSorter = new Comparator<Long>() {\n\n    @Override\n    public int compare(Long o1, Long o2) {\n        return -o1.compareTo(o2);\n    }\n};\n\npublic String[] getConcreteIndices(Set<String> set) {\n    return client.admin().cluster().state(new ClusterStateRequest()).actionGet().getState().\n            getMetaData().concreteIndices(set.toArray(new String[set.size()]));\n}\n```\n\nTEST\n\n```\n@Test public void rollingIndex() throws Exception {\n    search.setClient(createTestClient());\n    search.setIndexName(\"tweets\");\n    String rollIndexTag = search.getIndexName() + \"_roll\";\n    String searchIndex = search.getIndexName() + \"_search\";\n    String feedIndex = search.getIndexName() + \"_feed\";\n    search.rollIndex(4);        \n    assertEquals(1, search.getAliases(rollIndexTag).size());\n    assertEquals(1, search.getAliases(searchIndex).size());\n    assertEquals(1, search.getAliases(feedIndex).size());\n\n    Thread.sleep(1000);\n    search.rollIndex(4);        \n    assertEquals(2, search.getAliases(rollIndexTag).size());\n    assertEquals(2, search.getAliases(searchIndex).size());\n    assertEquals(1, search.getAliases(feedIndex).size());\n\n    Thread.sleep(1000);\n    search.rollIndex(4);        \n    assertEquals(3, search.getAliases(rollIndexTag).size());\n    assertEquals(3, search.getAliases(searchIndex).size());\n    assertEquals(1, search.getAliases(feedIndex).size());\n\n    Thread.sleep(1000);\n    search.rollIndex(4);        \n    assertEquals(4, search.getAliases(rollIndexTag).size());\n    assertEquals(4, search.getAliases(searchIndex).size());\n    assertEquals(1, search.getAliases(feedIndex).size());\n\n    Thread.sleep(1000);\n    search.rollIndex(4);        \n    assertEquals(4, search.getAliases(rollIndexTag).size());\n    assertEquals(4, search.getAliases(searchIndex).size());\n    assertEquals(1, search.getAliases(feedIndex).size());\n\n    Thread.sleep(1000);\n    search.rollIndex(search.getIndexName(), 4, 3);        \n    assertEquals(4, search.getAliases(rollIndexTag).size());\n    assertEquals(3, search.getAliases(searchIndex).size());\n    assertEquals(1, search.getAliases(feedIndex).size());\n}\n```\n","closed_by":{"login":"karussell","id":129644,"node_id":"MDQ6VXNlcjEyOTY0NA==","avatar_url":"https://avatars0.githubusercontent.com/u/129644?v=4","gravatar_id":"","url":"https://api.github.com/users/karussell","html_url":"https://github.com/karussell","followers_url":"https://api.github.com/users/karussell/followers","following_url":"https://api.github.com/users/karussell/following{/other_user}","gists_url":"https://api.github.com/users/karussell/gists{/gist_id}","starred_url":"https://api.github.com/users/karussell/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/karussell/subscriptions","organizations_url":"https://api.github.com/users/karussell/orgs","repos_url":"https://api.github.com/users/karussell/repos","events_url":"https://api.github.com/users/karussell/events{/privacy}","received_events_url":"https://api.github.com/users/karussell/received_events","type":"User","site_admin":false},"performed_via_github_app":null}