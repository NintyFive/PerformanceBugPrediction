{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/2709","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/2709/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/2709/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/2709/events","html_url":"https://github.com/elastic/elasticsearch/issues/2709","id":11503300,"node_id":"MDU6SXNzdWUxMTUwMzMwMA==","number":2709,"title":"Add Phrase Suggester","user":{"login":"s1monw","id":973334,"node_id":"MDQ6VXNlcjk3MzMzNA==","avatar_url":"https://avatars0.githubusercontent.com/u/973334?v=4","gravatar_id":"","url":"https://api.github.com/users/s1monw","html_url":"https://github.com/s1monw","followers_url":"https://api.github.com/users/s1monw/followers","following_url":"https://api.github.com/users/s1monw/following{/other_user}","gists_url":"https://api.github.com/users/s1monw/gists{/gist_id}","starred_url":"https://api.github.com/users/s1monw/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/s1monw/subscriptions","organizations_url":"https://api.github.com/users/s1monw/orgs","repos_url":"https://api.github.com/users/s1monw/repos","events_url":"https://api.github.com/users/s1monw/events{/privacy}","received_events_url":"https://api.github.com/users/s1monw/received_events","type":"User","site_admin":false},"labels":[{"id":23174,"node_id":"MDU6TGFiZWwyMzE3NA==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/%3Eenhancement","name":">enhancement","color":"4a4ea8","default":false,"description":null},{"id":23172,"node_id":"MDU6TGFiZWwyMzE3Mg==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/%3Efeature","name":">feature","color":"006b75","default":false,"description":null},{"id":29805870,"node_id":"MDU6TGFiZWwyOTgwNTg3MA==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/v0.90.0.RC1","name":"v0.90.0.RC1","color":"DDDDDD","default":false,"description":null}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":38,"created_at":"2013-02-28T14:49:40Z","updated_at":"2014-03-30T10:11:38Z","closed_at":"2013-02-28T15:18:15Z","author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"# Phrase Suggester\n\nThe `term` suggester provides a very convenient API to access word alternatives on token\nbasis within a certain string distance. The API allows accessing each token in the stream\nindividually while suggest-selection is left to the API consumer. Yet, often already ranked\n/ selected suggestions are required in order to present to the end-user.\nInside ElasticSearch we have the ability to access way more statistics and information quickly\nto make better decision which token alternative to pick or if to pick an alternative at all.\n\nThis `phrase` suggester adds some logic on top of the `term` suggester to select entire\ncorrected phrases instead of individual tokens weighted based on a _ngram-langugage models_. In practice it\nwill be able to make better decision about which tokens to pick based on co-occurence and frequencies.\nThe current implementation is kept quite general and leaves room for future improvements.\n# API Example\n\nThe `phrase` request is defined along side the query part in the json request:\n\n``` json\ncurl -s -XPOST 'localhost:9200/_search' -d {\n  \"suggest\" : {\n    \"text\" : \"Xor the Got-Jewel\",\n    \"simple_phrase\" : {\n      \"phrase\" : {\n        \"analyzer\" : \"body\",\n        \"field\" : \"bigram\",\n        \"size\" : 1,\n        \"real_word_error_likelihood\" : 0.95,\n        \"max_errors\" : 0.5,\n        \"gram_size\" : 2,\n        \"direct_generator\" : [ {\n          \"field\" : \"body\",\n          \"suggest_mode\" : \"always\",\n          \"min_word_len\" : 1\n        } ]\n      }\n    }\n  }\n}\n```\n\nThe response contains suggested sored by the most likely spell correction first. In this case we got the expected correction\n`xorr the god jewel` first while the second correction is less conservative where only one of the errors is corrected. Note, the request\nis executed with `max_errors` set to `0.5` so 50% of the terms can contain misspellings (See parameter descriptions below).\n\n``` json\n  {\n  \"took\" : 37,\n  \"timed_out\" : false,\n  \"_shards\" : {\n    \"total\" : 5,\n    \"successful\" : 5,\n    \"failed\" : 0\n  },\n  \"hits\" : {\n    \"total\" : 2938,\n    \"max_score\" : 0.0,\n    \"hits\" : [ ]\n  },\n  \"suggest\" : {\n    \"simple_phrase\" : [ {\n      \"text\" : \"Xor the Got-Jewel\",\n      \"offset\" : 0,\n      \"length\" : 17,\n      \"options\" : [ {\n        \"text\" : \"xorr the god jewel\",\n        \"score\" : 0.17877324\n      }, {\n        \"text\" : \"xor the god jewel\",\n        \"score\" : 0.14231323\n      } ]\n    } ]\n  }\n}\n```\n# Phrase suggest API\n## Basic parameters\n- `field` - the name of the field used to do n-gram lookups for the language model, the suggester will use this field to gain statistics to score corrections.\n- `gram_size` - sets max size of the n-grams (shingles) in the `field`. If the field doesn't contain n-grams (shingles) this should be omitted or set to `1`.\n- `real_word_error_likelihood` - the likelihood of a term being a misspelled even if the term exists in the dictionary. The default it `0.95` corresponding to 5% or the real words are misspelled.\n- `confidence` - The confidence level defines a factor applied to the input phrases score which is used as a threshold for other suggest candidates. Only candidates that score higher than the threshold will be included in the result. For instance a confidence level of `1.0` will only return suggestions that score higher than the input phrase. If set to `0.0` the top N candidates are returned. The default is `1.0`.\n- `max_errors` - the maximum percentage of the terms that at most considered to be misspellings in order to form a correction. This method accepts a float value in the range `[0..1)` as a fraction of the actual query terms a number `>=1` as an absolut number of query terms. The default is set to `1.0` which corresponds to that only corrections with at most 1 misspelled term are returned.\n- `separator` - the separator that is used to separate terms in the bigram field. If not set the whitespce character is used as a separator.\n- `size` - the number of candidates that are generated for each individual query term Low numbers like `3` or `5` typically produce good results. Raising this can bring up terms with higher edit distances. The default is `5`.\n- `analyzer` -  Sets the analyzer to analyse to suggest text with. Defaults to the search analyzer of the suggest field passed via `field`.\n- `shard_size` - Sets the maximum number of suggested term to be retrieved from each individual shard. During the reduce phase the only the top N suggestions are returned based on the `size` option. Defaults to `5`.\n- `text` - Sets the text / query to provide suggestions for.\n## Smoothing Models\n\nThe `phrase` suggester supports multiple smoothing models to balance weight between infrequent grams (grams (shingles) are not existing in the index) and frequent grams (appear at least once in the index).\n- `laplace` - the default model that uses an additive smoothing model where a constant (typically `1.0` or smaller) is added to all counts to balance weights, The default `alpha` is `0.5`.\n- `stupid_backoff` - a simple backoff model that backs off to lower order n-gram models if the higher order count is `0` and discounts the lower order n-gram model by a constant factor. The default `discount` is `0.4`.\n- `linear_interpolation` - a smoothing model that takes the weighted mean of the unigrams, bigrams and trigrams based on user supplied weights (lambdas). Linear Interpolation doesn't have any default values. All parameters (`trigram_lambda`, `bigram_lambda`, `unigram_lambda`) must be supplied.\n## Candidate Generators\n\nThe `phrase` suggester uses candidate generators to produce a list of possible terms per term in the given text. A single candidate generator is similar to a `term` suggester called for each individual term in the text. The output of the generators is subsequently scored in in combination with the candidates from the other terms to for suggestion candidates.\nCurrently only one type of candidate generator is supported, the `direct_generator`. The Phrase suggest API accepts a list of generators under the key `direct_generator` each of the generators in the list are called per term in the original text.\n## Direct Generators\n\nThe direct generators support the following parameters:\n- `field` - The field to fetch the candidate suggestions from. This is an required option that either needs to be set globally or per suggestion.\n- `analyzer` - The analyzer to analyse the suggest text with. Defaults to the search analyzer of the suggest field.\n- `size` - The maximum corrections to be returned per suggest text token.\n- `suggest_mode` - The suggest mode controls what suggestions are included or controls for what suggest text terms, suggestions should be suggested. Three possible values can be specified:\n  - `missing` - Only suggest terms in the suggest text that aren't in the index. This is the default.\n  - `popular` - Only suggest suggestions that occur in more docs then the original suggest text term.\n  - `always` - Suggest any matching suggestions based on terms in the suggest text.\n- `max_edits` - The maximum edit distance candidate suggestions can have in order to be considered as a suggestion. Can only be a value between 1 and 2. Any other value result in an bad request error being thrown. Defaults to 2.\n- `min_prefix` - The number of minimal prefix characters that must match in order be a candidate suggestions. Defaults to 1. Increasing this number improves spellcheck performance. Usually misspellings don't occur in the beginning of terms.\n- `min_query_length` -  The minimum length a suggest text term must have in order to be included. Defaults to 4.\n- `max_inspections` - A factor that is used to multiply with the `shards_size` in order to inspect more candidate spell corrections on the shard level. Can improve accuracy at the cost of performance. Defaults to 5.\n- `threshold_frequency` - The minimal threshold in number of documents a suggestion should appear in. This can be specified as an absolute number or as a relative percentage of number of documents. This can improve quality by only suggesting high frequency terms. Defaults to 0f and is not enabled. If a value higher than 1 is specified then the number cannot be fractional. The shard level document frequencies are used for this option.\n- `max_query_frequency` - The maximum threshold in number of documents a sugges text token can exist in order to be included. Can be a relative percentage number (e.g 0.4) or an absolute number to represent document frequencies. If an value higher than 1 is specified then fractional can not be specified. Defaults to 0.01f. This can be used to exclude high frequency terms from being spellchecked. High frequency terms are usually spelled correctly on top of this this also improves the spellcheck performance.  The shard level document frequencies are used for this option.\n- pre_filter -  a filter (analyzer) that is applied to each of the tokens passed to this candidate generator. This filter is applied to the original token before candidates are generated. (optional)\n- post_filter - a filter (analyzer) that is applied to each of the generated tokens before they are passed to the actual phrase scorer. (optional)\n\nThe following example shows a `phrase` suggest call with two generators, the first one is using a field containing ordinary indexed terms and the second one uses a field that uses\nterms indexed with a `reverse` filter (tokens are index in reverse order). This is used to overcome the limitation of the direct generators to require a constant prefix to provide high-performance suggestions. The `pre_filter` and `post_filter` options accept ordinary analyzer names. \n\n``` json\ncurl -s -XPOST 'localhost:9200/_search' -d {\n \"suggest\" : {\n    \"text\" : \"Xor the Got-Jewel\",\n    \"simple_phrase\" : {\n      \"phrase\" : {\n        \"analyzer\" : \"body\",\n        \"field\" : \"bigram\",\n        \"size\" : 4,\n        \"real_word_error_likelihood\" : 0.95,\n        \"confidence\" : 2.0,\n        \"gram_size\" : 2,\n        \"direct_generator\" : [ {\n          \"field\" : \"body\",\n          \"suggest_mode\" : \"always\",\n          \"min_word_len\" : 1\n        }, {\n          \"field\" : \"reverse\",\n          \"suggest_mode\" : \"always\",\n          \"min_word_len\" : 1,\n          \"pre_filter\" : \"reverse\",\n          \"post_filter\" : \"reverse\"\n        } ]\n      }\n    }\n  }\n}\n```\n\n`pre_filter` and `post_filter` can also be used to inject synonyms after candidates are generated. For instance for the query `captain usq` we might generate a candidate `usa` for term `usq` which is a synonym for `america` which allows to present `captain america` to the user if this phrase scores high enough.\n","closed_by":{"login":"s1monw","id":973334,"node_id":"MDQ6VXNlcjk3MzMzNA==","avatar_url":"https://avatars0.githubusercontent.com/u/973334?v=4","gravatar_id":"","url":"https://api.github.com/users/s1monw","html_url":"https://github.com/s1monw","followers_url":"https://api.github.com/users/s1monw/followers","following_url":"https://api.github.com/users/s1monw/following{/other_user}","gists_url":"https://api.github.com/users/s1monw/gists{/gist_id}","starred_url":"https://api.github.com/users/s1monw/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/s1monw/subscriptions","organizations_url":"https://api.github.com/users/s1monw/orgs","repos_url":"https://api.github.com/users/s1monw/repos","events_url":"https://api.github.com/users/s1monw/events{/privacy}","received_events_url":"https://api.github.com/users/s1monw/received_events","type":"User","site_admin":false},"performed_via_github_app":null}