{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/15201","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/15201/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/15201/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/15201/events","html_url":"https://github.com/elastic/elasticsearch/issues/15201","id":120034683,"node_id":"MDU6SXNzdWUxMjAwMzQ2ODM=","number":15201,"title":"Reindex API","user":{"login":"nik9000","id":215970,"node_id":"MDQ6VXNlcjIxNTk3MA==","avatar_url":"https://avatars2.githubusercontent.com/u/215970?v=4","gravatar_id":"","url":"https://api.github.com/users/nik9000","html_url":"https://github.com/nik9000","followers_url":"https://api.github.com/users/nik9000/followers","following_url":"https://api.github.com/users/nik9000/following{/other_user}","gists_url":"https://api.github.com/users/nik9000/gists{/gist_id}","starred_url":"https://api.github.com/users/nik9000/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/nik9000/subscriptions","organizations_url":"https://api.github.com/users/nik9000/orgs","repos_url":"https://api.github.com/users/nik9000/repos","events_url":"https://api.github.com/users/nik9000/events{/privacy}","received_events_url":"https://api.github.com/users/nik9000/received_events","type":"User","site_admin":false},"labels":[{"id":145572580,"node_id":"MDU6TGFiZWwxNDU1NzI1ODA=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/:Distributed/CRUD","name":":Distributed/CRUD","color":"0e8a16","default":false,"description":"A catch all label for issues around indexing, updating and getting a doc by id. Not search."},{"id":23172,"node_id":"MDU6TGFiZWwyMzE3Mg==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/%3Efeature","name":">feature","color":"006b75","default":false,"description":null},{"id":158399402,"node_id":"MDU6TGFiZWwxNTgzOTk0MDI=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/Meta","name":"Meta","color":"e11d21","default":false,"description":null}],"state":"closed","locked":false,"assignee":{"login":"nik9000","id":215970,"node_id":"MDQ6VXNlcjIxNTk3MA==","avatar_url":"https://avatars2.githubusercontent.com/u/215970?v=4","gravatar_id":"","url":"https://api.github.com/users/nik9000","html_url":"https://github.com/nik9000","followers_url":"https://api.github.com/users/nik9000/followers","following_url":"https://api.github.com/users/nik9000/following{/other_user}","gists_url":"https://api.github.com/users/nik9000/gists{/gist_id}","starred_url":"https://api.github.com/users/nik9000/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/nik9000/subscriptions","organizations_url":"https://api.github.com/users/nik9000/orgs","repos_url":"https://api.github.com/users/nik9000/repos","events_url":"https://api.github.com/users/nik9000/events{/privacy}","received_events_url":"https://api.github.com/users/nik9000/received_events","type":"User","site_admin":false},"assignees":[{"login":"nik9000","id":215970,"node_id":"MDQ6VXNlcjIxNTk3MA==","avatar_url":"https://avatars2.githubusercontent.com/u/215970?v=4","gravatar_id":"","url":"https://api.github.com/users/nik9000","html_url":"https://github.com/nik9000","followers_url":"https://api.github.com/users/nik9000/followers","following_url":"https://api.github.com/users/nik9000/following{/other_user}","gists_url":"https://api.github.com/users/nik9000/gists{/gist_id}","starred_url":"https://api.github.com/users/nik9000/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/nik9000/subscriptions","organizations_url":"https://api.github.com/users/nik9000/orgs","repos_url":"https://api.github.com/users/nik9000/repos","events_url":"https://api.github.com/users/nik9000/events{/privacy}","received_events_url":"https://api.github.com/users/nik9000/received_events","type":"User","site_admin":false}],"milestone":null,"comments":12,"created_at":"2015-12-02T20:59:53Z","updated_at":"2018-02-13T19:44:17Z","closed_at":"2016-04-26T20:26:18Z","author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"The time has come for a Elasticsearch to implement a native API for reindexing! The first request I've found for this is (#492) filed back in 2010. With the Task Management API (#15117) will make this easier to manage. This meta ticket will cover the following use cases:\n- [x] Resharding\n- [x] Incompatible mapping updates\n- [x] `touch`ing documents to pick up mapping updates made on the fly\n- [x] Limiting the reindexed documents using a query\n- [x] Update-by-query style changes to portions of the index at a time\n\n<s>\\* [ ] Copying an index from a remote cluster into this one</s>\n\nNOTICE: This meta issue gets fairly rambly from here on out. It will change. The list above will change. Everything is up for negotiation and everything needs to be prototyped before we're sure of anything. Things higher on the list are more likely to be in the final product.\n# Resharding\n\nIt'd work like:\n\n``` bash\n# Stop writes to index\n\ncurl -XPUT localhost:9200/index_v2 -d'{\n  \"settings\": {\n    \"number_of_shards\": 10\n  }\n}'\n\ncurl -XPOST localhost:9200/a_single_command_to_start_copying_all_documents_from_index_v1_to_index_v2\n# Save the returned task id\n\nwhile [ curl -s \"localhost:9200/_task/$TASK_ID?pretty&awaitComplete\" ]; do\n  echo \"not done\"\ndone\n\n# Do any manual checks that index_v2 is ok. Maybe warm it. Maybe raise its number of replicas if you built it with 0 replicas.\n\ncurl -XPOST localhost:9200/_aliases -d '{\n    \"actions\": [\n        { \"remove\": { \"alias\": \"index\", \"index\": \"index_v1\" }},\n        { \"add\":    { \"alias\": \"index\", \"index\": \"index_v2\" }}\n    ]\n}\n'\n\ncurl -XDELETE localhost:9200/index_v2\n\n# Resume writes to index\n```\n\nYou see from the example that its not automatic or atomic. It's still an event and it's very similar to [an old blog post](https://www.elastic.co/blog/changing-mapping-with-zero-downtime) about changing mappings with no downtime. The advantages of this as opposed to the scroll implementation proposed in the blog post are:\n1. Elasticsearch can handle the messy details of the scroll API like `sort: \"_doc\"` and clearing the context when the copy is done and retrying when things fail.\n2. Elasticsearch can to optimize the process to the point where it can do filesystem level things rather than scroll. The first implementation of reindex won't support such optimizations but they are totally possible and could cut the runtime down significantly.\n\nThe two curl commands in the middle are the new bits. This should start a background task to perform the copy:\n\n```\ncurl -XPOST localhost:9200/a_single_command_to_start_copying_all_documents_from_index_v1_to_index_v2\n```\n\nand this should block for a while waiting for the task to complete:\n\n```\ncurl -s \"localhost:9200/_task/$TASK_ID?pretty&awaitComplete\"\n```\n\nThis all piggy backs on the Task Management API (#15117) which isn't done yet, so it'll likely change. The reason this reindex command is a task is because it can take a long time. I, @nik9000, have personally seen these scroll type reindexes take hours for pretty big indexes. So if its going to take hours you'll need a way to cancel it or throttle it. And the task management API should have those ways though I have no idea what they'll look like.\n\nYou may ask \"Why don't you combine the index creation, alias swap, and index delete into one task?\" And that'd be a good question. It won't be part of the first implementation of this but might be part of later ones. Right now I don't like the idea very much. Keep reading. Maybe you'll agree with me. Maybe not. Leave a comment?\n# Incompatible mapping updates\n\nThese'll work almost just like resharding. So much so that I won't give a curl example because I trust you, dear reader, can figure it out. The manual check of the index becomes much more important in this case. It's fairly believable that you'd want to keep both indexes alive for a period of time to test both. A/B testing or something.\n\nThe other way that mapping updates differ from resharding is that filesystem level optimization are much much less likely.\n# `touch`ing documents to pick up mapping updates made on the fly\n\nSome mapping updates can be made to an index on the fly but aren't picked up:\n- Adding a new [field](https://www.elastic.co/guide/en/elasticsearch/reference/current/multi-fields.html) to a property\n- Adding a new property to a type when `\"dynamic\": false`\n\n[This](https://gist.github.com/nik9000/3dcd921f7c6656d67430) offers a fairly complete example of adding a field using the PUT mapping API works and how you could use the reindex API to `touch` the documents.\n\nThis use case differs from the resharding and incompatible mapping update use cases in that the document isn't being added to an empty index, its being updated in an existing index. So if the the reindex process goes to touch the document but its changed between the time that the scroll took its snapshot of the index then the document shouldn't be changed. Luckily, Elasticsearch has built in support for optimistic concurrency control.\n# Limiting the reindexed documents using a query\n\nThis seems like the logical extension to the other use cases more than a use case on its own. Its just a useful optimization on top of the other use cases. For example, you could use a query to only `touch` documents modified after a certain time.\n# Update-by-query style changes to portions of the index at a time\n\n\"Increment `counter` on all documents matching this query\" is a fairly normal operation on a relational database and Elasticsearch could have it too. Its fairly different internally from the other proposals but could be quite compelling though I admit to not having a good use case for it in mind. The trouble with this use case is that it tempts \"increment `counter` on all documents\" operations which are fairly inefficient in Elasticsearch. Its fairly inefficient in any system with concurrency control and most of them implement it anyway, but Elasticsearch makes an effort to make it difficult to do very inefficient things. Its inefficient because in Elasticsearch an update is an atomic delete and index operation and both of those operations are more expensive their relational counterparts. The delete itself is just as cheap but deleted document have to be reclaimed segment at a time rather than the aggressive measures relational datbases use. The index is much more expensive because the whole document has to be reanalyzed.\n\nIn many cases it'd be faster to copy the documents to a new index and then do the alias swap dance on it rather than update than it would be to touch every document in the index.\n\nEven with all that it may be a fairly useful API to implement.\n# Copying an index from a remote cluster into this one\n\nMaybe the most ambitious use case on the list, the idea here is to scroll on a remote cluster and index into the cluster handling the request. This seems like a sensible way to implement basic disaster recovery. It'd be better if the query could subscribe to updates and get them streamed back, but even as is it'd fairly nice to run daily/hourly updates. Especially if the documents had a `last_modified_time` style column.\n","closed_by":{"login":"nik9000","id":215970,"node_id":"MDQ6VXNlcjIxNTk3MA==","avatar_url":"https://avatars2.githubusercontent.com/u/215970?v=4","gravatar_id":"","url":"https://api.github.com/users/nik9000","html_url":"https://github.com/nik9000","followers_url":"https://api.github.com/users/nik9000/followers","following_url":"https://api.github.com/users/nik9000/following{/other_user}","gists_url":"https://api.github.com/users/nik9000/gists{/gist_id}","starred_url":"https://api.github.com/users/nik9000/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/nik9000/subscriptions","organizations_url":"https://api.github.com/users/nik9000/orgs","repos_url":"https://api.github.com/users/nik9000/repos","events_url":"https://api.github.com/users/nik9000/events{/privacy}","received_events_url":"https://api.github.com/users/nik9000/received_events","type":"User","site_admin":false},"performed_via_github_app":null}