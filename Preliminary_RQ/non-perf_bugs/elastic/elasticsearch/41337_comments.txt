[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/484516142","html_url":"https://github.com/elastic/elasticsearch/issues/41337#issuecomment-484516142","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/41337","id":484516142,"node_id":"MDEyOklzc3VlQ29tbWVudDQ4NDUxNjE0Mg==","user":{"login":"elasticmachine","id":15837671,"node_id":"MDQ6VXNlcjE1ODM3Njcx","avatar_url":"https://avatars3.githubusercontent.com/u/15837671?v=4","gravatar_id":"","url":"https://api.github.com/users/elasticmachine","html_url":"https://github.com/elasticmachine","followers_url":"https://api.github.com/users/elasticmachine/followers","following_url":"https://api.github.com/users/elasticmachine/following{/other_user}","gists_url":"https://api.github.com/users/elasticmachine/gists{/gist_id}","starred_url":"https://api.github.com/users/elasticmachine/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/elasticmachine/subscriptions","organizations_url":"https://api.github.com/users/elasticmachine/orgs","repos_url":"https://api.github.com/users/elasticmachine/repos","events_url":"https://api.github.com/users/elasticmachine/events{/privacy}","received_events_url":"https://api.github.com/users/elasticmachine/received_events","type":"User","site_admin":false},"created_at":"2019-04-18T13:46:33Z","updated_at":"2019-04-18T13:46:33Z","author_association":"COLLABORATOR","body":"Pinging @elastic/es-distributed","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/484516159","html_url":"https://github.com/elastic/elasticsearch/issues/41337#issuecomment-484516159","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/41337","id":484516159,"node_id":"MDEyOklzc3VlQ29tbWVudDQ4NDUxNjE1OQ==","user":{"login":"elasticmachine","id":15837671,"node_id":"MDQ6VXNlcjE1ODM3Njcx","avatar_url":"https://avatars3.githubusercontent.com/u/15837671?v=4","gravatar_id":"","url":"https://api.github.com/users/elasticmachine","html_url":"https://github.com/elasticmachine","followers_url":"https://api.github.com/users/elasticmachine/followers","following_url":"https://api.github.com/users/elasticmachine/following{/other_user}","gists_url":"https://api.github.com/users/elasticmachine/gists{/gist_id}","starred_url":"https://api.github.com/users/elasticmachine/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/elasticmachine/subscriptions","organizations_url":"https://api.github.com/users/elasticmachine/orgs","repos_url":"https://api.github.com/users/elasticmachine/repos","events_url":"https://api.github.com/users/elasticmachine/events{/privacy}","received_events_url":"https://api.github.com/users/elasticmachine/received_events","type":"User","site_admin":false},"created_at":"2019-04-18T13:46:34Z","updated_at":"2019-04-18T13:46:34Z","author_association":"COLLABORATOR","body":"Pinging @elastic/es-search","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/484517175","html_url":"https://github.com/elastic/elasticsearch/issues/41337#issuecomment-484517175","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/41337","id":484517175,"node_id":"MDEyOklzc3VlQ29tbWVudDQ4NDUxNzE3NQ==","user":{"login":"DaveCTurner","id":5058284,"node_id":"MDQ6VXNlcjUwNTgyODQ=","avatar_url":"https://avatars3.githubusercontent.com/u/5058284?v=4","gravatar_id":"","url":"https://api.github.com/users/DaveCTurner","html_url":"https://github.com/DaveCTurner","followers_url":"https://api.github.com/users/DaveCTurner/followers","following_url":"https://api.github.com/users/DaveCTurner/following{/other_user}","gists_url":"https://api.github.com/users/DaveCTurner/gists{/gist_id}","starred_url":"https://api.github.com/users/DaveCTurner/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/DaveCTurner/subscriptions","organizations_url":"https://api.github.com/users/DaveCTurner/orgs","repos_url":"https://api.github.com/users/DaveCTurner/repos","events_url":"https://api.github.com/users/DaveCTurner/events{/privacy}","received_events_url":"https://api.github.com/users/DaveCTurner/received_events","type":"User","site_admin":false},"created_at":"2019-04-18T13:48:43Z","updated_at":"2019-04-18T13:48:43Z","author_association":"CONTRIBUTOR","body":"Hi @bra-fsn, thanks for raising this. Yes, some heap dumps would be very useful. Can you upload them here please?\r\n\r\nhttps://upload-staging.elstc.co/u/0079f0c8-8f70-43b6-bec4-f8f84e45541a\r\n\r\nCertainly interested in the one you have analysed above, but if there are others that look different then please share them too.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/484538573","html_url":"https://github.com/elastic/elasticsearch/issues/41337#issuecomment-484538573","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/41337","id":484538573,"node_id":"MDEyOklzc3VlQ29tbWVudDQ4NDUzODU3Mw==","user":{"login":"bra-fsn","id":820331,"node_id":"MDQ6VXNlcjgyMDMzMQ==","avatar_url":"https://avatars2.githubusercontent.com/u/820331?v=4","gravatar_id":"","url":"https://api.github.com/users/bra-fsn","html_url":"https://github.com/bra-fsn","followers_url":"https://api.github.com/users/bra-fsn/followers","following_url":"https://api.github.com/users/bra-fsn/following{/other_user}","gists_url":"https://api.github.com/users/bra-fsn/gists{/gist_id}","starred_url":"https://api.github.com/users/bra-fsn/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bra-fsn/subscriptions","organizations_url":"https://api.github.com/users/bra-fsn/orgs","repos_url":"https://api.github.com/users/bra-fsn/repos","events_url":"https://api.github.com/users/bra-fsn/events{/privacy}","received_events_url":"https://api.github.com/users/bra-fsn/received_events","type":"User","site_admin":false},"created_at":"2019-04-18T14:40:14Z","updated_at":"2019-04-18T14:41:15Z","author_association":"NONE","body":"Thanks @DaveCTurner! I've uploaded the above dump.\r\nWill attach some more later.\r\nBTW, nice upload service (a simple curl upload would also be good)!","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/484592500","html_url":"https://github.com/elastic/elasticsearch/issues/41337#issuecomment-484592500","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/41337","id":484592500,"node_id":"MDEyOklzc3VlQ29tbWVudDQ4NDU5MjUwMA==","user":{"login":"DaveCTurner","id":5058284,"node_id":"MDQ6VXNlcjUwNTgyODQ=","avatar_url":"https://avatars3.githubusercontent.com/u/5058284?v=4","gravatar_id":"","url":"https://api.github.com/users/DaveCTurner","html_url":"https://github.com/DaveCTurner","followers_url":"https://api.github.com/users/DaveCTurner/followers","following_url":"https://api.github.com/users/DaveCTurner/following{/other_user}","gists_url":"https://api.github.com/users/DaveCTurner/gists{/gist_id}","starred_url":"https://api.github.com/users/DaveCTurner/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/DaveCTurner/subscriptions","organizations_url":"https://api.github.com/users/DaveCTurner/orgs","repos_url":"https://api.github.com/users/DaveCTurner/repos","events_url":"https://api.github.com/users/DaveCTurner/events{/privacy}","received_events_url":"https://api.github.com/users/DaveCTurner/received_events","type":"User","site_admin":false},"created_at":"2019-04-18T16:59:48Z","updated_at":"2019-04-18T16:59:48Z","author_association":"CONTRIBUTOR","body":"Thanks, got them. I've been looking at the first one you uploaded and I don't see anything terribly obvious yet. This is clearly a very busy node, and there's some hints that it needs more resources to deal with all the updates/deletes in your workload: for instance, the bulk of the 100s of MBs taken up by those `org.apache.lucene.index.IndexWriter`s looks to be tracking the live docs in each segment, which is only needed for segments containing deletes (which includes deletes due to updates).\r\n\r\nThe `org.elasticsearch.indices.IndicesQueryCache$ElasticsearchLRUQueryCache` also looks normal - by default it's limited to 10% of the heap, which appears to be 7.5GB, so 750MB seems right.\r\n\r\nBelow that there's a bunch of network buffers and some FSTs (10+MB). It all gets a bit deep into Lucene's internals about here, so I'm going to try and find someone more knowledgable to take a closer look.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/484705964","html_url":"https://github.com/elastic/elasticsearch/issues/41337#issuecomment-484705964","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/41337","id":484705964,"node_id":"MDEyOklzc3VlQ29tbWVudDQ4NDcwNTk2NA==","user":{"login":"bra-fsn","id":820331,"node_id":"MDQ6VXNlcjgyMDMzMQ==","avatar_url":"https://avatars2.githubusercontent.com/u/820331?v=4","gravatar_id":"","url":"https://api.github.com/users/bra-fsn","html_url":"https://github.com/bra-fsn","followers_url":"https://api.github.com/users/bra-fsn/followers","following_url":"https://api.github.com/users/bra-fsn/following{/other_user}","gists_url":"https://api.github.com/users/bra-fsn/gists{/gist_id}","starred_url":"https://api.github.com/users/bra-fsn/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bra-fsn/subscriptions","organizations_url":"https://api.github.com/users/bra-fsn/orgs","repos_url":"https://api.github.com/users/bra-fsn/repos","events_url":"https://api.github.com/users/bra-fsn/events{/privacy}","received_events_url":"https://api.github.com/users/bra-fsn/received_events","type":"User","site_admin":false},"created_at":"2019-04-18T22:08:21Z","updated_at":"2019-04-18T22:09:21Z","author_association":"NONE","body":"Yes, these nodes have work to do and indeed, there are a lot of updates here.\r\nI'm not good in Lucene internals, so this is new to me. So if there is at least one deleted doc in a segment, all (latest, in case of updates) docs are referenced in memory?\r\nFor us it essentially means all of the docs...\r\nIf this is true, having #40159 seems to be a must for us (so we can forcemerge big shards into smaller number of segments).\r\nThanks a lot for looking into this!","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/484786956","html_url":"https://github.com/elastic/elasticsearch/issues/41337#issuecomment-484786956","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/41337","id":484786956,"node_id":"MDEyOklzc3VlQ29tbWVudDQ4NDc4Njk1Ng==","user":{"login":"DaveCTurner","id":5058284,"node_id":"MDQ6VXNlcjUwNTgyODQ=","avatar_url":"https://avatars3.githubusercontent.com/u/5058284?v=4","gravatar_id":"","url":"https://api.github.com/users/DaveCTurner","html_url":"https://github.com/DaveCTurner","followers_url":"https://api.github.com/users/DaveCTurner/followers","following_url":"https://api.github.com/users/DaveCTurner/following{/other_user}","gists_url":"https://api.github.com/users/DaveCTurner/gists{/gist_id}","starred_url":"https://api.github.com/users/DaveCTurner/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/DaveCTurner/subscriptions","organizations_url":"https://api.github.com/users/DaveCTurner/orgs","repos_url":"https://api.github.com/users/DaveCTurner/repos","events_url":"https://api.github.com/users/DaveCTurner/events{/privacy}","received_events_url":"https://api.github.com/users/DaveCTurner/received_events","type":"User","site_admin":false},"created_at":"2019-04-19T07:04:45Z","updated_at":"2019-04-19T07:04:45Z","author_association":"CONTRIBUTOR","body":"> all (latest, in case of updates) docs are referenced in memory?\r\n\r\nNot quite, no, it's just a single bit for each document in the segment indicating whether it's live or not. One of the larger such segments on this node has nearly 40M documents, so that's about 5MB of heap, but I see 65 copies of this data which adds up to over 300MB. This corresponds with the enormous amount of heap retained by `org.apache.lucene.index.IndexWriter @ 0x8e322cd30` in your question. As far as I can tell we allocate another 5MB for this segment at each refresh, but we don't discard the old ones until all the searches that were using it have completed. There look to be quite a few scrolls open keeping these old copies around. Is there anything you can do to reduce the refreshes or to close these scrolls more quickly?","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/484867150","html_url":"https://github.com/elastic/elasticsearch/issues/41337#issuecomment-484867150","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/41337","id":484867150,"node_id":"MDEyOklzc3VlQ29tbWVudDQ4NDg2NzE1MA==","user":{"login":"bra-fsn","id":820331,"node_id":"MDQ6VXNlcjgyMDMzMQ==","avatar_url":"https://avatars2.githubusercontent.com/u/820331?v=4","gravatar_id":"","url":"https://api.github.com/users/bra-fsn","html_url":"https://github.com/bra-fsn","followers_url":"https://api.github.com/users/bra-fsn/followers","following_url":"https://api.github.com/users/bra-fsn/following{/other_user}","gists_url":"https://api.github.com/users/bra-fsn/gists{/gist_id}","starred_url":"https://api.github.com/users/bra-fsn/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bra-fsn/subscriptions","organizations_url":"https://api.github.com/users/bra-fsn/orgs","repos_url":"https://api.github.com/users/bra-fsn/repos","events_url":"https://api.github.com/users/bra-fsn/events{/privacy}","received_events_url":"https://api.github.com/users/bra-fsn/received_events","type":"User","site_admin":false},"created_at":"2019-04-19T11:39:36Z","updated_at":"2019-04-19T11:39:36Z","author_association":"NONE","body":"Quite useful conversation, thank you very much for sharing details about the internals!\r\nOMG, that sounds pretty bad. Do I get it right that when I open a scroll, all subsequent refreshes to all shards will lock these allocations until the scroll is cleared?\r\nOr is it just for the allocations already made before the scroll was created?\r\nAs for the refreshes, I don't really see anything I can do. If I'm right they depend mainly on `refresh_interval` and the number of incoming modifications. We have already optimized this, so have higher `refresh_interval` where it's possible.\r\nAre there anything else which can be done here?\r\n\r\nAs for keeping scroll contexts alive (which we really do, we scroll over selected docs in the large indices quite regularly), I'm also not sure.\r\nWe quite depend on this. Some can be rewritten with simple searches (maybe combined with `wait_for`s, so we know we won't hit already modified docs in the next search, which scroll automatically solves now).\r\nHaving read through the docs I know that it causes the segments to stick around, but the exact consequences of this was (and I guess still) not entirely clear.\r\nIf you could clarify this part in the doc that would be awesome. (currently it says we need more open file descriptors, but that's the minor problem here)\r\n\r\nThese are great points and help to understand what's happening here a lot.\r\nBut I guess if this would be the only problem here, I should have crashes every days and (luckily, not yet?) it's not the case.\r\n\r\nI know I can see how many scroll contexts are open, but is it possible to query details about them? I mean for example how long they are open.\r\nI will check this.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/484881018","html_url":"https://github.com/elastic/elasticsearch/issues/41337#issuecomment-484881018","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/41337","id":484881018,"node_id":"MDEyOklzc3VlQ29tbWVudDQ4NDg4MTAxOA==","user":{"login":"atris","id":1724131,"node_id":"MDQ6VXNlcjE3MjQxMzE=","avatar_url":"https://avatars0.githubusercontent.com/u/1724131?v=4","gravatar_id":"","url":"https://api.github.com/users/atris","html_url":"https://github.com/atris","followers_url":"https://api.github.com/users/atris/followers","following_url":"https://api.github.com/users/atris/following{/other_user}","gists_url":"https://api.github.com/users/atris/gists{/gist_id}","starred_url":"https://api.github.com/users/atris/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/atris/subscriptions","organizations_url":"https://api.github.com/users/atris/orgs","repos_url":"https://api.github.com/users/atris/repos","events_url":"https://api.github.com/users/atris/events{/privacy}","received_events_url":"https://api.github.com/users/atris/received_events","type":"User","site_admin":false},"created_at":"2019-04-19T12:33:26Z","updated_at":"2019-04-19T12:33:26Z","author_association":"NONE","body":"What is your segment merging policy? Did you change the default from TieredMergePolicy?\r\n\r\nAs @DaveCTurner said, having open scroll contexts will cause old segments to lie around. Typically, TieredMergePolicy will ensure that you do not have more than 15% deleted documents, so IndexWriter instances tracking live docs will have a smaller footprint.\r\n\r\nHow frequent are your deletes? If you delete at a more or less constant rate over time with multiple scroll contexts open, you will eventually run out of memory due to Lucene's inability to merge old segments and get rid of the deleted documents. As Dave explained, deleted documents not purged yet also have the overhead corresponding to IndexWriters.\r\n\r\nTo verify this suspicion, you could synthetically trigger a larger delete rate (maybe in a test cluster) while keeping other parameters same. You would run into OOM faster if above is the case applicable to you.\r\n\r\nTo get details of scroll contexts currently applicable to an index, use node stats API:\r\n\r\n`curl -XGET 'ES_HOST:ES_PORT/_nodes/stats/indices/search'`","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/484884954","html_url":"https://github.com/elastic/elasticsearch/issues/41337#issuecomment-484884954","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/41337","id":484884954,"node_id":"MDEyOklzc3VlQ29tbWVudDQ4NDg4NDk1NA==","user":{"login":"atris","id":1724131,"node_id":"MDQ6VXNlcjE3MjQxMzE=","avatar_url":"https://avatars0.githubusercontent.com/u/1724131?v=4","gravatar_id":"","url":"https://api.github.com/users/atris","html_url":"https://github.com/atris","followers_url":"https://api.github.com/users/atris/followers","following_url":"https://api.github.com/users/atris/following{/other_user}","gists_url":"https://api.github.com/users/atris/gists{/gist_id}","starred_url":"https://api.github.com/users/atris/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/atris/subscriptions","organizations_url":"https://api.github.com/users/atris/orgs","repos_url":"https://api.github.com/users/atris/repos","events_url":"https://api.github.com/users/atris/events{/privacy}","received_events_url":"https://api.github.com/users/atris/received_events","type":"User","site_admin":false},"created_at":"2019-04-19T12:47:27Z","updated_at":"2019-04-19T12:47:27Z","author_association":"NONE","body":"\r\n> To get details of scroll contexts currently applicable to an index, use node stats API:\r\n> \r\n> `curl -XGET 'ES_HOST:ES_PORT/_nodes/stats/indices/search'`\r\n\r\nAlthough, I dont recall offhand if this tells you how long a scroll context has been up for, so it might not really help.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/484887187","html_url":"https://github.com/elastic/elasticsearch/issues/41337#issuecomment-484887187","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/41337","id":484887187,"node_id":"MDEyOklzc3VlQ29tbWVudDQ4NDg4NzE4Nw==","user":{"login":"bra-fsn","id":820331,"node_id":"MDQ6VXNlcjgyMDMzMQ==","avatar_url":"https://avatars2.githubusercontent.com/u/820331?v=4","gravatar_id":"","url":"https://api.github.com/users/bra-fsn","html_url":"https://github.com/bra-fsn","followers_url":"https://api.github.com/users/bra-fsn/followers","following_url":"https://api.github.com/users/bra-fsn/following{/other_user}","gists_url":"https://api.github.com/users/bra-fsn/gists{/gist_id}","starred_url":"https://api.github.com/users/bra-fsn/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bra-fsn/subscriptions","organizations_url":"https://api.github.com/users/bra-fsn/orgs","repos_url":"https://api.github.com/users/bra-fsn/repos","events_url":"https://api.github.com/users/bra-fsn/events{/privacy}","received_events_url":"https://api.github.com/users/bra-fsn/received_events","type":"User","site_admin":false},"created_at":"2019-04-19T12:55:25Z","updated_at":"2019-04-19T12:55:25Z","author_association":"NONE","body":"I know and use this, and sadly it doesn't tell it, just how many contexts are open currently.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/484892009","html_url":"https://github.com/elastic/elasticsearch/issues/41337#issuecomment-484892009","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/41337","id":484892009,"node_id":"MDEyOklzc3VlQ29tbWVudDQ4NDg5MjAwOQ==","user":{"login":"bra-fsn","id":820331,"node_id":"MDQ6VXNlcjgyMDMzMQ==","avatar_url":"https://avatars2.githubusercontent.com/u/820331?v=4","gravatar_id":"","url":"https://api.github.com/users/bra-fsn","html_url":"https://github.com/bra-fsn","followers_url":"https://api.github.com/users/bra-fsn/followers","following_url":"https://api.github.com/users/bra-fsn/following{/other_user}","gists_url":"https://api.github.com/users/bra-fsn/gists{/gist_id}","starred_url":"https://api.github.com/users/bra-fsn/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bra-fsn/subscriptions","organizations_url":"https://api.github.com/users/bra-fsn/orgs","repos_url":"https://api.github.com/users/bra-fsn/repos","events_url":"https://api.github.com/users/bra-fsn/events{/privacy}","received_events_url":"https://api.github.com/users/bra-fsn/received_events","type":"User","site_admin":false},"created_at":"2019-04-19T13:13:06Z","updated_at":"2019-04-19T13:13:28Z","author_association":"NONE","body":"> What is your segment merging policy? Did you change the default from TieredMergePolicy?\r\n\r\nNope, it's the default.\r\n\r\n> As @DaveCTurner said, having open scroll contexts will cause old segments to lie around. Typically, TieredMergePolicy will ensure that you do not have more than 15% deleted documents, so IndexWriter instances tracking live docs will have a smaller footprint.\r\n\r\nI have 1.56B deleted docs out of 21.09B total currently (primaries).\r\n\r\n> How frequent are your deletes? If you delete at a more or less constant rate over time with multiple scroll contexts open, you will eventually run out of memory due to Lucene's inability to merge old segments and get rid of the deleted documents. As Dave explained, deleted documents not purged yet also have the overhead corresponding to IndexWriters.\r\n\r\nQuite frequent. I mean on a daily average I have (per second):\r\nindex: 4.92k\r\ndelete: 209\r\nrefresh: 918\r\n\r\nIs Lucene smart enough to merge segments not involved in an open scroll context?\r\nI mean these two questions:\r\n1. (I guess this works because it's trivial) only keeps segments for involved indices (so if I do a search on index1, segments in other indices will be just merged)\r\n2. if I open a scroll, all segments at that time will be preserved until the scroll context is alive. But will newly written segments be merged, or they will also be held until the context is destroyed?\r\n\r\n> To verify this suspicion, you could synthetically trigger a larger delete rate (maybe in a test cluster) while keeping other parameters same. You would run into OOM faster if above is the case applicable to you.\r\n\r\nI can try this. What parameter should contain the memory which will be growing faster than currently?\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/484910525","html_url":"https://github.com/elastic/elasticsearch/issues/41337#issuecomment-484910525","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/41337","id":484910525,"node_id":"MDEyOklzc3VlQ29tbWVudDQ4NDkxMDUyNQ==","user":{"login":"atris","id":1724131,"node_id":"MDQ6VXNlcjE3MjQxMzE=","avatar_url":"https://avatars0.githubusercontent.com/u/1724131?v=4","gravatar_id":"","url":"https://api.github.com/users/atris","html_url":"https://github.com/atris","followers_url":"https://api.github.com/users/atris/followers","following_url":"https://api.github.com/users/atris/following{/other_user}","gists_url":"https://api.github.com/users/atris/gists{/gist_id}","starred_url":"https://api.github.com/users/atris/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/atris/subscriptions","organizations_url":"https://api.github.com/users/atris/orgs","repos_url":"https://api.github.com/users/atris/repos","events_url":"https://api.github.com/users/atris/events{/privacy}","received_events_url":"https://api.github.com/users/atris/received_events","type":"User","site_admin":false},"created_at":"2019-04-19T14:21:59Z","updated_at":"2019-04-19T14:21:59Z","author_association":"NONE","body":"\r\n> > How frequent are your deletes? If you delete at a more or less constant rate over time with multiple scroll contexts open, you will eventually run out of memory due to Lucene's inability to merge old segments and get rid of the deleted documents. As Dave explained, deleted documents not purged yet also have the overhead corresponding to IndexWriters.\r\n> \r\n> Quite frequent. I mean on a daily average I have (per second):\r\n> index: 4.92k\r\n> delete: 209\r\n> refresh: 918\r\n> \r\n\r\nOk, that might be the source of the problem.\r\n\r\n> Is Lucene smart enough to merge segments not involved in an open scroll context?\r\n> I mean these two questions:\r\n> \r\n> 1. (I guess this works because it's trivial) only keeps segments for involved indices (so if I do a search on index1, segments in other indices will be just merged)\r\n\r\nYes.\r\n\r\n> 2. if I open a scroll, all segments at that time will be preserved until the scroll context is alive. But will newly written segments be merged, or they will also be held until the context is destroyed?\r\n\r\nI believe so. The semantic is that segments currently opened by an `IndexReader` cannot be merged, but unless you explicitly ask for a new `IndexReader` instance from your `Directory`, the changes being done by merging will not be visible to your executing query.\r\n\r\n> > To verify this suspicion, you could synthetically trigger a larger delete rate (maybe in a test cluster) while keeping other parameters same. You would run into OOM faster if above is the case applicable to you.\r\n> \r\n> I can try this. What parameter should contain the memory which will be growing faster than currently?\r\n\r\nI am not sure I understand your question. If you increase the deletion rate of documents while keeping the number of open scroll contexts same (or maybe open a few more and keep them open to further stress the scenario), keep the ingestion rate constant, then you should hit OOM earlier. Even before OOM, check your consumed memory and it should increase at a faster rate than what happens in your current scenario.\r\n\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/484911824","html_url":"https://github.com/elastic/elasticsearch/issues/41337#issuecomment-484911824","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/41337","id":484911824,"node_id":"MDEyOklzc3VlQ29tbWVudDQ4NDkxMTgyNA==","user":{"login":"atris","id":1724131,"node_id":"MDQ6VXNlcjE3MjQxMzE=","avatar_url":"https://avatars0.githubusercontent.com/u/1724131?v=4","gravatar_id":"","url":"https://api.github.com/users/atris","html_url":"https://github.com/atris","followers_url":"https://api.github.com/users/atris/followers","following_url":"https://api.github.com/users/atris/following{/other_user}","gists_url":"https://api.github.com/users/atris/gists{/gist_id}","starred_url":"https://api.github.com/users/atris/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/atris/subscriptions","organizations_url":"https://api.github.com/users/atris/orgs","repos_url":"https://api.github.com/users/atris/repos","events_url":"https://api.github.com/users/atris/events{/privacy}","received_events_url":"https://api.github.com/users/atris/received_events","type":"User","site_admin":false},"created_at":"2019-04-19T14:25:54Z","updated_at":"2019-04-19T14:25:54Z","author_association":"NONE","body":"> I know and use this, and sadly it doesn't tell it, just how many contexts are open currently.\r\n\r\nThat is a limitation, and unless we have another way of getting this information, I would suggest addition of the same to Indices stats. @DaveCTurner Any thoughts on this?","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/484920352","html_url":"https://github.com/elastic/elasticsearch/issues/41337#issuecomment-484920352","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/41337","id":484920352,"node_id":"MDEyOklzc3VlQ29tbWVudDQ4NDkyMDM1Mg==","user":{"login":"bra-fsn","id":820331,"node_id":"MDQ6VXNlcjgyMDMzMQ==","avatar_url":"https://avatars2.githubusercontent.com/u/820331?v=4","gravatar_id":"","url":"https://api.github.com/users/bra-fsn","html_url":"https://github.com/bra-fsn","followers_url":"https://api.github.com/users/bra-fsn/followers","following_url":"https://api.github.com/users/bra-fsn/following{/other_user}","gists_url":"https://api.github.com/users/bra-fsn/gists{/gist_id}","starred_url":"https://api.github.com/users/bra-fsn/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bra-fsn/subscriptions","organizations_url":"https://api.github.com/users/bra-fsn/orgs","repos_url":"https://api.github.com/users/bra-fsn/repos","events_url":"https://api.github.com/users/bra-fsn/events{/privacy}","received_events_url":"https://api.github.com/users/bra-fsn/received_events","type":"User","site_admin":false},"created_at":"2019-04-19T14:53:50Z","updated_at":"2019-04-19T14:53:50Z","author_association":"NONE","body":"> > I can try this. What parameter should contain the memory which will be growing faster than currently?\r\n> \r\n> I am not sure I understand your question. If you increase the deletion rate of documents while keeping the number of open scroll contexts same (or maybe open a few more and keep them open to further stress the scenario), keep the ingestion rate constant, then you should hit OOM earlier. Even before OOM, check your consumed memory and it should increase at a faster rate than what happens in your current scenario.\r\n\r\nSorry, I mean should I watch for indices/segments/index_writer_memory_in_bytes in _nodes/stats and I should see the increased growth there?\r\nAnd if this is the real cause of my issue, a sawtooth-like graph eventually? I'm asking this because while this fluctuates currently (seems normal), I can't see this shape.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/484922630","html_url":"https://github.com/elastic/elasticsearch/issues/41337#issuecomment-484922630","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/41337","id":484922630,"node_id":"MDEyOklzc3VlQ29tbWVudDQ4NDkyMjYzMA==","user":{"login":"DaveCTurner","id":5058284,"node_id":"MDQ6VXNlcjUwNTgyODQ=","avatar_url":"https://avatars3.githubusercontent.com/u/5058284?v=4","gravatar_id":"","url":"https://api.github.com/users/DaveCTurner","html_url":"https://github.com/DaveCTurner","followers_url":"https://api.github.com/users/DaveCTurner/followers","following_url":"https://api.github.com/users/DaveCTurner/following{/other_user}","gists_url":"https://api.github.com/users/DaveCTurner/gists{/gist_id}","starred_url":"https://api.github.com/users/DaveCTurner/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/DaveCTurner/subscriptions","organizations_url":"https://api.github.com/users/DaveCTurner/orgs","repos_url":"https://api.github.com/users/DaveCTurner/repos","events_url":"https://api.github.com/users/DaveCTurner/events{/privacy}","received_events_url":"https://api.github.com/users/DaveCTurner/received_events","type":"User","site_admin":false},"created_at":"2019-04-19T15:01:16Z","updated_at":"2019-04-19T15:01:39Z","author_association":"CONTRIBUTOR","body":"> Having read through the docs I know that it causes the segments to stick around, but the exact consequences of this was (and I guess still) not entirely clear.\r\n\r\nYes, I opened #41375 to suggest a clarification, although this is not really my area of expertise so I wouldn't trust the accuracy of my wording until it's been reviewed.\r\n\r\n> only keeps segments for involved indices (so if I do a search on index1, segments in other indices will be just merged)\r\n\r\nYes, there's no interaction between shards here.\r\n\r\n> But will newly written segments be merged, or they will also be held until the context is destroyed?\r\n\r\nNo, it's just the existing segments that are held. Merging continues as normal. Segments held by a scroll are also merged as normal, except that they're not deleted after being merged while there's still an open context that needs them. From [the docs]:(https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-scroll.html)\r\n\r\n>Normally, the background merge process optimizes the index by merging together smaller segments to create new bigger segments, at which time the smaller segments are deleted. This process continues during scrolling, but an open search context prevents the old segments from being deleted while they are still in use. This is how Elasticsearch is able to return the results of the initial search request, regardless of subsequent changes to documents.\r\n\r\n> I know I can see how many scroll contexts are open, but is it possible to query details about them?\r\n\r\nNo I can't see a way of doing this (unless you count taking a heap dump :grin:)\r\n\r\nI do not think that increasing the _rate_ of deletions will exacerbate what we're seeing here. The big heap consumer I'm looking at here is held by the live docs arrays, which are a bit complicated to explain but I'll try to do so as follows. If a scroll is working on a segment containing deletes then it needs to hold 1-2 bits per document in that segment. But if there are multiple scrolls on that segment with the same sets of live docs then I think they share the data. If you want to increase the heap usage from live docs arrays, could you try the following:\r\n\r\n1. find a segment with lots of docs (ideally, make a one-shard one-segment index using force-merge, it'll simplify the rest of this)\r\n2. open a scroll involving this segment\r\n3. delete a doc\r\n4. refresh this index\r\n5. GOTO 2\r\n\r\nYou should see heap usage increasing each time round, and then when you close each scroll you should see it drop again. I don't know that this is tracked in any stats, mind, so you might have to talk to the JVM to observe this, or to do it until it OOMs.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/484923011","html_url":"https://github.com/elastic/elasticsearch/issues/41337#issuecomment-484923011","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/41337","id":484923011,"node_id":"MDEyOklzc3VlQ29tbWVudDQ4NDkyMzAxMQ==","user":{"login":"bra-fsn","id":820331,"node_id":"MDQ6VXNlcjgyMDMzMQ==","avatar_url":"https://avatars2.githubusercontent.com/u/820331?v=4","gravatar_id":"","url":"https://api.github.com/users/bra-fsn","html_url":"https://github.com/bra-fsn","followers_url":"https://api.github.com/users/bra-fsn/followers","following_url":"https://api.github.com/users/bra-fsn/following{/other_user}","gists_url":"https://api.github.com/users/bra-fsn/gists{/gist_id}","starred_url":"https://api.github.com/users/bra-fsn/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bra-fsn/subscriptions","organizations_url":"https://api.github.com/users/bra-fsn/orgs","repos_url":"https://api.github.com/users/bra-fsn/repos","events_url":"https://api.github.com/users/bra-fsn/events{/privacy}","received_events_url":"https://api.github.com/users/bra-fsn/received_events","type":"User","site_admin":false},"created_at":"2019-04-19T15:02:35Z","updated_at":"2019-04-19T15:02:35Z","author_association":"NONE","body":"> > I know and use this, and sadly it doesn't tell it, just how many contexts are open currently.\r\n> \r\n> That is a limitation, and unless we have another way of getting this information, I would suggest addition of the same to Indices stats. @DaveCTurner Any thoughts on this?\r\n\r\nShouldn't this deserve a new stat endpoint (for querying the open scroll contexts)?\r\nJust having the number may be not enough for debugging who/which holds these. It would be nice to have the client IP, the ID, the open time, the timeout and whatever else is available as well.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/484926863","html_url":"https://github.com/elastic/elasticsearch/issues/41337#issuecomment-484926863","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/41337","id":484926863,"node_id":"MDEyOklzc3VlQ29tbWVudDQ4NDkyNjg2Mw==","user":{"login":"DaveCTurner","id":5058284,"node_id":"MDQ6VXNlcjUwNTgyODQ=","avatar_url":"https://avatars3.githubusercontent.com/u/5058284?v=4","gravatar_id":"","url":"https://api.github.com/users/DaveCTurner","html_url":"https://github.com/DaveCTurner","followers_url":"https://api.github.com/users/DaveCTurner/followers","following_url":"https://api.github.com/users/DaveCTurner/following{/other_user}","gists_url":"https://api.github.com/users/DaveCTurner/gists{/gist_id}","starred_url":"https://api.github.com/users/DaveCTurner/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/DaveCTurner/subscriptions","organizations_url":"https://api.github.com/users/DaveCTurner/orgs","repos_url":"https://api.github.com/users/DaveCTurner/repos","events_url":"https://api.github.com/users/DaveCTurner/events{/privacy}","received_events_url":"https://api.github.com/users/DaveCTurner/received_events","type":"User","site_admin":false},"created_at":"2019-04-19T15:14:17Z","updated_at":"2019-04-19T15:14:17Z","author_association":"CONTRIBUTOR","body":"Since I think these OOMs are because your nodes don't have the resources needed to do what you're asking them to do, and not because of a bug, I think it best to close this issue and ask you to move this discussion over to the [discussion forum](https://discuss.elastic.co/c/elasticsearch). If it turns out that there is a bug here then we can of course re-open this.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/484928180","html_url":"https://github.com/elastic/elasticsearch/issues/41337#issuecomment-484928180","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/41337","id":484928180,"node_id":"MDEyOklzc3VlQ29tbWVudDQ4NDkyODE4MA==","user":{"login":"bra-fsn","id":820331,"node_id":"MDQ6VXNlcjgyMDMzMQ==","avatar_url":"https://avatars2.githubusercontent.com/u/820331?v=4","gravatar_id":"","url":"https://api.github.com/users/bra-fsn","html_url":"https://github.com/bra-fsn","followers_url":"https://api.github.com/users/bra-fsn/followers","following_url":"https://api.github.com/users/bra-fsn/following{/other_user}","gists_url":"https://api.github.com/users/bra-fsn/gists{/gist_id}","starred_url":"https://api.github.com/users/bra-fsn/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bra-fsn/subscriptions","organizations_url":"https://api.github.com/users/bra-fsn/orgs","repos_url":"https://api.github.com/users/bra-fsn/repos","events_url":"https://api.github.com/users/bra-fsn/events{/privacy}","received_events_url":"https://api.github.com/users/bra-fsn/received_events","type":"User","site_admin":false},"created_at":"2019-04-19T15:18:22Z","updated_at":"2019-04-19T15:19:57Z","author_association":"NONE","body":"> > I know I can see how many scroll contexts are open, but is it possible to query details about them?\r\n> \r\n> No I can't see a way of doing this (unless you count taking a heap dump grin)\r\n\r\nIt would be nice to have this feature (opened a feature request).\r\n \r\n> I do not think that increasing the _rate_ of deletions will exacerbate what we're seeing here. The big heap consumer I'm looking at here is held by the live docs arrays, which are a bit complicated to explain but I'll try to do so as follows. If a scroll is working on a segment containing deletes then it needs to hold 1-2 bits per document in that segment. But if there are multiple scrolls on that segment with the same sets of live docs then I think they share the data. If you want to increase the heap usage from live docs arrays, could you try the following:\r\n\r\nDo you see any possibilities to overcome this issue?\r\n\r\n> \r\n>     1. find a segment with lots of docs (ideally, make a one-shard one-segment index using force-merge, it'll simplify the rest of this)\r\n> \r\n>     2. open a scroll involving this segment\r\n> \r\n>     3. delete a doc\r\n> \r\n>     4. refresh this index\r\n> \r\n>     5. GOTO 2\r\n> \r\n> \r\n> You should see heap usage increasing each time round, and then when you close each scroll you should see it drop again. I don't know that this is tracked in any stats, mind, so you might have to talk to the JVM to observe this, or to do it until it OOMs.\r\n\r\nI think it's vital to have this in the stats. I have graphs from all memory related metrics and currently nothing indicates that there is a problem here.\r\nAccording to the above, shouldn't index_writer_memory_in_bytes contain this?","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/484960433","html_url":"https://github.com/elastic/elasticsearch/issues/41337#issuecomment-484960433","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/41337","id":484960433,"node_id":"MDEyOklzc3VlQ29tbWVudDQ4NDk2MDQzMw==","user":{"login":"atris","id":1724131,"node_id":"MDQ6VXNlcjE3MjQxMzE=","avatar_url":"https://avatars0.githubusercontent.com/u/1724131?v=4","gravatar_id":"","url":"https://api.github.com/users/atris","html_url":"https://github.com/atris","followers_url":"https://api.github.com/users/atris/followers","following_url":"https://api.github.com/users/atris/following{/other_user}","gists_url":"https://api.github.com/users/atris/gists{/gist_id}","starred_url":"https://api.github.com/users/atris/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/atris/subscriptions","organizations_url":"https://api.github.com/users/atris/orgs","repos_url":"https://api.github.com/users/atris/repos","events_url":"https://api.github.com/users/atris/events{/privacy}","received_events_url":"https://api.github.com/users/atris/received_events","type":"User","site_admin":false},"created_at":"2019-04-19T17:13:54Z","updated_at":"2019-04-19T17:13:54Z","author_association":"NONE","body":"\r\n> I do not think that increasing the _rate_ of deletions will exacerbate what we're seeing here. The big heap consumer I'm looking at here is held by the live docs arrays, which are a bit complicated to explain but I'll try to do so as follows. If a scroll is working on a segment containing deletes then it needs to hold 1-2 bits per document in that segment. But if there are multiple scrolls on that segment with the same sets of live docs then I think they share the data. If you want to increase the heap usage from live docs arrays, could you try the following:\r\n\r\nYes, multiple scrolls would share the same `IndexWriter` for live docs tracking for same segment.\r\n\r\nI am curious to understand why increase the rate of deletions keeping everything else constant would not aggravate this scenario. If a large segment was opened by multiple scrolls and the deletion rate for that segment grew significantly, would the live docs array not grow proportionately since you cannot merge the segment yet?\r\n\r\n\r\n> 1. find a segment with lots of docs (ideally, make a one-shard one-segment index using force-merge, it'll simplify the rest of this)\r\n> 2. open a scroll involving this segment\r\n> 3. delete a doc\r\n> 4. refresh this index\r\n> 5. GOTO 2\r\n> \r\n\r\nWould it not be a better way to aggravate if each scroll was opened on a different segment, since that means that there would be different live docs array per scroll?\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/485015079","html_url":"https://github.com/elastic/elasticsearch/issues/41337#issuecomment-485015079","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/41337","id":485015079,"node_id":"MDEyOklzc3VlQ29tbWVudDQ4NTAxNTA3OQ==","user":{"login":"bra-fsn","id":820331,"node_id":"MDQ6VXNlcjgyMDMzMQ==","avatar_url":"https://avatars2.githubusercontent.com/u/820331?v=4","gravatar_id":"","url":"https://api.github.com/users/bra-fsn","html_url":"https://github.com/bra-fsn","followers_url":"https://api.github.com/users/bra-fsn/followers","following_url":"https://api.github.com/users/bra-fsn/following{/other_user}","gists_url":"https://api.github.com/users/bra-fsn/gists{/gist_id}","starred_url":"https://api.github.com/users/bra-fsn/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bra-fsn/subscriptions","organizations_url":"https://api.github.com/users/bra-fsn/orgs","repos_url":"https://api.github.com/users/bra-fsn/repos","events_url":"https://api.github.com/users/bra-fsn/events{/privacy}","received_events_url":"https://api.github.com/users/bra-fsn/received_events","type":"User","site_admin":false},"created_at":"2019-04-19T21:10:24Z","updated_at":"2019-04-19T21:33:12Z","author_association":"NONE","body":"BTW, open scrolls per nodes:\r\n![image](https://user-images.githubusercontent.com/820331/56437080-6a77ab00-62de-11e9-84c7-892c0f60bea3.png)\r\n\r\nand index_writer_memory:\r\n![image](https://user-images.githubusercontent.com/820331/56437116-80856b80-62de-11e9-983b-0c151a3f39c8.png)\r\n\r\nAnd index_writer_memory cluster wide:\r\n![image](https://user-images.githubusercontent.com/820331/56444244-37421580-62f8-11e9-8176-3fafda867700.png)\r\n\r\nIt seems that index_writer_memory doesn't account/track an important piece of memory.\r\nCan you confirm this and agree on that this should be fixed?","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/485059244","html_url":"https://github.com/elastic/elasticsearch/issues/41337#issuecomment-485059244","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/41337","id":485059244,"node_id":"MDEyOklzc3VlQ29tbWVudDQ4NTA1OTI0NA==","user":{"login":"atris","id":1724131,"node_id":"MDQ6VXNlcjE3MjQxMzE=","avatar_url":"https://avatars0.githubusercontent.com/u/1724131?v=4","gravatar_id":"","url":"https://api.github.com/users/atris","html_url":"https://github.com/atris","followers_url":"https://api.github.com/users/atris/followers","following_url":"https://api.github.com/users/atris/following{/other_user}","gists_url":"https://api.github.com/users/atris/gists{/gist_id}","starred_url":"https://api.github.com/users/atris/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/atris/subscriptions","organizations_url":"https://api.github.com/users/atris/orgs","repos_url":"https://api.github.com/users/atris/repos","events_url":"https://api.github.com/users/atris/events{/privacy}","received_events_url":"https://api.github.com/users/atris/received_events","type":"User","site_admin":false},"created_at":"2019-04-20T05:05:42Z","updated_at":"2019-04-20T05:05:42Z","author_association":"NONE","body":"@bra-fsn The portion of `index_writer_memory` graph that you showed is too less of data to really comment on, but from what's available, isnt that graph following the same pattern as `index_writer_memory_cluster`?\r\n\r\nCan you highlight all the three graphs for a smaller (and the same) time window? That would help corraborate patterns across the three.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/485930720","html_url":"https://github.com/elastic/elasticsearch/issues/41337#issuecomment-485930720","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/41337","id":485930720,"node_id":"MDEyOklzc3VlQ29tbWVudDQ4NTkzMDcyMA==","user":{"login":"bra-fsn","id":820331,"node_id":"MDQ6VXNlcjgyMDMzMQ==","avatar_url":"https://avatars2.githubusercontent.com/u/820331?v=4","gravatar_id":"","url":"https://api.github.com/users/bra-fsn","html_url":"https://github.com/bra-fsn","followers_url":"https://api.github.com/users/bra-fsn/followers","following_url":"https://api.github.com/users/bra-fsn/following{/other_user}","gists_url":"https://api.github.com/users/bra-fsn/gists{/gist_id}","starred_url":"https://api.github.com/users/bra-fsn/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bra-fsn/subscriptions","organizations_url":"https://api.github.com/users/bra-fsn/orgs","repos_url":"https://api.github.com/users/bra-fsn/repos","events_url":"https://api.github.com/users/bra-fsn/events{/privacy}","received_events_url":"https://api.github.com/users/bra-fsn/received_events","type":"User","site_admin":false},"created_at":"2019-04-23T18:55:18Z","updated_at":"2019-04-23T19:01:31Z","author_association":"NONE","body":"@atris: here are the graphs (sadly some missing intervals have slipped in):\r\nThis is index_memory_in_bytes cluster wide:\r\n![image](https://user-images.githubusercontent.com/820331/56607762-94e0a580-6609-11e9-9b8f-5a694fb0e9c5.png)\r\nThis is index_writer_memory_in_bytes per node:\r\n![image](https://user-images.githubusercontent.com/820331/56607874-d1ac9c80-6609-11e9-8860-4043640eb5ff.png)\r\nThis is number of scrolls per node:\r\n![image](https://user-images.githubusercontent.com/820331/56607823-b8a3eb80-6609-11e9-988e-61e3c8f4ce16.png)\r\nScrolls cluster wide:\r\n![image](https://user-images.githubusercontent.com/820331/56607928-f274f200-6609-11e9-9693-ebfa4c3cce1c.png)\r\n\r\nAccording to this, I would say either the assumption is wrong, or not all memory is accounted in index_writer_memory.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/488577588","html_url":"https://github.com/elastic/elasticsearch/issues/41337#issuecomment-488577588","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/41337","id":488577588,"node_id":"MDEyOklzc3VlQ29tbWVudDQ4ODU3NzU4OA==","user":{"login":"bra-fsn","id":820331,"node_id":"MDQ6VXNlcjgyMDMzMQ==","avatar_url":"https://avatars2.githubusercontent.com/u/820331?v=4","gravatar_id":"","url":"https://api.github.com/users/bra-fsn","html_url":"https://github.com/bra-fsn","followers_url":"https://api.github.com/users/bra-fsn/followers","following_url":"https://api.github.com/users/bra-fsn/following{/other_user}","gists_url":"https://api.github.com/users/bra-fsn/gists{/gist_id}","starred_url":"https://api.github.com/users/bra-fsn/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bra-fsn/subscriptions","organizations_url":"https://api.github.com/users/bra-fsn/orgs","repos_url":"https://api.github.com/users/bra-fsn/repos","events_url":"https://api.github.com/users/bra-fsn/events{/privacy}","received_events_url":"https://api.github.com/users/bra-fsn/received_events","type":"User","site_admin":false},"created_at":"2019-05-02T07:33:39Z","updated_at":"2019-05-02T07:33:39Z","author_association":"NONE","body":"@DaveCTurner, @atris: so index_writer_memory per node (according to elastic) tops at around 20-50 MiBs and doesn't show a pattern of accumulation, it just surges with the traffic rate.\r\nSo how could I prove that the assumption about IndexWriter eating all of the memory is true? How can I measure this?","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/488588267","html_url":"https://github.com/elastic/elasticsearch/issues/41337#issuecomment-488588267","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/41337","id":488588267,"node_id":"MDEyOklzc3VlQ29tbWVudDQ4ODU4ODI2Nw==","user":{"login":"DaveCTurner","id":5058284,"node_id":"MDQ6VXNlcjUwNTgyODQ=","avatar_url":"https://avatars3.githubusercontent.com/u/5058284?v=4","gravatar_id":"","url":"https://api.github.com/users/DaveCTurner","html_url":"https://github.com/DaveCTurner","followers_url":"https://api.github.com/users/DaveCTurner/followers","following_url":"https://api.github.com/users/DaveCTurner/following{/other_user}","gists_url":"https://api.github.com/users/DaveCTurner/gists{/gist_id}","starred_url":"https://api.github.com/users/DaveCTurner/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/DaveCTurner/subscriptions","organizations_url":"https://api.github.com/users/DaveCTurner/orgs","repos_url":"https://api.github.com/users/DaveCTurner/repos","events_url":"https://api.github.com/users/DaveCTurner/events{/privacy}","received_events_url":"https://api.github.com/users/DaveCTurner/received_events","type":"User","site_admin":false},"created_at":"2019-05-02T08:21:06Z","updated_at":"2019-05-02T08:21:06Z","author_association":"CONTRIBUTOR","body":"Hi @bra-fsn, repeating https://github.com/elastic/elasticsearch/issues/41337#issuecomment-484926863 could you continue this conversation on the [discussion forum](https://discuss.elastic.co/c/elasticsearch)? I'll try and answer you over there, but GitHub isn't the right place for this discussion.","performed_via_github_app":null}]