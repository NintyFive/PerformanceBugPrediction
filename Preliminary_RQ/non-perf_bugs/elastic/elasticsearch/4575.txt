{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/4575","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/4575/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/4575/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/4575/events","html_url":"https://github.com/elastic/elasticsearch/issues/4575","id":24911647,"node_id":"MDU6SXNzdWUyNDkxMTY0Nw==","number":4575,"title":"Allow analyzer to be specified for object and nested field mappings","user":{"login":"benquarmby","id":1434816,"node_id":"MDQ6VXNlcjE0MzQ4MTY=","avatar_url":"https://avatars0.githubusercontent.com/u/1434816?v=4","gravatar_id":"","url":"https://api.github.com/users/benquarmby","html_url":"https://github.com/benquarmby","followers_url":"https://api.github.com/users/benquarmby/followers","following_url":"https://api.github.com/users/benquarmby/following{/other_user}","gists_url":"https://api.github.com/users/benquarmby/gists{/gist_id}","starred_url":"https://api.github.com/users/benquarmby/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/benquarmby/subscriptions","organizations_url":"https://api.github.com/users/benquarmby/orgs","repos_url":"https://api.github.com/users/benquarmby/repos","events_url":"https://api.github.com/users/benquarmby/events{/privacy}","received_events_url":"https://api.github.com/users/benquarmby/received_events","type":"User","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":2,"created_at":"2013-12-31T04:56:41Z","updated_at":"2013-12-31T08:13:55Z","closed_at":"2013-12-31T08:13:55Z","author_association":"NONE","active_lock_reason":null,"body":"Currently Elasticsearch allows analyzers to be set broadly at the type level or finely at the field level. However, there are scenarios where something in between would be very useful.\n\nFor example, where a nested object actually represents a dynamic string dictionary (i.e. a `Map<String, String>`) who's child field names aren't known up front. Assume also that the default analyzer for the type shouldn't apply to anything in this object field. When new keys are added to the dictionary, and new dynamic mappings appear, it would great to use the analyzer mapped to the parent field before falling back to the type default.\n\nImagine a put mapping request like the following:\n\n> {\n>     \"mytype\": {\n>         \"analyzer\": \"standard\",\n>         \"properties\": {\n>             \"myobjectfield\": {\n>                 \"type\": \"object\", \n>                 **\"analyzer\": \"some_other_analyzer\",**\n>                 \"dynamic\": true\n>             }\n>         }\n>     }\n> }\n\nNow when string fields are dynamically added to the \"myobjectfield\" object field, they will use \"some_other_analyzer\" rather than \"standard\".\n","closed_by":{"login":"benquarmby","id":1434816,"node_id":"MDQ6VXNlcjE0MzQ4MTY=","avatar_url":"https://avatars0.githubusercontent.com/u/1434816?v=4","gravatar_id":"","url":"https://api.github.com/users/benquarmby","html_url":"https://github.com/benquarmby","followers_url":"https://api.github.com/users/benquarmby/followers","following_url":"https://api.github.com/users/benquarmby/following{/other_user}","gists_url":"https://api.github.com/users/benquarmby/gists{/gist_id}","starred_url":"https://api.github.com/users/benquarmby/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/benquarmby/subscriptions","organizations_url":"https://api.github.com/users/benquarmby/orgs","repos_url":"https://api.github.com/users/benquarmby/repos","events_url":"https://api.github.com/users/benquarmby/events{/privacy}","received_events_url":"https://api.github.com/users/benquarmby/received_events","type":"User","site_admin":false},"performed_via_github_app":null}