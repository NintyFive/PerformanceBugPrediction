{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/6316","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/6316/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/6316/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/6316/events","html_url":"https://github.com/elastic/elasticsearch/issues/6316","id":34365445,"node_id":"MDU6SXNzdWUzNDM2NTQ0NQ==","number":6316,"title":"Multiple threads creating and closing connections results in random org.elasticsearch.client.transport.NoNodeAvailableException","user":{"login":"apatrida","id":182340,"node_id":"MDQ6VXNlcjE4MjM0MA==","avatar_url":"https://avatars3.githubusercontent.com/u/182340?v=4","gravatar_id":"","url":"https://api.github.com/users/apatrida","html_url":"https://github.com/apatrida","followers_url":"https://api.github.com/users/apatrida/followers","following_url":"https://api.github.com/users/apatrida/following{/other_user}","gists_url":"https://api.github.com/users/apatrida/gists{/gist_id}","starred_url":"https://api.github.com/users/apatrida/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/apatrida/subscriptions","organizations_url":"https://api.github.com/users/apatrida/orgs","repos_url":"https://api.github.com/users/apatrida/repos","events_url":"https://api.github.com/users/apatrida/events{/privacy}","received_events_url":"https://api.github.com/users/apatrida/received_events","type":"User","site_admin":false},"labels":[{"id":111624690,"node_id":"MDU6TGFiZWwxMTE2MjQ2OTA=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/feedback_needed","name":"feedback_needed","color":"d4c5f9","default":false,"description":null}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":8,"created_at":"2014-05-27T12:04:49Z","updated_at":"2015-01-26T20:49:47Z","closed_at":"2015-01-26T20:49:47Z","author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"I have code that has worked consistently well on 1.0.0.RC1 of ES but dies often on 1.1.1 ... it basically has a thread pool of workers doing long running scan/scroll queries (with \"_shards:N;_local\") and each creates its own TransportClient connection at the start of a run, and closes it at the end.  A finally block guarantees the close is run.  \n\nFirst, after a bunch of connections are used, somewhere along the way a thread picks up new work item and creates a new transport client and uses the client the first time it causes a  org.elasticsearch.client.transport.NoNodeAvailableException when executing the query for the first time.  The cluster health is fine at the time.  No logs, or errors in any cluster node, cluster state shows healthy, no recovery, index is static at the time with no updates.\n\nThe same code worked flawlessly with 1.0.0.RC1 and now fails consistently and quickly, but not repeatable enough to see that it is some specific case in the code, more likely some race condition with the closing of a past connection, opening of new, and the timing of the first query.  Adding pauses seems silly, and 1 second after close and 1 second after open do not resolve it anyway.\n\nSecond issue that is new, is that I now also get Netty errors java.lang.OutOfMemoryError: Direct buffer memory with direct memory set to 1G and all connection open/close protected by try..finally blocks so nothing should be leaking.\n\nIt appears the creation and closing of TransportClients at higher volume does not bode well for ES at the moment.  I create the clients because I am doing large data extracts from different nodes and shards and am keeping nodes that do not need to be involved from participating for each shard, and previously had issues with clients timing out if they were in a pool and unused for a long time.  But regardless of pooling, there shouldn't be a leak or a break (exception) with create/close connections.\n\nI have noticed this newer StackOverFlow issue as well which seems very similar:\nhttp://stackoverflow.com/questions/23739137\n\nAnd before people comment \"use one client and share for all threads\" ... I know that the clients can be used in that way, but I am still worried about this bug and resource leak and this issue is about those, not about designing how this code works.\n","closed_by":{"login":"clintongormley","id":56599,"node_id":"MDQ6VXNlcjU2NTk5","avatar_url":"https://avatars0.githubusercontent.com/u/56599?v=4","gravatar_id":"","url":"https://api.github.com/users/clintongormley","html_url":"https://github.com/clintongormley","followers_url":"https://api.github.com/users/clintongormley/followers","following_url":"https://api.github.com/users/clintongormley/following{/other_user}","gists_url":"https://api.github.com/users/clintongormley/gists{/gist_id}","starred_url":"https://api.github.com/users/clintongormley/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/clintongormley/subscriptions","organizations_url":"https://api.github.com/users/clintongormley/orgs","repos_url":"https://api.github.com/users/clintongormley/repos","events_url":"https://api.github.com/users/clintongormley/events{/privacy}","received_events_url":"https://api.github.com/users/clintongormley/received_events","type":"User","site_admin":false},"performed_via_github_app":null}