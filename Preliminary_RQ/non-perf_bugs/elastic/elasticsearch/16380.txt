{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/16380","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/16380/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/16380/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/16380/events","html_url":"https://github.com/elastic/elasticsearch/issues/16380","id":130759616,"node_id":"MDU6SXNzdWUxMzA3NTk2MTY=","number":16380,"title":"Nested Aggregations - Filtering of child aggs on parent agg's key","user":{"login":"roytmana","id":2524911,"node_id":"MDQ6VXNlcjI1MjQ5MTE=","avatar_url":"https://avatars0.githubusercontent.com/u/2524911?v=4","gravatar_id":"","url":"https://api.github.com/users/roytmana","html_url":"https://github.com/roytmana","followers_url":"https://api.github.com/users/roytmana/followers","following_url":"https://api.github.com/users/roytmana/following{/other_user}","gists_url":"https://api.github.com/users/roytmana/gists{/gist_id}","starred_url":"https://api.github.com/users/roytmana/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/roytmana/subscriptions","organizations_url":"https://api.github.com/users/roytmana/orgs","repos_url":"https://api.github.com/users/roytmana/repos","events_url":"https://api.github.com/users/roytmana/events{/privacy}","received_events_url":"https://api.github.com/users/roytmana/received_events","type":"User","site_admin":false},"labels":[{"id":141145460,"node_id":"MDU6TGFiZWwxNDExNDU0NjA=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/:Search/Mapping","name":":Search/Mapping","color":"0e8a16","default":false,"description":"How fields should be indexed"},{"id":23174,"node_id":"MDU6TGFiZWwyMzE3NA==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/%3Eenhancement","name":">enhancement","color":"4a4ea8","default":false,"description":null},{"id":111416437,"node_id":"MDU6TGFiZWwxMTE0MTY0Mzc=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/discuss","name":"discuss","color":"fbca04","default":false,"description":null}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":4,"created_at":"2016-02-02T17:48:13Z","updated_at":"2019-12-15T23:00:17Z","closed_at":"2018-08-16T20:46:20Z","author_association":"NONE","active_lock_reason":null,"body":"Let me start with an example to explain the issue which is a major pain point for us when using nested aggregations.\n\nImagine having Teams that handle Requests of certain Priority. Each request may have multiple teams assigned to it and each team request assignment has number of hours allocated for this team on this request\n\n``` javascript\nrequest:{\n  priority:1,\n  teams:[\n    {name:'team1', hours:10},\n    {name:'team2', hours:20},\n  ]\n}\n```\n\nI need a report that gives me number of hours by team by priority. Doing nested aggregation on **teams.name** and then reverse nested to group on **priority** and then nested to sum **teams.hours** double-counts hours because second nesting on teams knows nothing about  upstream nesting as it is executed in context of request and as result it will lump hours for each team on request under the top level team aggregation. \n\nPlease do not suggest :-) that I can aggregate on Priority first and then on Teams and then flip/collate my nested result. Yes I can but this example is a small portion of a report full of similar cases not to mention that it would not work in our generic solution where users can pick and choose any group by and metrics at any level of nesting\n\nA **very practical**, generic, concise and easy to use  solution would be to allow aggregating on properties of owner document(s) from a nested aggregation without having to change context back to parent document buy using reverse nested aggregation. In our example as simple as doing terms sub aggregation on \"../priority\" from teams nested document context.\n\nAnother solution would be to support filtering expressions that are based on upstream aggregation values so that i can filter lowest teams nested aggregation calculating hours based on top level team aggregation. it could be useful for many scenarious but for this one it is a bit artificial. I think it would be  a great capability to be able to use parent agg bukets as input for child bucket filters etc \n\nAnother, and in my opinion **pretty powerful** solution would be ability to flatten/de-normalize nested aggregation (like Cartesian join) prior to applying filters/aggregations. This will be much more useful in very many cases than aggregation on nested data as it is available now.\n\nSorry for a rant below please do read it:-)\n\nAs a person who has to deal with lots of nested data and produce complicated analytic on it I can tell you that this is the single most difficult part. After promoting elastic heavily instead of traditional star-schema based data-mart we suffer a lot trying to produce reports on nested data. One of selling point was that we can store complex data in its natural form and filter/search it, report/export it  and also produce analytic from it without creating dozens of fragmented single purpose de-normalized data-marts. As far as searching it works fairly well except for a similar issue of not being able to filter nested data when one of the criteria is on that nested data element and users do not wish to see nested records that do not match the criteria (this would have happened naturally and for free with relational database). With aggregation it is even worse - we cant escape this kind of double counting without all sorts of shenanigans. \nIf only handling of nested fields were richer we could have gotten much further with it. You may say de-normalize all your nested relationships into separate indices. yes it could be done but it defeats the purpose and given lack of joins it will lead to enormous data duplication and won't be a generic solution anyways. I would love if elastic could do de-normalization on the fly on specific nested fields and apply filtering/aggregation logic to the denormalized dataset  \n\nIt (the nested de-normalization) would also be extremely useful for plain search scenario particularly when combined with ability to return selected snippets of both owner and nested objects \n","closed_by":{"login":"jdconrad","id":2126764,"node_id":"MDQ6VXNlcjIxMjY3NjQ=","avatar_url":"https://avatars2.githubusercontent.com/u/2126764?v=4","gravatar_id":"","url":"https://api.github.com/users/jdconrad","html_url":"https://github.com/jdconrad","followers_url":"https://api.github.com/users/jdconrad/followers","following_url":"https://api.github.com/users/jdconrad/following{/other_user}","gists_url":"https://api.github.com/users/jdconrad/gists{/gist_id}","starred_url":"https://api.github.com/users/jdconrad/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jdconrad/subscriptions","organizations_url":"https://api.github.com/users/jdconrad/orgs","repos_url":"https://api.github.com/users/jdconrad/repos","events_url":"https://api.github.com/users/jdconrad/events{/privacy}","received_events_url":"https://api.github.com/users/jdconrad/received_events","type":"User","site_admin":false},"performed_via_github_app":null}