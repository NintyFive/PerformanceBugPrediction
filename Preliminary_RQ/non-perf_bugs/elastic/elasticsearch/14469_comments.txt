[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/153302610","html_url":"https://github.com/elastic/elasticsearch/issues/14469#issuecomment-153302610","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/14469","id":153302610,"node_id":"MDEyOklzc3VlQ29tbWVudDE1MzMwMjYxMA==","user":{"login":"jpountz","id":299848,"node_id":"MDQ6VXNlcjI5OTg0OA==","avatar_url":"https://avatars2.githubusercontent.com/u/299848?v=4","gravatar_id":"","url":"https://api.github.com/users/jpountz","html_url":"https://github.com/jpountz","followers_url":"https://api.github.com/users/jpountz/followers","following_url":"https://api.github.com/users/jpountz/following{/other_user}","gists_url":"https://api.github.com/users/jpountz/gists{/gist_id}","starred_url":"https://api.github.com/users/jpountz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jpountz/subscriptions","organizations_url":"https://api.github.com/users/jpountz/orgs","repos_url":"https://api.github.com/users/jpountz/repos","events_url":"https://api.github.com/users/jpountz/events{/privacy}","received_events_url":"https://api.github.com/users/jpountz/received_events","type":"User","site_admin":false},"created_at":"2015-11-03T09:56:43Z","updated_at":"2015-11-03T09:56:43Z","author_association":"CONTRIBUTOR","body":"I'm curious what your use-case is, for now the only use-case I knew about for doc values on binary fields was an image plugin for elasticsearch (#5669) and doc values were consumed directly through the plugin, bypassing the scripting layer.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/153315954","html_url":"https://github.com/elastic/elasticsearch/issues/14469#issuecomment-153315954","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/14469","id":153315954,"node_id":"MDEyOklzc3VlQ29tbWVudDE1MzMxNTk1NA==","user":{"login":"jrots","id":195346,"node_id":"MDQ6VXNlcjE5NTM0Ng==","avatar_url":"https://avatars1.githubusercontent.com/u/195346?v=4","gravatar_id":"","url":"https://api.github.com/users/jrots","html_url":"https://github.com/jrots","followers_url":"https://api.github.com/users/jrots/followers","following_url":"https://api.github.com/users/jrots/following{/other_user}","gists_url":"https://api.github.com/users/jrots/gists{/gist_id}","starred_url":"https://api.github.com/users/jrots/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jrots/subscriptions","organizations_url":"https://api.github.com/users/jrots/orgs","repos_url":"https://api.github.com/users/jrots/repos","events_url":"https://api.github.com/users/jrots/events{/privacy}","received_events_url":"https://api.github.com/users/jrots/received_events","type":"User","site_admin":false},"created_at":"2015-11-03T11:06:18Z","updated_at":"2015-11-03T11:11:56Z","author_association":"NONE","body":"Well I have an index that contains +/- 100M documents, the data that is indexed are \"persons\" and a typically search is :\nfind users that are around me, but the sorting needs to be done dynamically: \nEach \"person\" has answered x questions with some answers. \nI need calculate a \"matchscore\" on the fly for the persons I find, basically the overlap of my questions with the persons I find. (And also some additional checks on the answers of those questions if they are the same). The \"matchscore\" will give back a percentage between 0 and 100. \nThere are about 1 to 1800 questions that can be answered by a person, \nI store the question data packed in 64 bit longs : so I only have to do a bitwise operation to find the \"matching\" questions.\nThis goes pretty fast in my benchmarks.\nmy questionids from 0 to 64 :               100000000000000000000000000000000000010001000000010000000000001 &\nthe other person questionids from 0 to 64 : 100000000000000000000000000000000000000001000000010000000000001\nresult will only contain the matching \"questionids\"\n\nAn array of all questions I have answered will look like (encoded in 64 bit ints: )\n\n``` json\n[-8989044006797179904,5629656300523520,0,2323857442082914304,36028797287432192,153122456050075656,8388640,144115188075855872,158329681740288,1099511627776,274877906944,34632368128,8796093022208,8623497224,3467807172325277696,0,274945015808,2305843009213693984,8192,576460752303423488,144116287587549184,0,128,4096,2147483648,0,36028797018964992,0,2161728080043835392,536870912\n]\n```\n\nAnd for an other person like:\n\n``` json\n[-8989040706113233866,5629656858499072,3499296910466940960,2323857992107163712,45036563478904864,1306043995025050154,2199031669792,180143985099014144,562949960761856,36047626155590656,274877906952,34632384512,1225551944202847296,4611967502027857928,3756319573209513984,1477180677777523712,9075601440770,2377900603251622304,134225920,612489549322420544,2449959296801276032,2305843009213693952,128,100732928,576601492006502400,22517998271135872,36028797018963968,288230376151711744,6773554836496449536,3149824\n]\n```\n\nI first stored the data as a long array in elastic, but you cannot rely on the order as doc_values will be ordered low to high, \nSo I created a bytearray that I base64 encode and such store in ES, afterwards decode \n\n``` java\n        byte[] decodeString  = Base64.getDecoder().decode(encodedString);\n        ByteBuffer byteBuf = ByteBuffer.wrap( decodeString );\n        byteBuf.order( ByteOrder.BIG_ENDIAN );\n        LongBuffer longBuf = byteBuf.asLongBuffer();\n        long[] questions = new long[numberOfQuestions];\n        longBuf.get(questions);\n```\n\nI found a workaround for now, to store it as \"text\" with: \n      \"qa_data\":{\"type\":\"string\", \"doc_values\": true, \"index\": \"no\", \"store\" : \"no\"}\nand not binary .. seems to work for now.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/153688849","html_url":"https://github.com/elastic/elasticsearch/issues/14469#issuecomment-153688849","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/14469","id":153688849,"node_id":"MDEyOklzc3VlQ29tbWVudDE1MzY4ODg0OQ==","user":{"login":"jpountz","id":299848,"node_id":"MDQ6VXNlcjI5OTg0OA==","avatar_url":"https://avatars2.githubusercontent.com/u/299848?v=4","gravatar_id":"","url":"https://api.github.com/users/jpountz","html_url":"https://github.com/jpountz","followers_url":"https://api.github.com/users/jpountz/followers","following_url":"https://api.github.com/users/jpountz/following{/other_user}","gists_url":"https://api.github.com/users/jpountz/gists{/gist_id}","starred_url":"https://api.github.com/users/jpountz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jpountz/subscriptions","organizations_url":"https://api.github.com/users/jpountz/orgs","repos_url":"https://api.github.com/users/jpountz/repos","events_url":"https://api.github.com/users/jpountz/events{/privacy}","received_events_url":"https://api.github.com/users/jpountz/received_events","type":"User","site_admin":false},"created_at":"2015-11-04T11:14:40Z","updated_at":"2015-11-04T11:14:40Z","author_association":"CONTRIBUTOR","body":"Thanks for explaining the use-case.\n\nUnrelated to binary doc values but I'm wondering that storing the questions ids directly could be a better option both in terms of storage and runtime. You could take ids from the shortest array and then use galloping search to find common ids in the other array?\n\nOtherwise I agree that we should either document the limitations with doc values on binary fields or add support so that you can at least use them in scripts.\n","performed_via_github_app":null}]