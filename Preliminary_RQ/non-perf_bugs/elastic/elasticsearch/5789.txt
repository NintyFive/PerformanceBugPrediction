{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/5789","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/5789/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/5789/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/5789/events","html_url":"https://github.com/elastic/elasticsearch/issues/5789","id":31409027,"node_id":"MDU6SXNzdWUzMTQwOTAyNw==","number":5789,"title":"Common fields aggregation / bucketing","user":{"login":"ncolomer","id":941891,"node_id":"MDQ6VXNlcjk0MTg5MQ==","avatar_url":"https://avatars0.githubusercontent.com/u/941891?v=4","gravatar_id":"","url":"https://api.github.com/users/ncolomer","html_url":"https://github.com/ncolomer","followers_url":"https://api.github.com/users/ncolomer/followers","following_url":"https://api.github.com/users/ncolomer/following{/other_user}","gists_url":"https://api.github.com/users/ncolomer/gists{/gist_id}","starred_url":"https://api.github.com/users/ncolomer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ncolomer/subscriptions","organizations_url":"https://api.github.com/users/ncolomer/orgs","repos_url":"https://api.github.com/users/ncolomer/repos","events_url":"https://api.github.com/users/ncolomer/events{/privacy}","received_events_url":"https://api.github.com/users/ncolomer/received_events","type":"User","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":{"login":"jpountz","id":299848,"node_id":"MDQ6VXNlcjI5OTg0OA==","avatar_url":"https://avatars2.githubusercontent.com/u/299848?v=4","gravatar_id":"","url":"https://api.github.com/users/jpountz","html_url":"https://github.com/jpountz","followers_url":"https://api.github.com/users/jpountz/followers","following_url":"https://api.github.com/users/jpountz/following{/other_user}","gists_url":"https://api.github.com/users/jpountz/gists{/gist_id}","starred_url":"https://api.github.com/users/jpountz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jpountz/subscriptions","organizations_url":"https://api.github.com/users/jpountz/orgs","repos_url":"https://api.github.com/users/jpountz/repos","events_url":"https://api.github.com/users/jpountz/events{/privacy}","received_events_url":"https://api.github.com/users/jpountz/received_events","type":"User","site_admin":false},"assignees":[{"login":"jpountz","id":299848,"node_id":"MDQ6VXNlcjI5OTg0OA==","avatar_url":"https://avatars2.githubusercontent.com/u/299848?v=4","gravatar_id":"","url":"https://api.github.com/users/jpountz","html_url":"https://github.com/jpountz","followers_url":"https://api.github.com/users/jpountz/followers","following_url":"https://api.github.com/users/jpountz/following{/other_user}","gists_url":"https://api.github.com/users/jpountz/gists{/gist_id}","starred_url":"https://api.github.com/users/jpountz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jpountz/subscriptions","organizations_url":"https://api.github.com/users/jpountz/orgs","repos_url":"https://api.github.com/users/jpountz/repos","events_url":"https://api.github.com/users/jpountz/events{/privacy}","received_events_url":"https://api.github.com/users/jpountz/received_events","type":"User","site_admin":false}],"milestone":null,"comments":14,"created_at":"2014-04-13T15:56:09Z","updated_at":"2015-10-15T04:59:30Z","closed_at":"2014-10-17T06:53:30Z","author_association":"NONE","active_lock_reason":null,"body":"Aggregations are great! It would be even more cool to have an aggregation that buckets by field occurrence (based on field name) from a given path, allowing us to apply sub-aggs on these _dynamically found_ fields.\n\nSay we have the following product index:\n\n```\ncurl -XPOST 'localhost:9200/store/product/1' -d '{\"name\":\"Galaxy S4\",\"manufacturer\":\"Samsung\",\"type\":\"phone\",\"specs\":{\"os\":\"Android\",\"core\":4,\"ram\":\"2GB\"}}'\ncurl -XPOST 'localhost:9200/store/product/2' -d '{\"name\":\"iPhone 5\",\"manufacturer\":\"Apple\",\"type\":\"phone\",\"specs\":{\"os\":\"iOS\",\"core\":2,\"ram\":\"1GB\"}}'\ncurl -XPOST 'localhost:9200/store/product/3' -d '{\"name\":\"WF210ANW/XAA\",\"manufacturer\":\"Samsung\",\"type\":\"washing-machine\",\"specs\":{\"capacity\":3.5,\"loadType\":\"front\",\"presets\":6}}'\ncurl -XPOST 'localhost:9200/store/product/4' -d '{\"name\":\"WT4801CW\",\"manufacturer\":\"LG\",\"type\":\"washing-machine\",\"specs\":{\"capacity\":3.7,\"loadType\":\"top\",\"presets\":9}}'\n```\n\nHere we have two different nature of products (phone and washing machine), they have consequently different features (the K/V pairs in the `specs` field).\nIf such an aggregation was available, we could apply it to retrieve the top _most frequent_ fields for a resulting data set and compute any kind of sub-agg over them. Combined with well-minded query/filter this could end to a nice magic agg effect :)\n\nI tried to build my own aggs tree using [terms aggregation](http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/search-aggregations-bucket-terms-aggregation.html), but I did not found any way to access the parent bucket key from a child aggregation. I only succeed to achieve the first part, ie. find the top-n field names sorted by occurence count. Anyway this seems not viable as it looks like a 2-step process: doing it this way, we need to evaluate the number of occurrences of each fields first and then compute sub-aggs on the selected ones.\n\n```\n... query and filters ...\n\"aggs\" : {\n  \"dynamic_agg_step1\": {\n    \"terms\": { \n      \"script\": \"_source.fields.keySet()\",\n      \"exclude\": \"type|subtype\"\n    }\n    \"aggs\": {\n      \"dynamic_agg_step2\": {\n        \"terms\": { \n          \"script\": \"_source.fields.get(_myMagicBucketKey?_)\"\n        }\n      }\n    }\n  }\n}\n```\n\nA simple (and probably naive) approach would be to compute declared sub-aggs on all fields seen from a given path (here the `specs` path) while keeping track of field occurrences and finally only retain agg trees from the _most frequent_ top-n fields. This represents extra workload and more memory to hold aggs for all fields but if the field cardinality remains reasonable, it mights worth it. We could also imagine to exclude some fields that we know we're not interested in (as we can currently [do](http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/search-aggregations-bucket-terms-aggregation.html#_filtering_values) with the terms agg). Obviously, the considered path necessarily have to point to a JSON hash to run correctly.\n\nTell me if that makes sense to you?\nMaybe I missed something or the feature already exists, and if so please tell me :)\n\nNicolas\n","closed_by":{"login":"clintongormley","id":56599,"node_id":"MDQ6VXNlcjU2NTk5","avatar_url":"https://avatars0.githubusercontent.com/u/56599?v=4","gravatar_id":"","url":"https://api.github.com/users/clintongormley","html_url":"https://github.com/clintongormley","followers_url":"https://api.github.com/users/clintongormley/followers","following_url":"https://api.github.com/users/clintongormley/following{/other_user}","gists_url":"https://api.github.com/users/clintongormley/gists{/gist_id}","starred_url":"https://api.github.com/users/clintongormley/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/clintongormley/subscriptions","organizations_url":"https://api.github.com/users/clintongormley/orgs","repos_url":"https://api.github.com/users/clintongormley/repos","events_url":"https://api.github.com/users/clintongormley/events{/privacy}","received_events_url":"https://api.github.com/users/clintongormley/received_events","type":"User","site_admin":false},"performed_via_github_app":null}