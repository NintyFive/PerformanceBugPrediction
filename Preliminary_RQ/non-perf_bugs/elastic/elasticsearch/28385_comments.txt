[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/363886968","html_url":"https://github.com/elastic/elasticsearch/issues/28385#issuecomment-363886968","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/28385","id":363886968,"node_id":"MDEyOklzc3VlQ29tbWVudDM2Mzg4Njk2OA==","user":{"login":"polyfractal","id":1224228,"node_id":"MDQ6VXNlcjEyMjQyMjg=","avatar_url":"https://avatars1.githubusercontent.com/u/1224228?v=4","gravatar_id":"","url":"https://api.github.com/users/polyfractal","html_url":"https://github.com/polyfractal","followers_url":"https://api.github.com/users/polyfractal/followers","following_url":"https://api.github.com/users/polyfractal/following{/other_user}","gists_url":"https://api.github.com/users/polyfractal/gists{/gist_id}","starred_url":"https://api.github.com/users/polyfractal/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/polyfractal/subscriptions","organizations_url":"https://api.github.com/users/polyfractal/orgs","repos_url":"https://api.github.com/users/polyfractal/repos","events_url":"https://api.github.com/users/polyfractal/events{/privacy}","received_events_url":"https://api.github.com/users/polyfractal/received_events","type":"User","site_admin":false},"created_at":"2018-02-07T19:42:39Z","updated_at":"2018-02-07T19:42:39Z","author_association":"MEMBER","body":"Urgh, this is indeed confusing.  I'm not sure if there's a reason for this behavior, perhaps it just needs better documentation. @jimczi or @dakrone may know more.\r\n\r\nThe difference is caused by the interaction of Lucene's query parser and Elasticsearch's field expansion mechanism... and the order the ANDs are applied in.  I've rewritten your searches into query_strings for better readability and ran them through the Validate API so we can see how they translate into lucene queries.\r\n\r\nFirst, if we look at the query against a single field, they yield the same thing:\r\n\r\n```js\r\nGET /twitter/_validate/query?explain\r\n{\r\n  \"query\": {\r\n    \"query_string\": {\r\n      \"default_field\": \"content\", \r\n      \"query\": \"doe AND green AND tech\"\r\n    }\r\n  }\r\n}\r\n\r\nGET /twitter/_validate/query?explain\r\n{\r\n  \"query\": {\r\n    \"query_string\": {\r\n      \"default_field\": \"content\", \r\n      \"default_operator\": \"AND\", \r\n      \"query\": \"doe green tech\"\r\n    }\r\n  }\r\n}\r\n```\r\n```\r\n+content:doe +content:green +content:tech\r\n```\r\n\r\nThe issue arises when we need to start search across multiple fields.  Query string attempts to expand the query to all matching fields if there isn't a default field, but this expansion causes slightly different behavior depending on how you structure the query.\r\n\r\nFirst, if we try with ANDs directly in the query:\r\n```js\r\nGET /twitter/_validate/query?explain\r\n{\r\n  \"query\": {\r\n    \"query_string\": {\r\n      \"query\": \"doe AND green AND tech\"\r\n    }\r\n  }\r\n}\r\n```\r\n```\r\n+(content.keyword:doe | name:doe | name.keyword:doe | categories:doe | content:doe | categories.keyword:doe) \r\n+(content.keyword:green | name:green | name.keyword:green | categories:green | content:green | categories.keyword:green) \r\n+(content.keyword:tech | name:tech | name.keyword:tech | categories:tech | content:tech | categories.keyword:tech)\r\n```\r\nWhich translates into three mandatory clauses, where each clause is looking for the term in any of the fields.  Essentially, the query is parsed, finds three mandatory terms, then expands to all the fields.  E.g. we must have a document where `doe` is in any field, `green` is in any field and `tech` is in any field.\r\n\r\nIn contrast, when we use the `default_operator`:\r\n```js\r\nGET /twitter/_validate/query?explain\r\n{\r\n  \"query\": {\r\n    \"query_string\": {\r\n      \"default_operator\": \"AND\", \r\n      \"query\": \"doe green tech\"\r\n    }\r\n  }\r\n}\r\n```\r\n```\r\n(content.keyword:doe green tech | (+name:doe +name:green +name:tech) | name.keyword:doe green tech \r\n| (+categories:doe +categories:green +categories:tech) \r\n| (+content:doe +content:green +content:tech) | categories.keyword:doe green tech)\r\n```\r\nThis query also has three optional clauses filled with mandatory terms.  It says we must find a document that has the terms `doe, green, tech` in one of `name`, `categories`, `content`.  The query is parsed, finds three optional terms, expands to all fields, THEN make it so at least one of the sets matches.  Which is why you end up with needing to match all in one field\r\n\r\nAll that said, if you are searching multiple fields I would just use the [Multi-Match Query](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-multi-match-query.html) directly, since it gives much better control with less surprising semantics.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/375088041","html_url":"https://github.com/elastic/elasticsearch/issues/28385#issuecomment-375088041","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/28385","id":375088041,"node_id":"MDEyOklzc3VlQ29tbWVudDM3NTA4ODA0MQ==","user":{"login":"mayya-sharipova","id":5738841,"node_id":"MDQ6VXNlcjU3Mzg4NDE=","avatar_url":"https://avatars1.githubusercontent.com/u/5738841?v=4","gravatar_id":"","url":"https://api.github.com/users/mayya-sharipova","html_url":"https://github.com/mayya-sharipova","followers_url":"https://api.github.com/users/mayya-sharipova/followers","following_url":"https://api.github.com/users/mayya-sharipova/following{/other_user}","gists_url":"https://api.github.com/users/mayya-sharipova/gists{/gist_id}","starred_url":"https://api.github.com/users/mayya-sharipova/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mayya-sharipova/subscriptions","organizations_url":"https://api.github.com/users/mayya-sharipova/orgs","repos_url":"https://api.github.com/users/mayya-sharipova/repos","events_url":"https://api.github.com/users/mayya-sharipova/events{/privacy}","received_events_url":"https://api.github.com/users/mayya-sharipova/received_events","type":"User","site_admin":false},"created_at":"2018-03-21T20:40:11Z","updated_at":"2018-03-21T20:40:11Z","author_association":"CONTRIBUTOR","body":"cc @elastic/es-search-aggs\r\n\r\nDo we think that this query is  **INCORRECTLY** rewritten:\r\n\r\n```HTTP\r\nGET /twitter/_validate/query?explain\r\n{\r\n  \"query\": {\r\n    \"query_string\": {\r\n      \"query\": \"doe AND green AND tech\"\r\n    }\r\n  }\r\n}\r\n```\r\ninto \r\n```\r\n+(content.keyword:doe | name:doe | name.keyword:doe | categories:doe | content:doe | categories.keyword:doe) \r\n+(content.keyword:green | name:green | name.keyword:green | categories:green | content:green | categories.keyword:green) \r\n+(content.keyword:tech | name:tech | name.keyword:tech | categories:tech | content:tech | categories.keyword:tech)\r\n```\r\n\r\nThis query instead of translating to find me a document where:\r\n `doe` is in any field AND `green` is in any field AND  `tech` is in any field, \r\n\r\nshould be translated into find me a document where:\r\n`doe` AND `green` and `tech` occur together in a single field, which could be any field of the document.\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/375096088","html_url":"https://github.com/elastic/elasticsearch/issues/28385#issuecomment-375096088","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/28385","id":375096088,"node_id":"MDEyOklzc3VlQ29tbWVudDM3NTA5NjA4OA==","user":{"login":"jimczi","id":15977469,"node_id":"MDQ6VXNlcjE1OTc3NDY5","avatar_url":"https://avatars0.githubusercontent.com/u/15977469?v=4","gravatar_id":"","url":"https://api.github.com/users/jimczi","html_url":"https://github.com/jimczi","followers_url":"https://api.github.com/users/jimczi/followers","following_url":"https://api.github.com/users/jimczi/following{/other_user}","gists_url":"https://api.github.com/users/jimczi/gists{/gist_id}","starred_url":"https://api.github.com/users/jimczi/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jimczi/subscriptions","organizations_url":"https://api.github.com/users/jimczi/orgs","repos_url":"https://api.github.com/users/jimczi/repos","events_url":"https://api.github.com/users/jimczi/events{/privacy}","received_events_url":"https://api.github.com/users/jimczi/received_events","type":"User","site_admin":false},"created_at":"2018-03-21T21:08:05Z","updated_at":"2018-03-21T21:08:16Z","author_association":"MEMBER","body":"@mayya-sharipova this is the expected behavior in any version of es. The `query_string` parses the input around operators and analyze each piece of text independently so `doe`, `green` and `tech`are parsed separately and produce one query each which is a max disjunction over the fields that the query targets (in this case all fields since `fields` is empty). What changed in 6.x is that if you omit the operator and do `do green tech` then we will build the query for each field using this single piece of text so you'll end up with a query that requires all terms to match in a single field. This change was made to allow analyzers to see more than one term in a single analysis, previously spaces were considered operators and that breaks any multi term analysis (shingles, multi-words synonyms, ...). \r\nSo in 6.x if you search in a `query_string` for `(new york) AND paris`, `new york` can be pass entirely to each analyzer targeted by the query. This also means that a `multi_match` query produces the same query than a `query_string` query without operator. For each piece of text (around operators) you can also choose whether you want the `cross_fields`, `best_fields` or `most_fields` mode like you would do for the entire query in a `multi_match`. \r\nI am going to close this issue because the behavior is expected and we changed the documentation of the `query_string` to emphasize this difference in 6.x:\r\nhttps://www.elastic.co/guide/en/elasticsearch/reference/6.x/query-dsl-query-string-query.html","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/375102445","html_url":"https://github.com/elastic/elasticsearch/issues/28385#issuecomment-375102445","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/28385","id":375102445,"node_id":"MDEyOklzc3VlQ29tbWVudDM3NTEwMjQ0NQ==","user":{"login":"mayya-sharipova","id":5738841,"node_id":"MDQ6VXNlcjU3Mzg4NDE=","avatar_url":"https://avatars1.githubusercontent.com/u/5738841?v=4","gravatar_id":"","url":"https://api.github.com/users/mayya-sharipova","html_url":"https://github.com/mayya-sharipova","followers_url":"https://api.github.com/users/mayya-sharipova/followers","following_url":"https://api.github.com/users/mayya-sharipova/following{/other_user}","gists_url":"https://api.github.com/users/mayya-sharipova/gists{/gist_id}","starred_url":"https://api.github.com/users/mayya-sharipova/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mayya-sharipova/subscriptions","organizations_url":"https://api.github.com/users/mayya-sharipova/orgs","repos_url":"https://api.github.com/users/mayya-sharipova/repos","events_url":"https://api.github.com/users/mayya-sharipova/events{/privacy}","received_events_url":"https://api.github.com/users/mayya-sharipova/received_events","type":"User","site_admin":false},"created_at":"2018-03-21T21:30:17Z","updated_at":"2018-03-21T21:30:17Z","author_association":"CONTRIBUTOR","body":"@jimczi thanks so much for elaborating on this","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/617990135","html_url":"https://github.com/elastic/elasticsearch/issues/28385#issuecomment-617990135","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/28385","id":617990135,"node_id":"MDEyOklzc3VlQ29tbWVudDYxNzk5MDEzNQ==","user":{"login":"hitendrapratap","id":400545,"node_id":"MDQ6VXNlcjQwMDU0NQ==","avatar_url":"https://avatars0.githubusercontent.com/u/400545?v=4","gravatar_id":"","url":"https://api.github.com/users/hitendrapratap","html_url":"https://github.com/hitendrapratap","followers_url":"https://api.github.com/users/hitendrapratap/followers","following_url":"https://api.github.com/users/hitendrapratap/following{/other_user}","gists_url":"https://api.github.com/users/hitendrapratap/gists{/gist_id}","starred_url":"https://api.github.com/users/hitendrapratap/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hitendrapratap/subscriptions","organizations_url":"https://api.github.com/users/hitendrapratap/orgs","repos_url":"https://api.github.com/users/hitendrapratap/repos","events_url":"https://api.github.com/users/hitendrapratap/events{/privacy}","received_events_url":"https://api.github.com/users/hitendrapratap/received_events","type":"User","site_admin":false},"created_at":"2020-04-22T19:36:32Z","updated_at":"2020-04-22T19:49:32Z","author_association":"NONE","body":"@jimczi We have use case where user could enter query with multiple terms without operators, with operators and advanced search like wildcard, parentheses and quotes. Is it possible to have 1 query which could all above use case?\r\n\r\n@huangenyan @mayya-sharipova What solution you guys implemented? I was think to explicitly _replace space with AND operator_ but that might work only if user has not entered any boolean operator in the query. Any suggestions?","performed_via_github_app":null}]