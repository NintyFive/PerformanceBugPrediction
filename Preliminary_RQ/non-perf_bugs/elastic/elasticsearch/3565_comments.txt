[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/23160810","html_url":"https://github.com/elastic/elasticsearch/issues/3565#issuecomment-23160810","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/3565","id":23160810,"node_id":"MDEyOklzc3VlQ29tbWVudDIzMTYwODEw","user":{"login":"s1monw","id":973334,"node_id":"MDQ6VXNlcjk3MzMzNA==","avatar_url":"https://avatars0.githubusercontent.com/u/973334?v=4","gravatar_id":"","url":"https://api.github.com/users/s1monw","html_url":"https://github.com/s1monw","followers_url":"https://api.github.com/users/s1monw/followers","following_url":"https://api.github.com/users/s1monw/following{/other_user}","gists_url":"https://api.github.com/users/s1monw/gists{/gist_id}","starred_url":"https://api.github.com/users/s1monw/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/s1monw/subscriptions","organizations_url":"https://api.github.com/users/s1monw/orgs","repos_url":"https://api.github.com/users/s1monw/repos","events_url":"https://api.github.com/users/s1monw/events{/privacy}","received_events_url":"https://api.github.com/users/s1monw/received_events","type":"User","site_admin":false},"created_at":"2013-08-23T12:36:57Z","updated_at":"2013-08-23T12:36:57Z","author_association":"CONTRIBUTOR","body":"Anne, thanks for opening this issue. First of all I think I need to elaborate on how the actual suggestions work vs. a fulltext search. In a fulltext search you basically have the following steps:\n1. tokenize\n2. build a query (in your example \"state\" and \"un*\")\n3. rewrite the query (in your case must:(state), should(\"unfold\", \"united\", \"unified\", \"unreal\", \"undefined\", \"under\", ...) )\n4. run the query and fined the union\n5. return the result (stored fields)\n\nin a suggestion you do things slighlty different\n1. tokenize\n2. build all possible paths through the tokenized phrase (\"state un\" in your case)\n3. check if this is a prefix in the suggester\n4. return the payload and the output form (this is important if you have different output forms than input forms like in asian languages or in certain domains)\n\nwhen you build you datastructure you can use different tokenstreams like stopword tokensfiler to make \"state of the union\" work. If you use a naive stopword filter like on fulltext search you can easily bring in a bad user experience like somebody types `state o` and you return `state of the union` but once somebody types the next char you get nothing since you `of` is a stopword. So this already requires specialized token streams for suggest vs. search.\n\nnow let me go further and tell you what the most important property of suggestions is... `speed`!! You have 200ms at most! from the keystroke until the suggestion needs to be rendered! That means including latency from the client (that is even more important if you are on mobil devices), all the processing in your infra etc. \n\nOk seems doable but on a reasonable index a prefix query that is completely unbounded essentially is translated into a boolean query for all the expansions.... lets think of the `state un` case again or better `state u` were we run a prefix query for `u` ok that seems like fun.... and here our 200ms are gone already without latency taken into account. Now you can use edgeNGrams etc. but then you still need to score and load stored fields etc. and it requires certain configuration. \nAnyway.... it seems like there is a chance that we can make this work on an ordinary index, what could break it? I think what most users don't think about is that their infrastructure they run this on is build for N Queries Per Second but once you add suggest to it you suddenly get hit by `N + N * AverageQueryLength` and if you do that off a normal index even a single disk access can kill your entire user experience. With something like a pre-build dedicated in-memory structure you can easily survive this and then your suggestion / completion is actually useful.\n\nif you want to make infix suggestions work, we are working on a suggest implementation that does that but it has several implications as well since it uses index sorting and has weight notions etc. \n\nAside of all the speed stuff, the biggest problem with running something on top of an ordinary index is that you don't have any notion of weight when you look at a term `unfolded` is as good as `unreal` or `unified` (note _frequency is not a good indicator!_) this means you literally need to look at all of them in all your segments... \n\n> By deferring the definition of the atoms to match against to the existing, flexible analyzers, this gives this much more control. We could even add fuzziness or stemming to the match targets...\n\nyou can do that with the `completion suggester` already! you can use stemmers and return the unstemmed version without loading stored fields. You can also use fuzzy matching (there is a nuts fast fuzzy prefix suggester already pushed to `0.90.4`  you have all the flexibility any other analyzer would give you. \n\n> It would be nice if the suggester could then also boost the \"union\" completion because there is a colocated \"state\" match, but that is left as an exercise for the ElasticSearch gurus ;-)\n\nI really appreciate that you left the hard part to us :) ...nevermind I can see that this sounds like the most likely thing to do but it's often in practice not feasible. if you have a small corpus this might be the way to go but in the ES case it's unlikely that your corpus is very small.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/23161299","html_url":"https://github.com/elastic/elasticsearch/issues/3565#issuecomment-23161299","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/3565","id":23161299,"node_id":"MDEyOklzc3VlQ29tbWVudDIzMTYxMjk5","user":{"login":"anneveling","id":223707,"node_id":"MDQ6VXNlcjIyMzcwNw==","avatar_url":"https://avatars1.githubusercontent.com/u/223707?v=4","gravatar_id":"","url":"https://api.github.com/users/anneveling","html_url":"https://github.com/anneveling","followers_url":"https://api.github.com/users/anneveling/followers","following_url":"https://api.github.com/users/anneveling/following{/other_user}","gists_url":"https://api.github.com/users/anneveling/gists{/gist_id}","starred_url":"https://api.github.com/users/anneveling/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/anneveling/subscriptions","organizations_url":"https://api.github.com/users/anneveling/orgs","repos_url":"https://api.github.com/users/anneveling/repos","events_url":"https://api.github.com/users/anneveling/events{/privacy}","received_events_url":"https://api.github.com/users/anneveling/received_events","type":"User","site_admin":false},"created_at":"2013-08-23T12:46:36Z","updated_at":"2013-08-23T12:46:36Z","author_association":"NONE","body":"Sure, I understand (on the high level) what the new suggester does and how it is different from search.\n\nIn my example \"state un\" would match on \"union\" even without a stopword filter for the \"of the\" in \"State of the Union\", that was my whole point.\n\nSure, it is a challenge. Sure, it needs to be fast. But that's just saying: yes this would be nice, but we haven't found a way to make it lightning-fast like we require all ES functions to work. That all the implementations we can think of are not fast enough, does not mean it's not possible by doing something smart.\n\nMy main point is, that the suggester (old and new) does not work for multiword suggestions, only like a standard prefix query. And all my real life use cases have always requested to work on multiple words separately as well. I have done some work in query analyzers to make that work, and was hoping that ES would start to come out of the box with a similar solution to work for autocompletion of words in a field that usually contains entire sentences (like a title), not just for controlled-vocabulary fields.\n\nAnd I know the best way to do this would be to implement this myself and create a pull request. Was just wondering whether you would feel a suggester that works as suggested [sic] would be valuable if it would be fast enough\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/23161995","html_url":"https://github.com/elastic/elasticsearch/issues/3565#issuecomment-23161995","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/3565","id":23161995,"node_id":"MDEyOklzc3VlQ29tbWVudDIzMTYxOTk1","user":{"login":"s1monw","id":973334,"node_id":"MDQ6VXNlcjk3MzMzNA==","avatar_url":"https://avatars0.githubusercontent.com/u/973334?v=4","gravatar_id":"","url":"https://api.github.com/users/s1monw","html_url":"https://github.com/s1monw","followers_url":"https://api.github.com/users/s1monw/followers","following_url":"https://api.github.com/users/s1monw/following{/other_user}","gists_url":"https://api.github.com/users/s1monw/gists{/gist_id}","starred_url":"https://api.github.com/users/s1monw/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/s1monw/subscriptions","organizations_url":"https://api.github.com/users/s1monw/orgs","repos_url":"https://api.github.com/users/s1monw/repos","events_url":"https://api.github.com/users/s1monw/events{/privacy}","received_events_url":"https://api.github.com/users/s1monw/received_events","type":"User","site_admin":false},"created_at":"2013-08-23T12:59:26Z","updated_at":"2013-08-23T12:59:26Z","author_association":"CONTRIBUTOR","body":"> In my example \"state un\" would match on \"union\" even without a stopword filter for the \"of the\" in \"State of the Union\", that was my whole point.\n> I can see your point - I just want to manage expectations here. This suggest stuff has many aspects and stopwords play an even greater role here. What do you do if somebody types a stopword? Do you scarify 1. performance and 2.  relevance? It's very hard though.\n> \n> And I know the best way to do this would be to implement this myself and create a pull request. Was just wondering whether you would feel a suggester that works as suggested [sic] would be valuable if it would be fast enough\n\nsure go ahead I am already looking forward to review it.\n\n> My main point is, that the suggester (old and new) does not work for multiword suggestions, only like a standard prefix query. \n\nactually I don't think this is near to the truth. This is much more flexible than a prefix query, it has weighting, it's blazing fast, it has analyzer support and it works perfectly for titles. \n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/48715825","html_url":"https://github.com/elastic/elasticsearch/issues/3565#issuecomment-48715825","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/3565","id":48715825,"node_id":"MDEyOklzc3VlQ29tbWVudDQ4NzE1ODI1","user":{"login":"clintongormley","id":56599,"node_id":"MDQ6VXNlcjU2NTk5","avatar_url":"https://avatars0.githubusercontent.com/u/56599?v=4","gravatar_id":"","url":"https://api.github.com/users/clintongormley","html_url":"https://github.com/clintongormley","followers_url":"https://api.github.com/users/clintongormley/followers","following_url":"https://api.github.com/users/clintongormley/following{/other_user}","gists_url":"https://api.github.com/users/clintongormley/gists{/gist_id}","starred_url":"https://api.github.com/users/clintongormley/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/clintongormley/subscriptions","organizations_url":"https://api.github.com/users/clintongormley/orgs","repos_url":"https://api.github.com/users/clintongormley/repos","events_url":"https://api.github.com/users/clintongormley/events{/privacy}","received_events_url":"https://api.github.com/users/clintongormley/received_events","type":"User","site_admin":false},"created_at":"2014-07-11T10:28:28Z","updated_at":"2014-07-11T10:28:28Z","author_association":"CONTRIBUTOR","body":"@areek Implementing the AnalyzingInfixSuggester could be the way to go here, although it wouldn't be config free?\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/142067727","html_url":"https://github.com/elastic/elasticsearch/issues/3565#issuecomment-142067727","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/3565","id":142067727,"node_id":"MDEyOklzc3VlQ29tbWVudDE0MjA2NzcyNw==","user":{"login":"clintongormley","id":56599,"node_id":"MDQ6VXNlcjU2NTk5","avatar_url":"https://avatars0.githubusercontent.com/u/56599?v=4","gravatar_id":"","url":"https://api.github.com/users/clintongormley","html_url":"https://github.com/clintongormley","followers_url":"https://api.github.com/users/clintongormley/followers","following_url":"https://api.github.com/users/clintongormley/following{/other_user}","gists_url":"https://api.github.com/users/clintongormley/gists{/gist_id}","starred_url":"https://api.github.com/users/clintongormley/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/clintongormley/subscriptions","organizations_url":"https://api.github.com/users/clintongormley/orgs","repos_url":"https://api.github.com/users/clintongormley/repos","events_url":"https://api.github.com/users/clintongormley/events{/privacy}","received_events_url":"https://api.github.com/users/clintongormley/received_events","type":"User","site_admin":false},"created_at":"2015-09-21T18:25:44Z","updated_at":"2015-09-21T18:25:44Z","author_association":"CONTRIBUTOR","body":"Closing in favour of #13692\n","performed_via_github_app":null}]