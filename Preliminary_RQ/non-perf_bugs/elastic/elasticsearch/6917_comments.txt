[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/50132794","html_url":"https://github.com/elastic/elasticsearch/issues/6917#issuecomment-50132794","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/6917","id":50132794,"node_id":"MDEyOklzc3VlQ29tbWVudDUwMTMyNzk0","user":{"login":"rmuir","id":504194,"node_id":"MDQ6VXNlcjUwNDE5NA==","avatar_url":"https://avatars1.githubusercontent.com/u/504194?v=4","gravatar_id":"","url":"https://api.github.com/users/rmuir","html_url":"https://github.com/rmuir","followers_url":"https://api.github.com/users/rmuir/followers","following_url":"https://api.github.com/users/rmuir/following{/other_user}","gists_url":"https://api.github.com/users/rmuir/gists{/gist_id}","starred_url":"https://api.github.com/users/rmuir/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/rmuir/subscriptions","organizations_url":"https://api.github.com/users/rmuir/orgs","repos_url":"https://api.github.com/users/rmuir/repos","events_url":"https://api.github.com/users/rmuir/events{/privacy}","received_events_url":"https://api.github.com/users/rmuir/received_events","type":"User","site_admin":false},"created_at":"2014-07-25T10:29:37Z","updated_at":"2014-07-25T10:29:37Z","author_association":"CONTRIBUTOR","body":"its tricky for collation because there is not a 1-to-1 mapping of keys to original values. collation rules may collapse two terms into the same key, for example because the strength determines it should ignore case, so \"Test\" and \"test\" get the same key... so what should the aggregation do in such a case, what would be the output?\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/52760850","html_url":"https://github.com/elastic/elasticsearch/issues/6917#issuecomment-52760850","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/6917","id":52760850,"node_id":"MDEyOklzc3VlQ29tbWVudDUyNzYwODUw","user":{"login":"maik2102","id":2410390,"node_id":"MDQ6VXNlcjI0MTAzOTA=","avatar_url":"https://avatars2.githubusercontent.com/u/2410390?v=4","gravatar_id":"","url":"https://api.github.com/users/maik2102","html_url":"https://github.com/maik2102","followers_url":"https://api.github.com/users/maik2102/followers","following_url":"https://api.github.com/users/maik2102/following{/other_user}","gists_url":"https://api.github.com/users/maik2102/gists{/gist_id}","starred_url":"https://api.github.com/users/maik2102/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/maik2102/subscriptions","organizations_url":"https://api.github.com/users/maik2102/orgs","repos_url":"https://api.github.com/users/maik2102/repos","events_url":"https://api.github.com/users/maik2102/events{/privacy}","received_events_url":"https://api.github.com/users/maik2102/received_events","type":"User","site_admin":false},"created_at":"2014-08-20T10:58:25Z","updated_at":"2014-08-20T10:58:25Z","author_association":"NONE","body":"In a first step it would be great to combine a sub-aggregation with the always given _count aggregation.\nE.g.: I want to boost my best eCommerce categories, but if the \"boost\" is equal, sort by the count of matching products.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/52785632","html_url":"https://github.com/elastic/elasticsearch/issues/6917#issuecomment-52785632","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/6917","id":52785632,"node_id":"MDEyOklzc3VlQ29tbWVudDUyNzg1NjMy","user":{"login":"brusic","id":354105,"node_id":"MDQ6VXNlcjM1NDEwNQ==","avatar_url":"https://avatars1.githubusercontent.com/u/354105?v=4","gravatar_id":"","url":"https://api.github.com/users/brusic","html_url":"https://github.com/brusic","followers_url":"https://api.github.com/users/brusic/followers","following_url":"https://api.github.com/users/brusic/following{/other_user}","gists_url":"https://api.github.com/users/brusic/gists{/gist_id}","starred_url":"https://api.github.com/users/brusic/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/brusic/subscriptions","organizations_url":"https://api.github.com/users/brusic/orgs","repos_url":"https://api.github.com/users/brusic/repos","events_url":"https://api.github.com/users/brusic/events{/privacy}","received_events_url":"https://api.github.com/users/brusic/received_events","type":"User","site_admin":false},"created_at":"2014-08-20T14:28:35Z","updated_at":"2014-08-20T14:28:35Z","author_association":"CONTRIBUTOR","body":"@maik2102, sounds like you want secondary sorting, which is a feature I would like as well.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/74538535","html_url":"https://github.com/elastic/elasticsearch/issues/6917#issuecomment-74538535","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/6917","id":74538535,"node_id":"MDEyOklzc3VlQ29tbWVudDc0NTM4NTM1","user":{"login":"hsm3","id":1920866,"node_id":"MDQ6VXNlcjE5MjA4NjY=","avatar_url":"https://avatars1.githubusercontent.com/u/1920866?v=4","gravatar_id":"","url":"https://api.github.com/users/hsm3","html_url":"https://github.com/hsm3","followers_url":"https://api.github.com/users/hsm3/followers","following_url":"https://api.github.com/users/hsm3/following{/other_user}","gists_url":"https://api.github.com/users/hsm3/gists{/gist_id}","starred_url":"https://api.github.com/users/hsm3/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hsm3/subscriptions","organizations_url":"https://api.github.com/users/hsm3/orgs","repos_url":"https://api.github.com/users/hsm3/repos","events_url":"https://api.github.com/users/hsm3/events{/privacy}","received_events_url":"https://api.github.com/users/hsm3/received_events","type":"User","site_admin":false},"created_at":"2015-02-16T16:54:00Z","updated_at":"2015-02-16T16:54:00Z","author_association":"NONE","body":"We are also doing ecommerce, and have groups of products being returned via a terms agg.  We would really like to use a secondary sort to improve the fine-grain ordering, and break ties to make the sort stable.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/372638556","html_url":"https://github.com/elastic/elasticsearch/issues/6917#issuecomment-372638556","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/6917","id":372638556,"node_id":"MDEyOklzc3VlQ29tbWVudDM3MjYzODU1Ng==","user":{"login":"colings86","id":236731,"node_id":"MDQ6VXNlcjIzNjczMQ==","avatar_url":"https://avatars0.githubusercontent.com/u/236731?v=4","gravatar_id":"","url":"https://api.github.com/users/colings86","html_url":"https://github.com/colings86","followers_url":"https://api.github.com/users/colings86/followers","following_url":"https://api.github.com/users/colings86/following{/other_user}","gists_url":"https://api.github.com/users/colings86/gists{/gist_id}","starred_url":"https://api.github.com/users/colings86/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/colings86/subscriptions","organizations_url":"https://api.github.com/users/colings86/orgs","repos_url":"https://api.github.com/users/colings86/repos","events_url":"https://api.github.com/users/colings86/events{/privacy}","received_events_url":"https://api.github.com/users/colings86/received_events","type":"User","site_admin":false},"created_at":"2018-03-13T11:48:13Z","updated_at":"2018-03-13T11:48:13Z","author_association":"MEMBER","body":"We now have the ability to order by mutliple criteria. Ordering by collation is tricky as mentioned above and we already have issues with unbounded errors in terms ordering as mntioned in https://github.com/elastic/elasticsearch/issues/17588.","performed_via_github_app":null}]