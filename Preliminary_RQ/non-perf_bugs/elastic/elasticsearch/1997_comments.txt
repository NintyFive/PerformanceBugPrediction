[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/6057942","html_url":"https://github.com/elastic/elasticsearch/issues/1997#issuecomment-6057942","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/1997","id":6057942,"node_id":"MDEyOklzc3VlQ29tbWVudDYwNTc5NDI=","user":{"login":"ofavre","id":95129,"node_id":"MDQ6VXNlcjk1MTI5","avatar_url":"https://avatars3.githubusercontent.com/u/95129?v=4","gravatar_id":"","url":"https://api.github.com/users/ofavre","html_url":"https://github.com/ofavre","followers_url":"https://api.github.com/users/ofavre/followers","following_url":"https://api.github.com/users/ofavre/following{/other_user}","gists_url":"https://api.github.com/users/ofavre/gists{/gist_id}","starred_url":"https://api.github.com/users/ofavre/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ofavre/subscriptions","organizations_url":"https://api.github.com/users/ofavre/orgs","repos_url":"https://api.github.com/users/ofavre/repos","events_url":"https://api.github.com/users/ofavre/events{/privacy}","received_events_url":"https://api.github.com/users/ofavre/received_events","type":"User","site_admin":false},"created_at":"2012-06-01T10:53:03Z","updated_at":"2012-06-01T10:53:03Z","author_association":"CONTRIBUTOR","body":"In multiple classes you can control whether or not to normalize and validate latitude and/or longitude.\nControlling this setting separately for latitude and longitude seems odd, considering the implication of a 180°lon shift in some cases.\n\nI can only think of one use case: One wants to superpose an (indefinite and dynamic) number of layers that must not be merged.\nOne can then decide to apply a `k*360`°lon shift, so that range queries made in one domain (defined by `x+k*360` with `x in ]-180:180]` for longitude and `y in [-90;90]` for latitude) do not leak to other layers.\nBut even in such weird use case, a filter on some field containing `k` would make more sense... maybe not performance wise, but still.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/6064496","html_url":"https://github.com/elastic/elasticsearch/issues/1997#issuecomment-6064496","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/1997","id":6064496,"node_id":"MDEyOklzc3VlQ29tbWVudDYwNjQ0OTY=","user":{"login":"ofavre","id":95129,"node_id":"MDQ6VXNlcjk1MTI5","avatar_url":"https://avatars3.githubusercontent.com/u/95129?v=4","gravatar_id":"","url":"https://api.github.com/users/ofavre","html_url":"https://github.com/ofavre","followers_url":"https://api.github.com/users/ofavre/followers","following_url":"https://api.github.com/users/ofavre/following{/other_user}","gists_url":"https://api.github.com/users/ofavre/gists{/gist_id}","starred_url":"https://api.github.com/users/ofavre/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ofavre/subscriptions","organizations_url":"https://api.github.com/users/ofavre/orgs","repos_url":"https://api.github.com/users/ofavre/repos","events_url":"https://api.github.com/users/ofavre/events{/privacy}","received_events_url":"https://api.github.com/users/ofavre/received_events","type":"User","site_admin":false},"created_at":"2012-06-01T16:26:46Z","updated_at":"2012-06-01T16:26:46Z","author_association":"CONTRIBUTOR","body":"### Normalizing geo polygons\n\n**Keep in mind** that a polygon is defined by a list connected of points, defining contiguous edges.\nAlso, the `GeoPolygonFilter.pointInPolygon()` algorithm uses the crossing number method, hence a self intersection defines a whole.\n\n#### The idea\n- A polygon should be split when one of its edges crosses a splitting axis (±90°lat or ±180°lon).\n  We must consider the intersection point, _normalized_ on both sides.\n- The points that are on the opposite side of the splitting axis will be taken care of as part of a new polygon.\n- As long as the points considered when iterating are at the opposite side, we ignore them in the context of the current polygon.\n- As soon as they come back in and to not cross an other splitting axis (at corners), we resume filling the current polygon, taking care of the intersection points with the axis.\n- When creating a new polygon, we must attach a new transformation to it, so that the _transformed_ points it considers are normalized, until they, too, eventually cross a splitting axis.\n- In order to close all polygons (especially those started at the middle of the iteration) we must reiterate on the points.\n  When the starting point is met again, we close the related polygon, etc. until all polygons are closed.\n\n**Note:** This algorithm keeps parts of the polygon that are in the same normalization space as part of a single polygon, hence self intersections are kept intact. However this comes with eventual edges being along the splitting axis, sometime multiple such edges being superposed, and this may affect the `pointInPolygon()` algorithm, but it shouldn't, considering such edges cover an empty area.\n\n**Complexity:** This algorithm is _O(n)_, _n_ being the number of points defining the polygon to normalize, but it's a bit verbose... (can it really be less?)\n\n#### Pseudo-implementation stub\n\n```\nmain:\n    let inPoints be the list of points defining the polygon to normalize\n    let list be the list of polygons\n    let polygon be composed of\n        tfo // a transform the normalizes the points to consider\n        points // a list of points that form the polygon\n        startIdx // the index of the first point that created this polygon\n        closed = false // whether the polygon has finished its construction\n        active = true // if the points considered don't yet cross a splitting axis\n        cutPoint = none // the cut point on the splitting axis\n        splittingAxis = none // the current splitting axis that paused the construction\n    let tfo be a transformation\n    set tfo = transformation normalizing the point inPoints[0]\n    let n be an integer\n    set n = 0\n    append new polygon(tfo=tfo, points=[inPoints[0]], startIdx=0) to list\n    iterate over the edges : edge\n        iterate over list : polygon\n            polygon.notify(n, edge)\n        increment n\n    set n = 0\n    let i be the index of the first non closed polygon\n    set nc = 0\n    iterate over the edges : edge\n        for i in nc to list.size-1\n            list[i].notify(n, edge)\n            if list[i].closed?\n                increment nc\n        if nc equals list.size\n            break\n        increment n\n    return list\n\npolygon.notify(n, edge):\n    transform edge according to tfo\n    if not active\n        if n == startIdx\n            set closed = true\n        else if edge crossing back splittingAxis\n            set cutPoint accordingly\n            set edge.begin = cutPoint\n            if edge crossing any splitting axis\n                set cutPoint accordingly\n                set splittingAxis accordingly\n            else\n                set active = true\n                self.notify(n, edge)\n    else\n        if edge crossing any splitting axis\n            set active = false\n            set cutPoint accordingly\n            set splittingAxis accordingly\n            append cutPoint to points\n            set edge.begin = cutPoint\n            let newTfo be a transformation\n            let newPoly be a polygon\n            set newTfo accordingly, to normalize points of the other side of splittingAxis\n            set newPoly = new polygon(tfo=newTfo, points=[edge.begin], startIdx=n)\n            append newPoly to list\n            call newPoly.notify(n, edge)\n        else\n            append edge.end to points\n```\n\n#### Feedback required\n\nI'm not really going to implement it because: I'm not 100% sure it works fine in all cases, and I'm not convinced geo polygon normalization is a real need.\n\nIt may even be prevented by other means if such problem arise.\nFor instance, with a few assumptions one can generate reflected/shifted copies of the polygon, and or together the results.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/6064812","html_url":"https://github.com/elastic/elasticsearch/issues/1997#issuecomment-6064812","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/1997","id":6064812,"node_id":"MDEyOklzc3VlQ29tbWVudDYwNjQ4MTI=","user":{"login":"ofavre","id":95129,"node_id":"MDQ6VXNlcjk1MTI5","avatar_url":"https://avatars3.githubusercontent.com/u/95129?v=4","gravatar_id":"","url":"https://api.github.com/users/ofavre","html_url":"https://github.com/ofavre","followers_url":"https://api.github.com/users/ofavre/followers","following_url":"https://api.github.com/users/ofavre/following{/other_user}","gists_url":"https://api.github.com/users/ofavre/gists{/gist_id}","starred_url":"https://api.github.com/users/ofavre/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ofavre/subscriptions","organizations_url":"https://api.github.com/users/ofavre/orgs","repos_url":"https://api.github.com/users/ofavre/repos","events_url":"https://api.github.com/users/ofavre/events{/privacy}","received_events_url":"https://api.github.com/users/ofavre/received_events","type":"User","site_admin":false},"created_at":"2012-06-01T16:41:35Z","updated_at":"2012-06-01T16:41:35Z","author_association":"CONTRIBUTOR","body":"### Normalizing geo polygons\n\n#### A naive approach\n\n_Why didn't I even think about that one before..._\n\n**Near up to 3 time slower.** No impact if already normalized.\n\n**Assumptions:**\n- the geo polygon is no wider than 360°lon and no taller than 180°lat (should usually be the case).\n- no undesired point lie outside the normalized range (if the user wants normalization... then it should normally be the case).\n\n**Steps:**\n- Compute the geo bounding box of the geo polygon\n- Normalize the range, but instead of generating just the missing parts,\n  shift and or reflect the whole polygon\n- Or-together the generated copies (3 maximum).\n\n#### Feedback required\n\nDo you think such assumptions are fair? the performance impact acceptable?\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/6065556","html_url":"https://github.com/elastic/elasticsearch/issues/1997#issuecomment-6065556","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/1997","id":6065556,"node_id":"MDEyOklzc3VlQ29tbWVudDYwNjU1NTY=","user":{"login":"ofavre","id":95129,"node_id":"MDQ6VXNlcjk1MTI5","avatar_url":"https://avatars3.githubusercontent.com/u/95129?v=4","gravatar_id":"","url":"https://api.github.com/users/ofavre","html_url":"https://github.com/ofavre","followers_url":"https://api.github.com/users/ofavre/followers","following_url":"https://api.github.com/users/ofavre/following{/other_user}","gists_url":"https://api.github.com/users/ofavre/gists{/gist_id}","starred_url":"https://api.github.com/users/ofavre/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ofavre/subscriptions","organizations_url":"https://api.github.com/users/ofavre/orgs","repos_url":"https://api.github.com/users/ofavre/repos","events_url":"https://api.github.com/users/ofavre/events{/privacy}","received_events_url":"https://api.github.com/users/ofavre/received_events","type":"User","site_admin":false},"created_at":"2012-06-01T17:15:57Z","updated_at":"2012-06-04T08:38:40Z","author_association":"CONTRIBUTOR","body":"### Normalizing geo polygons\n\n#### Using triangulation\n- Check if the geo bounding box is already normalized and early exit.\n- Triangulate the polygon.\n- Eventually split each triangle\n\n```\nnormalize the first point, transforming the two others accordingly.\nselect the number of adjacent edges of the first point that cross a splitting axis\n    if zero\n        if the opposite edge crosses a splitting axis\n            // the first point is on a splitting axis\n            calculate the cut point\n            split the triangle in two\n            // no need to normalize the two pieces as none of their edge would cross a splitting axis\n        // otherwise, the triangle is normalized (as the other two points are within the same normalization space and a triangle is convex!)\n    if one\n        // the opposite edge is crossing the same splitting axis too\n        calculate the cut point\n        create a new triangle with the second and third points, and the cut point (all but the first point)\n        normalize that new triangle\n        modify the current triangle to use the cut point instead of the faulty vertex\n        // no need to re-normalize as we've fixed the only crossing of the current triangle\n    if two\n        calculate the two cut points\n        create two triangles with the second and third points, and the two cut points\n        normalize them\n        modify the current triangle to use the two cut points instead of the second and third points\n        // no need to re-normalize as we've fixed the two crossing of the current triangle\n```\n\n**Complexity:** Triangulation can be no faster than _O(n*log(n))_ if polygon has holes, _O(n)_ otherwise. Furthermore, re-normalization of split triangles are sometimes needed.\n\n#### Feedback required\n\nThis method seems more conventional and simple.\n\nIf not handled by the triangulation method, it however it breaks the crossing number method, by ignoring the self-intersections.\nThe `pointInPolygon` method will also be modified/simplified, but not necessarily to become more performant.\n","performed_via_github_app":null}]