{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/13654","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/13654/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/13654/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/13654/events","html_url":"https://github.com/elastic/elasticsearch/issues/13654","id":107185133,"node_id":"MDU6SXNzdWUxMDcxODUxMzM=","number":13654,"title":"Open Questions with MLT","user":{"login":"alexksikes","id":43475,"node_id":"MDQ6VXNlcjQzNDc1","avatar_url":"https://avatars2.githubusercontent.com/u/43475?v=4","gravatar_id":"","url":"https://api.github.com/users/alexksikes","html_url":"https://github.com/alexksikes","followers_url":"https://api.github.com/users/alexksikes/followers","following_url":"https://api.github.com/users/alexksikes/following{/other_user}","gists_url":"https://api.github.com/users/alexksikes/gists{/gist_id}","starred_url":"https://api.github.com/users/alexksikes/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alexksikes/subscriptions","organizations_url":"https://api.github.com/users/alexksikes/orgs","repos_url":"https://api.github.com/users/alexksikes/repos","events_url":"https://api.github.com/users/alexksikes/events{/privacy}","received_events_url":"https://api.github.com/users/alexksikes/received_events","type":"User","site_admin":false},"labels":[{"id":146832564,"node_id":"MDU6TGFiZWwxNDY4MzI1NjQ=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/:Search/Search","name":":Search/Search","color":"0e8a16","default":false,"description":"Search-related issues that do not fall into other categories"},{"id":23172,"node_id":"MDU6TGFiZWwyMzE3Mg==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/%3Efeature","name":">feature","color":"006b75","default":false,"description":null},{"id":158399402,"node_id":"MDU6TGFiZWwxNTgzOTk0MDI=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/Meta","name":"Meta","color":"e11d21","default":false,"description":null},{"id":111416437,"node_id":"MDU6TGFiZWwxMTE0MTY0Mzc=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/discuss","name":"discuss","color":"fbca04","default":false,"description":null}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":2,"created_at":"2015-09-18T11:35:28Z","updated_at":"2018-03-23T21:52:54Z","closed_at":"2018-03-23T21:52:54Z","author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"In this issue I'll list a couple of features that we may or may not want to support for Elasticsearch More Like This (MLT). This is very much subject for discussion.\n\n1) Some queries have a **fuzzy option**. It could be interesting to provide this functionality to More Like This as well. In this case, the generated query would just fuzzify the list of selected terms, according to the fuzziness parameter.\n\n2) Some queries provide **fields boosting**. For More Like This this would boost the fields of the generated query.\n\n3) More Like This could also support **regex patterns** in field names.\n\n4) There is a common use case of **MLT with tags**, that is with unique keywords attached to each document. The problem is that on tags the MLT query does not return any result out of the box because the default min term parameter is set to 2. We could detect such a use case automatically and in this case disregard the min term freq parameter.\n\n5) At the moment MLT only works on string fields. However, it could be useful to also consider other types such as **numerics and/or geo locations**. We have two options, either we treat them as a fixed value, for example for product codes, or treat them as a sort of range. The later case could be handled if the fuzziness parameter is set.\n\n6) MLT generates a boolean query of the \"best\" terms in the provided document(s). The strategy used on multiple fields is a sort of best field approach. It could be nice to let the user control such a strategy such as asking for **cross fields** instead, in a similar manner to the [Multi Match Query](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-multi-match-query.html).\n\n7) At the moment the document input is a combination of a list of strings, a spec to a document in the index, or a spec to a document not present in the index ([artificial document](https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-termvectors.html#docs-termvectors-artificial-doc)). We could additionally provide the ability to specify document inputs as the top n documents returned by a query. This could be useful to build a cheap **recommender system** which would for example return the documents most similar to the last favorited user's documents.\n\nThe syntax could look like this:\n\n``` json\n{\n  \"mlt\": {\n    \"like\": {\n      \"query\" : {\n        \"a query that fetches the docs from the user's history\"\n      },\n      \"top_n\": 3\n    }\n}\n```\n\nThis feature could also be useful in a **query expansion** scenario. In this case, the user's original text query could be augmented by the terms of the documents returned after having executed the original query.\n\nThis could be used in a bool query in the following manner:\n\n``` json\n{\n  \"bool\": {\n    \"must\": {\n      \"term\": { \"user\": \"kimchy\" }\n    },\n    \"should\": {\n      \"mlt\": {\n        \"like\": {\n          \"query\": {\n            \"term\": { \"user\": \"kimchy\" }\n          },\n          \"top_n\": 3\n        }\n      }\n    }\n  }\n}\n```\n\nThis feature would also let us run **nested MLT queries**, although I'm unsure as to how useful this would be.\n\n8) Do we want to do the same with the terms returned by an aggregation? This would let use the **significant terms** as the important terms instead of more generally use the terms with the highest TF-IDF.\n\n9) The actual Lucene MLT lets us select a **different similarity**. These are limited to TF-IDF similarities though, yet it could still be useful to let the user specify his own custom similarity here.\n\n10) When not using term vectors and on large documents, there could be a performance issue when parsing too many tokens. We could provide an option that sets the **maximum number of tokens** to parse in each field that does not support term vectors.\n\n11) A [highly requested feature](https://github.com/elasticsearch/elasticsearch/issues/1412) is to return the actual **interesting terms** which were selected for the generated query. Although we can now use the [Validate API](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-validate.html) for this, it could still be interesting to return these terms as part of the response.\n\n12) Another important feature when using MLT is to be able **highlight with a degree of importance the terms** that match in each document. This is related to the [Intensity Highligthing](https://github.com/elastic/elasticsearch/issues/12326) issue. Perhaps we could provide an option for that as well in the actual MLT query?\n\n13) At some point we may be interested to **replace MLT** with [Item Query](https://github.com/elastic/elasticsearch/issues/12293) which is a cleaner more faithful implementation of nearest neighbor search, and which let's the user exactly determine how the best terms should be selected and how the items should be combined. The original MLT query would then be deprecated. Item Query would then be implemented as a plugin, along side the Term Vectors API.\n\n14) Any other options I may not have covered? Please feel free to expand on this issue.\n","closed_by":{"login":"talevy","id":388837,"node_id":"MDQ6VXNlcjM4ODgzNw==","avatar_url":"https://avatars0.githubusercontent.com/u/388837?v=4","gravatar_id":"","url":"https://api.github.com/users/talevy","html_url":"https://github.com/talevy","followers_url":"https://api.github.com/users/talevy/followers","following_url":"https://api.github.com/users/talevy/following{/other_user}","gists_url":"https://api.github.com/users/talevy/gists{/gist_id}","starred_url":"https://api.github.com/users/talevy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/talevy/subscriptions","organizations_url":"https://api.github.com/users/talevy/orgs","repos_url":"https://api.github.com/users/talevy/repos","events_url":"https://api.github.com/users/talevy/events{/privacy}","received_events_url":"https://api.github.com/users/talevy/received_events","type":"User","site_admin":false},"performed_via_github_app":null}