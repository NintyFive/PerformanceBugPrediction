{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/33656","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/33656/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/33656/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/33656/events","html_url":"https://github.com/elastic/elasticsearch/issues/33656","id":359710531,"node_id":"MDU6SXNzdWUzNTk3MTA1MzE=","number":33656,"title":"Uses auto generated timestamp with soft-deletes","user":{"login":"dnhatn","id":13474362,"node_id":"MDQ6VXNlcjEzNDc0MzYy","avatar_url":"https://avatars3.githubusercontent.com/u/13474362?v=4","gravatar_id":"","url":"https://api.github.com/users/dnhatn","html_url":"https://github.com/dnhatn","followers_url":"https://api.github.com/users/dnhatn/followers","following_url":"https://api.github.com/users/dnhatn/following{/other_user}","gists_url":"https://api.github.com/users/dnhatn/gists{/gist_id}","starred_url":"https://api.github.com/users/dnhatn/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dnhatn/subscriptions","organizations_url":"https://api.github.com/users/dnhatn/orgs","repos_url":"https://api.github.com/users/dnhatn/repos","events_url":"https://api.github.com/users/dnhatn/events{/privacy}","received_events_url":"https://api.github.com/users/dnhatn/received_events","type":"User","site_admin":false},"labels":[{"id":912824565,"node_id":"MDU6TGFiZWw5MTI4MjQ1NjU=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/:Distributed/CCR","name":":Distributed/CCR","color":"0e8a16","default":false,"description":"Issues around the Cross Cluster State Replication features"}],"state":"closed","locked":false,"assignee":{"login":"dnhatn","id":13474362,"node_id":"MDQ6VXNlcjEzNDc0MzYy","avatar_url":"https://avatars3.githubusercontent.com/u/13474362?v=4","gravatar_id":"","url":"https://api.github.com/users/dnhatn","html_url":"https://github.com/dnhatn","followers_url":"https://api.github.com/users/dnhatn/followers","following_url":"https://api.github.com/users/dnhatn/following{/other_user}","gists_url":"https://api.github.com/users/dnhatn/gists{/gist_id}","starred_url":"https://api.github.com/users/dnhatn/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dnhatn/subscriptions","organizations_url":"https://api.github.com/users/dnhatn/orgs","repos_url":"https://api.github.com/users/dnhatn/repos","events_url":"https://api.github.com/users/dnhatn/events{/privacy}","received_events_url":"https://api.github.com/users/dnhatn/received_events","type":"User","site_admin":false},"assignees":[{"login":"dnhatn","id":13474362,"node_id":"MDQ6VXNlcjEzNDc0MzYy","avatar_url":"https://avatars3.githubusercontent.com/u/13474362?v=4","gravatar_id":"","url":"https://api.github.com/users/dnhatn","html_url":"https://github.com/dnhatn","followers_url":"https://api.github.com/users/dnhatn/followers","following_url":"https://api.github.com/users/dnhatn/following{/other_user}","gists_url":"https://api.github.com/users/dnhatn/gists{/gist_id}","starred_url":"https://api.github.com/users/dnhatn/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dnhatn/subscriptions","organizations_url":"https://api.github.com/users/dnhatn/orgs","repos_url":"https://api.github.com/users/dnhatn/repos","events_url":"https://api.github.com/users/dnhatn/events{/privacy}","received_events_url":"https://api.github.com/users/dnhatn/received_events","type":"User","site_admin":false}],"milestone":null,"comments":5,"created_at":"2018-09-13T01:37:54Z","updated_at":"2018-10-04T03:19:58Z","closed_at":"2018-10-04T03:16:09Z","author_association":"MEMBER","active_lock_reason":null,"body":"### 1. Peer-recovery \r\nToday we don't store the auto-generated timestamp of indexing operations in Lucene and always [assign -1](https://github.com/elastic/elasticsearch/blob/b2f78e5a47a9fba5b29542a2babbdae939483474/server/src/main/java/org/elasticsearch/index/engine/LuceneChangesSnapshot.java#L271-L274) to all index operations from LuceneChangesSnapshot. This looks innocent but it generates duplicate documents on a replica in the following test.\r\n\r\n```java\r\npublic void testRetryAppendOnlyInRecoveryAndReplication() throws Exception {\r\n    Settings settings = Settings.builder()\r\n        .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)\r\n        .build();\r\n    try (ReplicationGroup shards = createGroup(0, settings)) {\r\n        shards.startAll();\r\n        final IndexRequest originalRequest = new IndexRequest(\r\n            index.getName(), \"type\").source(\"{}\", XContentType.JSON);\r\n        originalRequest.process(Version.CURRENT, null, index.getName());\r\n        IndexRequest retryRequest = new IndexRequest();\r\n        try (BytesStreamOutput out = new BytesStreamOutput()) {\r\n            originalRequest.writeTo(out);\r\n            try (StreamInput in = out.bytes().streamInput()) {\r\n                retryRequest.readFrom(in);\r\n            }\r\n        }\r\n        retryRequest.onRetry();\r\n        shards.index(retryRequest);\r\n        IndexShard replica = shards.addReplica();\r\n        shards.recoverReplica(replica); // timestamp on replica is -1\r\n        shards.assertAllEqual(1);\r\n        shards.index(originalRequest); // we optimize this request on replica\r\n        shards.assertAllEqual(1);\r\n    }\r\n}\r\n```\r\n\r\nTo fix this, we need to assign a value which is at least the (original) timestamp of the index request to its corresponding index request from LucenChangeSnapshot. Here we can use the latest auto-generated timestamp of Engine.\r\n\r\n### 2. Optimize indexing on a FollowingEngine in CCR\r\n\r\nWe [disable optimization](https://github.com/elastic/elasticsearch/blob/b097eff34244d6b046cdadfec84e8fc9f1af6714/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java#L1257) for index requests whose origin are recovery (retry always is true). To enable this optimization in CCR:\r\n\r\n1. We need to make sure that a FollowingEngine processes an append-only operation once. This can be done using LocalCheckpointTracker.\r\n\r\n2. We need to store the retry flag to Lucene index and extend Translog#Index to include this flag. This should be fast with a single value DocValues.\r\n\r\n@s1monw WDYT? /cc @bleskes\r\n\r\nThis a subtask of #30086.","closed_by":{"login":"dnhatn","id":13474362,"node_id":"MDQ6VXNlcjEzNDc0MzYy","avatar_url":"https://avatars3.githubusercontent.com/u/13474362?v=4","gravatar_id":"","url":"https://api.github.com/users/dnhatn","html_url":"https://github.com/dnhatn","followers_url":"https://api.github.com/users/dnhatn/followers","following_url":"https://api.github.com/users/dnhatn/following{/other_user}","gists_url":"https://api.github.com/users/dnhatn/gists{/gist_id}","starred_url":"https://api.github.com/users/dnhatn/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dnhatn/subscriptions","organizations_url":"https://api.github.com/users/dnhatn/orgs","repos_url":"https://api.github.com/users/dnhatn/repos","events_url":"https://api.github.com/users/dnhatn/events{/privacy}","received_events_url":"https://api.github.com/users/dnhatn/received_events","type":"User","site_admin":false},"performed_via_github_app":null}