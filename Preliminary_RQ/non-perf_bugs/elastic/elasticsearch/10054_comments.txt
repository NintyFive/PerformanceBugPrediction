[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/78191807","html_url":"https://github.com/elastic/elasticsearch/issues/10054#issuecomment-78191807","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/10054","id":78191807,"node_id":"MDEyOklzc3VlQ29tbWVudDc4MTkxODA3","user":{"login":"markwalkom","id":3184718,"node_id":"MDQ6VXNlcjMxODQ3MTg=","avatar_url":"https://avatars0.githubusercontent.com/u/3184718?v=4","gravatar_id":"","url":"https://api.github.com/users/markwalkom","html_url":"https://github.com/markwalkom","followers_url":"https://api.github.com/users/markwalkom/followers","following_url":"https://api.github.com/users/markwalkom/following{/other_user}","gists_url":"https://api.github.com/users/markwalkom/gists{/gist_id}","starred_url":"https://api.github.com/users/markwalkom/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/markwalkom/subscriptions","organizations_url":"https://api.github.com/users/markwalkom/orgs","repos_url":"https://api.github.com/users/markwalkom/repos","events_url":"https://api.github.com/users/markwalkom/events{/privacy}","received_events_url":"https://api.github.com/users/markwalkom/received_events","type":"User","site_admin":false},"created_at":"2015-03-11T03:03:46Z","updated_at":"2015-03-11T03:03:46Z","author_association":"MEMBER","body":"This is 1.4.4 according to @masaruh \n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/78196769","html_url":"https://github.com/elastic/elasticsearch/issues/10054#issuecomment-78196769","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/10054","id":78196769,"node_id":"MDEyOklzc3VlQ29tbWVudDc4MTk2NzY5","user":{"login":"masaruh","id":572174,"node_id":"MDQ6VXNlcjU3MjE3NA==","avatar_url":"https://avatars3.githubusercontent.com/u/572174?v=4","gravatar_id":"","url":"https://api.github.com/users/masaruh","html_url":"https://github.com/masaruh","followers_url":"https://api.github.com/users/masaruh/followers","following_url":"https://api.github.com/users/masaruh/following{/other_user}","gists_url":"https://api.github.com/users/masaruh/gists{/gist_id}","starred_url":"https://api.github.com/users/masaruh/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/masaruh/subscriptions","organizations_url":"https://api.github.com/users/masaruh/orgs","repos_url":"https://api.github.com/users/masaruh/repos","events_url":"https://api.github.com/users/masaruh/events{/privacy}","received_events_url":"https://api.github.com/users/masaruh/received_events","type":"User","site_admin":false},"created_at":"2015-03-11T03:26:51Z","updated_at":"2015-03-11T03:26:51Z","author_association":"CONTRIBUTOR","body":"Forgot to mention it's not dangling index.\n\nIt can be reproduced by:\n1. Create three nodes cluster, node1 and node2 are master eligible and node3 is data only node.\n2. Create index\n3. Stop node2\n4. Delete the index\n5. Stop node1 and node3\n6. Start node1, node2 and node3\n7. Deleted index comes back\n\nIt looks old cluster state on node2 is imported on restart during `LocalGateway.performStateRecovery`.\nIt looks indices found in any `nodeState` are getting recovered. I wonder if it should recover only indices in `electedGlobalState`.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/83216980","html_url":"https://github.com/elastic/elasticsearch/issues/10054#issuecomment-83216980","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/10054","id":83216980,"node_id":"MDEyOklzc3VlQ29tbWVudDgzMjE2OTgw","user":{"login":"brwe","id":4320215,"node_id":"MDQ6VXNlcjQzMjAyMTU=","avatar_url":"https://avatars0.githubusercontent.com/u/4320215?v=4","gravatar_id":"","url":"https://api.github.com/users/brwe","html_url":"https://github.com/brwe","followers_url":"https://api.github.com/users/brwe/followers","following_url":"https://api.github.com/users/brwe/following{/other_user}","gists_url":"https://api.github.com/users/brwe/gists{/gist_id}","starred_url":"https://api.github.com/users/brwe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/brwe/subscriptions","organizations_url":"https://api.github.com/users/brwe/orgs","repos_url":"https://api.github.com/users/brwe/repos","events_url":"https://api.github.com/users/brwe/events{/privacy}","received_events_url":"https://api.github.com/users/brwe/received_events","type":"User","site_admin":false},"created_at":"2015-03-18T22:50:58Z","updated_at":"2015-03-18T22:50:58Z","author_association":"CONTRIBUTOR","body":"This is actually expected behavior. When a master eligible node joins a cluster then all information is has about indices from it's last cluster state are imported as well. This is a safety measure to make sure that a master with an empty cluster state (for example because the data folder of a master eligible node was deleted and it becomes master after full cluster restart) does not cause all indices to be deleted. We are even changing that now to work in a similar way for data only nodes, see https://github.com/elastic/elasticsearch/issues/8823\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/83841471","html_url":"https://github.com/elastic/elasticsearch/issues/10054#issuecomment-83841471","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/10054","id":83841471,"node_id":"MDEyOklzc3VlQ29tbWVudDgzODQxNDcx","user":{"login":"masaruh","id":572174,"node_id":"MDQ6VXNlcjU3MjE3NA==","avatar_url":"https://avatars3.githubusercontent.com/u/572174?v=4","gravatar_id":"","url":"https://api.github.com/users/masaruh","html_url":"https://github.com/masaruh","followers_url":"https://api.github.com/users/masaruh/followers","following_url":"https://api.github.com/users/masaruh/following{/other_user}","gists_url":"https://api.github.com/users/masaruh/gists{/gist_id}","starred_url":"https://api.github.com/users/masaruh/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/masaruh/subscriptions","organizations_url":"https://api.github.com/users/masaruh/orgs","repos_url":"https://api.github.com/users/masaruh/repos","events_url":"https://api.github.com/users/masaruh/events{/privacy}","received_events_url":"https://api.github.com/users/masaruh/received_events","type":"User","site_admin":false},"created_at":"2015-03-20T01:29:11Z","updated_at":"2015-03-20T01:29:11Z","author_association":"CONTRIBUTOR","body":"Thanks @brwe. Makes sense.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/83970321","html_url":"https://github.com/elastic/elasticsearch/issues/10054#issuecomment-83970321","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/10054","id":83970321,"node_id":"MDEyOklzc3VlQ29tbWVudDgzOTcwMzIx","user":{"login":"bleskes","id":1006375,"node_id":"MDQ6VXNlcjEwMDYzNzU=","avatar_url":"https://avatars1.githubusercontent.com/u/1006375?v=4","gravatar_id":"","url":"https://api.github.com/users/bleskes","html_url":"https://github.com/bleskes","followers_url":"https://api.github.com/users/bleskes/followers","following_url":"https://api.github.com/users/bleskes/following{/other_user}","gists_url":"https://api.github.com/users/bleskes/gists{/gist_id}","starred_url":"https://api.github.com/users/bleskes/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bleskes/subscriptions","organizations_url":"https://api.github.com/users/bleskes/orgs","repos_url":"https://api.github.com/users/bleskes/repos","events_url":"https://api.github.com/users/bleskes/events{/privacy}","received_events_url":"https://api.github.com/users/bleskes/received_events","type":"User","site_admin":false},"created_at":"2015-03-20T09:47:45Z","updated_at":"2015-03-20T09:47:45Z","author_association":"MEMBER","body":"A common failure here is people forgetting to configure min_master_nodes or recover_after, do a full cluster restart (or what ever) while adding new nodes to the cluster. If one of the new nodes gets elected as master before the older nodes join, it will not wait for them and iniitialize an empty cluster state (thinking it’s alone in a fresh cluster). We need this protection to make sure that we don’t delete all data once the old nodes join.\n\n> On 18 Mar 2015, at 23:51, Britta Weber notifications@github.com wrote:\n> \n> This is actually expected behavior. When a master eligible node joins a cluster then all information is has about indices from it's last cluster state are imported as well. This is a safety measure to make sure that a master with an empty cluster state (for example because the data folder of a master eligible node was deleted and it becomes master after full cluster restart) does not cause all indices to be deleted. We are even changing that now to work in a similar way for data only nodes, see #8823\n> \n> —\n> Reply to this email directly or view it on GitHub.\n","performed_via_github_app":null}]