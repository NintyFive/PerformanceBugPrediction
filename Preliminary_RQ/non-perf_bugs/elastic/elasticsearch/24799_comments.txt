[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/302735133","html_url":"https://github.com/elastic/elasticsearch/issues/24799#issuecomment-302735133","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/24799","id":302735133,"node_id":"MDEyOklzc3VlQ29tbWVudDMwMjczNTEzMw==","user":{"login":"jonathanihm","id":6002459,"node_id":"MDQ6VXNlcjYwMDI0NTk=","avatar_url":"https://avatars0.githubusercontent.com/u/6002459?v=4","gravatar_id":"","url":"https://api.github.com/users/jonathanihm","html_url":"https://github.com/jonathanihm","followers_url":"https://api.github.com/users/jonathanihm/followers","following_url":"https://api.github.com/users/jonathanihm/following{/other_user}","gists_url":"https://api.github.com/users/jonathanihm/gists{/gist_id}","starred_url":"https://api.github.com/users/jonathanihm/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jonathanihm/subscriptions","organizations_url":"https://api.github.com/users/jonathanihm/orgs","repos_url":"https://api.github.com/users/jonathanihm/repos","events_url":"https://api.github.com/users/jonathanihm/events{/privacy}","received_events_url":"https://api.github.com/users/jonathanihm/received_events","type":"User","site_admin":false},"created_at":"2017-05-19T15:31:12Z","updated_at":"2017-05-19T15:31:12Z","author_association":"NONE","body":"Could this possibly be a low-hanging fruit issue which I could handle as a new contributor?","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/303077561","html_url":"https://github.com/elastic/elasticsearch/issues/24799#issuecomment-303077561","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/24799","id":303077561,"node_id":"MDEyOklzc3VlQ29tbWVudDMwMzA3NzU2MQ==","user":{"login":"danielmitterdorfer","id":1699576,"node_id":"MDQ6VXNlcjE2OTk1NzY=","avatar_url":"https://avatars3.githubusercontent.com/u/1699576?v=4","gravatar_id":"","url":"https://api.github.com/users/danielmitterdorfer","html_url":"https://github.com/danielmitterdorfer","followers_url":"https://api.github.com/users/danielmitterdorfer/followers","following_url":"https://api.github.com/users/danielmitterdorfer/following{/other_user}","gists_url":"https://api.github.com/users/danielmitterdorfer/gists{/gist_id}","starred_url":"https://api.github.com/users/danielmitterdorfer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/danielmitterdorfer/subscriptions","organizations_url":"https://api.github.com/users/danielmitterdorfer/orgs","repos_url":"https://api.github.com/users/danielmitterdorfer/repos","events_url":"https://api.github.com/users/danielmitterdorfer/events{/privacy}","received_events_url":"https://api.github.com/users/danielmitterdorfer/received_events","type":"User","site_admin":false},"created_at":"2017-05-22T11:47:37Z","updated_at":"2017-05-22T11:49:07Z","author_association":"MEMBER","body":"Thanks for the ticket @sabi0! I can confirm that the behavior that you describe is indeed a problem. The microbenchmarking framework JMH uses a similar approach (take start timestamp, run benchmark for a while and then take the end timestamp) for that reason (and has a fat warning for the benchmark mode `SingleShotTime` which allows you not to do this intentionally). \r\n\r\nHence I also think that we need to reduce the sampling granularity for such short-running calls. However, I do not know the design of the query profiler well enough to give a definitive answer on how easy that is (maybe @polyfractal knows better?). \r\n\r\nWhile a sampling approach makes sense to me, taking stack traces does not. One of them is about granularity (tracing vs. sampling) and the other one is what information is captured. Stack traces would not help us much here because we don't want a Java execution profile but a more application specific one and we already have much better information available that we'd lose by taking stack traces.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/303316920","html_url":"https://github.com/elastic/elasticsearch/issues/24799#issuecomment-303316920","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/24799","id":303316920,"node_id":"MDEyOklzc3VlQ29tbWVudDMwMzMxNjkyMA==","user":{"login":"jpountz","id":299848,"node_id":"MDQ6VXNlcjI5OTg0OA==","avatar_url":"https://avatars2.githubusercontent.com/u/299848?v=4","gravatar_id":"","url":"https://api.github.com/users/jpountz","html_url":"https://github.com/jpountz","followers_url":"https://api.github.com/users/jpountz/followers","following_url":"https://api.github.com/users/jpountz/following{/other_user}","gists_url":"https://api.github.com/users/jpountz/gists{/gist_id}","starred_url":"https://api.github.com/users/jpountz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jpountz/subscriptions","organizations_url":"https://api.github.com/users/jpountz/orgs","repos_url":"https://api.github.com/users/jpountz/repos","events_url":"https://api.github.com/users/jpountz/events{/privacy}","received_events_url":"https://api.github.com/users/jpountz/received_events","type":"User","site_admin":false},"created_at":"2017-05-23T07:44:54Z","updated_at":"2017-05-23T07:44:54Z","author_association":"CONTRIBUTOR","body":"I like the idea of reducing the sampling granularity, I don't think that would be too hard to change. Maybe we should use an interval that grows linearly (something like `min(1000, i++/1024)`) in order to still have a meaningful profile with queries that match few documents. We'd probably also want to do it in the `ProfileScorer` class since most its methods are also cheap and called in a tight loop.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/303507757","html_url":"https://github.com/elastic/elasticsearch/issues/24799#issuecomment-303507757","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/24799","id":303507757,"node_id":"MDEyOklzc3VlQ29tbWVudDMwMzUwNzc1Nw==","user":{"login":"polyfractal","id":1224228,"node_id":"MDQ6VXNlcjEyMjQyMjg=","avatar_url":"https://avatars1.githubusercontent.com/u/1224228?v=4","gravatar_id":"","url":"https://api.github.com/users/polyfractal","html_url":"https://github.com/polyfractal","followers_url":"https://api.github.com/users/polyfractal/followers","following_url":"https://api.github.com/users/polyfractal/following{/other_user}","gists_url":"https://api.github.com/users/polyfractal/gists{/gist_id}","starred_url":"https://api.github.com/users/polyfractal/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/polyfractal/subscriptions","organizations_url":"https://api.github.com/users/polyfractal/orgs","repos_url":"https://api.github.com/users/polyfractal/repos","events_url":"https://api.github.com/users/polyfractal/events{/privacy}","received_events_url":"https://api.github.com/users/polyfractal/received_events","type":"User","site_admin":false},"created_at":"2017-05-23T19:32:48Z","updated_at":"2017-05-23T19:32:48Z","author_association":"MEMBER","body":"Whoops, just saw this (been fiddling with email filters lately and apparently broke everything).\r\n\r\nI don't think this will be very difficult to add... we are already maintaining a count of method invocations, so implementing sampling should be relatively trivial.  Just need some logic at the end to extrapolate based on the sampled data.\r\n\r\nI agree with @jpountz point, it would be nice if this could grow in some fashion so that small matching sets.  It's not uncommon to have slow queries (scripts, etc) that only match a few documents","performed_via_github_app":null}]