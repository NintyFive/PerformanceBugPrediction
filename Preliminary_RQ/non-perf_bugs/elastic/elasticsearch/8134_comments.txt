[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/59840006","html_url":"https://github.com/elastic/elasticsearch/issues/8134#issuecomment-59840006","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/8134","id":59840006,"node_id":"MDEyOklzc3VlQ29tbWVudDU5ODQwMDA2","user":{"login":"martijnvg","id":580421,"node_id":"MDQ6VXNlcjU4MDQyMQ==","avatar_url":"https://avatars3.githubusercontent.com/u/580421?v=4","gravatar_id":"","url":"https://api.github.com/users/martijnvg","html_url":"https://github.com/martijnvg","followers_url":"https://api.github.com/users/martijnvg/followers","following_url":"https://api.github.com/users/martijnvg/following{/other_user}","gists_url":"https://api.github.com/users/martijnvg/gists{/gist_id}","starred_url":"https://api.github.com/users/martijnvg/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/martijnvg/subscriptions","organizations_url":"https://api.github.com/users/martijnvg/orgs","repos_url":"https://api.github.com/users/martijnvg/repos","events_url":"https://api.github.com/users/martijnvg/events{/privacy}","received_events_url":"https://api.github.com/users/martijnvg/received_events","type":"User","site_admin":false},"created_at":"2014-10-20T21:08:17Z","updated_at":"2014-10-20T21:08:17Z","author_association":"MEMBER","body":"+1 to make the parent/child logic less fragile.\n\nJust wondering how these two separate searches are executed:\n1) We could run the first search in the query parser and pass the matching parent ordinals (optionally with scores) as argument to the query/filter that is returned by the parser.\n2) We could back to how has_child was executed around version `0.19` where there was scoped queries infrastructure. If a query implemented `ScopePhase` interface it ran twice as separate queries. First just the inner query ran and it collected parent ids, then the actual has_child query ran and only emitted parent docs that had a parent id that was collected before. Running with two distinct queries would mean that we wouldn't run into this filter cache issue. I believe this mechanism was removed because it added additional complexity in the query phase that was unwanted at that time. Maybe was can bring it back to live and simplify it.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/59892872","html_url":"https://github.com/elastic/elasticsearch/issues/8134#issuecomment-59892872","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/8134","id":59892872,"node_id":"MDEyOklzc3VlQ29tbWVudDU5ODkyODcy","user":{"login":"clintongormley","id":56599,"node_id":"MDQ6VXNlcjU2NTk5","avatar_url":"https://avatars0.githubusercontent.com/u/56599?v=4","gravatar_id":"","url":"https://api.github.com/users/clintongormley","html_url":"https://github.com/clintongormley","followers_url":"https://api.github.com/users/clintongormley/followers","following_url":"https://api.github.com/users/clintongormley/following{/other_user}","gists_url":"https://api.github.com/users/clintongormley/gists{/gist_id}","starred_url":"https://api.github.com/users/clintongormley/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/clintongormley/subscriptions","organizations_url":"https://api.github.com/users/clintongormley/orgs","repos_url":"https://api.github.com/users/clintongormley/repos","events_url":"https://api.github.com/users/clintongormley/events{/privacy}","received_events_url":"https://api.github.com/users/clintongormley/received_events","type":"User","site_admin":false},"created_at":"2014-10-21T08:08:16Z","updated_at":"2014-10-21T08:08:16Z","author_association":"CONTRIBUTOR","body":"Wondering if it would be possible to take parent-level filters into account within the child queries. For instance, imagine you have a filter on the parent which matches only 1% of your parents, but the `has_child` query/filter matches 90% of your docs.  Currently, the `has_child` clause can't take advantage of the parent-level filter and so has to match all 90% of parents regardless.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/60154807","html_url":"https://github.com/elastic/elasticsearch/issues/8134#issuecomment-60154807","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/8134","id":60154807,"node_id":"MDEyOklzc3VlQ29tbWVudDYwMTU0ODA3","user":{"login":"gmenegatti","id":2567095,"node_id":"MDQ6VXNlcjI1NjcwOTU=","avatar_url":"https://avatars1.githubusercontent.com/u/2567095?v=4","gravatar_id":"","url":"https://api.github.com/users/gmenegatti","html_url":"https://github.com/gmenegatti","followers_url":"https://api.github.com/users/gmenegatti/followers","following_url":"https://api.github.com/users/gmenegatti/following{/other_user}","gists_url":"https://api.github.com/users/gmenegatti/gists{/gist_id}","starred_url":"https://api.github.com/users/gmenegatti/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/gmenegatti/subscriptions","organizations_url":"https://api.github.com/users/gmenegatti/orgs","repos_url":"https://api.github.com/users/gmenegatti/repos","events_url":"https://api.github.com/users/gmenegatti/events{/privacy}","received_events_url":"https://api.github.com/users/gmenegatti/received_events","type":"User","site_admin":false},"created_at":"2014-10-22T21:02:36Z","updated_at":"2014-10-22T21:03:28Z","author_association":"NONE","body":"+1 one million times @martijnvg @clintongormley \nFor a company like ours that currently has more than 500 million parents and in few months around 60 billion children, and where the goal is to count and filter the number of parent based on some data that is stored on the child, this is definitely important.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/60474697","html_url":"https://github.com/elastic/elasticsearch/issues/8134#issuecomment-60474697","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/8134","id":60474697,"node_id":"MDEyOklzc3VlQ29tbWVudDYwNDc0Njk3","user":{"login":"iddoav","id":7713579,"node_id":"MDQ6VXNlcjc3MTM1Nzk=","avatar_url":"https://avatars3.githubusercontent.com/u/7713579?v=4","gravatar_id":"","url":"https://api.github.com/users/iddoav","html_url":"https://github.com/iddoav","followers_url":"https://api.github.com/users/iddoav/followers","following_url":"https://api.github.com/users/iddoav/following{/other_user}","gists_url":"https://api.github.com/users/iddoav/gists{/gist_id}","starred_url":"https://api.github.com/users/iddoav/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/iddoav/subscriptions","organizations_url":"https://api.github.com/users/iddoav/orgs","repos_url":"https://api.github.com/users/iddoav/repos","events_url":"https://api.github.com/users/iddoav/events{/privacy}","received_events_url":"https://api.github.com/users/iddoav/received_events","type":"User","site_admin":false},"created_at":"2014-10-25T07:35:00Z","updated_at":"2014-10-25T07:35:00Z","author_association":"NONE","body":"The optimization @clintongormley suggests would be very beneficial for our use-cases in Totango. Probably also @martijnvg's. Currently, the latency for such queries is not acceptable product-wise, and we'll have to work around with ugly denormalization. What we really want, is to have the parent-child queries to work faster. So, I am happy that you're pushing for it.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/71894256","html_url":"https://github.com/elastic/elasticsearch/issues/8134#issuecomment-71894256","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/8134","id":71894256,"node_id":"MDEyOklzc3VlQ29tbWVudDcxODk0MjU2","user":{"login":"RossLieberman","id":4537661,"node_id":"MDQ6VXNlcjQ1Mzc2NjE=","avatar_url":"https://avatars2.githubusercontent.com/u/4537661?v=4","gravatar_id":"","url":"https://api.github.com/users/RossLieberman","html_url":"https://github.com/RossLieberman","followers_url":"https://api.github.com/users/RossLieberman/followers","following_url":"https://api.github.com/users/RossLieberman/following{/other_user}","gists_url":"https://api.github.com/users/RossLieberman/gists{/gist_id}","starred_url":"https://api.github.com/users/RossLieberman/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/RossLieberman/subscriptions","organizations_url":"https://api.github.com/users/RossLieberman/orgs","repos_url":"https://api.github.com/users/RossLieberman/repos","events_url":"https://api.github.com/users/RossLieberman/events{/privacy}","received_events_url":"https://api.github.com/users/RossLieberman/received_events","type":"User","site_admin":false},"created_at":"2015-01-28T19:03:13Z","updated_at":"2015-01-28T19:03:13Z","author_association":"NONE","body":"I too ran into the issue described in #5116 using rescore with has_child. Performing the query X times for each set of rescore works and is the difference between 60ms (each rescore) versus 10,000ms for my data, but it would be more ideal to just use the parent's data set during rescore or even better if function_score in the original query supported summing child document values to generate the score on each node before combining on the cluster.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/74222649","html_url":"https://github.com/elastic/elasticsearch/issues/8134#issuecomment-74222649","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/8134","id":74222649,"node_id":"MDEyOklzc3VlQ29tbWVudDc0MjIyNjQ5","user":{"login":"jpountz","id":299848,"node_id":"MDQ6VXNlcjI5OTg0OA==","avatar_url":"https://avatars2.githubusercontent.com/u/299848?v=4","gravatar_id":"","url":"https://api.github.com/users/jpountz","html_url":"https://github.com/jpountz","followers_url":"https://api.github.com/users/jpountz/followers","following_url":"https://api.github.com/users/jpountz/following{/other_user}","gists_url":"https://api.github.com/users/jpountz/gists{/gist_id}","starred_url":"https://api.github.com/users/jpountz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jpountz/subscriptions","organizations_url":"https://api.github.com/users/jpountz/orgs","repos_url":"https://api.github.com/users/jpountz/repos","events_url":"https://api.github.com/users/jpountz/events{/privacy}","received_events_url":"https://api.github.com/users/jpountz/received_events","type":"User","site_admin":false},"created_at":"2015-02-13T08:51:47Z","updated_at":"2015-02-13T08:51:47Z","author_association":"CONTRIBUTOR","body":"I tried to think more about it and essentially:\n1. the current design has the issue that queries are not cacheable per segment because whether a document matches a document depends on what happens in other segments as well\n2. as a work-around, we could run the first phase (collecting ids) in the query parser and then return a query for the second phase (which would essentially be a fielddata terms filter with scores for each term). However this query would be specific to a given index searcher and it would not work for things that want to keep queries alive for a long time like filtered aliases or the percolator\n3. using a different abstraction is tempting, but then you could only use parent/child queries as top-level queries (ie. no more nesting in boolean queries)\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/74225371","html_url":"https://github.com/elastic/elasticsearch/issues/8134#issuecomment-74225371","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/8134","id":74225371,"node_id":"MDEyOklzc3VlQ29tbWVudDc0MjI1Mzcx","user":{"login":"martijnvg","id":580421,"node_id":"MDQ6VXNlcjU4MDQyMQ==","avatar_url":"https://avatars3.githubusercontent.com/u/580421?v=4","gravatar_id":"","url":"https://api.github.com/users/martijnvg","html_url":"https://github.com/martijnvg","followers_url":"https://api.github.com/users/martijnvg/followers","following_url":"https://api.github.com/users/martijnvg/following{/other_user}","gists_url":"https://api.github.com/users/martijnvg/gists{/gist_id}","starred_url":"https://api.github.com/users/martijnvg/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/martijnvg/subscriptions","organizations_url":"https://api.github.com/users/martijnvg/orgs","repos_url":"https://api.github.com/users/martijnvg/repos","events_url":"https://api.github.com/users/martijnvg/events{/privacy}","received_events_url":"https://api.github.com/users/martijnvg/received_events","type":"User","site_admin":false},"created_at":"2015-02-13T09:17:15Z","updated_at":"2015-02-13T09:17:15Z","author_association":"MEMBER","body":"@jpountz I think that option 2 is fair. The terms collected in phase1 are always tied to a given IndexSearch/DirectoryReader, so if that changes the collected terms are invalid. I think for the percolator we should forbid the usage of parent/child queries.\n\nWhat I also wanted to tackle with this issue is making parent/child queries smarter in terms of execution. Currently most of the times parent/child queries need either evaluate all parent or children documents (depending on whether `has_child` or `has_parent` is used) if there is a match with the inner query, which is unneeded because usually parent/child queries are part of a bigger query and therefor not all parents/children will ever match. \n\nThe best thing I can come up with is to make the parent/child queries execute lazily. So for example if a parent document matches with all other queries we push it to has_child and check it has a child document and if it matches with the inner query. Maybe we need to buffer all matching parent docs in order to make this efficient. The easiest place this approach could be applied is if has_child was defined as a post filter.  If has_child was defined in a bool query in the main query applying this approach is trickier, because of how the query execution works at the moment.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/75215043","html_url":"https://github.com/elastic/elasticsearch/issues/8134#issuecomment-75215043","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/8134","id":75215043,"node_id":"MDEyOklzc3VlQ29tbWVudDc1MjE1MDQz","user":{"login":"jpountz","id":299848,"node_id":"MDQ6VXNlcjI5OTg0OA==","avatar_url":"https://avatars2.githubusercontent.com/u/299848?v=4","gravatar_id":"","url":"https://api.github.com/users/jpountz","html_url":"https://github.com/jpountz","followers_url":"https://api.github.com/users/jpountz/followers","following_url":"https://api.github.com/users/jpountz/following{/other_user}","gists_url":"https://api.github.com/users/jpountz/gists{/gist_id}","starred_url":"https://api.github.com/users/jpountz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jpountz/subscriptions","organizations_url":"https://api.github.com/users/jpountz/orgs","repos_url":"https://api.github.com/users/jpountz/repos","events_url":"https://api.github.com/users/jpountz/events{/privacy}","received_events_url":"https://api.github.com/users/jpountz/received_events","type":"User","site_admin":false},"created_at":"2015-02-20T10:06:44Z","updated_at":"2015-02-20T10:06:44Z","author_association":"CONTRIBUTOR","body":"> The best thing I can come up with is to make the parent/child queries execute lazily. So for example if a parent document matches with all other queries we push it to has_child and check it has a child document and if it matches with the inner query.\n\nI believe this could be done with two-phase iteration that has been introduced in Lucene 5.1: https://issues.apache.org/jira/browse/LUCENE-6198\n\nWe just discussed this issue a bit more and agreed on the following points:\n- the limitations of option 2 are fair (no use in filtered aliases or the percolator)\n- we need to move the infrastructure to Lucene\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/75464977","html_url":"https://github.com/elastic/elasticsearch/issues/8134#issuecomment-75464977","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/8134","id":75464977,"node_id":"MDEyOklzc3VlQ29tbWVudDc1NDY0OTc3","user":{"login":"martijnvg","id":580421,"node_id":"MDQ6VXNlcjU4MDQyMQ==","avatar_url":"https://avatars3.githubusercontent.com/u/580421?v=4","gravatar_id":"","url":"https://api.github.com/users/martijnvg","html_url":"https://github.com/martijnvg","followers_url":"https://api.github.com/users/martijnvg/followers","following_url":"https://api.github.com/users/martijnvg/following{/other_user}","gists_url":"https://api.github.com/users/martijnvg/gists{/gist_id}","starred_url":"https://api.github.com/users/martijnvg/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/martijnvg/subscriptions","organizations_url":"https://api.github.com/users/martijnvg/orgs","repos_url":"https://api.github.com/users/martijnvg/repos","events_url":"https://api.github.com/users/martijnvg/events{/privacy}","received_events_url":"https://api.github.com/users/martijnvg/received_events","type":"User","site_admin":false},"created_at":"2015-02-22T21:54:37Z","updated_at":"2015-02-22T21:54:37Z","author_association":"MEMBER","body":"> I believe this could be done with two-phase iteration that has been introduced in Lucene 5.1\n\nCool, with that the second phase matching logic in `has_child` and `has_parent` then only needs to be executed for docs we know that are going to match. This should speed things up significantly.\n\n> we need to move the infrastructure to Lucene\n\n+1 I think we should rewrite the JoinUtil in the join module to do what `has_child` and `has_parent` do. \n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/75992456","html_url":"https://github.com/elastic/elasticsearch/issues/8134#issuecomment-75992456","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/8134","id":75992456,"node_id":"MDEyOklzc3VlQ29tbWVudDc1OTkyNDU2","user":{"login":"rmuir","id":504194,"node_id":"MDQ6VXNlcjUwNDE5NA==","avatar_url":"https://avatars1.githubusercontent.com/u/504194?v=4","gravatar_id":"","url":"https://api.github.com/users/rmuir","html_url":"https://github.com/rmuir","followers_url":"https://api.github.com/users/rmuir/followers","following_url":"https://api.github.com/users/rmuir/following{/other_user}","gists_url":"https://api.github.com/users/rmuir/gists{/gist_id}","starred_url":"https://api.github.com/users/rmuir/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/rmuir/subscriptions","organizations_url":"https://api.github.com/users/rmuir/orgs","repos_url":"https://api.github.com/users/rmuir/repos","events_url":"https://api.github.com/users/rmuir/events{/privacy}","received_events_url":"https://api.github.com/users/rmuir/received_events","type":"User","site_admin":false},"created_at":"2015-02-25T16:27:20Z","updated_at":"2015-02-25T16:27:35Z","author_association":"CONTRIBUTOR","body":"+1 this sounds great.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/99554133","html_url":"https://github.com/elastic/elasticsearch/issues/8134#issuecomment-99554133","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/8134","id":99554133,"node_id":"MDEyOklzc3VlQ29tbWVudDk5NTU0MTMz","user":{"login":"pauleil","id":313140,"node_id":"MDQ6VXNlcjMxMzE0MA==","avatar_url":"https://avatars2.githubusercontent.com/u/313140?v=4","gravatar_id":"","url":"https://api.github.com/users/pauleil","html_url":"https://github.com/pauleil","followers_url":"https://api.github.com/users/pauleil/followers","following_url":"https://api.github.com/users/pauleil/following{/other_user}","gists_url":"https://api.github.com/users/pauleil/gists{/gist_id}","starred_url":"https://api.github.com/users/pauleil/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/pauleil/subscriptions","organizations_url":"https://api.github.com/users/pauleil/orgs","repos_url":"https://api.github.com/users/pauleil/repos","events_url":"https://api.github.com/users/pauleil/events{/privacy}","received_events_url":"https://api.github.com/users/pauleil/received_events","type":"User","site_admin":false},"created_at":"2015-05-06T18:02:31Z","updated_at":"2015-05-06T18:02:31Z","author_association":"NONE","body":"What are your plans on this task? Asking because it blocks #2917, which (at least for us) would save an enormous amount of effort and maintenance involved in roundabout solutions.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/106325506","html_url":"https://github.com/elastic/elasticsearch/issues/8134#issuecomment-106325506","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/8134","id":106325506,"node_id":"MDEyOklzc3VlQ29tbWVudDEwNjMyNTUwNg==","user":{"login":"pauleil","id":313140,"node_id":"MDQ6VXNlcjMxMzE0MA==","avatar_url":"https://avatars2.githubusercontent.com/u/313140?v=4","gravatar_id":"","url":"https://api.github.com/users/pauleil","html_url":"https://github.com/pauleil","followers_url":"https://api.github.com/users/pauleil/followers","following_url":"https://api.github.com/users/pauleil/following{/other_user}","gists_url":"https://api.github.com/users/pauleil/gists{/gist_id}","starred_url":"https://api.github.com/users/pauleil/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/pauleil/subscriptions","organizations_url":"https://api.github.com/users/pauleil/orgs","repos_url":"https://api.github.com/users/pauleil/repos","events_url":"https://api.github.com/users/pauleil/events{/privacy}","received_events_url":"https://api.github.com/users/pauleil/received_events","type":"User","site_admin":false},"created_at":"2015-05-28T14:01:24Z","updated_at":"2015-05-28T14:01:24Z","author_association":"NONE","body":"Does your commit mean that you've solved this? If so, that's really great.\n","performed_via_github_app":null}]