{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/62246","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/62246/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/62246/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/62246/events","html_url":"https://github.com/elastic/elasticsearch/issues/62246","id":698274034,"node_id":"MDU6SXNzdWU2OTgyNzQwMzQ=","number":62246,"title":"Mixing regexp-based and set-based include and exclude in *Terms aggregations","user":{"login":"hchargois","id":535234,"node_id":"MDQ6VXNlcjUzNTIzNA==","avatar_url":"https://avatars1.githubusercontent.com/u/535234?v=4","gravatar_id":"","url":"https://api.github.com/users/hchargois","html_url":"https://github.com/hchargois","followers_url":"https://api.github.com/users/hchargois/followers","following_url":"https://api.github.com/users/hchargois/following{/other_user}","gists_url":"https://api.github.com/users/hchargois/gists{/gist_id}","starred_url":"https://api.github.com/users/hchargois/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hchargois/subscriptions","organizations_url":"https://api.github.com/users/hchargois/orgs","repos_url":"https://api.github.com/users/hchargois/repos","events_url":"https://api.github.com/users/hchargois/events{/privacy}","received_events_url":"https://api.github.com/users/hchargois/received_events","type":"User","site_admin":false},"labels":[{"id":141141324,"node_id":"MDU6TGFiZWwxNDExNDEzMjQ=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/:Analytics/Aggregations","name":":Analytics/Aggregations","color":"0e8a16","default":false,"description":"Aggregations"},{"id":1967499105,"node_id":"MDU6TGFiZWwxOTY3NDk5MTA1","url":"https://api.github.com/repos/elastic/elasticsearch/labels/Team:Analytics","name":"Team:Analytics","color":"fef2c0","default":false,"description":"Meta label for analytics/geo team"}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":5,"created_at":"2020-09-10T17:30:54Z","updated_at":"2020-11-11T20:50:33Z","closed_at":"2020-11-11T20:50:33Z","author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"# Background\r\n\r\nThe Terms, Significant Terms and Rare Terms aggregations support the `include` and `exclude` options to filter the buckets via either:\r\n\r\n* a single regexp e.g. `\"this.*|that.*\"`\r\n* a list of exact terms e.g. `[\"thisTerm\", \"thatTerm\"]`\r\n\r\nYou can give both an `include` and an `exclude` at the same time, but they have to be the same type, both regexp-based or set-based. If you mix and match, you get an error (and this is not documented BTW).\r\n\r\n```\r\n        \"reason\": \"[8:34] [terms] failed to parse field [include]\",\r\n        \"caused_by\": {\r\n            \"type\": \"illegal_argument_exception\",\r\n            \"reason\": \"Cannot mix a set-based include with a regex-based method\"\r\n        }\r\n```\r\n\r\n# The problem\r\n\r\nThe problem we faced is that we need both a regexp-based include and a set-based exclude. We thought about converting the set-based exclude into a regexp-based exclude so that both could be regexps, like so:\r\n\r\n    [\"term1\", \"term2\", \"term3\"] -> \"term1|term2|term3\"\r\n\r\nAnd obviously both give exactly the same buckets in the aggregation... But the performance is way worse with the regexp.\r\n\r\nTo give an idea of how worse the performance is, this is the performance of a typical aggregation that we can make on our index (to allow testing and comparing both set and regexp, I removed any include parameter):\r\n\r\n* without exclude: ~300 ms\r\n* with a set-based exclude containing 100 terms: ~500 ms\r\n* with a regexp-based exclude containing the same 100 terms: ~10 s\r\n\r\nSo, while setting a set-based exclude is just a bit slower than no exclude, the regexp-based exclude is *20 times slower* than the set-based one. We can't afford that kind of performance unfortunately.\r\n\r\n# The proposed solution\r\n\r\nWe would like to lift that limitation about having to use the same type of include and exclude. We want to be able to mix and match both kinds of include with both kinds of exclude. That way, we could use a regexp when we need the flexibility of one, and use a set when we can, to keep performance high.\r\n\r\nI've seen the relevant code (`server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/IncludeExclude.java`) and just by a bit of refactoring in this file, I've been able to make a proof of concept that achieves that goal. I've confirmed that mixing a regexp and set give the performance we expect, which is much faster that two regexps.\r\n\r\nSo, I'm opening this issue to gather feedback before hopefully getting the green light to implement this properly in a pull request.","closed_by":{"login":"polyfractal","id":1224228,"node_id":"MDQ6VXNlcjEyMjQyMjg=","avatar_url":"https://avatars1.githubusercontent.com/u/1224228?v=4","gravatar_id":"","url":"https://api.github.com/users/polyfractal","html_url":"https://github.com/polyfractal","followers_url":"https://api.github.com/users/polyfractal/followers","following_url":"https://api.github.com/users/polyfractal/following{/other_user}","gists_url":"https://api.github.com/users/polyfractal/gists{/gist_id}","starred_url":"https://api.github.com/users/polyfractal/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/polyfractal/subscriptions","organizations_url":"https://api.github.com/users/polyfractal/orgs","repos_url":"https://api.github.com/users/polyfractal/repos","events_url":"https://api.github.com/users/polyfractal/events{/privacy}","received_events_url":"https://api.github.com/users/polyfractal/received_events","type":"User","site_admin":false},"performed_via_github_app":null}