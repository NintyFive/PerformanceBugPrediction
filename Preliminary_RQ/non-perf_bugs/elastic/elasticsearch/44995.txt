{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/44995","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/44995/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/44995/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/44995/events","html_url":"https://github.com/elastic/elasticsearch/issues/44995","id":474442127,"node_id":"MDU6SXNzdWU0NzQ0NDIxMjc=","number":44995,"title":"Optimize Encoding of Action Type in Network Protocol","user":{"login":"original-brownbear","id":6490959,"node_id":"MDQ6VXNlcjY0OTA5NTk=","avatar_url":"https://avatars0.githubusercontent.com/u/6490959?v=4","gravatar_id":"","url":"https://api.github.com/users/original-brownbear","html_url":"https://github.com/original-brownbear","followers_url":"https://api.github.com/users/original-brownbear/followers","following_url":"https://api.github.com/users/original-brownbear/following{/other_user}","gists_url":"https://api.github.com/users/original-brownbear/gists{/gist_id}","starred_url":"https://api.github.com/users/original-brownbear/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/original-brownbear/subscriptions","organizations_url":"https://api.github.com/users/original-brownbear/orgs","repos_url":"https://api.github.com/users/original-brownbear/repos","events_url":"https://api.github.com/users/original-brownbear/events{/privacy}","received_events_url":"https://api.github.com/users/original-brownbear/received_events","type":"User","site_admin":false},"labels":[{"id":146854632,"node_id":"MDU6TGFiZWwxNDY4NTQ2MzI=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/:Distributed/Network","name":":Distributed/Network","color":"0e8a16","default":false,"description":"Http and internode communication implementations"},{"id":23174,"node_id":"MDU6TGFiZWwyMzE3NA==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/%3Eenhancement","name":">enhancement","color":"4a4ea8","default":false,"description":null}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":4,"created_at":"2019-07-30T08:20:13Z","updated_at":"2019-07-31T14:03:01Z","closed_at":"2019-07-31T13:59:39Z","author_association":"MEMBER","active_lock_reason":null,"body":"Our current network protocol is pretty inefficient when it comes to encoding the \"action\" which tends to require upwards of 20 bytes in every message. This could be way optimized by having two nodes negotiate all the actions on handshake (which looks like it does only require exchanging the version for all core actions). \r\nWhy not just encode the action as a 32bit `int`?\r\nSince the core actions seem to fit into 9 bits (rough count only admittedly, but it seems it's fewer than 300), the remaining 23 bits in an `int` could just be made available to plugins like xpack to encode their actions. In the handshake between two nodes the nodes could simply exchange which relevant plugins they use and the offsets in the int for those plugins.\r\nSo e.g. if two nodes used two plugins, one (X) with 8 actions and another (Y) with 20 actions and ES core had 300 actions registered with the transport: \r\n* The initiator in a handshake could just sent the map `X: 1, Y: 9` to communicate that 301 is the first action in plugin X and e.g. 312 would be the 4th action in the action `int`.\r\n\r\nI think there's a number of advantages to this:\r\n* This would save ~ 16 bytes or more per message (action names tend to be 20 bytes(ish))\r\n  * This could also be used for further optimizations. There isn't really much point in all the objects we create on the IO loop in `org.elasticsearch.transport.InboundMessage.Reader#deserialize` and the code around it\r\n* We wouldn't have to read and instantiate a `String` for every message and look it up from a map to get the transport handler for a message. Instead we could just look up the actions from an array in the `TransportService`and not touch most of the bytes in a message on the IO loop or allocate anything before deciding what to do with a message.\r\n\r\nSince all the action resolving happens on the IO thread, this might be worth it?","closed_by":{"login":"original-brownbear","id":6490959,"node_id":"MDQ6VXNlcjY0OTA5NTk=","avatar_url":"https://avatars0.githubusercontent.com/u/6490959?v=4","gravatar_id":"","url":"https://api.github.com/users/original-brownbear","html_url":"https://github.com/original-brownbear","followers_url":"https://api.github.com/users/original-brownbear/followers","following_url":"https://api.github.com/users/original-brownbear/following{/other_user}","gists_url":"https://api.github.com/users/original-brownbear/gists{/gist_id}","starred_url":"https://api.github.com/users/original-brownbear/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/original-brownbear/subscriptions","organizations_url":"https://api.github.com/users/original-brownbear/orgs","repos_url":"https://api.github.com/users/original-brownbear/repos","events_url":"https://api.github.com/users/original-brownbear/events{/privacy}","received_events_url":"https://api.github.com/users/original-brownbear/received_events","type":"User","site_admin":false},"performed_via_github_app":null}