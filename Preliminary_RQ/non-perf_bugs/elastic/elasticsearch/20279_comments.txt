[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/244036895","html_url":"https://github.com/elastic/elasticsearch/issues/20279#issuecomment-244036895","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/20279","id":244036895,"node_id":"MDEyOklzc3VlQ29tbWVudDI0NDAzNjg5NQ==","user":{"login":"bleskes","id":1006375,"node_id":"MDQ6VXNlcjEwMDYzNzU=","avatar_url":"https://avatars1.githubusercontent.com/u/1006375?v=4","gravatar_id":"","url":"https://api.github.com/users/bleskes","html_url":"https://github.com/bleskes","followers_url":"https://api.github.com/users/bleskes/followers","following_url":"https://api.github.com/users/bleskes/following{/other_user}","gists_url":"https://api.github.com/users/bleskes/gists{/gist_id}","starred_url":"https://api.github.com/users/bleskes/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bleskes/subscriptions","organizations_url":"https://api.github.com/users/bleskes/orgs","repos_url":"https://api.github.com/users/bleskes/repos","events_url":"https://api.github.com/users/bleskes/events{/privacy}","received_events_url":"https://api.github.com/users/bleskes/received_events","type":"User","site_admin":false},"created_at":"2016-09-01T10:15:47Z","updated_at":"2016-09-01T10:15:47Z","author_association":"MEMBER","body":"one more note - when converting an index name to an `Index` instances, we always have to wait in the case the index is not there. The reason is that, sadly,  a create index operation can finish successfully without all nodes knowing about it. Since we can then accept a follow up indexing request on arbitrary nodes, which should also give a chance for lagging cluster state to arrive. Practically this means that TransportIndexAction and friends need to wait also when they don't create a missing index . I expect this to be a common pattern when we move all index resolving to the rest layer (once the transport client has been removed, so there is time...)\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/372880304","html_url":"https://github.com/elastic/elasticsearch/issues/20279#issuecomment-372880304","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/20279","id":372880304,"node_id":"MDEyOklzc3VlQ29tbWVudDM3Mjg4MDMwNA==","user":{"login":"elasticmachine","id":15837671,"node_id":"MDQ6VXNlcjE1ODM3Njcx","avatar_url":"https://avatars3.githubusercontent.com/u/15837671?v=4","gravatar_id":"","url":"https://api.github.com/users/elasticmachine","html_url":"https://github.com/elasticmachine","followers_url":"https://api.github.com/users/elasticmachine/followers","following_url":"https://api.github.com/users/elasticmachine/following{/other_user}","gists_url":"https://api.github.com/users/elasticmachine/gists{/gist_id}","starred_url":"https://api.github.com/users/elasticmachine/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/elasticmachine/subscriptions","organizations_url":"https://api.github.com/users/elasticmachine/orgs","repos_url":"https://api.github.com/users/elasticmachine/repos","events_url":"https://api.github.com/users/elasticmachine/events{/privacy}","received_events_url":"https://api.github.com/users/elasticmachine/received_events","type":"User","site_admin":false},"created_at":"2018-03-14T02:06:04Z","updated_at":"2018-03-14T02:06:04Z","author_association":"COLLABORATOR","body":"Pinging @elastic/es-distributed","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/559437995","html_url":"https://github.com/elastic/elasticsearch/issues/20279#issuecomment-559437995","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/20279","id":559437995,"node_id":"MDEyOklzc3VlQ29tbWVudDU1OTQzNzk5NQ==","user":{"login":"ywelsch","id":3718355,"node_id":"MDQ6VXNlcjM3MTgzNTU=","avatar_url":"https://avatars3.githubusercontent.com/u/3718355?v=4","gravatar_id":"","url":"https://api.github.com/users/ywelsch","html_url":"https://github.com/ywelsch","followers_url":"https://api.github.com/users/ywelsch/followers","following_url":"https://api.github.com/users/ywelsch/following{/other_user}","gists_url":"https://api.github.com/users/ywelsch/gists{/gist_id}","starred_url":"https://api.github.com/users/ywelsch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ywelsch/subscriptions","organizations_url":"https://api.github.com/users/ywelsch/orgs","repos_url":"https://api.github.com/users/ywelsch/repos","events_url":"https://api.github.com/users/ywelsch/events{/privacy}","received_events_url":"https://api.github.com/users/ywelsch/received_events","type":"User","site_admin":false},"created_at":"2019-11-28T10:33:03Z","updated_at":"2019-11-28T10:33:03Z","author_association":"CONTRIBUTOR","body":"> Require ReplicationRequests to have a complete ShardId when they get to the reroute phase in TRA.\r\n\r\nAddressed by #40424\r\n\r\n> Fail immediately when that shard id can not be resolved.\r\n\r\nThere's no resolving anymore of the shard id in TRA\r\n\r\n> Change TransportIndexAction and similar write actions to resolve the incoming requests and set their proper shard id (with index uuid). If they need to create the index, they can go ahead, but then it's up to them to also wait until the current (data) node, knows about the index that was just created. We can have a shared utility method for this on AutoCreateIndex\r\n\r\nThis is taken care of by TransportBulkAction now.\r\n\r\nRemaining points addressed by #49647\r\n","performed_via_github_app":null}]