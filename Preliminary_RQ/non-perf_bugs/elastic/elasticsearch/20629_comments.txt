[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/248860383","html_url":"https://github.com/elastic/elasticsearch/issues/20629#issuecomment-248860383","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/20629","id":248860383,"node_id":"MDEyOklzc3VlQ29tbWVudDI0ODg2MDM4Mw==","user":{"login":"nik9000","id":215970,"node_id":"MDQ6VXNlcjIxNTk3MA==","avatar_url":"https://avatars2.githubusercontent.com/u/215970?v=4","gravatar_id":"","url":"https://api.github.com/users/nik9000","html_url":"https://github.com/nik9000","followers_url":"https://api.github.com/users/nik9000/followers","following_url":"https://api.github.com/users/nik9000/following{/other_user}","gists_url":"https://api.github.com/users/nik9000/gists{/gist_id}","starred_url":"https://api.github.com/users/nik9000/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/nik9000/subscriptions","organizations_url":"https://api.github.com/users/nik9000/orgs","repos_url":"https://api.github.com/users/nik9000/repos","events_url":"https://api.github.com/users/nik9000/events{/privacy}","received_events_url":"https://api.github.com/users/nik9000/received_events","type":"User","site_admin":false},"created_at":"2016-09-22T10:04:16Z","updated_at":"2016-09-22T10:04:16Z","author_association":"CONTRIBUTOR","body":"On problem with just using equals is that it can be difficult to find the\ndifference. I'm not really sure what to do about that though, but I figure\nthis is a place to bring it up.\n\nOn Sep 22, 2016 5:52 AM, \"Christoph Büscher\" notifications@github.com\nwrote:\n\n> For the query refactoring we started testing equals()/hashCode() contracts\n> for the query builders in a central abstract base test\n> https://github.com/elastic/elasticsearch/blob/master/test/framework/src/main/java/org/elasticsearch/test/AbstractQueryTestCase.java#L725,\n> assuming the test can use some helper methods to e.g. make deep copies of\n> objects via serialization. We have similar tests e.g. in\n> BaseAggregationTestCase and for several other parts of the search request\n> (e.g. the SuggestBuilderTests via the abstract WritableTestCase,\n> AbstractShapeBuilderTestCase). We also started doing those kind of tests in\n> a helper class now in the rank_eval module, which triggered the discussion\n> if we should make an effort to centralize this.\n> \n> While putting this kind of basic equals/hashCode tests into abstract\n> superclasses works for test of similar classes (e.g. all queries), it is a\n> bit tricky to generalize this easily and makes the test inheritance\n> structure hard and tests sometimes difficult to read. On the other hand,\n> having this kind of tests clearly documented in some central test utility\n> class would make reusing it more straight forward and avoid the duplication\n> we have today. I'm leaning towards not inheriting this kind of testing code\n> but rather have some utility function somewhere that e.g. takes the\n> original object, some function that returns a deep copy and a function that\n> returns a mutation (an instance different in only one aspect) as arguments\n> and does all the assertions necessary. This way it can be used by different\n> tests without the burden of having to inherit various levels of abstract\n> base test classes.\n> \n> —\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> https://github.com/elastic/elasticsearch/issues/20629, or mute the\n> thread\n> https://github.com/notifications/unsubscribe-auth/AANLol4mCh5zrOhXfOT54sSl4RRrrrKGks5qsk_PgaJpZM4KDtf1\n> .\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/248909635","html_url":"https://github.com/elastic/elasticsearch/issues/20629#issuecomment-248909635","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/20629","id":248909635,"node_id":"MDEyOklzc3VlQ29tbWVudDI0ODkwOTYzNQ==","user":{"login":"javanna","id":832460,"node_id":"MDQ6VXNlcjgzMjQ2MA==","avatar_url":"https://avatars1.githubusercontent.com/u/832460?v=4","gravatar_id":"","url":"https://api.github.com/users/javanna","html_url":"https://github.com/javanna","followers_url":"https://api.github.com/users/javanna/followers","following_url":"https://api.github.com/users/javanna/following{/other_user}","gists_url":"https://api.github.com/users/javanna/gists{/gist_id}","starred_url":"https://api.github.com/users/javanna/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/javanna/subscriptions","organizations_url":"https://api.github.com/users/javanna/orgs","repos_url":"https://api.github.com/users/javanna/repos","events_url":"https://api.github.com/users/javanna/events{/privacy}","received_events_url":"https://api.github.com/users/javanna/received_events","type":"User","site_admin":false},"created_at":"2016-09-22T13:53:02Z","updated_at":"2016-09-22T13:53:09Z","author_association":"MEMBER","body":"++ on this I wondered the same as well looking at the repetition. Most of it can be eliminated I think.\n\n> On problem with just using equals is that it can be difficult to find the\n> difference. I'm not really sure what to do about that though, but I figure\n> this is a place to bring it up.\n\nVery true, the tests that we have now around equals and hashcode are not perfect. Testing that something is not equal to something else requires writing code to change some original instance of the object. In many cases we don't do it and we only verify that unmodified objects remain equal (and hashcode is the same) even after serialization, that is the part that can be generified.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/253903317","html_url":"https://github.com/elastic/elasticsearch/issues/20629#issuecomment-253903317","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/20629","id":253903317,"node_id":"MDEyOklzc3VlQ29tbWVudDI1MzkwMzMxNw==","user":{"login":"cbuescher","id":10398885,"node_id":"MDQ6VXNlcjEwMzk4ODg1","avatar_url":"https://avatars0.githubusercontent.com/u/10398885?v=4","gravatar_id":"","url":"https://api.github.com/users/cbuescher","html_url":"https://github.com/cbuescher","followers_url":"https://api.github.com/users/cbuescher/followers","following_url":"https://api.github.com/users/cbuescher/following{/other_user}","gists_url":"https://api.github.com/users/cbuescher/gists{/gist_id}","starred_url":"https://api.github.com/users/cbuescher/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cbuescher/subscriptions","organizations_url":"https://api.github.com/users/cbuescher/orgs","repos_url":"https://api.github.com/users/cbuescher/repos","events_url":"https://api.github.com/users/cbuescher/events{/privacy}","received_events_url":"https://api.github.com/users/cbuescher/received_events","type":"User","site_admin":false},"created_at":"2016-10-14T19:51:58Z","updated_at":"2016-10-14T19:51:58Z","author_association":"MEMBER","body":"@nik9000 @javanna I opened a PR for this, there are a lot of tests that can use this. It works also for cases where we don't check that a modified object is not equal to its original, in that case this part of the test is skipped. However, I left TODOs where we should add this to the existing test (basically all QueryBuilders, Aggregations etc...)\n","performed_via_github_app":null}]