[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/56875834","html_url":"https://github.com/elastic/elasticsearch/issues/7805#issuecomment-56875834","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/7805","id":56875834,"node_id":"MDEyOklzc3VlQ29tbWVudDU2ODc1ODM0","user":{"login":"clintongormley","id":56599,"node_id":"MDQ6VXNlcjU2NTk5","avatar_url":"https://avatars0.githubusercontent.com/u/56599?v=4","gravatar_id":"","url":"https://api.github.com/users/clintongormley","html_url":"https://github.com/clintongormley","followers_url":"https://api.github.com/users/clintongormley/followers","following_url":"https://api.github.com/users/clintongormley/following{/other_user}","gists_url":"https://api.github.com/users/clintongormley/gists{/gist_id}","starred_url":"https://api.github.com/users/clintongormley/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/clintongormley/subscriptions","organizations_url":"https://api.github.com/users/clintongormley/orgs","repos_url":"https://api.github.com/users/clintongormley/repos","events_url":"https://api.github.com/users/clintongormley/events{/privacy}","received_events_url":"https://api.github.com/users/clintongormley/received_events","type":"User","site_admin":false},"created_at":"2014-09-25T20:07:32Z","updated_at":"2014-09-25T20:07:32Z","author_association":"CONTRIBUTOR","body":"Hi @rbnacharya \n\nYour agg should use another `nested` agg to step down into the grandchild, eg:\n\n```\nPOST /x1/x4/_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"rating\": {\n      \"nested\": {\n        \"path\": \"playerYears\"\n      },\n      \"aggs\": {\n        \"rating-filtered\": {\n          \"nested\": {\n            \"path\": \"playerYears.schoolsOfInterest\"\n          }\n        }\n      }\n    }\n  },\n  \"query\": {\n    \"match_all\": {}\n  }\n}\n```\n\nThat said, I can see why you would think that your example should work. \n\n@martijnvg any thoughts about this?\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/69569924","html_url":"https://github.com/elastic/elasticsearch/issues/7805#issuecomment-69569924","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/7805","id":69569924,"node_id":"MDEyOklzc3VlQ29tbWVudDY5NTY5OTI0","user":{"login":"martijnvg","id":580421,"node_id":"MDQ6VXNlcjU4MDQyMQ==","avatar_url":"https://avatars3.githubusercontent.com/u/580421?v=4","gravatar_id":"","url":"https://api.github.com/users/martijnvg","html_url":"https://github.com/martijnvg","followers_url":"https://api.github.com/users/martijnvg/followers","following_url":"https://api.github.com/users/martijnvg/following{/other_user}","gists_url":"https://api.github.com/users/martijnvg/gists{/gist_id}","starred_url":"https://api.github.com/users/martijnvg/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/martijnvg/subscriptions","organizations_url":"https://api.github.com/users/martijnvg/orgs","repos_url":"https://api.github.com/users/martijnvg/repos","events_url":"https://api.github.com/users/martijnvg/events{/privacy}","received_events_url":"https://api.github.com/users/martijnvg/received_events","type":"User","site_admin":false},"created_at":"2015-01-12T13:34:05Z","updated_at":"2015-01-12T13:34:05Z","author_association":"MEMBER","body":"I would expect that @rbnacharya example to work too, but the issue is that the `nested` filter is unaware of the fact it is wrapped in a `nested` aggregator and therefor assumes it needs to translate the nested hits to root (non nested) hits. The nested query simply doesn't get the context it is in from the `nested` aggregator. This is different then when a `nested` query/filter is wrapped in another `nested` query/filter, in that case the wrapped `nested` query is aware of the fact it is wrapped by a parent `nested` query/filter.\n\nDue to the structure of the `nested` aggregator and the streaming parsing fixing this issue is tricky. One can define the request so that the child agg appears first:\n\n```\n{\n  \"aggs\": {\n    \"rating\": {\n      \"aggs\": {\n        \"rating-filtered\": {\n          \"filter\": {\n            \"nested\": {\n              \"path\": \"playerYears.schoolsOfInterest\",\n              \"query\": {\n                \"match_all\": {}\n              }\n            }\n          }\n        },\n        \"nested\": {\n           \"path\": \"playerYears\"\n        }\n      }\n    }\n  },\n}\n```\n\nSo event if we did pass the nested context to the nested filter in the above case nothing would be passed, because the nested options have not been parsed yet.\n\nI think the example that @clintongormley shared is a clearer way to define what @rbnacharya is after, because that example only makes used of `nested` aggregator and doesn't mix it with `nested` filter. One can still wrap the filter in the `rating-filtered` agg, that uses a term or range filter.\n\nThat said I think the best way to improve here is to add more validation. In this case the nested agg was expecting docs on the `playerYears` level while the nested filter was production root (non nested) documents as hits. ES should fail here, so that it is clear that the query defined is producing incorrect results (instead of returning 0 count as result).\n\nI think this validation should not just be for the nested query/filter, but also for the nested aggregation and nested inner hits. Lets say one wraps two `nested` inner aggregations, but the `path` of the second `nested` aggregator is invalid, because it doesn't fall under the `path` of the first `nested` aggregator, it would good to fail. I'll open an issue for that.\n","performed_via_github_app":null}]