{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/19370","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19370/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19370/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19370/events","html_url":"https://github.com/elastic/elasticsearch/issues/19370","id":164920372,"node_id":"MDU6SXNzdWUxNjQ5MjAzNzI=","number":19370,"title":"Thread leak in TribeNode when a cluster is offline","user":{"login":"escheie","id":1410311,"node_id":"MDQ6VXNlcjE0MTAzMTE=","avatar_url":"https://avatars2.githubusercontent.com/u/1410311?v=4","gravatar_id":"","url":"https://api.github.com/users/escheie","html_url":"https://github.com/escheie","followers_url":"https://api.github.com/users/escheie/followers","following_url":"https://api.github.com/users/escheie/following{/other_user}","gists_url":"https://api.github.com/users/escheie/gists{/gist_id}","starred_url":"https://api.github.com/users/escheie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/escheie/subscriptions","organizations_url":"https://api.github.com/users/escheie/orgs","repos_url":"https://api.github.com/users/escheie/repos","events_url":"https://api.github.com/users/escheie/events{/privacy}","received_events_url":"https://api.github.com/users/escheie/received_events","type":"User","site_admin":false},"labels":[{"id":23173,"node_id":"MDU6TGFiZWwyMzE3Mw==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/%3Ebug","name":">bug","color":"b60205","default":false,"description":null}],"state":"closed","locked":false,"assignee":{"login":"tlrx","id":642733,"node_id":"MDQ6VXNlcjY0MjczMw==","avatar_url":"https://avatars1.githubusercontent.com/u/642733?v=4","gravatar_id":"","url":"https://api.github.com/users/tlrx","html_url":"https://github.com/tlrx","followers_url":"https://api.github.com/users/tlrx/followers","following_url":"https://api.github.com/users/tlrx/following{/other_user}","gists_url":"https://api.github.com/users/tlrx/gists{/gist_id}","starred_url":"https://api.github.com/users/tlrx/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/tlrx/subscriptions","organizations_url":"https://api.github.com/users/tlrx/orgs","repos_url":"https://api.github.com/users/tlrx/repos","events_url":"https://api.github.com/users/tlrx/events{/privacy}","received_events_url":"https://api.github.com/users/tlrx/received_events","type":"User","site_admin":false},"assignees":[{"login":"tlrx","id":642733,"node_id":"MDQ6VXNlcjY0MjczMw==","avatar_url":"https://avatars1.githubusercontent.com/u/642733?v=4","gravatar_id":"","url":"https://api.github.com/users/tlrx","html_url":"https://github.com/tlrx","followers_url":"https://api.github.com/users/tlrx/followers","following_url":"https://api.github.com/users/tlrx/following{/other_user}","gists_url":"https://api.github.com/users/tlrx/gists{/gist_id}","starred_url":"https://api.github.com/users/tlrx/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/tlrx/subscriptions","organizations_url":"https://api.github.com/users/tlrx/orgs","repos_url":"https://api.github.com/users/tlrx/repos","events_url":"https://api.github.com/users/tlrx/events{/privacy}","received_events_url":"https://api.github.com/users/tlrx/received_events","type":"User","site_admin":false}],"milestone":null,"comments":6,"created_at":"2016-07-11T19:56:35Z","updated_at":"2016-12-21T14:09:59Z","closed_at":"2016-12-21T14:09:59Z","author_association":"NONE","active_lock_reason":null,"body":"**Elasticsearch version**:  2.3.4\n**JVM version**: 1.8.0_91\n**OS version**: RedHat 6.5\n\nWe are using the TribeNode feature to enable search across a number of geographically distributed ElasticSearch clusters.  Occasionally when we take one of these clusters completely offline, we find that our TribeNode hits the following exception:\n\n```\njava.lang.OutOfMemoryError: unable to create new native thread\n        at java.lang.Thread.start0(Native Method)\n        at java.lang.Thread.start(Thread.java:714)\n        at java.util.concurrent.ThreadPoolExecutor.addWorker(ThreadPoolExecutor.java:950)\n        at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1368)\n        at org.elasticsearch.common.util.concurrent.EsThreadPoolExecutor.execute(EsThreadPoolExecutor.java:85)\n        at org.elasticsearch.threadpool.ThreadPool$ThreadedRunnable.run(ThreadPool.java:676)\n        at org.elasticsearch.threadpool.ThreadPool$LoggingRunnable.run(ThreadPool.java:640)\n        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n        at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\n        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n        at java.lang.Thread.run(Thread.java:745)\n```\n\nThis exception is thrown because of thread exhaustion due to the TribeNode creating a new thread every couple of seconds.  Below is the stack trace of the leaked threads:\n\n```\njava.util.concurrent.locks.LockSupport.park(LockSupport.java:186)\n       java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:834)\n       java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued(AbstractQueuedSynchronizer.java:867)\n       java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(AbstractQueuedSynchronizer.java:1197)\n       java.util.concurrent.locks.ReentrantLock$NonfairSync.lock(ReentrantLock.java:214)\n       java.util.concurrent.locks.ReentrantLock.lock(ReentrantLock.java:290)\n       org.elasticsearch.common.util.concurrent.KeyedLock.acquire(KeyedLock.java:75)\n       org.elasticsearch.transport.netty.NettyTransport.disconnectFromNode(NettyTransport.java:1063)\n       org.elasticsearch.transport.TransportService.disconnectFromNode(TransportService.java:274)\n       org.elasticsearch.discovery.zen.ping.unicast.UnicastZenPing$2$1.doRun(UnicastZenPing.java:258)\n       org.elasticsearch.common.util.concurrent.AbstractRunnable.run(AbstractRunnable.java:37)\n       java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\n       java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\n       java.lang.Thread.run(Thread.java:745)\n```\n\n**Steps to reproduce**:\n Create TribeNode configuration where one cluster is offline.   Its not enough that the processes are shutdown and the machine is online, the nodes specified in the discovery.zen.ping.unicast.hosts for the offline cluster must be offline and not respond to ping/connection attempts.    Here is a simple configuration I was able to use to reproduce the problem.\n\n```\n\n---\ncluster.name: \"thread-leak-test\"\nnode.name: \"thread-leak-node\"\nhttp.port: \"9201\"\nhttp.host: \"127.0.0.1\"\ntribe:\n  online-cluster:\n    cluster.name: \"online-cluster\"\n    discovery.zen.ping.unicast.hosts:\n    - \"localhost\"\n  offline-cluster:\n    cluster.name: \"offline-cluster\"\n    discovery.zen.ping.unicast.hosts:\n    - \"10.10.10.10\"\n```\n\nStart the Tribe node.   Observe that the number of threads continue to grow unbounded (`ps -m <pid> | wc -l`) until the OutOfMemoryError: unable to create new native thread exceptions are thrown.\n\nThis issue appears similar to the problem described in #8057.\n","closed_by":{"login":"bleskes","id":1006375,"node_id":"MDQ6VXNlcjEwMDYzNzU=","avatar_url":"https://avatars1.githubusercontent.com/u/1006375?v=4","gravatar_id":"","url":"https://api.github.com/users/bleskes","html_url":"https://github.com/bleskes","followers_url":"https://api.github.com/users/bleskes/followers","following_url":"https://api.github.com/users/bleskes/following{/other_user}","gists_url":"https://api.github.com/users/bleskes/gists{/gist_id}","starred_url":"https://api.github.com/users/bleskes/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bleskes/subscriptions","organizations_url":"https://api.github.com/users/bleskes/orgs","repos_url":"https://api.github.com/users/bleskes/repos","events_url":"https://api.github.com/users/bleskes/events{/privacy}","received_events_url":"https://api.github.com/users/bleskes/received_events","type":"User","site_admin":false},"performed_via_github_app":null}