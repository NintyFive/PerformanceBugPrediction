[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/338226865","html_url":"https://github.com/elastic/elasticsearch/issues/27023#issuecomment-338226865","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/27023","id":338226865,"node_id":"MDEyOklzc3VlQ29tbWVudDMzODIyNjg2NQ==","user":{"login":"nik9000","id":215970,"node_id":"MDQ6VXNlcjIxNTk3MA==","avatar_url":"https://avatars2.githubusercontent.com/u/215970?v=4","gravatar_id":"","url":"https://api.github.com/users/nik9000","html_url":"https://github.com/nik9000","followers_url":"https://api.github.com/users/nik9000/followers","following_url":"https://api.github.com/users/nik9000/following{/other_user}","gists_url":"https://api.github.com/users/nik9000/gists{/gist_id}","starred_url":"https://api.github.com/users/nik9000/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/nik9000/subscriptions","organizations_url":"https://api.github.com/users/nik9000/orgs","repos_url":"https://api.github.com/users/nik9000/repos","events_url":"https://api.github.com/users/nik9000/events{/privacy}","received_events_url":"https://api.github.com/users/nik9000/received_events","type":"User","site_admin":false},"created_at":"2017-10-20T14:43:07Z","updated_at":"2017-10-20T14:43:15Z","author_association":"CONTRIBUTOR","body":"So normally we'd bounce you to the forums because this is totally \"how types work\" but it is a great example of why types are a problem. And you wrote such great reproduction steps it'd be a shame not to keep this here for people that find this issue in the future.\r\n\r\nSo, types are just a field added to the document and we automatically set up filters based on the URL. The whole point of types initially was to reduce the number of indexes you need because they have some overhead ([more](https://www.elastic.co/blog/index-vs-type)). The problem with types is that people think that they partition the data internally somehow. They don't do that precisely because such partitions would come with fairly high overhead, both in memory to track the separate fields and on disk because the fields are sparse. This misconception is super common. I thought they worked that way until I really started hacking on Elasticsearch consistently and bumbled into how they are implemented. It was a total \"ah ha!\" moment.\r\n\r\nAnd you are bumping up against the way that multi-term queries like phrase prefix work. They rewrite to a list of matching terms and then execute the query. This is because queries have to iterate in a particular order that isn't compatible with walking the terms dictionary at query time. At least, not compatible without doing some serious tricks.\r\n\r\nThis is why we're slowly [migrating away from types](https://www.elastic.co/guide/en/elasticsearch/reference/6.0/removal-of-types.html). They are just confusing. In the future, if you want a field to use as a filter you should declare a keyword field and filter on it. If you want separate fields then use a separate index. You can't quite do that with parent/child (replaced by [`join`](https://www.elastic.co/guide/en/elasticsearch/reference/6.0/parent-join.html) fields), but joins come with compromises.\r\n\r\nOne last this. This:\r\n> After the phrase_prefix query on the whole shard is complete, it discards any matches with types that do not match the type requested in the URL.\r\n\r\nisn't 100% correct. The rewrite is indeed done first but the rewritten phrase prefix query and type filter are interleaved. The actual order is a bit complicated because of the phrase bit, but the upshot is that you *mostly* get the benefit of whichever filter is sparser.","performed_via_github_app":null}]