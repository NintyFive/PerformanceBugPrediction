{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/13272","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/13272/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/13272/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/13272/events","html_url":"https://github.com/elastic/elasticsearch/issues/13272","id":104513488,"node_id":"MDU6SXNzdWUxMDQ1MTM0ODg=","number":13272,"title":"combine different query boost values","user":{"login":"javanna","id":832460,"node_id":"MDQ6VXNlcjgzMjQ2MA==","avatar_url":"https://avatars1.githubusercontent.com/u/832460?v=4","gravatar_id":"","url":"https://api.github.com/users/javanna","html_url":"https://github.com/javanna","followers_url":"https://api.github.com/users/javanna/followers","following_url":"https://api.github.com/users/javanna/following{/other_user}","gists_url":"https://api.github.com/users/javanna/gists{/gist_id}","starred_url":"https://api.github.com/users/javanna/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/javanna/subscriptions","organizations_url":"https://api.github.com/users/javanna/orgs","repos_url":"https://api.github.com/users/javanna/repos","events_url":"https://api.github.com/users/javanna/events{/privacy}","received_events_url":"https://api.github.com/users/javanna/received_events","type":"User","site_admin":false},"labels":[{"id":146832564,"node_id":"MDU6TGFiZWwxNDY4MzI1NjQ=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/:Search/Search","name":":Search/Search","color":"0e8a16","default":false,"description":"Search-related issues that do not fall into other categories"},{"id":23174,"node_id":"MDU6TGFiZWwyMzE3NA==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/%3Eenhancement","name":">enhancement","color":"4a4ea8","default":false,"description":null}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":7,"created_at":"2015-09-02T15:52:11Z","updated_at":"2018-02-14T13:41:31Z","closed_at":"2015-09-08T16:01:11Z","author_association":"MEMBER","active_lock_reason":null,"body":"With #11744 we made sure that every query in our DSL supports the `boost` and `_name` fields, meaning that those fields always get parsed and applied to the corresponding lucene query (done in the query-refactoring branch). When dealing with a compound query though, there might be multiple boost values specified in the query like in the following case:\n\n```\n{\n    \"filtered\" : {\n        \"query\" : {\n            \"term\" : {\n                \"field\" : {\n                    \"query\" : \"value\",\n                    \"boost\" : 2\n                }\n            }\n        },\n        \"boost\": 3\n    }\n}\n```\n\nThe example above contains for instance a single term query, so the final lucene query will simply be a term query (rather than a filtered query), but what should the boost be? At the moment we ignore the main boost (3) and apply 2 only to the resulting query (in master). Note that only a few amount of compound queries are affected by this \"problem\". For instance the bool query will always create a lucene boolean query, no matter how many clauses there are (even with a single one), so all the potential boost values are preserved and will be handled by lucene when running the query.\n\nThe query_string has a similar, yet a bit different behaviour:\n\n```\n{\n    \"query_string\" : {\n        \"query\" : \"(field1:value1^3 field2:value2^2)^5\",\n        \"boost\" : 2\n    }\n}\n```\n\nIn the above case we multiply whatever boost comes out of parsing the query string, with the main boost that gets explicitly set.\n\nIn the query_refactoring branch, having centralized where the boost gets applied to the final lucene query, we have the chance to standardize what we do in these few cases, while in master we handle it case by case. I can see at least three options:\n- keep the inner query boost (even if 1.0 which is the default) and ignore the main one whatever that is\n- keep the main boost (only if != 1.0 which is the default?) and ignore the inner one\n- combine the two boost values, e.g. multiply them\n\nI am leaning towards the last option to be honest, but I think this is worth some discussion. What do people think about this?\n","closed_by":{"login":"javanna","id":832460,"node_id":"MDQ6VXNlcjgzMjQ2MA==","avatar_url":"https://avatars1.githubusercontent.com/u/832460?v=4","gravatar_id":"","url":"https://api.github.com/users/javanna","html_url":"https://github.com/javanna","followers_url":"https://api.github.com/users/javanna/followers","following_url":"https://api.github.com/users/javanna/following{/other_user}","gists_url":"https://api.github.com/users/javanna/gists{/gist_id}","starred_url":"https://api.github.com/users/javanna/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/javanna/subscriptions","organizations_url":"https://api.github.com/users/javanna/orgs","repos_url":"https://api.github.com/users/javanna/repos","events_url":"https://api.github.com/users/javanna/events{/privacy}","received_events_url":"https://api.github.com/users/javanna/received_events","type":"User","site_admin":false},"performed_via_github_app":null}