[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/604544274","html_url":"https://github.com/elastic/elasticsearch/issues/54289#issuecomment-604544274","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/54289","id":604544274,"node_id":"MDEyOklzc3VlQ29tbWVudDYwNDU0NDI3NA==","user":{"login":"elasticmachine","id":15837671,"node_id":"MDQ6VXNlcjE1ODM3Njcx","avatar_url":"https://avatars3.githubusercontent.com/u/15837671?v=4","gravatar_id":"","url":"https://api.github.com/users/elasticmachine","html_url":"https://github.com/elasticmachine","followers_url":"https://api.github.com/users/elasticmachine/followers","following_url":"https://api.github.com/users/elasticmachine/following{/other_user}","gists_url":"https://api.github.com/users/elasticmachine/gists{/gist_id}","starred_url":"https://api.github.com/users/elasticmachine/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/elasticmachine/subscriptions","organizations_url":"https://api.github.com/users/elasticmachine/orgs","repos_url":"https://api.github.com/users/elasticmachine/repos","events_url":"https://api.github.com/users/elasticmachine/events{/privacy}","received_events_url":"https://api.github.com/users/elasticmachine/received_events","type":"User","site_admin":false},"created_at":"2020-03-26T16:52:19Z","updated_at":"2020-03-26T16:52:19Z","author_association":"COLLABORATOR","body":"Pinging @elastic/es-security (:Security/Authentication)","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/604629764","html_url":"https://github.com/elastic/elasticsearch/issues/54289#issuecomment-604629764","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/54289","id":604629764,"node_id":"MDEyOklzc3VlQ29tbWVudDYwNDYyOTc2NA==","user":{"login":"jkakavas","id":10281256,"node_id":"MDQ6VXNlcjEwMjgxMjU2","avatar_url":"https://avatars2.githubusercontent.com/u/10281256?v=4","gravatar_id":"","url":"https://api.github.com/users/jkakavas","html_url":"https://github.com/jkakavas","followers_url":"https://api.github.com/users/jkakavas/followers","following_url":"https://api.github.com/users/jkakavas/following{/other_user}","gists_url":"https://api.github.com/users/jkakavas/gists{/gist_id}","starred_url":"https://api.github.com/users/jkakavas/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jkakavas/subscriptions","organizations_url":"https://api.github.com/users/jkakavas/orgs","repos_url":"https://api.github.com/users/jkakavas/repos","events_url":"https://api.github.com/users/jkakavas/events{/privacy}","received_events_url":"https://api.github.com/users/jkakavas/received_events","type":"User","site_admin":false},"created_at":"2020-03-26T19:12:33Z","updated_at":"2020-03-26T19:12:33Z","author_association":"CONTRIBUTOR","body":"My original thought was that the culprit is the WAIT_UNTIL here : https://github.com/elastic/elasticsearch/blob/a90c1de8745681356a6516f4f22a8c40f71f6b12/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/TokenService.java#L339\n\nWhich would mean that after we refresh the token and index the new document, the index hasn't been refreshed by the time that the _authenticate call arrives \n\nBut @azasypkin tried this out with IMMEDIATE and still reproduces.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/604785555","html_url":"https://github.com/elastic/elasticsearch/issues/54289#issuecomment-604785555","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/54289","id":604785555,"node_id":"MDEyOklzc3VlQ29tbWVudDYwNDc4NTU1NQ==","user":{"login":"ywangd","id":2344308,"node_id":"MDQ6VXNlcjIzNDQzMDg=","avatar_url":"https://avatars3.githubusercontent.com/u/2344308?v=4","gravatar_id":"","url":"https://api.github.com/users/ywangd","html_url":"https://github.com/ywangd","followers_url":"https://api.github.com/users/ywangd/followers","following_url":"https://api.github.com/users/ywangd/following{/other_user}","gists_url":"https://api.github.com/users/ywangd/gists{/gist_id}","starred_url":"https://api.github.com/users/ywangd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ywangd/subscriptions","organizations_url":"https://api.github.com/users/ywangd/orgs","repos_url":"https://api.github.com/users/ywangd/repos","events_url":"https://api.github.com/users/ywangd/events{/privacy}","received_events_url":"https://api.github.com/users/ywangd/received_events","type":"User","site_admin":false},"created_at":"2020-03-27T02:42:43Z","updated_at":"2020-03-27T02:48:29Z","author_association":"MEMBER","body":"The problem is likely a racing condition between two threads handling the refreshing request. The following scenario is one possible way for it to happen:\r\n\r\nWhen the 1st refresh request is _done updating_ the exsiting document but _before it can create the new document_ (can be simulated by adding `Thread.sleep` before this [line](https://github.com/elastic/elasticsearch/blob/7.6/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/TokenService.java#L982)), the 2nd refresh request comes in and tries to refresh the token again. The 2nd request will see that the existing document is refreshed and take a [shortcut](https://github.com/elastic/elasticsearch/blob/7.6/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/TokenService.java#L941) to return the information directly from the updated existing document. At this point, the new token document has not yet been created since the 1st thread is slow.\r\n\r\nTherefore the 2nd request will come back to user before the 1st request can complete (and actually creating the new token document). If user immediately tries to authenticate with the new access token, it will fail since the document has not yet been created. If you wait for a while till the 1st refresh request (the slower one) to complete, the new token will become valid.\r\n\r\nIn summary, the problem is that end-user can get back an access token which is yet to be created because of the two-stage processing on the server side.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/604835875","html_url":"https://github.com/elastic/elasticsearch/issues/54289#issuecomment-604835875","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/54289","id":604835875,"node_id":"MDEyOklzc3VlQ29tbWVudDYwNDgzNTg3NQ==","user":{"login":"azasypkin","id":1713708,"node_id":"MDQ6VXNlcjE3MTM3MDg=","avatar_url":"https://avatars1.githubusercontent.com/u/1713708?v=4","gravatar_id":"","url":"https://api.github.com/users/azasypkin","html_url":"https://github.com/azasypkin","followers_url":"https://api.github.com/users/azasypkin/followers","following_url":"https://api.github.com/users/azasypkin/following{/other_user}","gists_url":"https://api.github.com/users/azasypkin/gists{/gist_id}","starred_url":"https://api.github.com/users/azasypkin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/azasypkin/subscriptions","organizations_url":"https://api.github.com/users/azasypkin/orgs","repos_url":"https://api.github.com/users/azasypkin/repos","events_url":"https://api.github.com/users/azasypkin/events{/privacy}","received_events_url":"https://api.github.com/users/azasypkin/received_events","type":"User","site_admin":false},"created_at":"2020-03-27T06:22:29Z","updated_at":"2020-03-27T06:22:29Z","author_association":"MEMBER","body":"Thanks @ywangd, what you're describing matches pretty close to what we were observing in another issue where we had two almost concurrent requests with an expired token (non-essential request/response details are omitted, second column is packet/request number and third one is UTC timestamp). Copying here, jfr.\r\n\r\n```http\r\n# First request with expired token\r\n56\t15:40:37.830393657\t232\tGET /_security/_authenticate HTTP/1.1\r\nauthorization: Bearer 46ToAxZCajVhTUladVRsYWpaWWoxbkZmZ2FB\r\n\r\n# Second request with expired token\r\n58\t15:40:37.830429114\t232\tGET /_security/_authenticate HTTP/1.1 \r\nauthorization: Bearer 46ToAxZCajVhTUladVRsYWpaWWoxbkZmZ2FB\r\n\r\n# Reply to the second request - token is expired - looks good\r\n60\t15:40:37.831789663\t684\tHTTP/1.1 401 Unauthorized  (application/json)\r\nWWW-Authenticate: Bearer realm=\"security\", error=\"invalid_token\", error_description=\"The access token expired\"\r\n\r\n# Reply to the first request - token is expired - looks good\r\n61\t15:40:37.831792090\t684\tHTTP/1.1 401 Unauthorized  (application/json)\r\nWWW-Authenticate: Bearer realm=\"security\", error=\"invalid_token\", error_description=\"The access token expired\"\r\n\r\n# Now let's refresh the tokens\r\n\r\n# First request to refresh token\r\n64\t15:40:37.832761215\t333\tPOST /_security/oauth2/token HTTP/1.1  (application/json)\r\nAuthorization: Basic a2liYW5hOmNoYW5nZW1l\r\n{\"grant_type\":\"refresh_token\",\"refresh_token\":\"46ToAxYzbjY1Y2lLX1FJZW05UFp0SHZqYkF3\"}\r\n\r\n# Second request to refresh token (using the same refresh token obviously)\r\nAuthorization: Basic a2liYW5hOmNoYW5nZW1l\r\n69\t15:40:37.833581671\t333\tPOST /_security/oauth2/token HTTP/1.1  (application/json)\r\n{\"grant_type\":\"refresh_token\",\"refresh_token\":\"46ToAxYzbjY1Y2lLX1FJZW05UFp0SHZqYkF3\"}\r\n\r\n# Reply to the second refresh request - looks good\r\n71\t15:40:37.839309282\t295\tHTTP/1.1 200 OK  (application/json)\r\n{\"access_token\":\"46ToAxZveGIwUTRYNVFpV1B1YVg0MFJRZDdR\",\"type\":\"Bearer\",\"expires_in\":15,\"refresh_token\":\"46ToAxZBdzM4UVZ1eFJnaW41LUZESmFPQTRB\"}\r\n\r\n# Since we have a refreshed token now, let's use it\r\n# Remember we still haven't received reply for the first refresh request!!!\r\n73\t15:40:37.840045203\t232\tGET /_security/_authenticate HTTP/1.1 \r\nauthorization: Bearer 46ToAxZveGIwUTRYNVFpV1B1YVg0MFJRZDdR\r\n\r\n# Reply to the first request with refreshed token ---- that seems to be a BUG\r\n75\t15:40:37.840803301\t795\tHTTP/1.1 401 Unauthorized  (application/json)\r\nWWW-Authenticate: Bearer realm=\"security\"\r\nWWW-Authenticate: ApiKey\r\nWWW-Authenticate: Basic realm=\"security\" charset=\"UTF-8\"\r\n{\"error\":{\"root_cause\":[{\"type\":\"security_exception\",\"reason\":\"missing authentication credentials for REST request [/_security/_authenticate]\",\"header\":{\"WWW-Authenticate\":[\"Bearer realm=\\\"security\\\"\",\"ApiKey\",\"Basic realm=\\\"security\\\" charset=\\\"UTF-8\\\"\"]}}],\"type\":\"security_exception\",\"reason\":\"missing authentication credentials for REST request [/_security/_authenticate]\",\"header\":{\"WWW-Authenticate\":[\"Bearer realm=\\\"security\\\"\",\"ApiKey\",\"Basic realm=\\\"security\\\"\r\n\r\n# Reply to the first refresh request (finally) - looks good\r\n99\t15:40:38.816817407\t295\tHTTP/1.1 200 OK  (application/json)\r\n{\"access_token\":\"46ToAxZveGIwUTRYNVFpV1B1YVg0MFJRZDdR\",\"type\":\"Bearer\",\"expires_in\":15,\"refresh_token\":\"46ToAxZBdzM4UVZ1eFJnaW41LUZESmFPQTRB\"}\r\n\r\n# Second request with refreshed token\r\n101\t15:40:38.817551907\t232\tGET /_security/_authenticate HTTP/1.1\r\nauthorization: Bearer 46ToAxZveGIwUTRYNVFpV1B1YVg0MFJRZDdR\r\n\r\n# Reply to the second request with refresh token - looks good\r\n103\t15:40:38.818535836\t473\tHTTP/1.1 200 OK  (application/json)\r\n{\"username\":\"a@b.c\",\"roles\":[],\"full_name\":null,\"email\":null,\"metadata\":{\"saml_nameid\":\"a@b.c\",\"saml_nameid_format\":\"urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified\",\"saml(urn:oid:0.0.7)\":[\"a@b.c\"]},\"enabled\":true,\"authentication_realm\":{\"name\":\"saml1\",\"type\":\"saml\"},\"lookup_realm\":{\"name\":\"saml1\",\"type\":\"saml\"}}\r\n```","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/604840435","html_url":"https://github.com/elastic/elasticsearch/issues/54289#issuecomment-604840435","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/54289","id":604840435,"node_id":"MDEyOklzc3VlQ29tbWVudDYwNDg0MDQzNQ==","user":{"login":"ywangd","id":2344308,"node_id":"MDQ6VXNlcjIzNDQzMDg=","avatar_url":"https://avatars3.githubusercontent.com/u/2344308?v=4","gravatar_id":"","url":"https://api.github.com/users/ywangd","html_url":"https://github.com/ywangd","followers_url":"https://api.github.com/users/ywangd/followers","following_url":"https://api.github.com/users/ywangd/following{/other_user}","gists_url":"https://api.github.com/users/ywangd/gists{/gist_id}","starred_url":"https://api.github.com/users/ywangd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ywangd/subscriptions","organizations_url":"https://api.github.com/users/ywangd/orgs","repos_url":"https://api.github.com/users/ywangd/repos","events_url":"https://api.github.com/users/ywangd/events{/privacy}","received_events_url":"https://api.github.com/users/ywangd/received_events","type":"User","site_admin":false},"created_at":"2020-03-27T06:39:35Z","updated_at":"2020-03-27T06:39:35Z","author_association":"MEMBER","body":"@azasypkin Thanks for the detailed request/response log. It matches exactly to what I have suspected. The same access token `46ToAxZveGIwUTRYNVFpV1B1YVg0MFJRZDdR` was returned by both refresh requests and became valid just one second after it's initial failure.\r\n\r\nBtw, this problem can happen regardless of the expiration time or whether the original token is expired or not.","performed_via_github_app":null}]