[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/448803516","html_url":"https://github.com/elastic/elasticsearch/issues/36872#issuecomment-448803516","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/36872","id":448803516,"node_id":"MDEyOklzc3VlQ29tbWVudDQ0ODgwMzUxNg==","user":{"login":"elasticmachine","id":15837671,"node_id":"MDQ6VXNlcjE1ODM3Njcx","avatar_url":"https://avatars3.githubusercontent.com/u/15837671?v=4","gravatar_id":"","url":"https://api.github.com/users/elasticmachine","html_url":"https://github.com/elasticmachine","followers_url":"https://api.github.com/users/elasticmachine/followers","following_url":"https://api.github.com/users/elasticmachine/following{/other_user}","gists_url":"https://api.github.com/users/elasticmachine/gists{/gist_id}","starred_url":"https://api.github.com/users/elasticmachine/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/elasticmachine/subscriptions","organizations_url":"https://api.github.com/users/elasticmachine/orgs","repos_url":"https://api.github.com/users/elasticmachine/repos","events_url":"https://api.github.com/users/elasticmachine/events{/privacy}","received_events_url":"https://api.github.com/users/elasticmachine/received_events","type":"User","site_admin":false},"created_at":"2018-12-20T00:20:51Z","updated_at":"2018-12-20T00:20:51Z","author_association":"COLLABORATOR","body":"Pinging @elastic/es-security","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/449351124","html_url":"https://github.com/elastic/elasticsearch/issues/36872#issuecomment-449351124","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/36872","id":449351124,"node_id":"MDEyOklzc3VlQ29tbWVudDQ0OTM1MTEyNA==","user":{"login":"jkakavas","id":10281256,"node_id":"MDQ6VXNlcjEwMjgxMjU2","avatar_url":"https://avatars2.githubusercontent.com/u/10281256?v=4","gravatar_id":"","url":"https://api.github.com/users/jkakavas","html_url":"https://github.com/jkakavas","followers_url":"https://api.github.com/users/jkakavas/followers","following_url":"https://api.github.com/users/jkakavas/following{/other_user}","gists_url":"https://api.github.com/users/jkakavas/gists{/gist_id}","starred_url":"https://api.github.com/users/jkakavas/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jkakavas/subscriptions","organizations_url":"https://api.github.com/users/jkakavas/orgs","repos_url":"https://api.github.com/users/jkakavas/repos","events_url":"https://api.github.com/users/jkakavas/events{/privacy}","received_events_url":"https://api.github.com/users/jkakavas/received_events","type":"User","site_admin":false},"created_at":"2018-12-21T10:28:25Z","updated_at":"2018-12-21T10:28:25Z","author_association":"CONTRIBUTOR","body":"That's a tricky one :) My initial reaction ( and I shared this with @kobelb in the issue we came across this ) is that this needs to be fixed on the client side. All the solutions that come to mind though, either require a shared server-side state in Kibana or do not handle the \"HA with many Kibana instances\" scenario. \r\n\r\nI think the suggested approach adds a lot of complexity and I'd like to propose a different solution, one where we do not invalidate refresh tokens on first use. The original decision to revoke refresh tokens on use, still makes sense and it is in the spirit of the [specification](https://tools.ietf.org/html/rfc6749#page-47):\r\n```\r\nThe authorization server MAY revoke the old\r\nrefresh token after issuing a new refresh token to the client.\r\n```\r\nbut I consider revisiting it as a sensible trade-off in order to resolve the issue at hand with low to no risk involved. \r\n\r\n#### Suggested Solution\r\nWe stop revoking refresh tokens on first use. This will resolve the issue at hand as Requests `A`,`B`, and `C` are fired off to Elasticsearch in parallel, all three get rejected due to an expired access token, and all three attempt to refresh the session using the same refresh token. `A` succeeds and gets a new access token and returns a new session cookie to the client. `B` and `C` also succeed but get new access tokens and refresh tokens that are stored in the users session cookie and overwrite the existing one. The end result is that the latest of the concurrent requests to get a response will dictate the access token and refresh token to store in the user's session cookie. \r\n\r\nThis means that nothing needs to change on the Kibana's side. Any concerns regarding the possibility of `A`, `B`, `C` returning *different* access/refresh tokens , all of which will be valid and with the same expiration ( give or take a few ms ) ? \r\n\r\n#### Standards and Best Practices compliance\r\nThere is nothing in the [original standard](https://tools.ietf.org/html/rfc6749), the [OAuth 2.0 Threat Model and Security Considerations](https://tools.ietf.org/html/rfc6819) or the recent [OAuth 2.0 Security Best Current Practice](https://tools.ietf.org/id/draft-ietf-oauth-security-topics-05.html) draft that mandates the revocation on use of the refresh tokens. \r\n\r\n#### Threat Model\r\n\r\n##### *Threat* : Retaining persistent access\r\n\r\n*Attack1* : A legitimate client could use the same refresh token multiple times. \r\n\r\n*Countermeasures* : The legitimate client would get a new access token and a new refresh token each time but \r\n* the access token would give them the same privileges that the original access token or the access token that they would get with the original refresh, would give them.\r\n* the new refresh tokens will extend the duration of its access ( each new one will give the option to refresh access for 24h ) but this is in no way different than sequentially refreshing using a new refresh token each time. \r\n\r\nAs such, this threat degrades into normal functionality and should not be considered as a risk.\r\n\r\n*Attack2* : An attacker could use the same leaked refresh token multiple times. \r\n\r\n*Countermeasures* : As above, this doesn't give any additional access to an attacker. The ability to explicitly invalidate tokens (either for specific tokens or for any user/realm combination) is another mitigating factor to this attack. Finally we do authenticate the client on the `refresh_grant` so leaked refresh tokens cannot be used by other clients ( outside Kibana )\r\n\r\n#####  *Threat* : Performance degradation / Denial of Service\r\n\r\n*Attack1*: A malicious user can continuously refresh an existing refresh token. Each of these requests would give them a new refresh token and access token and they could then start also using this new refresh token to get additional ones, etc. Compared to the old approach, this would allow the malicious user to create documents in the security index in an exponential rate which depending on deployment specific factors could hurt performance of the Token Service. \r\n\r\n*Countermeasures*: We already delete expired tokens so there is an upper limit to the amount of documents they can create, as we would periodically delete ones containing expired refresh tokens. Additionally, we can decide on a sensible maximum number of refreshes that would resolve the issue but further mitigate the mentioned threat.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/449409392","html_url":"https://github.com/elastic/elasticsearch/issues/36872#issuecomment-449409392","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/36872","id":449409392,"node_id":"MDEyOklzc3VlQ29tbWVudDQ0OTQwOTM5Mg==","user":{"login":"kobelb","id":627123,"node_id":"MDQ6VXNlcjYyNzEyMw==","avatar_url":"https://avatars0.githubusercontent.com/u/627123?v=4","gravatar_id":"","url":"https://api.github.com/users/kobelb","html_url":"https://github.com/kobelb","followers_url":"https://api.github.com/users/kobelb/followers","following_url":"https://api.github.com/users/kobelb/following{/other_user}","gists_url":"https://api.github.com/users/kobelb/gists{/gist_id}","starred_url":"https://api.github.com/users/kobelb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/kobelb/subscriptions","organizations_url":"https://api.github.com/users/kobelb/orgs","repos_url":"https://api.github.com/users/kobelb/repos","events_url":"https://api.github.com/users/kobelb/events{/privacy}","received_events_url":"https://api.github.com/users/kobelb/received_events","type":"User","site_admin":false},"created_at":"2018-12-21T14:56:40Z","updated_at":"2018-12-21T14:56:40Z","author_association":"CONTRIBUTOR","body":"Do we need to take the logout/token-invalidation behavior into consideration here? If we could potentially have multiple access/refresh tokens that were created from the initial refresh token, it becomes quite complicated (perhaps impossible) to ensure that on logout \"all\" of the refresh/access tokens are invalidated. This is one of the main complaints which I hear from users about our existing basic auth provider, that on logout they can re-use the previous session cookies (which would contain the previous access/refresh tokens) to authenticate subsequently.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/449460612","html_url":"https://github.com/elastic/elasticsearch/issues/36872#issuecomment-449460612","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/36872","id":449460612,"node_id":"MDEyOklzc3VlQ29tbWVudDQ0OTQ2MDYxMg==","user":{"login":"jkakavas","id":10281256,"node_id":"MDQ6VXNlcjEwMjgxMjU2","avatar_url":"https://avatars2.githubusercontent.com/u/10281256?v=4","gravatar_id":"","url":"https://api.github.com/users/jkakavas","html_url":"https://github.com/jkakavas","followers_url":"https://api.github.com/users/jkakavas/followers","following_url":"https://api.github.com/users/jkakavas/following{/other_user}","gists_url":"https://api.github.com/users/jkakavas/gists{/gist_id}","starred_url":"https://api.github.com/users/jkakavas/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jkakavas/subscriptions","organizations_url":"https://api.github.com/users/jkakavas/orgs","repos_url":"https://api.github.com/users/jkakavas/repos","events_url":"https://api.github.com/users/jkakavas/events{/privacy}","received_events_url":"https://api.github.com/users/jkakavas/received_events","type":"User","site_admin":false},"created_at":"2018-12-21T18:16:12Z","updated_at":"2018-12-21T18:16:12Z","author_association":"CONTRIBUTOR","body":"@kobelb wouldn't a call to [invalidate all tokens of the user](https://www.elastic.co/guide/en/elasticsearch/reference/6.6/security-api-invalidate-token.html) satisfy the logout requirement ?\r\n\r\n```\r\nDELETE /_xpack/security/oauth2/token\r\n{\r\n  \"username\" : \"user\"\r\n}\r\n```","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/449470283","html_url":"https://github.com/elastic/elasticsearch/issues/36872#issuecomment-449470283","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/36872","id":449470283,"node_id":"MDEyOklzc3VlQ29tbWVudDQ0OTQ3MDI4Mw==","user":{"login":"kobelb","id":627123,"node_id":"MDQ6VXNlcjYyNzEyMw==","avatar_url":"https://avatars0.githubusercontent.com/u/627123?v=4","gravatar_id":"","url":"https://api.github.com/users/kobelb","html_url":"https://github.com/kobelb","followers_url":"https://api.github.com/users/kobelb/followers","following_url":"https://api.github.com/users/kobelb/following{/other_user}","gists_url":"https://api.github.com/users/kobelb/gists{/gist_id}","starred_url":"https://api.github.com/users/kobelb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/kobelb/subscriptions","organizations_url":"https://api.github.com/users/kobelb/orgs","repos_url":"https://api.github.com/users/kobelb/repos","events_url":"https://api.github.com/users/kobelb/events{/privacy}","received_events_url":"https://api.github.com/users/kobelb/received_events","type":"User","site_admin":false},"created_at":"2018-12-21T18:56:37Z","updated_at":"2018-12-21T18:56:37Z","author_association":"CONTRIBUTOR","body":"@jkakavas I forgot we could do that now, that's awesome! Would there be a way to limit this to only the tokens associated with the instance of Kibana so it wouldn't log them out of all other instances of Kibana, or their other usages of tokens.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/449690992","html_url":"https://github.com/elastic/elasticsearch/issues/36872#issuecomment-449690992","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/36872","id":449690992,"node_id":"MDEyOklzc3VlQ29tbWVudDQ0OTY5MDk5Mg==","user":{"login":"jkakavas","id":10281256,"node_id":"MDQ6VXNlcjEwMjgxMjU2","avatar_url":"https://avatars2.githubusercontent.com/u/10281256?v=4","gravatar_id":"","url":"https://api.github.com/users/jkakavas","html_url":"https://github.com/jkakavas","followers_url":"https://api.github.com/users/jkakavas/followers","following_url":"https://api.github.com/users/jkakavas/following{/other_user}","gists_url":"https://api.github.com/users/jkakavas/gists{/gist_id}","starred_url":"https://api.github.com/users/jkakavas/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jkakavas/subscriptions","organizations_url":"https://api.github.com/users/jkakavas/orgs","repos_url":"https://api.github.com/users/jkakavas/repos","events_url":"https://api.github.com/users/jkakavas/events{/privacy}","received_events_url":"https://api.github.com/users/jkakavas/received_events","type":"User","site_admin":false},"created_at":"2018-12-24T06:13:51Z","updated_at":"2018-12-24T06:13:51Z","author_association":"CONTRIBUTOR","body":"> Would there be a way to limit this to only the tokens associated with the instance of Kibana\r\n\r\nNo, that's a good catch. I didn't think about this scenario at all. I don't think that we have a good way of differentiating that. We could add the API parameter to also filter by `oAuth2 client` but there is also a high probability that these different kibana instances will use the same user to authenticate to Elasticsearch (that `principal` is what we keep track as client). The original proposal will also need a solution around this as `B`, `C`, `D` would create new `refresh_tokens` also and on logout we would revoke only the one that `D` created. \r\n\r\nI'll go back to the drawing board and re-evaluate @epixa 's proposal also. ","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/450633165","html_url":"https://github.com/elastic/elasticsearch/issues/36872#issuecomment-450633165","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/36872","id":450633165,"node_id":"MDEyOklzc3VlQ29tbWVudDQ1MDYzMzE2NQ==","user":{"login":"albertzaharovits","id":4568420,"node_id":"MDQ6VXNlcjQ1Njg0MjA=","avatar_url":"https://avatars2.githubusercontent.com/u/4568420?v=4","gravatar_id":"","url":"https://api.github.com/users/albertzaharovits","html_url":"https://github.com/albertzaharovits","followers_url":"https://api.github.com/users/albertzaharovits/followers","following_url":"https://api.github.com/users/albertzaharovits/following{/other_user}","gists_url":"https://api.github.com/users/albertzaharovits/gists{/gist_id}","starred_url":"https://api.github.com/users/albertzaharovits/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/albertzaharovits/subscriptions","organizations_url":"https://api.github.com/users/albertzaharovits/orgs","repos_url":"https://api.github.com/users/albertzaharovits/repos","events_url":"https://api.github.com/users/albertzaharovits/events{/privacy}","received_events_url":"https://api.github.com/users/albertzaharovits/received_events","type":"User","site_admin":false},"created_at":"2018-12-31T11:02:12Z","updated_at":"2018-12-31T11:02:12Z","author_association":"CONTRIBUTOR","body":"I agree with @jkakavas's assessment that we will not be introducing new attack vectors by not invalidating the refresh token on use. But I worry that we might increase the possibility of leaking refresh tokens if we generate new ones on each reuse. I would propose that we not generate a new refresh token for each use of another refresh token, and maintain the original one valid for subsequent uses.\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/452836027","html_url":"https://github.com/elastic/elasticsearch/issues/36872#issuecomment-452836027","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/36872","id":452836027,"node_id":"MDEyOklzc3VlQ29tbWVudDQ1MjgzNjAyNw==","user":{"login":"jkakavas","id":10281256,"node_id":"MDQ6VXNlcjEwMjgxMjU2","avatar_url":"https://avatars2.githubusercontent.com/u/10281256?v=4","gravatar_id":"","url":"https://api.github.com/users/jkakavas","html_url":"https://github.com/jkakavas","followers_url":"https://api.github.com/users/jkakavas/followers","following_url":"https://api.github.com/users/jkakavas/following{/other_user}","gists_url":"https://api.github.com/users/jkakavas/gists{/gist_id}","starred_url":"https://api.github.com/users/jkakavas/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jkakavas/subscriptions","organizations_url":"https://api.github.com/users/jkakavas/orgs","repos_url":"https://api.github.com/users/jkakavas/repos","events_url":"https://api.github.com/users/jkakavas/events{/privacy}","received_events_url":"https://api.github.com/users/jkakavas/received_events","type":"User","site_admin":false},"created_at":"2019-01-09T19:57:20Z","updated_at":"2019-01-09T19:57:20Z","author_association":"CONTRIBUTOR","body":"> I would propose that we not generate a new refresh token for each use of another refresh token, and maintain the original one valid for subsequent uses.\r\n\r\nIn terms of token leakage that would also broaden the attack surface in the time dimension as we would have fewer refresh tokens but with longer validity period. ( i.e. an attacker finds a refresh token logged somewhere from 4-5 days ago which might still be active )\r\nThis also suffers from the same issue with regards to access token invalidation on logout , as the previous proposal.\r\n\r\nIn general , the fact that the refresh token can only be used by the original client makes token leakage a reduced impact threat as an attacker would also need to compromise the client(usually kibana for now) credentials in order to exploit a leaked refresh token. \r\n\r\n> I'll go back to the drawing board and re-evaluate @epixa 's proposal also.\r\n\r\nI'll get to it in the next couple of days. ","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/455067521","html_url":"https://github.com/elastic/elasticsearch/issues/36872#issuecomment-455067521","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/36872","id":455067521,"node_id":"MDEyOklzc3VlQ29tbWVudDQ1NTA2NzUyMQ==","user":{"login":"jkakavas","id":10281256,"node_id":"MDQ6VXNlcjEwMjgxMjU2","avatar_url":"https://avatars2.githubusercontent.com/u/10281256?v=4","gravatar_id":"","url":"https://api.github.com/users/jkakavas","html_url":"https://github.com/jkakavas","followers_url":"https://api.github.com/users/jkakavas/followers","following_url":"https://api.github.com/users/jkakavas/following{/other_user}","gists_url":"https://api.github.com/users/jkakavas/gists{/gist_id}","starred_url":"https://api.github.com/users/jkakavas/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jkakavas/subscriptions","organizations_url":"https://api.github.com/users/jkakavas/orgs","repos_url":"https://api.github.com/users/jkakavas/repos","events_url":"https://api.github.com/users/jkakavas/events{/privacy}","received_events_url":"https://api.github.com/users/jkakavas/received_events","type":"User","site_admin":false},"created_at":"2019-01-17T07:19:09Z","updated_at":"2019-01-17T07:19:09Z","author_association":"CONTRIBUTOR","body":"We discussed this today in our team meeting. Jay came up with an idea to simplify the original proposal by not requiring a nonce and using a window of 1 min. We can probably bring this down to a few seconds as we're trying to solve for concurrent requests. The idea is that we would return the same access token for the duration of this window as the original proposal also suggests.\r\nI have an idea of an implementation that would allow this and plan to give it  a shot unless someone brings up a concern that we have missed. @epixa did you have any specific ideas why the nonce would be of use that is not covered by just a time window?\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/455188554","html_url":"https://github.com/elastic/elasticsearch/issues/36872#issuecomment-455188554","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/36872","id":455188554,"node_id":"MDEyOklzc3VlQ29tbWVudDQ1NTE4ODU1NA==","user":{"login":"epixa","id":53814,"node_id":"MDQ6VXNlcjUzODE0","avatar_url":"https://avatars0.githubusercontent.com/u/53814?v=4","gravatar_id":"","url":"https://api.github.com/users/epixa","html_url":"https://github.com/epixa","followers_url":"https://api.github.com/users/epixa/followers","following_url":"https://api.github.com/users/epixa/following{/other_user}","gists_url":"https://api.github.com/users/epixa/gists{/gist_id}","starred_url":"https://api.github.com/users/epixa/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/epixa/subscriptions","organizations_url":"https://api.github.com/users/epixa/orgs","repos_url":"https://api.github.com/users/epixa/repos","events_url":"https://api.github.com/users/epixa/events{/privacy}","received_events_url":"https://api.github.com/users/epixa/received_events","type":"User","site_admin":false},"created_at":"2019-01-17T14:22:53Z","updated_at":"2019-01-17T14:22:53Z","author_association":"MEMBER","body":"I don't have strong opinions about the `nonce`, but I do think it solves a different problem that is possible within the time window.\r\n\r\nIn a UI client, if an attacker gets access to the access token for another user's session, they almost certainly have access to the refresh token as well. Both of these things must be associated with a session in order to be useful.\r\n\r\nWe can't prevent an attacker from initiating the session reset themselves, but without the `nonce` feature, these two things are reality:\r\n\r\n1. If the attacker is the one that first initiates the token refresh, the original user remains unaware that something is wrong as their session will also seamlessly refresh (to an already-exploited new token). If a `nonce` was in place, the original user's session would fail to refresh and we could potentially error with something like \"this refresh token has already been used\" which might tip them off to a problem.\r\n2. If the original user is the one that first initiates the token refresh, the attacker can still safely refresh the token anyway (still unbeknownst to the user). If the `nonce` was in place, the attacker's request would be rejected.\r\n\r\nTo \"quietly\" exploit the `nonce` feature, the attacker needs to attack a different mechanism entirely in order to get a valid nonce. The act of getting the session info isn't enough.\r\n\r\nWith the time window alone, no additional exploit is necessary, the timing just needs to be right. This window could be made easier to exploit if the attacker can determine approximately when a token was due to expire. I notice the token service itself returns with expires_in, so if that info is available on an ongoing basis from ES, then it would be pretty easy for an attacker to exploit the window. If not available easily through ES, it's also not unlikely that a client would store the whole token service payload (including expires_in) along with a created_at timestamp with the session, so in that case the attacker could exploit the window using the info they had on hand.\r\n\r\nI'm comfortable leaving it to this team to decide the extent to which this is acceptable in our auth threat model.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/455204844","html_url":"https://github.com/elastic/elasticsearch/issues/36872#issuecomment-455204844","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/36872","id":455204844,"node_id":"MDEyOklzc3VlQ29tbWVudDQ1NTIwNDg0NA==","user":{"login":"albertzaharovits","id":4568420,"node_id":"MDQ6VXNlcjQ1Njg0MjA=","avatar_url":"https://avatars2.githubusercontent.com/u/4568420?v=4","gravatar_id":"","url":"https://api.github.com/users/albertzaharovits","html_url":"https://github.com/albertzaharovits","followers_url":"https://api.github.com/users/albertzaharovits/followers","following_url":"https://api.github.com/users/albertzaharovits/following{/other_user}","gists_url":"https://api.github.com/users/albertzaharovits/gists{/gist_id}","starred_url":"https://api.github.com/users/albertzaharovits/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/albertzaharovits/subscriptions","organizations_url":"https://api.github.com/users/albertzaharovits/orgs","repos_url":"https://api.github.com/users/albertzaharovits/repos","events_url":"https://api.github.com/users/albertzaharovits/events{/privacy}","received_events_url":"https://api.github.com/users/albertzaharovits/received_events","type":"User","site_admin":false},"created_at":"2019-01-17T15:08:02Z","updated_at":"2019-01-17T15:08:02Z","author_association":"CONTRIBUTOR","body":"@epixa If I'm following correctly the `nonce` is a use-once token, that unlike the `refresh` token, which is also use-once atm, is generated by Kibana and not by ES. For that matter, the `nonce` is generated instead of stored.\r\n\r\nI think the `nonce` is a raw method of binding the `access`-`refresh` token pair to a Kibana instance.\r\nInstead, and this is not mentioned in the previous description, the `refresh` token is bound to the credentials of the kibana process that generated the `access`-`refresh` token pair in the first place. So, an attacker does not simply has to race for the refresh, or guess the generated nonce, it has to know the secret kibana password.\r\n\r\nI guess, this is not how things work right now, but each authenticator process in a multiple kibana deployment should use different secret credentials. In this way, the `nonce` is not required to identify a Kibana instance (it is still useful, if credentials are shared, but then I don't think the `refresh` token is useful anymore).","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/455250760","html_url":"https://github.com/elastic/elasticsearch/issues/36872#issuecomment-455250760","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/36872","id":455250760,"node_id":"MDEyOklzc3VlQ29tbWVudDQ1NTI1MDc2MA==","user":{"login":"jkakavas","id":10281256,"node_id":"MDQ6VXNlcjEwMjgxMjU2","avatar_url":"https://avatars2.githubusercontent.com/u/10281256?v=4","gravatar_id":"","url":"https://api.github.com/users/jkakavas","html_url":"https://github.com/jkakavas","followers_url":"https://api.github.com/users/jkakavas/followers","following_url":"https://api.github.com/users/jkakavas/following{/other_user}","gists_url":"https://api.github.com/users/jkakavas/gists{/gist_id}","starred_url":"https://api.github.com/users/jkakavas/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jkakavas/subscriptions","organizations_url":"https://api.github.com/users/jkakavas/orgs","repos_url":"https://api.github.com/users/jkakavas/repos","events_url":"https://api.github.com/users/jkakavas/events{/privacy}","received_events_url":"https://api.github.com/users/jkakavas/received_events","type":"User","site_admin":false},"created_at":"2019-01-17T17:07:15Z","updated_at":"2019-01-17T17:07:15Z","author_association":"CONTRIBUTOR","body":"I don't think the `nonce` binds the `access`-`refresh` token pair to a client. It binds the pair to a user \r\n\r\n> A client like Kibana can generate a random nonce value each time a user does a page reload on Kibana, \r\n\r\nand Court's argument was that this can be used as a canary token of sorts to indicate that only one user is allowed to refresh a refresh token ( someone else attempting to refresh again with a leaked refresh token within the proposed allowed window will not be successful as they won't send the same nonce ). \r\n\r\n> In a UI client, if an attacker gets access to the access token for another user's session, they almost certainly have access to the refresh token as well. Both of these things must be associated with a session in order to be useful.\r\n\r\nThe premise of this attack, presupposes that someone (in increasing order of complexity/decreasing order of probability) either \r\n\r\na. happens to get a kibana auth cookie laying around and try to use it as is\r\nb. has access to the `encryptionKey` value ( thus access to `kibana.yml`  and probably the kibana user credentials ) and gets a kibana auth cookie somewhere (logged in debug logs in the server ?- assuming physical access) so that they can decrypt an auth cookie they got somehow to get the values of the access token and refresh token and use them with the token API\r\nc. have access to the kibana process\r\nd.  are in a MITM position between Elasticsearch and a client and can see raw traffic which means that they need to be doing SSL stripping as the token service requires TLS on the `http` layer of Elasticsearch. \r\n\r\n\r\n`c` and `d` we can't protect against. They have the kibana user credentials, access to the values of `access_token` and `refresh_token` , can see the `nonce` being sent etc. Silently refreshing a token is the least they could do.\r\n\r\n`b` has physical access to the kibana server, I believe they can do far more destructive actions than silently refreshing a user's token. \r\n\r\nSo, we're trying to solve this for `a`: This attacker can't see the refresh token as it is encrypted, and even if they could decrypt they cannot use it on their own because they don't have the credentials of the client that originally got the refresh token. They can only trick Kibana to refresh it for them taking advantage of our refresh window. \r\n\r\nLet's assume the refresh window is 10sec and the access token is valid for 10 mins. \r\n\r\n- Without the refresh window and multiple refreshes ,the attacker would be able to refresh the token anytime within the first 10 mins of access token validity, before the legitimate user refreshed it because their access token expired.  The legitimate user will get an error when their access token expired and would need to re-authenticate. \r\n- With the refresh window and multiple refreshes, the attacker would still be able to do the above plus do it without the user noticing if they could time the refresh (by sending a request to kibana) somewhere between 9m50s and 10m10s. They would then need to keep doing this every 10 min to retain access without logging out the legitimate user. \r\n\r\nI'm leaning to this being an acceptable risk given the prerequisites to exploit this. The stealth property of this attack (which is the only thing an attacker gains here as compared to our current behavior) is , I think, not particularly interesting from an attacker perspective in a web environments where \"you were logged out, please reauthenticate\" messages are not too uncommon to make a legitimate user suspicious. \r\n\r\n@epixa if you think that there is an easy way to have Kibana predictably send the same value for all XHR requests of the same user that might come concurrently, then it doesn't complicate our implementation that much. But if it's a significant effort from your side, I'm not sure we gain much by doing so.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/455300881","html_url":"https://github.com/elastic/elasticsearch/issues/36872#issuecomment-455300881","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/36872","id":455300881,"node_id":"MDEyOklzc3VlQ29tbWVudDQ1NTMwMDg4MQ==","user":{"login":"albertzaharovits","id":4568420,"node_id":"MDQ6VXNlcjQ1Njg0MjA=","avatar_url":"https://avatars2.githubusercontent.com/u/4568420?v=4","gravatar_id":"","url":"https://api.github.com/users/albertzaharovits","html_url":"https://github.com/albertzaharovits","followers_url":"https://api.github.com/users/albertzaharovits/followers","following_url":"https://api.github.com/users/albertzaharovits/following{/other_user}","gists_url":"https://api.github.com/users/albertzaharovits/gists{/gist_id}","starred_url":"https://api.github.com/users/albertzaharovits/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/albertzaharovits/subscriptions","organizations_url":"https://api.github.com/users/albertzaharovits/orgs","repos_url":"https://api.github.com/users/albertzaharovits/repos","events_url":"https://api.github.com/users/albertzaharovits/events{/privacy}","received_events_url":"https://api.github.com/users/albertzaharovits/received_events","type":"User","site_admin":false},"created_at":"2019-01-17T19:29:31Z","updated_at":"2019-01-17T19:29:31Z","author_association":"CONTRIBUTOR","body":"> I don't think the nonce binds the access-refresh token pair to a client. It binds the pair to a user\r\n\r\n >>   A client like Kibana can generate a random nonce value each time a user does a page reload on Kibana,\r\n\r\n> and Court's argument was that this can be used as a canary token of sorts to indicate that only one user is allowed to refresh a refresh token ( someone else attempting to refresh again with a leaked refresh token within the proposed allowed window will not be successful as they won't send the same nonce (1) ).\r\n\r\nUnderstood, thanks for clarifying this @jkakavas ! But from (1) - above , and this bellow\r\n\r\n> They can only trick Kibana to refresh it for them taking advantage of our refresh window.\r\n\r\nI understand that the threat model is that the attacker can trick Kibana to refresh the token but cannot trick it to also use the correct `nonce` ?\r\n\r\nIf that is so, it sounds pretty low risk to me.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/455302019","html_url":"https://github.com/elastic/elasticsearch/issues/36872#issuecomment-455302019","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/36872","id":455302019,"node_id":"MDEyOklzc3VlQ29tbWVudDQ1NTMwMjAxOQ==","user":{"login":"epixa","id":53814,"node_id":"MDQ6VXNlcjUzODE0","avatar_url":"https://avatars0.githubusercontent.com/u/53814?v=4","gravatar_id":"","url":"https://api.github.com/users/epixa","html_url":"https://github.com/epixa","followers_url":"https://api.github.com/users/epixa/followers","following_url":"https://api.github.com/users/epixa/following{/other_user}","gists_url":"https://api.github.com/users/epixa/gists{/gist_id}","starred_url":"https://api.github.com/users/epixa/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/epixa/subscriptions","organizations_url":"https://api.github.com/users/epixa/orgs","repos_url":"https://api.github.com/users/epixa/repos","events_url":"https://api.github.com/users/epixa/events{/privacy}","received_events_url":"https://api.github.com/users/epixa/received_events","type":"User","site_admin":false},"created_at":"2019-01-17T19:32:29Z","updated_at":"2019-01-17T19:32:29Z","author_association":"MEMBER","body":"@kobelb I'd like your thoughts on this:\r\n\r\nGenerating a nonce on page load in Kibana and passing it through on all requests to Elasticsearch should be pretty easy. We'd pass the nonce to the UI via `injectVars`, add it as a header for all HTTP requests to the backend, and then update the authenticate logic to pass the nonce through in the event of refresh.\r\n\r\nHowever, multiple browser tabs complicate the situation as each would have its own `nonce`, which at best would be a bad experience as we break other tabs and at worst would log the user out anyway as the logout operation would fire when refresh failed on another tab.\r\n\r\nWe could address this cross-tab issue by generating the nonce in `sessionStorage` instead. The downside to this approach is that the nonce is a little more sticky than it was before, and it's hard to say how much that impacts the value of the nonce from a security perspective. Since our tokens are stored in a cookie and the nonce is in sessionStorage, pwning the session token doesn't mean pwning the nonce, but that feels like an implementation detail of storage that would be easy to overlook and could realistically change in the future.\r\n\r\nAt this point, I'm leaning toward just abandoning the nonce concept entirely which is the prevailing preference from the ES side anyway.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/455321792","html_url":"https://github.com/elastic/elasticsearch/issues/36872#issuecomment-455321792","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/36872","id":455321792,"node_id":"MDEyOklzc3VlQ29tbWVudDQ1NTMyMTc5Mg==","user":{"login":"kobelb","id":627123,"node_id":"MDQ6VXNlcjYyNzEyMw==","avatar_url":"https://avatars0.githubusercontent.com/u/627123?v=4","gravatar_id":"","url":"https://api.github.com/users/kobelb","html_url":"https://github.com/kobelb","followers_url":"https://api.github.com/users/kobelb/followers","following_url":"https://api.github.com/users/kobelb/following{/other_user}","gists_url":"https://api.github.com/users/kobelb/gists{/gist_id}","starred_url":"https://api.github.com/users/kobelb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/kobelb/subscriptions","organizations_url":"https://api.github.com/users/kobelb/orgs","repos_url":"https://api.github.com/users/kobelb/repos","events_url":"https://api.github.com/users/kobelb/events{/privacy}","received_events_url":"https://api.github.com/users/kobelb/received_events","type":"User","site_admin":false},"created_at":"2019-01-17T20:32:43Z","updated_at":"2019-01-17T20:33:20Z","author_association":"CONTRIBUTOR","body":"> However, multiple browser tabs complicate the situation as each would have its own nonce, which at best would be a bad experience as we break other tabs and at worst would log the user out anyway as the logout operation would fire when refresh failed on another tab.\r\n> \r\n> We could address this cross-tab issue by generating the nonce in sessionStorage instead. The downside to this approach is that the nonce is a little more sticky than it was before, and it's hard to say how much that impacts the value of the nonce from a security perspective. Since our tokens are stored in a cookie and the nonce is in sessionStorage, pwning the session token doesn't mean pwning the nonce, but that feels like an implementation detail of storage that would be easy to overlook and could realistically change in the future.\r\n>\r\n> At this point, I'm leaning toward just abandoning the nonce concept entirely which is the prevailing preference from the ES side anyway.\r\n\r\nI think this is the biggest issue that we're doing to run into when trying to use a nonce for this mechanism. If the attacker is able to access the cookie using some mechanism in the browser (which is even less likely because it has the HttpOnly flag so they can't client-side) they'll definitely be able to access sessionStorage. This means that they're most likely going to get access to the nonce by intercepting a network request to Kibana, which will have both the nonce and the session, so we're already compromised in this scenario.\r\n\r\nI'm also leaning toward abandoning the nonce concept, given the recent discussions.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/455336014","html_url":"https://github.com/elastic/elasticsearch/issues/36872#issuecomment-455336014","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/36872","id":455336014,"node_id":"MDEyOklzc3VlQ29tbWVudDQ1NTMzNjAxNA==","user":{"login":"epixa","id":53814,"node_id":"MDQ6VXNlcjUzODE0","avatar_url":"https://avatars0.githubusercontent.com/u/53814?v=4","gravatar_id":"","url":"https://api.github.com/users/epixa","html_url":"https://github.com/epixa","followers_url":"https://api.github.com/users/epixa/followers","following_url":"https://api.github.com/users/epixa/following{/other_user}","gists_url":"https://api.github.com/users/epixa/gists{/gist_id}","starred_url":"https://api.github.com/users/epixa/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/epixa/subscriptions","organizations_url":"https://api.github.com/users/epixa/orgs","repos_url":"https://api.github.com/users/epixa/repos","events_url":"https://api.github.com/users/epixa/events{/privacy}","received_events_url":"https://api.github.com/users/epixa/received_events","type":"User","site_admin":false},"created_at":"2019-01-17T21:20:31Z","updated_at":"2019-01-17T21:20:31Z","author_association":"MEMBER","body":"Let's consider the `nonce` detail of this proposal abandoned from Kibana's side then.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/455449238","html_url":"https://github.com/elastic/elasticsearch/issues/36872#issuecomment-455449238","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/36872","id":455449238,"node_id":"MDEyOklzc3VlQ29tbWVudDQ1NTQ0OTIzOA==","user":{"login":"jkakavas","id":10281256,"node_id":"MDQ6VXNlcjEwMjgxMjU2","avatar_url":"https://avatars2.githubusercontent.com/u/10281256?v=4","gravatar_id":"","url":"https://api.github.com/users/jkakavas","html_url":"https://github.com/jkakavas","followers_url":"https://api.github.com/users/jkakavas/followers","following_url":"https://api.github.com/users/jkakavas/following{/other_user}","gists_url":"https://api.github.com/users/jkakavas/gists{/gist_id}","starred_url":"https://api.github.com/users/jkakavas/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jkakavas/subscriptions","organizations_url":"https://api.github.com/users/jkakavas/orgs","repos_url":"https://api.github.com/users/jkakavas/repos","events_url":"https://api.github.com/users/jkakavas/events{/privacy}","received_events_url":"https://api.github.com/users/jkakavas/received_events","type":"User","site_admin":false},"created_at":"2019-01-18T07:13:05Z","updated_at":"2019-01-18T07:13:05Z","author_association":"CONTRIBUTOR","body":"@epixa thanks for raising this and thanks for the iterations @kobelb, @albertzaharovits, @jaymode . I'll move with the original proposal without the nonce.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/468920586","html_url":"https://github.com/elastic/elasticsearch/issues/36872#issuecomment-468920586","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/36872","id":468920586,"node_id":"MDEyOklzc3VlQ29tbWVudDQ2ODkyMDU4Ng==","user":{"login":"epixa","id":53814,"node_id":"MDQ6VXNlcjUzODE0","avatar_url":"https://avatars0.githubusercontent.com/u/53814?v=4","gravatar_id":"","url":"https://api.github.com/users/epixa","html_url":"https://github.com/epixa","followers_url":"https://api.github.com/users/epixa/followers","following_url":"https://api.github.com/users/epixa/following{/other_user}","gists_url":"https://api.github.com/users/epixa/gists{/gist_id}","starred_url":"https://api.github.com/users/epixa/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/epixa/subscriptions","organizations_url":"https://api.github.com/users/epixa/orgs","repos_url":"https://api.github.com/users/epixa/repos","events_url":"https://api.github.com/users/epixa/events{/privacy}","received_events_url":"https://api.github.com/users/epixa/received_events","type":"User","site_admin":false},"created_at":"2019-03-02T13:26:55Z","updated_at":"2019-03-02T13:26:55Z","author_association":"MEMBER","body":"I think the change was temporary reverted based on the latest comments in the PR, so I’m reopening this. Feel free to close if I’m mistaken.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/468924598","html_url":"https://github.com/elastic/elasticsearch/issues/36872#issuecomment-468924598","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/36872","id":468924598,"node_id":"MDEyOklzc3VlQ29tbWVudDQ2ODkyNDU5OA==","user":{"login":"jkakavas","id":10281256,"node_id":"MDQ6VXNlcjEwMjgxMjU2","avatar_url":"https://avatars2.githubusercontent.com/u/10281256?v=4","gravatar_id":"","url":"https://api.github.com/users/jkakavas","html_url":"https://github.com/jkakavas","followers_url":"https://api.github.com/users/jkakavas/followers","following_url":"https://api.github.com/users/jkakavas/following{/other_user}","gists_url":"https://api.github.com/users/jkakavas/gists{/gist_id}","starred_url":"https://api.github.com/users/jkakavas/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jkakavas/subscriptions","organizations_url":"https://api.github.com/users/jkakavas/orgs","repos_url":"https://api.github.com/users/jkakavas/repos","events_url":"https://api.github.com/users/jkakavas/events{/privacy}","received_events_url":"https://api.github.com/users/jkakavas/received_events","type":"User","site_admin":false},"created_at":"2019-03-02T14:18:44Z","updated_at":"2019-03-02T14:18:44Z","author_association":"CONTRIBUTOR","body":"You re right Court, I will re-close this on Monday upon submitting the PR again ","performed_via_github_app":null}]