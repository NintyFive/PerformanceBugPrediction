[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/237699123","html_url":"https://github.com/elastic/elasticsearch/issues/19805#issuecomment-237699123","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19805","id":237699123,"node_id":"MDEyOklzc3VlQ29tbWVudDIzNzY5OTEyMw==","user":{"login":"jpountz","id":299848,"node_id":"MDQ6VXNlcjI5OTg0OA==","avatar_url":"https://avatars2.githubusercontent.com/u/299848?v=4","gravatar_id":"","url":"https://api.github.com/users/jpountz","html_url":"https://github.com/jpountz","followers_url":"https://api.github.com/users/jpountz/followers","following_url":"https://api.github.com/users/jpountz/following{/other_user}","gists_url":"https://api.github.com/users/jpountz/gists{/gist_id}","starred_url":"https://api.github.com/users/jpountz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jpountz/subscriptions","organizations_url":"https://api.github.com/users/jpountz/orgs","repos_url":"https://api.github.com/users/jpountz/repos","events_url":"https://api.github.com/users/jpountz/events{/privacy}","received_events_url":"https://api.github.com/users/jpountz/received_events","type":"User","site_admin":false},"created_at":"2016-08-04T22:11:43Z","updated_at":"2016-08-04T22:11:43Z","author_association":"CONTRIBUTOR","body":"I don't think you could avoid the issue that tracing would make the query slower. For instance you mentioned you'd be curious to know how much time was spent in doc values, but we do not run the query, then sort, then run aggregations, everything is interleaved, it makes it hard to measure how much time is spent in every part without slowing down the query.\n\nIt's true profiling only supports queries today but for the record, profiling of aggregations is coming too #18414.\n\nI agree with you it would be nice to know more about decisions.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/237699226","html_url":"https://github.com/elastic/elasticsearch/issues/19805#issuecomment-237699226","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19805","id":237699226,"node_id":"MDEyOklzc3VlQ29tbWVudDIzNzY5OTIyNg==","user":{"login":"jpountz","id":299848,"node_id":"MDQ6VXNlcjI5OTg0OA==","avatar_url":"https://avatars2.githubusercontent.com/u/299848?v=4","gravatar_id":"","url":"https://api.github.com/users/jpountz","html_url":"https://github.com/jpountz","followers_url":"https://api.github.com/users/jpountz/followers","following_url":"https://api.github.com/users/jpountz/following{/other_user}","gists_url":"https://api.github.com/users/jpountz/gists{/gist_id}","starred_url":"https://api.github.com/users/jpountz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jpountz/subscriptions","organizations_url":"https://api.github.com/users/jpountz/orgs","repos_url":"https://api.github.com/users/jpountz/repos","events_url":"https://api.github.com/users/jpountz/events{/privacy}","received_events_url":"https://api.github.com/users/jpountz/received_events","type":"User","site_admin":false},"created_at":"2016-08-04T22:12:12Z","updated_at":"2016-08-04T22:12:12Z","author_association":"CONTRIBUTOR","body":"cc @polyfractal and @colings86 as they might be interested in discussing this issue.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/237876472","html_url":"https://github.com/elastic/elasticsearch/issues/19805#issuecomment-237876472","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19805","id":237876472,"node_id":"MDEyOklzc3VlQ29tbWVudDIzNzg3NjQ3Mg==","user":{"login":"polyfractal","id":1224228,"node_id":"MDQ6VXNlcjEyMjQyMjg=","avatar_url":"https://avatars1.githubusercontent.com/u/1224228?v=4","gravatar_id":"","url":"https://api.github.com/users/polyfractal","html_url":"https://github.com/polyfractal","followers_url":"https://api.github.com/users/polyfractal/followers","following_url":"https://api.github.com/users/polyfractal/following{/other_user}","gists_url":"https://api.github.com/users/polyfractal/gists{/gist_id}","starred_url":"https://api.github.com/users/polyfractal/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/polyfractal/subscriptions","organizations_url":"https://api.github.com/users/polyfractal/orgs","repos_url":"https://api.github.com/users/polyfractal/repos","events_url":"https://api.github.com/users/polyfractal/events{/privacy}","received_events_url":"https://api.github.com/users/polyfractal/received_events","type":"User","site_admin":false},"created_at":"2016-08-05T15:10:24Z","updated_at":"2016-08-05T15:10:24Z","author_association":"MEMBER","body":"++ to knowing more about the decisions being taken.  I think we could include some of this information without too much pain, and the response format gives us room to expand.  \n\nThe response format right now is broken down per-shard, per-\"operation\":\n\n``` json\n{\n  \"profile\": {\n     \"shards\": [\n        {\n           \"id\": \"[2aE02wS1R8q_QFnYu6vDVQ][test][1]\",\n           \"searches\": [ ... ],\n           \"aggregations\": [ ... ]\n        }\n    ]\n  }\n}\n```\n\nSo we have room to add more pieces in the future (`\"highlight\"`, `\"suggesters\"`, etc), as well as potentially a `\"decisions\"` section which gives some high-level information about if caches are used, if the query was rewritten because nothing matched on the shard, etc.\n\nAnd since each profile result is keyed by the `\"id\"` field, there's enough information there to determine what's happening on each shard of each index on each node... it'll just take some munging in a UI to transform based on what you want to view.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/238064007","html_url":"https://github.com/elastic/elasticsearch/issues/19805#issuecomment-238064007","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19805","id":238064007,"node_id":"MDEyOklzc3VlQ29tbWVudDIzODA2NDAwNw==","user":{"login":"asafm","id":989425,"node_id":"MDQ6VXNlcjk4OTQyNQ==","avatar_url":"https://avatars2.githubusercontent.com/u/989425?v=4","gravatar_id":"","url":"https://api.github.com/users/asafm","html_url":"https://github.com/asafm","followers_url":"https://api.github.com/users/asafm/followers","following_url":"https://api.github.com/users/asafm/following{/other_user}","gists_url":"https://api.github.com/users/asafm/gists{/gist_id}","starred_url":"https://api.github.com/users/asafm/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/asafm/subscriptions","organizations_url":"https://api.github.com/users/asafm/orgs","repos_url":"https://api.github.com/users/asafm/repos","events_url":"https://api.github.com/users/asafm/events{/privacy}","received_events_url":"https://api.github.com/users/asafm/received_events","type":"User","site_admin":false},"created_at":"2016-08-07T05:08:23Z","updated_at":"2016-08-07T05:08:23Z","author_association":"NONE","body":"@jpountz - Regarding the interleaving - can you please describe that in more detail? From I can gather, this is the situation when you're doing the query in a streaming fashion - thus multiple threads doing different work, as opposed to one thread executing the query linearly. In that case measuring wall-clock time won't do due to many context switches, but cpu time can be measured per thread, per action taken, and then results could be gathered together per query. In this way, other than adding stop/start measurements you're not slowing down the query. If I'm mistaken, then can you please describe it so I can understand the difficulty here? \n\nRegarding the addition of aggregation to Query API - it's will be great, none the less it won't serve the purpose of knowing what has transpired inside the query - what decision has been made? What actions has been taken? Think that with the output of this feature you can draw a tree of the actions taken to execute the query and _truly_ understand the debug the query. \n\n@polyfractal - Sounds good. I think it's only merly decisions but the execution path tracing - any action that has been taken. You can easily switch between debug/trace levels to know how deep you'd like the actions to be listed. \n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/238218670","html_url":"https://github.com/elastic/elasticsearch/issues/19805#issuecomment-238218670","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19805","id":238218670,"node_id":"MDEyOklzc3VlQ29tbWVudDIzODIxODY3MA==","user":{"login":"jpountz","id":299848,"node_id":"MDQ6VXNlcjI5OTg0OA==","avatar_url":"https://avatars2.githubusercontent.com/u/299848?v=4","gravatar_id":"","url":"https://api.github.com/users/jpountz","html_url":"https://github.com/jpountz","followers_url":"https://api.github.com/users/jpountz/followers","following_url":"https://api.github.com/users/jpountz/following{/other_user}","gists_url":"https://api.github.com/users/jpountz/gists{/gist_id}","starred_url":"https://api.github.com/users/jpountz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jpountz/subscriptions","organizations_url":"https://api.github.com/users/jpountz/orgs","repos_url":"https://api.github.com/users/jpountz/repos","events_url":"https://api.github.com/users/jpountz/events{/privacy}","received_events_url":"https://api.github.com/users/jpountz/received_events","type":"User","site_admin":false},"created_at":"2016-08-08T12:17:14Z","updated_at":"2016-08-08T12:17:14Z","author_association":"CONTRIBUTOR","body":"> can you please describe that in more detail?\n\nWhen you run a query with Lucene, you can provide one or more `Collector` objects, which are callbacks that will be called for every matching document. For instance if you run a query that wants to compute the best 20 hits and the maximum value of a field, there will be two collectors: one that maintains a priority queue of the top 20 hits that have been seen so far, and another one that maintains the maximum value of some field. Then matches are iterated in order and Lucene will call the collectors on every matching document in a single thread. So conceptually, the logic looks like this:\n\n```\nfor (doc in matching_documents) {\n  for (collector in collectors) {\n    collector.collect(doc);\n  }\n}\n```\n\n> Regarding the addition of aggregation to Query API - it's will be great, none the less it won't serve the purpose of knowing what has transpired inside the query - what decision has been made?\n\nAgreed. I wanted to emphasize that what you are seeing today is a first iteration and that we aim at having more in the future. Understanding the execution plan better would definitely be a great addition.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/238327554","html_url":"https://github.com/elastic/elasticsearch/issues/19805#issuecomment-238327554","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19805","id":238327554,"node_id":"MDEyOklzc3VlQ29tbWVudDIzODMyNzU1NA==","user":{"login":"asafm","id":989425,"node_id":"MDQ6VXNlcjk4OTQyNQ==","avatar_url":"https://avatars2.githubusercontent.com/u/989425?v=4","gravatar_id":"","url":"https://api.github.com/users/asafm","html_url":"https://github.com/asafm","followers_url":"https://api.github.com/users/asafm/followers","following_url":"https://api.github.com/users/asafm/following{/other_user}","gists_url":"https://api.github.com/users/asafm/gists{/gist_id}","starred_url":"https://api.github.com/users/asafm/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/asafm/subscriptions","organizations_url":"https://api.github.com/users/asafm/orgs","repos_url":"https://api.github.com/users/asafm/repos","events_url":"https://api.github.com/users/asafm/events{/privacy}","received_events_url":"https://api.github.com/users/asafm/received_events","type":"User","site_admin":false},"created_at":"2016-08-08T18:15:18Z","updated_at":"2016-08-08T18:15:18Z","author_association":"NONE","body":"@jpountz - ok, so we can measure CPU time and/or clock time inside the callback to know the cost of calculating the top (i.e. aggregations), without any impact on performance right? Something like\n\n```\nClass MyCollector {\n     LongAdder wallClockTimeSpent = new LongAdder();\n     public void collect() {\n           Stopwatch sw = new Stopwatch().start();\n           // ... do the logic here\n          wallClockTimeSpent.add(sw.stop().elaspsed());\n     }\n}\n```\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/238475257","html_url":"https://github.com/elastic/elasticsearch/issues/19805#issuecomment-238475257","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19805","id":238475257,"node_id":"MDEyOklzc3VlQ29tbWVudDIzODQ3NTI1Nw==","user":{"login":"jpountz","id":299848,"node_id":"MDQ6VXNlcjI5OTg0OA==","avatar_url":"https://avatars2.githubusercontent.com/u/299848?v=4","gravatar_id":"","url":"https://api.github.com/users/jpountz","html_url":"https://github.com/jpountz","followers_url":"https://api.github.com/users/jpountz/followers","following_url":"https://api.github.com/users/jpountz/following{/other_user}","gists_url":"https://api.github.com/users/jpountz/gists{/gist_id}","starred_url":"https://api.github.com/users/jpountz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jpountz/subscriptions","organizations_url":"https://api.github.com/users/jpountz/orgs","repos_url":"https://api.github.com/users/jpountz/repos","events_url":"https://api.github.com/users/jpountz/events{/privacy}","received_events_url":"https://api.github.com/users/jpountz/received_events","type":"User","site_admin":false},"created_at":"2016-08-09T07:28:48Z","updated_at":"2016-08-09T07:28:48Z","author_association":"CONTRIBUTOR","body":"@asafm This is the way things work today. Collectors are usually fast (for instance a max aggregation just has to read a value from the index and then update the running max) but called in tight loops, so the impact of such counters is not negligible.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/238493482","html_url":"https://github.com/elastic/elasticsearch/issues/19805#issuecomment-238493482","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19805","id":238493482,"node_id":"MDEyOklzc3VlQ29tbWVudDIzODQ5MzQ4Mg==","user":{"login":"asafm","id":989425,"node_id":"MDQ6VXNlcjk4OTQyNQ==","avatar_url":"https://avatars2.githubusercontent.com/u/989425?v=4","gravatar_id":"","url":"https://api.github.com/users/asafm","html_url":"https://github.com/asafm","followers_url":"https://api.github.com/users/asafm/followers","following_url":"https://api.github.com/users/asafm/following{/other_user}","gists_url":"https://api.github.com/users/asafm/gists{/gist_id}","starred_url":"https://api.github.com/users/asafm/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/asafm/subscriptions","organizations_url":"https://api.github.com/users/asafm/orgs","repos_url":"https://api.github.com/users/asafm/repos","events_url":"https://api.github.com/users/asafm/events{/privacy}","received_events_url":"https://api.github.com/users/asafm/received_events","type":"User","site_admin":false},"created_at":"2016-08-09T08:54:32Z","updated_at":"2016-08-09T08:54:32Z","author_association":"NONE","body":"@jpountz - Ok. So when you activate \"trace:true\" you will know that the query performance will be hit. \nFrom my observations, when I turn on profile:true, queries taking 40 seconds can take several minutes, so I guess in our discussion, \"trace:true\" should affect in matter or seconds top (I suspect milliseconds).\n\nSince we have the need for this feature in the company I work for, I might manage to get time allocated implementing this. What would be the approach to do this? Can I get some pointers on where to begin and places to start my homework and then suggest a high level design for it?\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/238496973","html_url":"https://github.com/elastic/elasticsearch/issues/19805#issuecomment-238496973","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19805","id":238496973,"node_id":"MDEyOklzc3VlQ29tbWVudDIzODQ5Njk3Mw==","user":{"login":"jpountz","id":299848,"node_id":"MDQ6VXNlcjI5OTg0OA==","avatar_url":"https://avatars2.githubusercontent.com/u/299848?v=4","gravatar_id":"","url":"https://api.github.com/users/jpountz","html_url":"https://github.com/jpountz","followers_url":"https://api.github.com/users/jpountz/followers","following_url":"https://api.github.com/users/jpountz/following{/other_user}","gists_url":"https://api.github.com/users/jpountz/gists{/gist_id}","starred_url":"https://api.github.com/users/jpountz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jpountz/subscriptions","organizations_url":"https://api.github.com/users/jpountz/orgs","repos_url":"https://api.github.com/users/jpountz/repos","events_url":"https://api.github.com/users/jpountz/events{/privacy}","received_events_url":"https://api.github.com/users/jpountz/received_events","type":"User","site_admin":false},"created_at":"2016-08-09T09:10:01Z","updated_at":"2016-08-09T09:10:01Z","author_association":"CONTRIBUTOR","body":"@asafm One important requirement for the profile API was that it should not be too invasive in the code base. So if you manage to get a proof of concept working that also meets this requirement while having less impact on the runtime of queries, I'd be willing to look into it more. Maybe you can start by looking at the `org.elasticsearch.search.profile` to see how the profile API works?\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/290667654","html_url":"https://github.com/elastic/elasticsearch/issues/19805#issuecomment-290667654","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19805","id":290667654,"node_id":"MDEyOklzc3VlQ29tbWVudDI5MDY2NzY1NA==","user":{"login":"colings86","id":236731,"node_id":"MDQ6VXNlcjIzNjczMQ==","avatar_url":"https://avatars0.githubusercontent.com/u/236731?v=4","gravatar_id":"","url":"https://api.github.com/users/colings86","html_url":"https://github.com/colings86","followers_url":"https://api.github.com/users/colings86/followers","following_url":"https://api.github.com/users/colings86/following{/other_user}","gists_url":"https://api.github.com/users/colings86/gists{/gist_id}","starred_url":"https://api.github.com/users/colings86/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/colings86/subscriptions","organizations_url":"https://api.github.com/users/colings86/orgs","repos_url":"https://api.github.com/users/colings86/repos","events_url":"https://api.github.com/users/colings86/events{/privacy}","received_events_url":"https://api.github.com/users/colings86/received_events","type":"User","site_admin":false},"created_at":"2017-03-31T09:41:02Z","updated_at":"2017-03-31T09:41:02Z","author_association":"MEMBER","body":"No further feedback so I will close this for now, please reopen if you have developments on this","performed_via_github_app":null}]