{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/3376","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/3376/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/3376/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/3376/events","html_url":"https://github.com/elastic/elasticsearch/issues/3376","id":17147252,"node_id":"MDU6SXNzdWUxNzE0NzI1Mg==","number":3376,"title":"Completion prefix suggestion ","user":{"login":"spinscale","id":667544,"node_id":"MDQ6VXNlcjY2NzU0NA==","avatar_url":"https://avatars2.githubusercontent.com/u/667544?v=4","gravatar_id":"","url":"https://api.github.com/users/spinscale","html_url":"https://github.com/spinscale","followers_url":"https://api.github.com/users/spinscale/followers","following_url":"https://api.github.com/users/spinscale/following{/other_user}","gists_url":"https://api.github.com/users/spinscale/gists{/gist_id}","starred_url":"https://api.github.com/users/spinscale/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/spinscale/subscriptions","organizations_url":"https://api.github.com/users/spinscale/orgs","repos_url":"https://api.github.com/users/spinscale/repos","events_url":"https://api.github.com/users/spinscale/events{/privacy}","received_events_url":"https://api.github.com/users/spinscale/received_events","type":"User","site_admin":false},"labels":[{"id":23172,"node_id":"MDU6TGFiZWwyMzE3Mg==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/%3Efeature","name":">feature","color":"006b75","default":false,"description":null},{"id":45109570,"node_id":"MDU6TGFiZWw0NTEwOTU3MA==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/v0.90.3","name":"v0.90.3","color":"DDDDDD","default":false,"description":null},{"id":37906111,"node_id":"MDU6TGFiZWwzNzkwNjExMQ==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/v1.0.0.Beta1","name":"v1.0.0.Beta1","color":"DDDDDD","default":false,"description":null}],"state":"closed","locked":false,"assignee":{"login":"spinscale","id":667544,"node_id":"MDQ6VXNlcjY2NzU0NA==","avatar_url":"https://avatars2.githubusercontent.com/u/667544?v=4","gravatar_id":"","url":"https://api.github.com/users/spinscale","html_url":"https://github.com/spinscale","followers_url":"https://api.github.com/users/spinscale/followers","following_url":"https://api.github.com/users/spinscale/following{/other_user}","gists_url":"https://api.github.com/users/spinscale/gists{/gist_id}","starred_url":"https://api.github.com/users/spinscale/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/spinscale/subscriptions","organizations_url":"https://api.github.com/users/spinscale/orgs","repos_url":"https://api.github.com/users/spinscale/repos","events_url":"https://api.github.com/users/spinscale/events{/privacy}","received_events_url":"https://api.github.com/users/spinscale/received_events","type":"User","site_admin":false},"assignees":[{"login":"spinscale","id":667544,"node_id":"MDQ6VXNlcjY2NzU0NA==","avatar_url":"https://avatars2.githubusercontent.com/u/667544?v=4","gravatar_id":"","url":"https://api.github.com/users/spinscale","html_url":"https://github.com/spinscale","followers_url":"https://api.github.com/users/spinscale/followers","following_url":"https://api.github.com/users/spinscale/following{/other_user}","gists_url":"https://api.github.com/users/spinscale/gists{/gist_id}","starred_url":"https://api.github.com/users/spinscale/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/spinscale/subscriptions","organizations_url":"https://api.github.com/users/spinscale/orgs","repos_url":"https://api.github.com/users/spinscale/repos","events_url":"https://api.github.com/users/spinscale/events{/privacy}","received_events_url":"https://api.github.com/users/spinscale/received_events","type":"User","site_admin":false}],"milestone":null,"comments":0,"created_at":"2013-07-24T09:29:30Z","updated_at":"2013-08-06T14:06:17Z","closed_at":"2013-08-01T06:56:11Z","author_association":"MEMBER","active_lock_reason":null,"body":"**Note**: This is an experimental feature!\n\nTraditionally FST suggesters needed to create an in-memory structure upfront, which needed to be in sync with the data inserted/deleted. This step to create a FST can be really expensive and long lasting on production systems.\n\nSo, why not trying to create an efficient FST alike structure on index time, load that quickly into memory and use this for suggestions?\n\nBefore deep diving into implementation details, let's start with a small sample\n# Sample\n\nCreate a simple mapping\n\n```\ncurl -X DELETE localhost:9200/music\ncurl -X PUT localhost:9200/music\n\ncurl -X PUT localhost:9200/music/song/_mapping -d '{\n  \"song\" : {\n        \"properties\" : {\n            \"name\" : { \"type\" : \"string\" },\n            \"suggest\" : { \"type\" : \"completion\",\n                          \"index_analyzer\" : \"stopword\",\n                          \"search_analyzer\" : \"simple\",\n                          \"payloads\" : true\n            }\n        }\n    }\n}'\n\ncurl -X PUT 'localhost:9200/music/song/1?refresh=true' -d '{\n    \"name\" : \"Nevermind\",\n    \"suggest\" : { \n        \"input\": [ \"Nevermind\", \"Nirvana\" ],\n        \"output\": \"Nirvana - Nevermind\",\n        \"payload\" : { \"artistId\" : 2321 }\n    }\n}'\n```\n\nA request looks like this\n\n```\ncurl -X POST 'localhost:9200/music/_suggest' -d '{\n    \"song-suggest\" : {\n        \"text\" : \"nev\",\n        \"completion\" : {\n            \"field\" : \"suggest\"\n        }\n    }\n}'\n```\n\nThis is the response\n\n```\n{\n  \"_shards\" : {\n    \"total\" : 5,\n    \"successful\" : 5,\n    \"failed\" : 0\n  },\n  \"song-suggest\" : [ {\n    \"text\" : \"nev\",\n    \"offset\" : 0,\n    \"length\" : 10,\n    \"options\" : [ {\n      \"text\" : \"Nirvana - Nevermind\",\n      \"score\" : 1.0, \"payload\" : {\"artistId\":2321}\n    } ]\n  } ]\n}\n```\n\nAs you can see, the text returned is the provided output during indexing. Also the payload is included, which might carry a reference ID to the artist and thus makes it easy to retrieve further information.\n# Mapping options\n\nIn order to support prefix suggestion the field has to be marked as type `completion`.\n\n```\n{\n    ...\n     \"properties\" : {\n        \"suggestField\" {\n            \"type\" : \"completion\"\n            \"index_analyzer\" : \"stopword\",\n            \"search_analyzer\" : \"simple\",\n        }\n    }\n}\n```\n\nWhile the `type` field is mandatory, the `index_analyzer` and `search_analyzer` fields can be omitted. The `simple` analyzer is used by default.\n## Payloads\n\nIf you want to return payloads, you have to explicitely enable them by using `payloads: true` - payloads can contain arbitrary JSON, but must be a JSON object, with opening `{` and closing `}` - no pure strings or arrays allowed.\n## Preserve separators\n\nIn addition, you can set `preserve_separators: false` in case you in case you want to return \"Foo Fighters\" when searching for \"foof\" (using the correct analyzer of course).\n## Preserve position increments\n\nYou can set `preserve_position_increments: false` in order to not count increase position increments, which is needed if the first word is a stopword and you are using an analyzer to filter out stopwords. This would allow you to suggest for `b` and get back `The Beatles`\n# Indexing\n## Simple case\n\nThe most simple case to index is like this\n\n```\n\"suggestField\" : [ \"The Prodigy Firestarter\", \"Firestarter\"]\n```\n\nDepending on the analyzer used\n## Outputs\n\nDefining an output will always return the output for a found suggestion.\n\n```\n\"suggestField\" : { \n  \"input\" : [ \"The Prodigy Firestarter\", \"Firestarter\"],\n  \"output\" : \"The Prodigy, Firestarter\",\n}\n```\n## Weights\n\nYou should define custom weights instead of relying on the default one (see the drawbacks section). The weight must be an positive integer (**no float**) and defines the order of your suggestions.\n\n```\n\"suggestField\" : { \n  \"input\" : [ \"The Prodigy Firestarter\", \"Firestarter\"],\n  \"output\" : \"The Prodigy, Firestarter\",\n  \"weight\" : 42\n}\n```\n\nAlso custom weights can make your suggestions valuable. Using weights you could boost the most played song or the best rated hotel first in your suggestions.\n# Search\n\nSearches are working exactly like the phrase and term suggesters\n\n```\ncurl -X POST 'localhost:9200/music/_suggest' -d '{\n    \"song-suggest\" : {\n        \"text\" : \"nev\",\n        \"completion\" : {\n            \"field\" : \"suggest\"\n        }\n    }\n}'\n```\n# Drawbacks\n## Using term frequency as default weight\n\nIf you do not specify a weight, the term frequency is used. This only makes sense if you optimize to a single segment or have large segments. If you do not, having custom weights might yield the results you are awaiting. So using term frequences as a weight indicator is not the best solution and you should set weight yourself.\n","closed_by":{"login":"spinscale","id":667544,"node_id":"MDQ6VXNlcjY2NzU0NA==","avatar_url":"https://avatars2.githubusercontent.com/u/667544?v=4","gravatar_id":"","url":"https://api.github.com/users/spinscale","html_url":"https://github.com/spinscale","followers_url":"https://api.github.com/users/spinscale/followers","following_url":"https://api.github.com/users/spinscale/following{/other_user}","gists_url":"https://api.github.com/users/spinscale/gists{/gist_id}","starred_url":"https://api.github.com/users/spinscale/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/spinscale/subscriptions","organizations_url":"https://api.github.com/users/spinscale/orgs","repos_url":"https://api.github.com/users/spinscale/repos","events_url":"https://api.github.com/users/spinscale/events{/privacy}","received_events_url":"https://api.github.com/users/spinscale/received_events","type":"User","site_admin":false},"performed_via_github_app":null}