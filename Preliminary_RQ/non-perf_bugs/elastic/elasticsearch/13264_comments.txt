[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/136953971","html_url":"https://github.com/elastic/elasticsearch/issues/13264#issuecomment-136953971","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/13264","id":136953971,"node_id":"MDEyOklzc3VlQ29tbWVudDEzNjk1Mzk3MQ==","user":{"login":"s1monw","id":973334,"node_id":"MDQ6VXNlcjk3MzMzNA==","avatar_url":"https://avatars0.githubusercontent.com/u/973334?v=4","gravatar_id":"","url":"https://api.github.com/users/s1monw","html_url":"https://github.com/s1monw","followers_url":"https://api.github.com/users/s1monw/followers","following_url":"https://api.github.com/users/s1monw/following{/other_user}","gists_url":"https://api.github.com/users/s1monw/gists{/gist_id}","starred_url":"https://api.github.com/users/s1monw/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/s1monw/subscriptions","organizations_url":"https://api.github.com/users/s1monw/orgs","repos_url":"https://api.github.com/users/s1monw/repos","events_url":"https://api.github.com/users/s1monw/events{/privacy}","received_events_url":"https://api.github.com/users/s1monw/received_events","type":"User","site_admin":false},"created_at":"2015-09-02T06:42:50Z","updated_at":"2015-09-02T06:43:40Z","author_association":"CONTRIBUTOR","body":"> deleteShardDirectorySafe is anything but safe. it calls deleteShardDirectoryUnderLock which doesn't actually delete under a lock either!!!! It calls this bogus method: acquireFSLockForPaths which acquires then releases locks. Why? Why? Why?\n\nso we need to clarify the naming here, we actually delete under lock but it's not the IW lock it's a shard lock that we maintain internally per  Node.\n\n``` Java\npublic void deleteShardDirectorySafe(ShardId shardId, @IndexSettings Settings indexSettings) throws IOException {\n        // This is to ensure someone doesn't use Settings.EMPTY\n        assert indexSettings != Settings.EMPTY;\n        final Path[] paths = availableShardPaths(shardId);\n        logger.trace(\"deleting shard {} directory, paths: [{}]\", shardId, paths);\n        try (ShardLock lock = shardLock(shardId)) { // <==== here we lock and keep the lock - it's JVM internal\n            deleteShardDirectoryUnderLock(lock, indexSettings);\n        }\n    }\n```\n\nthe `Why? Why? Why?` is especially interesting and I think you should talk to the guy who reviewed the change: `https://github.com/elastic/elasticsearch/pull/11127` He said:\n\n`yes, I am +1 for this approach. Maybe we can add a line to the javadocs just mentioning this is the case. Especially if you think about locking on shared filesystems, we should not rush to do something complex.`\n\nI am not sure if the Javadoc happened but it need clarification.\n\n> assertEnvIsLocked is only called under assert. why? Look at findAllIndices, its about to do something really expensive, why can't the call to ensureValid be a real check?\n\n+1 to make it a real check where it makes sense...\n\n> assertEnvIsLocked has a bunch of leniency, why in the hell would it return true when closed or when there are no locks at all, thats broken.\n\n+1 to beef it up.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/136954687","html_url":"https://github.com/elastic/elasticsearch/issues/13264#issuecomment-136954687","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/13264","id":136954687,"node_id":"MDEyOklzc3VlQ29tbWVudDEzNjk1NDY4Nw==","user":{"login":"rmuir","id":504194,"node_id":"MDQ6VXNlcjUwNDE5NA==","avatar_url":"https://avatars1.githubusercontent.com/u/504194?v=4","gravatar_id":"","url":"https://api.github.com/users/rmuir","html_url":"https://github.com/rmuir","followers_url":"https://api.github.com/users/rmuir/followers","following_url":"https://api.github.com/users/rmuir/following{/other_user}","gists_url":"https://api.github.com/users/rmuir/gists{/gist_id}","starred_url":"https://api.github.com/users/rmuir/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/rmuir/subscriptions","organizations_url":"https://api.github.com/users/rmuir/orgs","repos_url":"https://api.github.com/users/rmuir/repos","events_url":"https://api.github.com/users/rmuir/events{/privacy}","received_events_url":"https://api.github.com/users/rmuir/received_events","type":"User","site_admin":false},"created_at":"2015-09-02T06:49:20Z","updated_at":"2015-09-02T06:49:20Z","author_association":"CONTRIBUTOR","body":"Yes, I remember this, but now is our chance to fix it, so locking is as good as we can make it. It seems we are broken because of the placement of the lock files being underneath what is deleted, but that is something fixable.\n\nIts 2.0, there is no constraint about back compat here, so I think its time to fix it correctly.\n\nAdditionally we spent lots of time, and added lots of paranoia in lucene to actually help with shitty behavior from shared filesystems, so it would be nice if it stands a chance.\n\nAs far as the shard lock, i have no idea what that is. How is it better than a filesystem lock? Its definitely got a shitload of abstractions, but i can't tell if its anything more than a in-process RWL.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/136956523","html_url":"https://github.com/elastic/elasticsearch/issues/13264#issuecomment-136956523","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/13264","id":136956523,"node_id":"MDEyOklzc3VlQ29tbWVudDEzNjk1NjUyMw==","user":{"login":"s1monw","id":973334,"node_id":"MDQ6VXNlcjk3MzMzNA==","avatar_url":"https://avatars0.githubusercontent.com/u/973334?v=4","gravatar_id":"","url":"https://api.github.com/users/s1monw","html_url":"https://github.com/s1monw","followers_url":"https://api.github.com/users/s1monw/followers","following_url":"https://api.github.com/users/s1monw/following{/other_user}","gists_url":"https://api.github.com/users/s1monw/gists{/gist_id}","starred_url":"https://api.github.com/users/s1monw/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/s1monw/subscriptions","organizations_url":"https://api.github.com/users/s1monw/orgs","repos_url":"https://api.github.com/users/s1monw/repos","events_url":"https://api.github.com/users/s1monw/events{/privacy}","received_events_url":"https://api.github.com/users/s1monw/received_events","type":"User","site_admin":false},"created_at":"2015-09-02T07:01:26Z","updated_at":"2015-09-02T07:01:26Z","author_association":"CONTRIBUTOR","body":"I think we should make this straight forward and add a `/locks` directory to each root path we are using. This directory can then be full of locks and will never be deleted. The crucial part is that it has to be on the same mount as the actual data it protects otherwise it will likely not help at all in the shared FS case.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/136972133","html_url":"https://github.com/elastic/elasticsearch/issues/13264#issuecomment-136972133","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/13264","id":136972133,"node_id":"MDEyOklzc3VlQ29tbWVudDEzNjk3MjEzMw==","user":{"login":"rmuir","id":504194,"node_id":"MDQ6VXNlcjUwNDE5NA==","avatar_url":"https://avatars1.githubusercontent.com/u/504194?v=4","gravatar_id":"","url":"https://api.github.com/users/rmuir","html_url":"https://github.com/rmuir","followers_url":"https://api.github.com/users/rmuir/followers","following_url":"https://api.github.com/users/rmuir/following{/other_user}","gists_url":"https://api.github.com/users/rmuir/gists{/gist_id}","starred_url":"https://api.github.com/users/rmuir/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/rmuir/subscriptions","organizations_url":"https://api.github.com/users/rmuir/orgs","repos_url":"https://api.github.com/users/rmuir/repos","events_url":"https://api.github.com/users/rmuir/events{/privacy}","received_events_url":"https://api.github.com/users/rmuir/received_events","type":"User","site_admin":false},"created_at":"2015-09-02T08:14:02Z","updated_at":"2015-09-02T08:14:02Z","author_association":"CONTRIBUTOR","body":"yeah, i think something along those lines: though is 'never deleted' a problem with ppl that have tons and tons of shards cycling through? accumulating a bunch of 0-byte files sounds dangerous and eventually the directory is gonna crap its pants. \n\nDeleting an NIOFS lock file is especially tricky and we just don't do it ever in lucene (we leave the lock file around). I dont know how to fix that without adding a \"master\" lock file that always stays around and is acquired around individual lock acquire/release+delete.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/137361080","html_url":"https://github.com/elastic/elasticsearch/issues/13264#issuecomment-137361080","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/13264","id":137361080,"node_id":"MDEyOklzc3VlQ29tbWVudDEzNzM2MTA4MA==","user":{"login":"s1monw","id":973334,"node_id":"MDQ6VXNlcjk3MzMzNA==","avatar_url":"https://avatars0.githubusercontent.com/u/973334?v=4","gravatar_id":"","url":"https://api.github.com/users/s1monw","html_url":"https://github.com/s1monw","followers_url":"https://api.github.com/users/s1monw/followers","following_url":"https://api.github.com/users/s1monw/following{/other_user}","gists_url":"https://api.github.com/users/s1monw/gists{/gist_id}","starred_url":"https://api.github.com/users/s1monw/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/s1monw/subscriptions","organizations_url":"https://api.github.com/users/s1monw/orgs","repos_url":"https://api.github.com/users/s1monw/repos","events_url":"https://api.github.com/users/s1monw/events{/privacy}","received_events_url":"https://api.github.com/users/s1monw/received_events","type":"User","site_admin":false},"created_at":"2015-09-03T07:34:26Z","updated_at":"2015-09-03T07:34:26Z","author_association":"CONTRIBUTOR","body":"> Deleting an NIOFS lock file is especially tricky and we just don't do it ever in lucene (we leave the lock file around). I dont know how to fix that without adding a \"master\" lock file that always stays around and is acquired around individual lock acquire/release+delete.\n\nyeah we won't have a way around that I guess. I think what we can do is to have an `$index_name.lock` that you need to own to make changes to the `$index_name_$shardId.lock` which also allows to delete it. That reduces the set to the number of indices. We can safely delete the `$index_name.lock` once the last shard of the index is deleted?\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/137364794","html_url":"https://github.com/elastic/elasticsearch/issues/13264#issuecomment-137364794","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/13264","id":137364794,"node_id":"MDEyOklzc3VlQ29tbWVudDEzNzM2NDc5NA==","user":{"login":"rmuir","id":504194,"node_id":"MDQ6VXNlcjUwNDE5NA==","avatar_url":"https://avatars1.githubusercontent.com/u/504194?v=4","gravatar_id":"","url":"https://api.github.com/users/rmuir","html_url":"https://github.com/rmuir","followers_url":"https://api.github.com/users/rmuir/followers","following_url":"https://api.github.com/users/rmuir/following{/other_user}","gists_url":"https://api.github.com/users/rmuir/gists{/gist_id}","starred_url":"https://api.github.com/users/rmuir/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/rmuir/subscriptions","organizations_url":"https://api.github.com/users/rmuir/orgs","repos_url":"https://api.github.com/users/rmuir/repos","events_url":"https://api.github.com/users/rmuir/events{/privacy}","received_events_url":"https://api.github.com/users/rmuir/received_events","type":"User","site_admin":false},"created_at":"2015-09-03T07:44:45Z","updated_at":"2015-09-03T07:44:45Z","author_association":"CONTRIBUTOR","body":"Why do that? just have global.lock. Its only needed around the actaul _acquire_ and _release+delete_. Its not gonna cause a concurrency issue. \n\nDoing this in a more fine grained way makes zero sense.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/137370804","html_url":"https://github.com/elastic/elasticsearch/issues/13264#issuecomment-137370804","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/13264","id":137370804,"node_id":"MDEyOklzc3VlQ29tbWVudDEzNzM3MDgwNA==","user":{"login":"s1monw","id":973334,"node_id":"MDQ6VXNlcjk3MzMzNA==","avatar_url":"https://avatars0.githubusercontent.com/u/973334?v=4","gravatar_id":"","url":"https://api.github.com/users/s1monw","html_url":"https://github.com/s1monw","followers_url":"https://api.github.com/users/s1monw/followers","following_url":"https://api.github.com/users/s1monw/following{/other_user}","gists_url":"https://api.github.com/users/s1monw/gists{/gist_id}","starred_url":"https://api.github.com/users/s1monw/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/s1monw/subscriptions","organizations_url":"https://api.github.com/users/s1monw/orgs","repos_url":"https://api.github.com/users/s1monw/repos","events_url":"https://api.github.com/users/s1monw/events{/privacy}","received_events_url":"https://api.github.com/users/s1monw/received_events","type":"User","site_admin":false},"created_at":"2015-09-03T07:57:52Z","updated_at":"2015-09-03T07:57:52Z","author_association":"CONTRIBUTOR","body":"> Doing this in a more fine grained way makes zero sense.\n\nhaving an index level lock make sense to have here anyway since we also have index metadata we want to protect from concurrent modifications. All I was saying here is that we might be able to get away with not locking the global lock as long as we are in the context of an index. \n","performed_via_github_app":null}]