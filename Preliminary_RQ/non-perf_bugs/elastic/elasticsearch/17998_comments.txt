[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/215506361","html_url":"https://github.com/elastic/elasticsearch/issues/17998#issuecomment-215506361","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/17998","id":215506361,"node_id":"MDEyOklzc3VlQ29tbWVudDIxNTUwNjM2MQ==","user":{"login":"clintongormley","id":56599,"node_id":"MDQ6VXNlcjU2NTk5","avatar_url":"https://avatars0.githubusercontent.com/u/56599?v=4","gravatar_id":"","url":"https://api.github.com/users/clintongormley","html_url":"https://github.com/clintongormley","followers_url":"https://api.github.com/users/clintongormley/followers","following_url":"https://api.github.com/users/clintongormley/following{/other_user}","gists_url":"https://api.github.com/users/clintongormley/gists{/gist_id}","starred_url":"https://api.github.com/users/clintongormley/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/clintongormley/subscriptions","organizations_url":"https://api.github.com/users/clintongormley/orgs","repos_url":"https://api.github.com/users/clintongormley/repos","events_url":"https://api.github.com/users/clintongormley/events{/privacy}","received_events_url":"https://api.github.com/users/clintongormley/received_events","type":"User","site_admin":false},"created_at":"2016-04-28T17:41:47Z","updated_at":"2016-04-28T17:41:47Z","author_association":"CONTRIBUTOR","body":"@HonzaKral I'm struggling to see how this would be useful, especially when dealing with the complexity of both documents existing (or neither document existing) for a period.  Could you elaborate on use cases?\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/215883042","html_url":"https://github.com/elastic/elasticsearch/issues/17998#issuecomment-215883042","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/17998","id":215883042,"node_id":"MDEyOklzc3VlQ29tbWVudDIxNTg4MzA0Mg==","user":{"login":"HonzaKral","id":32132,"node_id":"MDQ6VXNlcjMyMTMy","avatar_url":"https://avatars0.githubusercontent.com/u/32132?v=4","gravatar_id":"","url":"https://api.github.com/users/HonzaKral","html_url":"https://github.com/HonzaKral","followers_url":"https://api.github.com/users/HonzaKral/followers","following_url":"https://api.github.com/users/HonzaKral/following{/other_user}","gists_url":"https://api.github.com/users/HonzaKral/gists{/gist_id}","starred_url":"https://api.github.com/users/HonzaKral/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/HonzaKral/subscriptions","organizations_url":"https://api.github.com/users/HonzaKral/orgs","repos_url":"https://api.github.com/users/HonzaKral/repos","events_url":"https://api.github.com/users/HonzaKral/events{/privacy}","received_events_url":"https://api.github.com/users/HonzaKral/received_events","type":"User","site_admin":false},"created_at":"2016-04-29T21:11:54Z","updated_at":"2016-04-29T21:11:54Z","author_association":"MEMBER","body":"The use case I have in mind is a migration from a single index and aliases to separate index. Let's assume you store user-generated data in one index and use aliases to give the app an illusion of an index-per-user architecture. Now one user proves to be too big to live in a common index and needs to be put into it's own index. With aliases it is very easy to do, but you need to move the data - copy them to the newly created index and delete them from the old one. You can do it with `reindex` and `delete-by-query` but making it into one command would be nicer and would also minimize the discrepancies during the process (where a document exists in both old and new indices).\n\nSimilar as #17997 it can be viewed as a generalization of the reindex api to allow for _any_ bulk operation - not just index, but also a delete/update and possibly against different indices.\n\nIn client code, using `scan`/`bulk` combination this can be simply achieved by adjusting the code generating the bulk request (both the action and data lines).\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/216196349","html_url":"https://github.com/elastic/elasticsearch/issues/17998#issuecomment-216196349","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/17998","id":216196349,"node_id":"MDEyOklzc3VlQ29tbWVudDIxNjE5NjM0OQ==","user":{"login":"clintongormley","id":56599,"node_id":"MDQ6VXNlcjU2NTk5","avatar_url":"https://avatars0.githubusercontent.com/u/56599?v=4","gravatar_id":"","url":"https://api.github.com/users/clintongormley","html_url":"https://github.com/clintongormley","followers_url":"https://api.github.com/users/clintongormley/followers","following_url":"https://api.github.com/users/clintongormley/following{/other_user}","gists_url":"https://api.github.com/users/clintongormley/gists{/gist_id}","starred_url":"https://api.github.com/users/clintongormley/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/clintongormley/subscriptions","organizations_url":"https://api.github.com/users/clintongormley/orgs","repos_url":"https://api.github.com/users/clintongormley/repos","events_url":"https://api.github.com/users/clintongormley/events{/privacy}","received_events_url":"https://api.github.com/users/clintongormley/received_events","type":"User","site_admin":false},"created_at":"2016-05-02T10:47:24Z","updated_at":"2016-05-02T10:47:24Z","author_association":"CONTRIBUTOR","body":"Aliases make the transition atomic.  Doing this doc-by-doc (besides being a much heavier operation) would result in moments when either the same doc is visible in both indices or is visible in neither index (because of the differences in refresh times).  This makes life more complex for the user, rather than less.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/216224449","html_url":"https://github.com/elastic/elasticsearch/issues/17998#issuecomment-216224449","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/17998","id":216224449,"node_id":"MDEyOklzc3VlQ29tbWVudDIxNjIyNDQ0OQ==","user":{"login":"HonzaKral","id":32132,"node_id":"MDQ6VXNlcjMyMTMy","avatar_url":"https://avatars0.githubusercontent.com/u/32132?v=4","gravatar_id":"","url":"https://api.github.com/users/HonzaKral","html_url":"https://github.com/HonzaKral","followers_url":"https://api.github.com/users/HonzaKral/followers","following_url":"https://api.github.com/users/HonzaKral/following{/other_user}","gists_url":"https://api.github.com/users/HonzaKral/gists{/gist_id}","starred_url":"https://api.github.com/users/HonzaKral/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/HonzaKral/subscriptions","organizations_url":"https://api.github.com/users/HonzaKral/orgs","repos_url":"https://api.github.com/users/HonzaKral/repos","events_url":"https://api.github.com/users/HonzaKral/events{/privacy}","received_events_url":"https://api.github.com/users/HonzaKral/received_events","type":"User","site_admin":false},"created_at":"2016-05-02T12:37:43Z","updated_at":"2016-05-02T12:37:43Z","author_association":"MEMBER","body":"Well, with aliases you have several options, each with its set of problems, none of those are really atomic - switch when the empty index is created and then wait for the reindex to populate it, in this case your user sees missing data for a long time.\n\nOther option is to point the alias to both indices, but then you have to have a separate write alias and you still need to solve moving the data - if you use reindex then you will start seeing duplicates until all the data is copied and then you remove the original index from the alias. During the transition updates can be also problematic.\n\nOr you can first copy the data and then switch the alias. Here you just have to keep track of all the documents that have changed after the reindex operation began, apply those updates and only then switch the alias. This can be also problematic.\n\nNone of the options are atomic and there is always a room for discrepancy unless you want to make the application aware of this mechanics, which can mean a lot of code and complexity for a few transitions.\n\nThis solution is by no means perfect, maybe even not better than the ones described, but it is simplest to implement and idempotent. I also agree that it would be difficult to manage expectations.\n\nAnother use case would be to help with entity-centric indexing (#17997) where you can just run a \"move\" with update periodically.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/217399306","html_url":"https://github.com/elastic/elasticsearch/issues/17998#issuecomment-217399306","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/17998","id":217399306,"node_id":"MDEyOklzc3VlQ29tbWVudDIxNzM5OTMwNg==","user":{"login":"s1monw","id":973334,"node_id":"MDQ6VXNlcjk3MzMzNA==","avatar_url":"https://avatars0.githubusercontent.com/u/973334?v=4","gravatar_id":"","url":"https://api.github.com/users/s1monw","html_url":"https://github.com/s1monw","followers_url":"https://api.github.com/users/s1monw/followers","following_url":"https://api.github.com/users/s1monw/following{/other_user}","gists_url":"https://api.github.com/users/s1monw/gists{/gist_id}","starred_url":"https://api.github.com/users/s1monw/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/s1monw/subscriptions","organizations_url":"https://api.github.com/users/s1monw/orgs","repos_url":"https://api.github.com/users/s1monw/repos","events_url":"https://api.github.com/users/s1monw/events{/privacy}","received_events_url":"https://api.github.com/users/s1monw/received_events","type":"User","site_admin":false},"created_at":"2016-05-06T09:45:58Z","updated_at":"2016-05-06T09:45:58Z","author_association":"CONTRIBUTOR","body":"We should not add features that suggest a certain behavior like atomicity of a move. As clinton said, building this means that you could see 1, 2 or even 0 results for a given document querying the two indices (source and target). The bigger issue that I see with this is that you potentially be stuck with 2 indices both half broken. I think reindexing should be always be able to trash the target index and don't loose data. We discussed this in a wider audience and decided to close it for now.\n","performed_via_github_app":null}]