[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/524943","html_url":"https://github.com/elastic/elasticsearch/issues/489#issuecomment-524943","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/489","id":524943,"node_id":"MDEyOklzc3VlQ29tbWVudDUyNDk0Mw==","user":{"login":"apatrida","id":182340,"node_id":"MDQ6VXNlcjE4MjM0MA==","avatar_url":"https://avatars3.githubusercontent.com/u/182340?v=4","gravatar_id":"","url":"https://api.github.com/users/apatrida","html_url":"https://github.com/apatrida","followers_url":"https://api.github.com/users/apatrida/followers","following_url":"https://api.github.com/users/apatrida/following{/other_user}","gists_url":"https://api.github.com/users/apatrida/gists{/gist_id}","starred_url":"https://api.github.com/users/apatrida/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/apatrida/subscriptions","organizations_url":"https://api.github.com/users/apatrida/orgs","repos_url":"https://api.github.com/users/apatrida/repos","events_url":"https://api.github.com/users/apatrida/events{/privacy}","received_events_url":"https://api.github.com/users/apatrida/received_events","type":"User","site_admin":false},"created_at":"2010-11-08T00:43:57Z","updated_at":"2010-11-08T00:43:57Z","author_association":"CONTRIBUTOR","body":"#485 and #487 provide a way to handle this, but I would still rather see it pushed to the top.  \n\nfor example, index, type and id are treated as very important:\n\n```\nhost:port/index/type/id\n```\n\nand language should fit into that top level, as it isn't always in the document (could be, but why?\n\nA change like this is better early rather than late, as unless it is placed at the end it can be breaking, or if you detect a language code (ISO 2 or 3 chars) you would have to differentiate it in some other way.\n\nThe \"hack\" way of doing this is to create indexes per language, such as\n\n```\nhost:port/index-en/\n```\n\nAnd then copy all of your field/type mappings across with the aliases meaning something new.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/524948","html_url":"https://github.com/elastic/elasticsearch/issues/489#issuecomment-524948","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/489","id":524948,"node_id":"MDEyOklzc3VlQ29tbWVudDUyNDk0OA==","user":{"login":"apatrida","id":182340,"node_id":"MDQ6VXNlcjE4MjM0MA==","avatar_url":"https://avatars3.githubusercontent.com/u/182340?v=4","gravatar_id":"","url":"https://api.github.com/users/apatrida","html_url":"https://github.com/apatrida","followers_url":"https://api.github.com/users/apatrida/followers","following_url":"https://api.github.com/users/apatrida/following{/other_user}","gists_url":"https://api.github.com/users/apatrida/gists{/gist_id}","starred_url":"https://api.github.com/users/apatrida/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/apatrida/subscriptions","organizations_url":"https://api.github.com/users/apatrida/orgs","repos_url":"https://api.github.com/users/apatrida/repos","events_url":"https://api.github.com/users/apatrida/events{/privacy}","received_events_url":"https://api.github.com/users/apatrida/received_events","type":"User","site_admin":false},"created_at":"2010-11-08T00:46:31Z","updated_at":"2010-11-08T00:46:31Z","author_association":"CONTRIBUTOR","body":"Actually, #485 does not handle this other than for cases such as knowing a doc has a special indexing case that is compatible with a common query analyzer.  But languages are rarely this.  With #485 you can index the document differently but then your search query would be analyzed how?  You need each set of language specific docs to have the query analyzed for that set specifically during a query.\n\nSo #485 helps with some indexing cases, but isn't an answer for language specific collections.  \n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/525003","html_url":"https://github.com/elastic/elasticsearch/issues/489#issuecomment-525003","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/489","id":525003,"node_id":"MDEyOklzc3VlQ29tbWVudDUyNTAwMw==","user":{"login":"otisg","id":332580,"node_id":"MDQ6VXNlcjMzMjU4MA==","avatar_url":"https://avatars2.githubusercontent.com/u/332580?v=4","gravatar_id":"","url":"https://api.github.com/users/otisg","html_url":"https://github.com/otisg","followers_url":"https://api.github.com/users/otisg/followers","following_url":"https://api.github.com/users/otisg/following{/other_user}","gists_url":"https://api.github.com/users/otisg/gists{/gist_id}","starred_url":"https://api.github.com/users/otisg/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/otisg/subscriptions","organizations_url":"https://api.github.com/users/otisg/orgs","repos_url":"https://api.github.com/users/otisg/repos","events_url":"https://api.github.com/users/otisg/events{/privacy}","received_events_url":"https://api.github.com/users/otisg/received_events","type":"User","site_admin":false},"created_at":"2010-11-08T01:54:40Z","updated_at":"2010-11-08T01:54:40Z","author_association":"NONE","body":"+1 (or how to make Github email you new comments on this issue)\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/525130","html_url":"https://github.com/elastic/elasticsearch/issues/489#issuecomment-525130","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/489","id":525130,"node_id":"MDEyOklzc3VlQ29tbWVudDUyNTEzMA==","user":{"login":"apatrida","id":182340,"node_id":"MDQ6VXNlcjE4MjM0MA==","avatar_url":"https://avatars3.githubusercontent.com/u/182340?v=4","gravatar_id":"","url":"https://api.github.com/users/apatrida","html_url":"https://github.com/apatrida","followers_url":"https://api.github.com/users/apatrida/followers","following_url":"https://api.github.com/users/apatrida/following{/other_user}","gists_url":"https://api.github.com/users/apatrida/gists{/gist_id}","starred_url":"https://api.github.com/users/apatrida/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/apatrida/subscriptions","organizations_url":"https://api.github.com/users/apatrida/orgs","repos_url":"https://api.github.com/users/apatrida/repos","events_url":"https://api.github.com/users/apatrida/events{/privacy}","received_events_url":"https://api.github.com/users/apatrida/received_events","type":"User","site_admin":false},"created_at":"2010-11-08T04:04:01Z","updated_at":"2010-11-08T04:04:01Z","author_association":"CONTRIBUTOR","body":"Hey Otis, I wouldn't mind the Github \"watch\" command, and also one to check my 2AM bad gramar when typing new issues... sheesh.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/525483","html_url":"https://github.com/elastic/elasticsearch/issues/489#issuecomment-525483","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/489","id":525483,"node_id":"MDEyOklzc3VlQ29tbWVudDUyNTQ4Mw==","user":{"login":"kimchy","id":41300,"node_id":"MDQ6VXNlcjQxMzAw","avatar_url":"https://avatars1.githubusercontent.com/u/41300?v=4","gravatar_id":"","url":"https://api.github.com/users/kimchy","html_url":"https://github.com/kimchy","followers_url":"https://api.github.com/users/kimchy/followers","following_url":"https://api.github.com/users/kimchy/following{/other_user}","gists_url":"https://api.github.com/users/kimchy/gists{/gist_id}","starred_url":"https://api.github.com/users/kimchy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/kimchy/subscriptions","organizations_url":"https://api.github.com/users/kimchy/orgs","repos_url":"https://api.github.com/users/kimchy/repos","events_url":"https://api.github.com/users/kimchy/events{/privacy}","received_events_url":"https://api.github.com/users/kimchy/received_events","type":"User","site_admin":false},"created_at":"2010-11-08T08:54:31Z","updated_at":"2010-11-08T08:54:31Z","author_association":"MEMBER","body":"Actually, I have thought about it and I see the previous issue as an enabled for it (allowing to choose an analyzer based on a json doc field). \n\nI don't necessarily agree that the way to model language support is to have different index for each language. Its one option, certainly, but you should also be able to handle several languages within the same index.\n\nIn order to support (both) options, I was thinking that the following features are needed:\n- Have an `_lang` field, that will automatically detect the language of the doc based on another field(s) or `_all`.  That `_lang` field can then be used to control the analyzer that will be used simply by pointing the new `_analyzer` mapping to it. Also, this field can be used to filter docs based on specific languages in a query.\n- For query time, it really only applies to `query_string` and `field` queries, which use an analyzer. You can already control the analyzer that will be used in the query DSL.  I was thinking that these queries will also support a `user_query` parameter, which will also go through the same language detection mechanism, and the analyzer wil be chosen based on that.\n- The language detection will also be provided as an api (give it text, and it will guess the language). This can then be used to have a different index per lang for example.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/525859","html_url":"https://github.com/elastic/elasticsearch/issues/489#issuecomment-525859","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/489","id":525859,"node_id":"MDEyOklzc3VlQ29tbWVudDUyNTg1OQ==","user":{"login":"apatrida","id":182340,"node_id":"MDQ6VXNlcjE4MjM0MA==","avatar_url":"https://avatars3.githubusercontent.com/u/182340?v=4","gravatar_id":"","url":"https://api.github.com/users/apatrida","html_url":"https://github.com/apatrida","followers_url":"https://api.github.com/users/apatrida/followers","following_url":"https://api.github.com/users/apatrida/following{/other_user}","gists_url":"https://api.github.com/users/apatrida/gists{/gist_id}","starred_url":"https://api.github.com/users/apatrida/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/apatrida/subscriptions","organizations_url":"https://api.github.com/users/apatrida/orgs","repos_url":"https://api.github.com/users/apatrida/repos","events_url":"https://api.github.com/users/apatrida/events{/privacy}","received_events_url":"https://api.github.com/users/apatrida/received_events","type":"User","site_admin":false},"created_at":"2010-11-08T12:54:59Z","updated_at":"2010-11-08T12:54:59Z","author_association":"CONTRIBUTOR","body":"So instead of stating \"index per language\" I should really say \"collection per language.\"\n\nYour solution above is great for a user searching in one language for a matching collection of documents in a matching language, or all documents by using one query analyzer for all collections assuming there is some base compatibility between analyzers (allowing that they may vary in areas such as stop words and stemming but that you can still go for an exact match).\n\n(by the way, stop words is not a great solution and we should look at bringing common grams or other variations of those into ES for larger document sets)\n\nSo just keep in mind a few possibilities:\n- User locales usually can indicate their language preference, but doesn't always match the language of their query\n- Language of the query may not always match the language of the documents they intend to search (i.e. a English researching talking about French poetry)\n- Language may not be accurately detectable for shorter queries (the longer the better)\n- Language of the query isn't always useful when they are searching for entities like people's names within the fulltext or fields\n- Regardless of language of the query, you might want to search across one or more of the language collections (but possibly boost documents with a matching language, but allowing the others in as well for higher recall)\n- Mixed language documents (i.e. a English researching talking about French poetry) -- which are not easy to solve anyway, just mentioning for completeness\n\nNow, these issues mentioned above don't negate your solution, but could help round it all off into being one of the first engines with good language support that doesn't feel bolted on as an after-though, or dealt with as a work-around.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/525892","html_url":"https://github.com/elastic/elasticsearch/issues/489#issuecomment-525892","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/489","id":525892,"node_id":"MDEyOklzc3VlQ29tbWVudDUyNTg5Mg==","user":{"login":"kimchy","id":41300,"node_id":"MDQ6VXNlcjQxMzAw","avatar_url":"https://avatars1.githubusercontent.com/u/41300?v=4","gravatar_id":"","url":"https://api.github.com/users/kimchy","html_url":"https://github.com/kimchy","followers_url":"https://api.github.com/users/kimchy/followers","following_url":"https://api.github.com/users/kimchy/following{/other_user}","gists_url":"https://api.github.com/users/kimchy/gists{/gist_id}","starred_url":"https://api.github.com/users/kimchy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/kimchy/subscriptions","organizations_url":"https://api.github.com/users/kimchy/orgs","repos_url":"https://api.github.com/users/kimchy/repos","events_url":"https://api.github.com/users/kimchy/events{/privacy}","received_events_url":"https://api.github.com/users/kimchy/received_events","type":"User","site_admin":false},"created_at":"2010-11-08T13:17:19Z","updated_at":"2010-11-08T13:17:19Z","author_association":"MEMBER","body":"Right, all the cases you suggested are relevant. What I try with ES is to build the engine that can support different usages types, and then build features that make more features dead easy. For example, in my purposed solution, the only new feature in ES is language detection, which if the client is doing, then all features are there already for ES. Thats why I pushed the `_anlayzer` feature fast, without it, it would have been impossible to implement something like what I suggested by the user.\n\nRegarding your points, are you then raising them in benefit of the index per language solution? You can easily implement it now, without additional features from ES. Just create an index per language, you can already search across indices, and define a different search analyzer per index, which will cause the query string to be analyzed using each index own language analyzer.\n\nWhat I am after is that major (breaking?) feature that ES is missing for better language support (even the `_analyzer` feature was not a major one, as it \"fell\" nicely into ES model, as expected :) since I had it in compass already).\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/525944","html_url":"https://github.com/elastic/elasticsearch/issues/489#issuecomment-525944","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/489","id":525944,"node_id":"MDEyOklzc3VlQ29tbWVudDUyNTk0NA==","user":{"login":"apatrida","id":182340,"node_id":"MDQ6VXNlcjE4MjM0MA==","avatar_url":"https://avatars3.githubusercontent.com/u/182340?v=4","gravatar_id":"","url":"https://api.github.com/users/apatrida","html_url":"https://github.com/apatrida","followers_url":"https://api.github.com/users/apatrida/followers","following_url":"https://api.github.com/users/apatrida/following{/other_user}","gists_url":"https://api.github.com/users/apatrida/gists{/gist_id}","starred_url":"https://api.github.com/users/apatrida/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/apatrida/subscriptions","organizations_url":"https://api.github.com/users/apatrida/orgs","repos_url":"https://api.github.com/users/apatrida/repos","events_url":"https://api.github.com/users/apatrida/events{/privacy}","received_events_url":"https://api.github.com/users/apatrida/received_events","type":"User","site_admin":false},"created_at":"2010-11-08T13:38:20Z","updated_at":"2010-11-08T13:38:20Z","author_association":"CONTRIBUTOR","body":"I have a good set of mixed language documents and a good use case to try them on with ES, let me see how it plays out under real world use.  Maybe Otis has thoughts being a linguistic guy himself?\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/525955","html_url":"https://github.com/elastic/elasticsearch/issues/489#issuecomment-525955","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/489","id":525955,"node_id":"MDEyOklzc3VlQ29tbWVudDUyNTk1NQ==","user":{"login":"apatrida","id":182340,"node_id":"MDQ6VXNlcjE4MjM0MA==","avatar_url":"https://avatars3.githubusercontent.com/u/182340?v=4","gravatar_id":"","url":"https://api.github.com/users/apatrida","html_url":"https://github.com/apatrida","followers_url":"https://api.github.com/users/apatrida/followers","following_url":"https://api.github.com/users/apatrida/following{/other_user}","gists_url":"https://api.github.com/users/apatrida/gists{/gist_id}","starred_url":"https://api.github.com/users/apatrida/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/apatrida/subscriptions","organizations_url":"https://api.github.com/users/apatrida/orgs","repos_url":"https://api.github.com/users/apatrida/repos","events_url":"https://api.github.com/users/apatrida/events{/privacy}","received_events_url":"https://api.github.com/users/apatrida/received_events","type":"User","site_admin":false},"created_at":"2010-11-08T13:43:04Z","updated_at":"2010-11-08T13:43:04Z","author_association":"CONTRIBUTOR","body":"After saying that, I realize that it still bothers me that you have to patch together your own story for multiple languages.  That you have a nice way of mapping types to analyzers, then have to override them completely when you go multi-lingual.  Why?  The type system is incomplete (to me)...\n\nI will most likely have one analyzer stack for say my Document Title, another for Document Author, another for the Abstract and Body of the document and so on.  Therefore for each field I have different analysis.  Now for multi-lingual sets of documents, I have to override how many things for each language?  I think it is an amazing feature to say that my type fo document title (say called \"bibtitle\") can have a analyzer definition for each language under that type definition.  The same for each of the other differing fields.  \n\nThen I can forget about the language aspect when sending documents and take that out of the business logic of the code (where you are forcing me to consider it down to the level of selecting analyzers).  And when querying I can forget about it again and let my linguistic folks tune the engine without my code having to think about it when passing in a well constructed query.\n\nI think we need a step more in ES to make languages easy to use and transparent outside the definition of the index.  It is a big step, but a place that ES could once again show it cares to make it incredibly easy.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/525961","html_url":"https://github.com/elastic/elasticsearch/issues/489#issuecomment-525961","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/489","id":525961,"node_id":"MDEyOklzc3VlQ29tbWVudDUyNTk2MQ==","user":{"login":"apatrida","id":182340,"node_id":"MDQ6VXNlcjE4MjM0MA==","avatar_url":"https://avatars3.githubusercontent.com/u/182340?v=4","gravatar_id":"","url":"https://api.github.com/users/apatrida","html_url":"https://github.com/apatrida","followers_url":"https://api.github.com/users/apatrida/followers","following_url":"https://api.github.com/users/apatrida/following{/other_user}","gists_url":"https://api.github.com/users/apatrida/gists{/gist_id}","starred_url":"https://api.github.com/users/apatrida/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/apatrida/subscriptions","organizations_url":"https://api.github.com/users/apatrida/orgs","repos_url":"https://api.github.com/users/apatrida/repos","events_url":"https://api.github.com/users/apatrida/events{/privacy}","received_events_url":"https://api.github.com/users/apatrida/received_events","type":"User","site_admin":false},"created_at":"2010-11-08T13:46:05Z","updated_at":"2010-11-08T13:46:05Z","author_association":"CONTRIBUTOR","body":"Your previous solutions would then be ways of overriding this nice behavior (from above) rather than as the main mechanism for doing a fairly common task (being multi-lingual).  \n\nRemember, that once you get out of the simple search cases, most search systems start to hit very detailed analyzer stacks and for many languages at once.  The default analyzers can rarely last past the first few days of a new project, and it is common that field after field will see different analysis.  \n\nThen toss in dismax and we have a workable system!\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/526575","html_url":"https://github.com/elastic/elasticsearch/issues/489#issuecomment-526575","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/489","id":526575,"node_id":"MDEyOklzc3VlQ29tbWVudDUyNjU3NQ==","user":{"login":"kimchy","id":41300,"node_id":"MDQ6VXNlcjQxMzAw","avatar_url":"https://avatars1.githubusercontent.com/u/41300?v=4","gravatar_id":"","url":"https://api.github.com/users/kimchy","html_url":"https://github.com/kimchy","followers_url":"https://api.github.com/users/kimchy/followers","following_url":"https://api.github.com/users/kimchy/following{/other_user}","gists_url":"https://api.github.com/users/kimchy/gists{/gist_id}","starred_url":"https://api.github.com/users/kimchy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/kimchy/subscriptions","organizations_url":"https://api.github.com/users/kimchy/orgs","repos_url":"https://api.github.com/users/kimchy/repos","events_url":"https://api.github.com/users/kimchy/events{/privacy}","received_events_url":"https://api.github.com/users/kimchy/received_events","type":"User","site_admin":false},"created_at":"2010-11-08T17:19:44Z","updated_at":"2010-11-08T17:19:44Z","author_association":"MEMBER","body":"I am not sure I agree that the best way to model your searchable document model is to have fields that can have different analyzers. Instead, a document will usually consist of a specific language. This option is better in terms of search, since you don't need to dismax your query (which is expensive), or deciding which analyzer to use on which field.\n\nNote that you can still define explicit field level analyzers, but the \"default\" analyzer for a document can be the language based one.\n\nThen, its just a matter of specifying that analyzer. It can either be done by creating an index per language, in which case the default analyzer for that index will be the language specific one (defined in the settings for that index, on index creation). Or, it can be based on `_analyzer` with its values (like `lang_en`, `lang_de`, ...) will map to Lucene language specific analyzers.\n\nYou can do both now with elasticsearch. The language detection option is a nice add on (which can be done on the client side as well, as far as I know, for example, perl has the best language detection lib around). But, for example, you might already know the language in question (maybe because it has a mime type, or many different ways to do it), and then its just a matter of suffixing the index name with the language code or setting the language in the `_analyzer`.\n\nWhen searching, it depends on which route your took. If you have an index per language, you can execute a search against a single index (based on a specific language), or query all indices. Because each index has its default analyzer set to the specific document, the query string will automatically be analyzed using it when the search is executed on that index (shards).\n\nIf using the `_analyzer` option, and without automatic language detection, you can also specify the analyzer for the `query_string` or `field` analyzer.\n\nThats the main two options that I see to use multi language, and both are possible with elasticsearch. Everything on top of it is sugar coating, which is very important, but the main output here is that elasticsearch has the constructs to support it, and that the sugar coating is _optional_.\n\nSome examples of sugar coating can be automatic language detection, and then using it to control indexing and search (as explained before). It can automatically control the `_analyzer` value, but, the most important thing is that its _optional_, since you, the user using elasticsearch, might have better knowledge of the language of the document.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/528672","html_url":"https://github.com/elastic/elasticsearch/issues/489#issuecomment-528672","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/489","id":528672,"node_id":"MDEyOklzc3VlQ29tbWVudDUyODY3Mg==","user":{"login":"apatrida","id":182340,"node_id":"MDQ6VXNlcjE4MjM0MA==","avatar_url":"https://avatars3.githubusercontent.com/u/182340?v=4","gravatar_id":"","url":"https://api.github.com/users/apatrida","html_url":"https://github.com/apatrida","followers_url":"https://api.github.com/users/apatrida/followers","following_url":"https://api.github.com/users/apatrida/following{/other_user}","gists_url":"https://api.github.com/users/apatrida/gists{/gist_id}","starred_url":"https://api.github.com/users/apatrida/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/apatrida/subscriptions","organizations_url":"https://api.github.com/users/apatrida/orgs","repos_url":"https://api.github.com/users/apatrida/repos","events_url":"https://api.github.com/users/apatrida/events{/privacy}","received_events_url":"https://api.github.com/users/apatrida/received_events","type":"User","site_admin":false},"created_at":"2010-11-09T12:18:41Z","updated_at":"2010-11-09T12:18:41Z","author_association":"CONTRIBUTOR","body":"> I am not sure I agree that the best way to model your searchable document model is\n> to have fields that can have different analyzers. Instead, a document will usually \n> consist of a specific language.\n\nA document is usually one language, sure.  But not all fields are treated equal.  For example, stemming an \"Author\" field may be undesirable, and for a \"Title\" field you might want to not eliminate the same set of stop words as you would from full text, and for a \"PartNo\" field you might want to tokenize based on rules of that identifier and not just on what is typically considered whitespace, and for a \"FullText\" field you might use common grams (or something better) instead of stop word removal, and on ...\n\nSure, you may not have a different analyzer for every field, but you might have 5-6 analyzers on a decently structured document.\n\nIf you make that hard, you then make it hard to have really good precision or the right amount of recall.\n\n> ...and then its just a matter of suffixing the index name with the language code...\n\nAssuming you want to search one language at a time.  You can actually use one query to search all languages, but then it has to be analyzed per collection of documents (matching each language).  And maybe that is possible now, does searching a list of indexes have each one do its own analysis?  (I would think so, but figured I should ask).\n\n> Everything on top of it is sugar coating...\n\nYes, and I think ES can stand out for having that sugar coating here since most other search engines give the same answer \"oh, it is possible, but you do all the work\" which means a large body of programmers repeating the exact same code, or work around, or making mistakes if they have no clue that language matters as much as it does.  In fact if you add this \"sugar\", we in the community could then add a bunch of great default analyzers and field types for common cases and they would just work if someone said \"this is an English\" or \"this is a French\" or \"this is a Japanese\" document.  We could make the ES search community that much better by having support for languages right out of the box if only they just say \"this document is language xx.\"  Otherwise, they have to learn about analyzers, have to pick from a list and maybe get it right, probably not.\n\n> Some examples of sugar coating can be automatic language detection\n\nI think this is less valuable as you probably do know the language of your document, and likely the language of the user.  But it is useful in some cases.  Right now I'm asking for the layer beneath that:  have a way to express the language of the document that allows type/analyzer mapping to pick a language specific analyzer for the given field.  Then we have good default analyzers for each language we happen to collect good analyzers for and a good set of field types for things people will run into but have no idea how to handle well unless they have been doing search for years.\n\n> This option is better in terms of search, since you don't need to dismax your query (which is expensive)\n\nI can't let you off the hook for this one either :)  Dismax is \"more\" expensive, but it is many times worth the price.  Let me price that one out for myself as I can still have Dismax while searching 500 million records in subsecond times if I want to...  Dismax does not mean \"slow,\" it means \"slower.\" \n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/528684","html_url":"https://github.com/elastic/elasticsearch/issues/489#issuecomment-528684","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/489","id":528684,"node_id":"MDEyOklzc3VlQ29tbWVudDUyODY4NA==","user":{"login":"kimchy","id":41300,"node_id":"MDQ6VXNlcjQxMzAw","avatar_url":"https://avatars1.githubusercontent.com/u/41300?v=4","gravatar_id":"","url":"https://api.github.com/users/kimchy","html_url":"https://github.com/kimchy","followers_url":"https://api.github.com/users/kimchy/followers","following_url":"https://api.github.com/users/kimchy/following{/other_user}","gists_url":"https://api.github.com/users/kimchy/gists{/gist_id}","starred_url":"https://api.github.com/users/kimchy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/kimchy/subscriptions","organizations_url":"https://api.github.com/users/kimchy/orgs","repos_url":"https://api.github.com/users/kimchy/repos","events_url":"https://api.github.com/users/kimchy/events{/privacy}","received_events_url":"https://api.github.com/users/kimchy/received_events","type":"User","site_admin":false},"created_at":"2010-11-09T12:25:20Z","updated_at":"2010-11-09T12:25:20Z","author_association":"MEMBER","body":"ok, I admit I got confused now. What are you suggesting that ES is missing and could make it handle languages better? More analyzers outside of the default Lucene ones? Any explicit feature?\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/528767","html_url":"https://github.com/elastic/elasticsearch/issues/489#issuecomment-528767","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/489","id":528767,"node_id":"MDEyOklzc3VlQ29tbWVudDUyODc2Nw==","user":{"login":"apatrida","id":182340,"node_id":"MDQ6VXNlcjE4MjM0MA==","avatar_url":"https://avatars3.githubusercontent.com/u/182340?v=4","gravatar_id":"","url":"https://api.github.com/users/apatrida","html_url":"https://github.com/apatrida","followers_url":"https://api.github.com/users/apatrida/followers","following_url":"https://api.github.com/users/apatrida/following{/other_user}","gists_url":"https://api.github.com/users/apatrida/gists{/gist_id}","starred_url":"https://api.github.com/users/apatrida/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/apatrida/subscriptions","organizations_url":"https://api.github.com/users/apatrida/orgs","repos_url":"https://api.github.com/users/apatrida/repos","events_url":"https://api.github.com/users/apatrida/events{/privacy}","received_events_url":"https://api.github.com/users/apatrida/received_events","type":"User","site_admin":false},"created_at":"2010-11-09T13:09:10Z","updated_at":"2010-11-09T13:09:10Z","author_association":"CONTRIBUTOR","body":"Things you can do for us:\n- make sure we can create new field types beyond the basics ourselves (done!)\n- make a definition for analyzer be able to include variations by language, as well as a default as a fallback (i.e. sometimes you fallback to one language, sometimes you have a specific fallback not attached to a language)\n- set a default language for an index\n- have a standard way of defining the language of a document just as you have for the type and ID of the document and use this in determining the appropriate analyzer\n- when overriding the analyzer at a field level or document level you can express the analyzer name, but also force it to a language as well with analyzer name + language identifier (i.e. in Canada you typically have Title_en and Title_fr in the same document and want to force those into those specific languages, but other times you want the language of the document to decide).\n- embrace the fact that dismax has value\n\nAnd we the community can...\n- give you a better set of analyzers for different languages\n- give you a better set of analyzers for other types of content typically found in fields\n- give you better concepts than stopword removal\n- give you better stemmers\n- help setup a strong list of default out-of-the-box mappings for ES for many languages\n\nAnd yes, the default Lucene analyzers and definitions are underwhelming and things like stopwords removal are fairly outdated, and the stemmers are sloppy and overly agressive (which is fine if you have ways for the system to know and handle that, otherwise it isn't) and should not be used all over the place.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/528811","html_url":"https://github.com/elastic/elasticsearch/issues/489#issuecomment-528811","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/489","id":528811,"node_id":"MDEyOklzc3VlQ29tbWVudDUyODgxMQ==","user":{"login":"apatrida","id":182340,"node_id":"MDQ6VXNlcjE4MjM0MA==","avatar_url":"https://avatars3.githubusercontent.com/u/182340?v=4","gravatar_id":"","url":"https://api.github.com/users/apatrida","html_url":"https://github.com/apatrida","followers_url":"https://api.github.com/users/apatrida/followers","following_url":"https://api.github.com/users/apatrida/following{/other_user}","gists_url":"https://api.github.com/users/apatrida/gists{/gist_id}","starred_url":"https://api.github.com/users/apatrida/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/apatrida/subscriptions","organizations_url":"https://api.github.com/users/apatrida/orgs","repos_url":"https://api.github.com/users/apatrida/repos","events_url":"https://api.github.com/users/apatrida/events{/privacy}","received_events_url":"https://api.github.com/users/apatrida/received_events","type":"User","site_admin":false},"created_at":"2010-11-09T13:26:16Z","updated_at":"2010-11-09T13:26:16Z","author_association":"CONTRIBUTOR","body":"While I'm listing it all here in this \"restructure how analyzers are connected to fields\" topic that I've gotten myself into...  You might as well consider the full package of ideas!\n\n(note:  this could be there, I just haven't seen it yet)\n\nThings like analyzed/not_analyzed, term_vector, omit_norms, omit_term_freq_and_positions, analyzer (+index/search), include_in_all ...  Can those be defaulted in a type?  And can you create quick user-defined types based on these settings?  i.e. variations of String.  Creating type mappings with all of the settings would make it easy to create types such as:\n- identifier (ISBN, ISSN, ...)\n- bibliographic title\n- names\n- facet\n- ...\n\nSomething to think on...  extending the type system so that you can share more of these definitions across fields and across indexes even.  \n\nWould be nice to then be able for people to contribute a good base type system for e-commerce, or another good one for document style searching, or another good one for bibliographic metadata records, etc.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/529258","html_url":"https://github.com/elastic/elasticsearch/issues/489#issuecomment-529258","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/489","id":529258,"node_id":"MDEyOklzc3VlQ29tbWVudDUyOTI1OA==","user":{"login":"apatrida","id":182340,"node_id":"MDQ6VXNlcjE4MjM0MA==","avatar_url":"https://avatars3.githubusercontent.com/u/182340?v=4","gravatar_id":"","url":"https://api.github.com/users/apatrida","html_url":"https://github.com/apatrida","followers_url":"https://api.github.com/users/apatrida/followers","following_url":"https://api.github.com/users/apatrida/following{/other_user}","gists_url":"https://api.github.com/users/apatrida/gists{/gist_id}","starred_url":"https://api.github.com/users/apatrida/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/apatrida/subscriptions","organizations_url":"https://api.github.com/users/apatrida/orgs","repos_url":"https://api.github.com/users/apatrida/repos","events_url":"https://api.github.com/users/apatrida/events{/privacy}","received_events_url":"https://api.github.com/users/apatrida/received_events","type":"User","site_admin":false},"created_at":"2010-11-09T16:25:01Z","updated_at":"2010-11-09T16:25:01Z","author_association":"CONTRIBUTOR","body":"I guess my summary still doesn't cover that language sharding or sub-index assignment which needs to vary if the analyzers vary -- but that is beneath the user's view so can just be decided with what works best as the mechanism.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/7507444","html_url":"https://github.com/elastic/elasticsearch/issues/489#issuecomment-7507444","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/489","id":7507444,"node_id":"MDEyOklzc3VlQ29tbWVudDc1MDc0NDQ=","user":{"login":"ghost","id":10137,"node_id":"MDQ6VXNlcjEwMTM3","avatar_url":"https://avatars3.githubusercontent.com/u/10137?v=4","gravatar_id":"","url":"https://api.github.com/users/ghost","html_url":"https://github.com/ghost","followers_url":"https://api.github.com/users/ghost/followers","following_url":"https://api.github.com/users/ghost/following{/other_user}","gists_url":"https://api.github.com/users/ghost/gists{/gist_id}","starred_url":"https://api.github.com/users/ghost/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ghost/subscriptions","organizations_url":"https://api.github.com/users/ghost/orgs","repos_url":"https://api.github.com/users/ghost/repos","events_url":"https://api.github.com/users/ghost/events{/privacy}","received_events_url":"https://api.github.com/users/ghost/received_events","type":"User","site_admin":false},"created_at":"2012-08-05T03:35:35Z","updated_at":"2012-08-05T03:35:35Z","author_association":"NONE","body":"Is there anything new regarding this? Has language detection of POSTed text been implemented?\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/48326170","html_url":"https://github.com/elastic/elasticsearch/issues/489#issuecomment-48326170","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/489","id":48326170,"node_id":"MDEyOklzc3VlQ29tbWVudDQ4MzI2MTcw","user":{"login":"clintongormley","id":56599,"node_id":"MDQ6VXNlcjU2NTk5","avatar_url":"https://avatars0.githubusercontent.com/u/56599?v=4","gravatar_id":"","url":"https://api.github.com/users/clintongormley","html_url":"https://github.com/clintongormley","followers_url":"https://api.github.com/users/clintongormley/followers","following_url":"https://api.github.com/users/clintongormley/following{/other_user}","gists_url":"https://api.github.com/users/clintongormley/gists{/gist_id}","starred_url":"https://api.github.com/users/clintongormley/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/clintongormley/subscriptions","organizations_url":"https://api.github.com/users/clintongormley/orgs","repos_url":"https://api.github.com/users/clintongormley/repos","events_url":"https://api.github.com/users/clintongormley/events{/privacy}","received_events_url":"https://api.github.com/users/clintongormley/received_events","type":"User","site_admin":false},"created_at":"2014-07-08T11:49:51Z","updated_at":"2014-07-08T11:49:51Z","author_association":"CONTRIBUTOR","body":"No discussion for years. Closing.\n","performed_via_github_app":null}]