[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/51442107","html_url":"https://github.com/elastic/elasticsearch/issues/7180#issuecomment-51442107","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/7180","id":51442107,"node_id":"MDEyOklzc3VlQ29tbWVudDUxNDQyMTA3","user":{"login":"jpountz","id":299848,"node_id":"MDQ6VXNlcjI5OTg0OA==","avatar_url":"https://avatars2.githubusercontent.com/u/299848?v=4","gravatar_id":"","url":"https://api.github.com/users/jpountz","html_url":"https://github.com/jpountz","followers_url":"https://api.github.com/users/jpountz/followers","following_url":"https://api.github.com/users/jpountz/following{/other_user}","gists_url":"https://api.github.com/users/jpountz/gists{/gist_id}","starred_url":"https://api.github.com/users/jpountz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jpountz/subscriptions","organizations_url":"https://api.github.com/users/jpountz/orgs","repos_url":"https://api.github.com/users/jpountz/repos","events_url":"https://api.github.com/users/jpountz/events{/privacy}","received_events_url":"https://api.github.com/users/jpountz/received_events","type":"User","site_admin":false},"created_at":"2014-08-07T08:00:27Z","updated_at":"2014-08-07T08:00:27Z","author_association":"CONTRIBUTOR","body":"One issue that I see with assigning priorities this way is that we have nothing that would enforce that a given term always has the same priority. What should Elasticsearch do if a given brand (say 'Apple') is given different priorities in different documents? I guess it could either consider them different or try to aggregate these values by taking the min/max/avg.\n\nFor this kind of use-case, I think it would be more flexible to reuse existing parts of the infrastructure such as sub aggregations and sorting by sub aggregations. If I reuse your example, that could give something like:\n\n``` json\nDELETE test\n\nPUT test\n{\n  \"mappings\": {\n    \"test\": {\n      \"properties\": {\n        \"title\": {\n          \"type\": \"string\"\n        },\n        \"brand\": {\n          \"type\": \"object\",\n          \"properties\": {\n            \"value\": {\n              \"type\": \"string\",\n              \"index\": \"not_analyzed\"\n            },\n            \"payload\": {\n              \"type\": \"object\",\n              \"properties\": {\n                \"priority\": {\n                  \"type\": \"integer\"\n                },\n                \"url\": {\n                  \"type\": \"string\",\n                  \"index\": \"not_analyzed\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nPOST test/test\n{\n  \"title\": \"iPhone\",\n  \"brand\": {\n    \"value\": \"Apple\",\n    \"payload\": {\n      \"priority\": 1,\n      \"url\": \"apple.html\"\n    }\n  }\n}\n\nPOST test/test\n{\n  \"title\": \"Galaxy S\",\n  \"brand\": {\n    \"value\": \"Samsung\",\n    \"payload\": {\n      \"priority\": 2,\n      \"url\": \"samsung.html\"\n    }\n  }\n}\n\nGET test/_search\n{\n  \"aggs\": {\n    \"top_brands\": {\n      \"terms\": {\n        \"field\": \"brand.value\",\n        \"order\": {\n          \"priority\": \"asc\"\n        }\n      },\n      \"aggs\": {\n        \"priority\": {\n          \"avg\": {\n            \"field\": \"brand.payload.priority\"\n          }\n        },\n        \"url\": {\n          \"terms\": {\n            \"field\": \"brand.payload.url\"\n          }\n        }\n      }\n    }\n  }\n}\n```\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/51444438","html_url":"https://github.com/elastic/elasticsearch/issues/7180#issuecomment-51444438","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/7180","id":51444438,"node_id":"MDEyOklzc3VlQ29tbWVudDUxNDQ0NDM4","user":{"login":"jpountz","id":299848,"node_id":"MDQ6VXNlcjI5OTg0OA==","avatar_url":"https://avatars2.githubusercontent.com/u/299848?v=4","gravatar_id":"","url":"https://api.github.com/users/jpountz","html_url":"https://github.com/jpountz","followers_url":"https://api.github.com/users/jpountz/followers","following_url":"https://api.github.com/users/jpountz/following{/other_user}","gists_url":"https://api.github.com/users/jpountz/gists{/gist_id}","starred_url":"https://api.github.com/users/jpountz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jpountz/subscriptions","organizations_url":"https://api.github.com/users/jpountz/orgs","repos_url":"https://api.github.com/users/jpountz/repos","events_url":"https://api.github.com/users/jpountz/events{/privacy}","received_events_url":"https://api.github.com/users/jpountz/received_events","type":"User","site_admin":false},"created_at":"2014-08-07T08:28:59Z","updated_at":"2014-08-07T08:28:59Z","author_association":"CONTRIBUTOR","body":"This issue might help as well for this kind of use-case: https://github.com/elasticsearch/elasticsearch/pull/7164 If the brand.payload object was stored as a nested doc, there could be a `top_hits` sub-aggregation under terms that would eg. collect the brand payload with the least priority.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/51456822","html_url":"https://github.com/elastic/elasticsearch/issues/7180#issuecomment-51456822","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/7180","id":51456822,"node_id":"MDEyOklzc3VlQ29tbWVudDUxNDU2ODIy","user":{"login":"kostiklv","id":620982,"node_id":"MDQ6VXNlcjYyMDk4Mg==","avatar_url":"https://avatars0.githubusercontent.com/u/620982?v=4","gravatar_id":"","url":"https://api.github.com/users/kostiklv","html_url":"https://github.com/kostiklv","followers_url":"https://api.github.com/users/kostiklv/followers","following_url":"https://api.github.com/users/kostiklv/following{/other_user}","gists_url":"https://api.github.com/users/kostiklv/gists{/gist_id}","starred_url":"https://api.github.com/users/kostiklv/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/kostiklv/subscriptions","organizations_url":"https://api.github.com/users/kostiklv/orgs","repos_url":"https://api.github.com/users/kostiklv/repos","events_url":"https://api.github.com/users/kostiklv/events{/privacy}","received_events_url":"https://api.github.com/users/kostiklv/received_events","type":"User","site_admin":false},"created_at":"2014-08-07T10:49:53Z","updated_at":"2014-08-07T10:49:53Z","author_association":"NONE","body":"@jpountz, thanks for your comments!\n\nAs for different payloads assigned to the same term - how does [delimited_payload_filter](http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/analysis-delimited-payload-tokenfilter.html) handle that? BTW, where the payloads extracted by this filter can be used?\nIn general, there may be different strategies, e.g. update the payload based on last index or fail if the payload differs. It can theoretically be even configurable.\n\nAs for nested aggregations - yes, it's possible, but I think it's not the best approach performance-wise. I haven't benchmarked it, but I'm pretty sure that my synthetic approach (i.e. joining the payload into the term) will be much faster than using nested aggregations. And if payloads would have been implemented, the work of extracting it would be just moved from user's application into ES. \n\nRegarding `top_hits` - also not sure about performance, since top_hits will go after the _documents_, rather than just _term properties_ (which can be stored in field data).\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/61244725","html_url":"https://github.com/elastic/elasticsearch/issues/7180#issuecomment-61244725","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/7180","id":61244725,"node_id":"MDEyOklzc3VlQ29tbWVudDYxMjQ0NzI1","user":{"login":"clintongormley","id":56599,"node_id":"MDQ6VXNlcjU2NTk5","avatar_url":"https://avatars0.githubusercontent.com/u/56599?v=4","gravatar_id":"","url":"https://api.github.com/users/clintongormley","html_url":"https://github.com/clintongormley","followers_url":"https://api.github.com/users/clintongormley/followers","following_url":"https://api.github.com/users/clintongormley/following{/other_user}","gists_url":"https://api.github.com/users/clintongormley/gists{/gist_id}","starred_url":"https://api.github.com/users/clintongormley/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/clintongormley/subscriptions","organizations_url":"https://api.github.com/users/clintongormley/orgs","repos_url":"https://api.github.com/users/clintongormley/repos","events_url":"https://api.github.com/users/clintongormley/events{/privacy}","received_events_url":"https://api.github.com/users/clintongormley/received_events","type":"User","site_admin":false},"created_at":"2014-10-31T10:51:53Z","updated_at":"2014-10-31T10:51:53Z","author_association":"CONTRIBUTOR","body":"Hi @kostiklv \n\nThe problem with this design is that payloads are per term/document, but aggregations summarise documents. It sounds like a better approach would be to allow some kind of query time lookup table for each bucket key, which could then return a single instance of arbitrary metadata per term.\n\nWe'll open another issue to discuss that.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/61693879","html_url":"https://github.com/elastic/elasticsearch/issues/7180#issuecomment-61693879","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/7180","id":61693879,"node_id":"MDEyOklzc3VlQ29tbWVudDYxNjkzODc5","user":{"login":"kostiklv","id":620982,"node_id":"MDQ6VXNlcjYyMDk4Mg==","avatar_url":"https://avatars0.githubusercontent.com/u/620982?v=4","gravatar_id":"","url":"https://api.github.com/users/kostiklv","html_url":"https://github.com/kostiklv","followers_url":"https://api.github.com/users/kostiklv/followers","following_url":"https://api.github.com/users/kostiklv/following{/other_user}","gists_url":"https://api.github.com/users/kostiklv/gists{/gist_id}","starred_url":"https://api.github.com/users/kostiklv/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/kostiklv/subscriptions","organizations_url":"https://api.github.com/users/kostiklv/orgs","repos_url":"https://api.github.com/users/kostiklv/repos","events_url":"https://api.github.com/users/kostiklv/events{/privacy}","received_events_url":"https://api.github.com/users/kostiklv/received_events","type":"User","site_admin":false},"created_at":"2014-11-04T18:56:56Z","updated_at":"2014-11-04T18:56:56Z","author_association":"NONE","body":"@clintongormley, could you please link the new issue here? Also, query-time lookup table sounds like SQL join, and indeed can provide endless possibilities if available in ES.\n","performed_via_github_app":null}]