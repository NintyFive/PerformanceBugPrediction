{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/7180","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/7180/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/7180/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/7180/events","html_url":"https://github.com/elastic/elasticsearch/issues/7180","id":39665091,"node_id":"MDU6SXNzdWUzOTY2NTA5MQ==","number":7180,"title":"Payloads and Terms Aggregation","user":{"login":"kostiklv","id":620982,"node_id":"MDQ6VXNlcjYyMDk4Mg==","avatar_url":"https://avatars0.githubusercontent.com/u/620982?v=4","gravatar_id":"","url":"https://api.github.com/users/kostiklv","html_url":"https://github.com/kostiklv","followers_url":"https://api.github.com/users/kostiklv/followers","following_url":"https://api.github.com/users/kostiklv/following{/other_user}","gists_url":"https://api.github.com/users/kostiklv/gists{/gist_id}","starred_url":"https://api.github.com/users/kostiklv/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/kostiklv/subscriptions","organizations_url":"https://api.github.com/users/kostiklv/orgs","repos_url":"https://api.github.com/users/kostiklv/repos","events_url":"https://api.github.com/users/kostiklv/events{/privacy}","received_events_url":"https://api.github.com/users/kostiklv/received_events","type":"User","site_admin":false},"labels":[{"id":111416437,"node_id":"MDU6TGFiZWwxMTE0MTY0Mzc=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/discuss","name":"discuss","color":"fbca04","default":false,"description":null}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":5,"created_at":"2014-08-06T20:56:32Z","updated_at":"2014-11-04T18:56:56Z","closed_at":"2014-10-31T10:51:53Z","author_association":"NONE","active_lock_reason":null,"body":"Is it possible to implement payloads which can be used in Terms Aggregation (similar to what's available for `completion` suggester)?\n\nI can see at least two use cases for that:\n- Just returning additional information with the term (key) in aggregation results\n- Sorting terms by a different value, such as manually assigned priority\n\nThe mapping may look like:\n\n```\n{\n    \"title\": {\n        \"type\": \"string\"\n    },\n    \"brand\" : {\n        \"type\": \"string\",\n        \"index\": \"not_analyzed\",\n        \"payloads\": true\n    }\n}\n```\n\nIndexing may look like:\n\n```\n{\n    \"title\": \"iPhone\",\n    \"brand\": {\n        \"value\": \"Apple\",\n        \"payload\": {\n            \"priority\": 1,\n            \"url\": \"apple.html\"\n        }\n    }\n},\n{\n    \"title\": \"Galaxy S\",\n    \"brand\": {\n        \"value\": \"Samsung\",\n        \"payload\": {\n            \"priority\": 2,\n            \"url\": \"samsung.html\"\n        }\n    }\n}\n```\n\nThen the query may look like:\n\n```\n{\n    \"aggs\": {\n        \"brand\": {\n            \"terms\": {\n                \"field\": \"brand\",\n                \"payloads\": true,\n                \"order\": {\"_payload.priority\": \"desc\"}\n            }\n        }\n    }\n}\n```\n\nAnd the result may look like:\n\n```\n{\n    \"aggregations\" : {\n        \"tags\" : {\n            \"buckets\" : [\n                {\n                    \"key\" : \"Samsung\",\n                    \"doc_count\" : 1,\n                    \"payload\": {\n                        \"priority\": 2,\n                        \"url\": \"samsung.html\"\n                    }\n                },\n                {\n                    \"key\" : \"Apple\",\n                    \"doc_count\" : 1,\n                    \"payload\": {\n                        \"priority\": 1,\n                        \"url\": \"apple.html\"\n                    }\n                }\n            ]\n        }\n    }\n}\n```\n\nCurrently, it can be implemented in userland by just encoding the payload into a (not analyzed) term (e.g. `Apple///apple.html///1`) before indexing and then decoding it from returned aggregation keys. For sorting it's a bit trickier - you need to make sure that your sorting key is placed in the beginning of the term and if you need to sort on different \"payload\" values, you just need to index into different fields.\n\nDoes implementing it natively sounds like a crazy idea?\n","closed_by":{"login":"clintongormley","id":56599,"node_id":"MDQ6VXNlcjU2NTk5","avatar_url":"https://avatars0.githubusercontent.com/u/56599?v=4","gravatar_id":"","url":"https://api.github.com/users/clintongormley","html_url":"https://github.com/clintongormley","followers_url":"https://api.github.com/users/clintongormley/followers","following_url":"https://api.github.com/users/clintongormley/following{/other_user}","gists_url":"https://api.github.com/users/clintongormley/gists{/gist_id}","starred_url":"https://api.github.com/users/clintongormley/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/clintongormley/subscriptions","organizations_url":"https://api.github.com/users/clintongormley/orgs","repos_url":"https://api.github.com/users/clintongormley/repos","events_url":"https://api.github.com/users/clintongormley/events{/privacy}","received_events_url":"https://api.github.com/users/clintongormley/received_events","type":"User","site_admin":false},"performed_via_github_app":null}