{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/46213","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/46213/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/46213/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/46213/events","html_url":"https://github.com/elastic/elasticsearch/issues/46213","id":487863066,"node_id":"MDU6SXNzdWU0ODc4NjMwNjY=","number":46213,"title":"Allow to partially query an adjacency matrix","user":{"login":"flash1293","id":1508364,"node_id":"MDQ6VXNlcjE1MDgzNjQ=","avatar_url":"https://avatars2.githubusercontent.com/u/1508364?v=4","gravatar_id":"","url":"https://api.github.com/users/flash1293","html_url":"https://github.com/flash1293","followers_url":"https://api.github.com/users/flash1293/followers","following_url":"https://api.github.com/users/flash1293/following{/other_user}","gists_url":"https://api.github.com/users/flash1293/gists{/gist_id}","starred_url":"https://api.github.com/users/flash1293/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/flash1293/subscriptions","organizations_url":"https://api.github.com/users/flash1293/orgs","repos_url":"https://api.github.com/users/flash1293/repos","events_url":"https://api.github.com/users/flash1293/events{/privacy}","received_events_url":"https://api.github.com/users/flash1293/received_events","type":"User","site_admin":false},"labels":[{"id":141141324,"node_id":"MDU6TGFiZWwxNDExNDEzMjQ=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/:Analytics/Aggregations","name":":Analytics/Aggregations","color":"0e8a16","default":false,"description":"Aggregations"},{"id":1967499105,"node_id":"MDU6TGFiZWwxOTY3NDk5MTA1","url":"https://api.github.com/repos/elastic/elasticsearch/labels/Team:Analytics","name":"Team:Analytics","color":"fef2c0","default":false,"description":"Meta label for analytics/geo team"}],"state":"closed","locked":false,"assignee":{"login":"markharwood","id":170925,"node_id":"MDQ6VXNlcjE3MDkyNQ==","avatar_url":"https://avatars0.githubusercontent.com/u/170925?v=4","gravatar_id":"","url":"https://api.github.com/users/markharwood","html_url":"https://github.com/markharwood","followers_url":"https://api.github.com/users/markharwood/followers","following_url":"https://api.github.com/users/markharwood/following{/other_user}","gists_url":"https://api.github.com/users/markharwood/gists{/gist_id}","starred_url":"https://api.github.com/users/markharwood/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/markharwood/subscriptions","organizations_url":"https://api.github.com/users/markharwood/orgs","repos_url":"https://api.github.com/users/markharwood/repos","events_url":"https://api.github.com/users/markharwood/events{/privacy}","received_events_url":"https://api.github.com/users/markharwood/received_events","type":"User","site_admin":false},"assignees":[{"login":"markharwood","id":170925,"node_id":"MDQ6VXNlcjE3MDkyNQ==","avatar_url":"https://avatars0.githubusercontent.com/u/170925?v=4","gravatar_id":"","url":"https://api.github.com/users/markharwood","html_url":"https://github.com/markharwood","followers_url":"https://api.github.com/users/markharwood/followers","following_url":"https://api.github.com/users/markharwood/following{/other_user}","gists_url":"https://api.github.com/users/markharwood/gists{/gist_id}","starred_url":"https://api.github.com/users/markharwood/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/markharwood/subscriptions","organizations_url":"https://api.github.com/users/markharwood/orgs","repos_url":"https://api.github.com/users/markharwood/repos","events_url":"https://api.github.com/users/markharwood/events{/privacy}","received_events_url":"https://api.github.com/users/markharwood/received_events","type":"User","site_admin":false}],"milestone":null,"comments":5,"created_at":"2019-09-01T09:31:24Z","updated_at":"2020-06-24T14:57:12Z","closed_at":"2020-06-24T14:57:11Z","author_association":"NONE","active_lock_reason":null,"body":"## Idea\r\n\r\nCurrently it is possible to fetch the adjacency matrix for a given set of filters. However it is necessary to always fetch the complete matrix, e.g. for filters `filter0` up to `filter99` all possible pairings will be returned. In some cases it would be helpful to be able to only fetch a portion of the adjacency matrix.\r\n\r\nThis would allow a user to\r\n* Incrementally query a very big adjacency matrix (thousands of filters), similar to how scroll searches and composite aggregations work today\r\n* Save computation when filters are added to a matrix already fetched in previous requests (e.g. user fetches a matrix for `filter0` up to `filter99` and after looking at the results decides to also add `filter100` and `filter101`)\r\n\r\nComputational and memory costs are mostly saved because not all possible pairings between filters have to be considered while calculating the matrix. This should be especially relevant in cases where costly child aggregations are done as part of the matrix aggregation.\r\n\r\n## Alternatives considered\r\n\r\n### Nested filters\r\n\r\nIt is possible to do the same thing by nesting filter aggregations, e.g. in the use case from above \"user fetches a matrix for `filter0` up to `filter99` and after looking at the results decides to also add `filter100` and `filter101`\" it would be possible to do a filter aggregation for `filter100` and `filter101`, then having a nested filter aggregation for `filter0` up to `filter99` below that. The downside of this approach (besides possible performance problems I didn't test for yet) is that some pairings are calculated multiple times (`filter100 & filter101` vs `filter101 & filter100`). This problem gets worse if there is more overlap between the two sets of filters.\r\n\r\n### Scope down to new filters\r\n\r\nAgain using the example from above, it would also be possible to use an adjacency matrix aggregation for `filter0` up to `filter101`, but scoping down the entire search to `filter100 OR filter101`. As long as all filters only operate on non-array fields, this should result in the same result as querying a partial adjacency matrix. However this approach would easily run into the limit of allowed filters per adjacency matrix aggregation even though the intended query would include way less data. Additionally lots of impossible pairings (e.g. `filter4 & filter55`) are considered during the calculation.\r\n\r\n## API proposal\r\n\r\nI propose to backwards-compatible extend the existing `adjacency_matrix` aggregation by adding an array property of filters for both selected rows and columns of the matrix.\r\n\r\n```json\r\n{\r\n  \"interactions\": {\r\n    \"adjacency_matrix\": {\r\n      \"filters\": {\r\n        \"grpA\": { \"terms\": { \"accounts\": [\"hillary\", \"sidney\"] } },\r\n        \"grpB\": { \"terms\": { \"accounts\": [\"donald\", \"mitt\"] } },\r\n        \"grpC\": { \"terms\": { \"accounts\": [\"vladimir\", \"nigel\"] } }\r\n      },\r\n      \"columns\": [\"grpC\"],\r\n      \"rows\": [\"grpA\", \"grpB\", \"grpC\"]\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nOnly pairings in the intersection of the row and column selector are returned to the user. If a selector is omitted, it falls back to all given filters, ensured backwards compatibility.\r\n\r\nThe downside of this API is that it's not trivial to efficiently query a very big adjacency matrix in an incremental fashion (keeping all requests around the same size and don't fetch the same data twice), however this could be implemented in a client library if the need arises.\r\n\r\n## Settings\r\n\r\nThe `index.max_adjacency_matrix_filters` setting limits the number of filters in an adjacency matrix. It could continue to work in the exact same way is it currently does (limiting the number of specified filters), however that would be unnecessarily constraining because depending on rows and columns selectors only a small portion of the matrix is actually queried.\r\n\r\nIdeally the limit should be applied to the product of selected rows and columns minus duplicates because of the symmetry of the matrix (maybe `index.max_adjacency_matrix_size`, defaulting to `5050` which is the current limit after considering duplicates), however that would make a breaking change necessary. This could be made part of the 8.0 release.\r\n\r\nConsidering duplicates in the calculation of the limit might be technically correct, but it's maybe too confusing to calculate, another option would be to simply not consider them in the limit and making sure to pick a default that also works for the worst case (no duplicates in rows and columns selector).\r\n\r\nThere is also the option to have a separate aggregation `partial_adjacency_matrix`, then limiting the product of rows and columns could be introduced in a minor version.\r\n\r\ncc @markharwood \r\n\r\nAlso see https://github.com/elastic/elasticsearch/issues/46212","closed_by":{"login":"markharwood","id":170925,"node_id":"MDQ6VXNlcjE3MDkyNQ==","avatar_url":"https://avatars0.githubusercontent.com/u/170925?v=4","gravatar_id":"","url":"https://api.github.com/users/markharwood","html_url":"https://github.com/markharwood","followers_url":"https://api.github.com/users/markharwood/followers","following_url":"https://api.github.com/users/markharwood/following{/other_user}","gists_url":"https://api.github.com/users/markharwood/gists{/gist_id}","starred_url":"https://api.github.com/users/markharwood/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/markharwood/subscriptions","organizations_url":"https://api.github.com/users/markharwood/orgs","repos_url":"https://api.github.com/users/markharwood/repos","events_url":"https://api.github.com/users/markharwood/events{/privacy}","received_events_url":"https://api.github.com/users/markharwood/received_events","type":"User","site_admin":false},"performed_via_github_app":null}