[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/143354816","html_url":"https://github.com/elastic/elasticsearch/issues/13806#issuecomment-143354816","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/13806","id":143354816,"node_id":"MDEyOklzc3VlQ29tbWVudDE0MzM1NDgxNg==","user":{"login":"jpotisch","id":583171,"node_id":"MDQ6VXNlcjU4MzE3MQ==","avatar_url":"https://avatars0.githubusercontent.com/u/583171?v=4","gravatar_id":"","url":"https://api.github.com/users/jpotisch","html_url":"https://github.com/jpotisch","followers_url":"https://api.github.com/users/jpotisch/followers","following_url":"https://api.github.com/users/jpotisch/following{/other_user}","gists_url":"https://api.github.com/users/jpotisch/gists{/gist_id}","starred_url":"https://api.github.com/users/jpotisch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jpotisch/subscriptions","organizations_url":"https://api.github.com/users/jpotisch/orgs","repos_url":"https://api.github.com/users/jpotisch/repos","events_url":"https://api.github.com/users/jpotisch/events{/privacy}","received_events_url":"https://api.github.com/users/jpotisch/received_events","type":"User","site_admin":false},"created_at":"2015-09-25T21:06:24Z","updated_at":"2015-09-25T21:06:24Z","author_association":"NONE","body":"**UPDATE**: In going over this with a colleague I realized that only knowing how many search terms matched a record in the index could obscure the fact that it really was a low quality match. e.g. the query terms `john jacob smith junior` would score a 2 against `john smith`, but the query `john smith` would produce the exactly same score against that record despite having no term misses.\n\nPerhaps in addition to or instead of `match_count` it could have `match_percent`. In that case `john smith` would get a score of 0.5 against the query `john jacob smith junior`, while the same query against the record `john smith` would produce a score of 1.\n\nThis is a little closer to Elasticsearch's behavior today, but with the important removal of the TF-IDF normalization and the exceedingly fine granularity that overwhelms our custom `function_score` ranking.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/143492181","html_url":"https://github.com/elastic/elasticsearch/issues/13806#issuecomment-143492181","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/13806","id":143492181,"node_id":"MDEyOklzc3VlQ29tbWVudDE0MzQ5MjE4MQ==","user":{"login":"s1monw","id":973334,"node_id":"MDQ6VXNlcjk3MzMzNA==","avatar_url":"https://avatars0.githubusercontent.com/u/973334?v=4","gravatar_id":"","url":"https://api.github.com/users/s1monw","html_url":"https://github.com/s1monw","followers_url":"https://api.github.com/users/s1monw/followers","following_url":"https://api.github.com/users/s1monw/following{/other_user}","gists_url":"https://api.github.com/users/s1monw/gists{/gist_id}","starred_url":"https://api.github.com/users/s1monw/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/s1monw/subscriptions","organizations_url":"https://api.github.com/users/s1monw/orgs","repos_url":"https://api.github.com/users/s1monw/repos","events_url":"https://api.github.com/users/s1monw/events{/privacy}","received_events_url":"https://api.github.com/users/s1monw/received_events","type":"User","site_admin":false},"created_at":"2015-09-26T20:25:20Z","updated_at":"2015-09-26T20:25:20Z","author_association":"CONTRIBUTOR","body":"so basically what you are saying is you just want to wrap each term in the boolean query in a constant score query that returns `1` on a match?\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/143540222","html_url":"https://github.com/elastic/elasticsearch/issues/13806#issuecomment-143540222","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/13806","id":143540222,"node_id":"MDEyOklzc3VlQ29tbWVudDE0MzU0MDIyMg==","user":{"login":"clintongormley","id":56599,"node_id":"MDQ6VXNlcjU2NTk5","avatar_url":"https://avatars0.githubusercontent.com/u/56599?v=4","gravatar_id":"","url":"https://api.github.com/users/clintongormley","html_url":"https://github.com/clintongormley","followers_url":"https://api.github.com/users/clintongormley/followers","following_url":"https://api.github.com/users/clintongormley/following{/other_user}","gists_url":"https://api.github.com/users/clintongormley/gists{/gist_id}","starred_url":"https://api.github.com/users/clintongormley/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/clintongormley/subscriptions","organizations_url":"https://api.github.com/users/clintongormley/orgs","repos_url":"https://api.github.com/users/clintongormley/repos","events_url":"https://api.github.com/users/clintongormley/events{/privacy}","received_events_url":"https://api.github.com/users/clintongormley/received_events","type":"User","site_admin":false},"created_at":"2015-09-27T10:25:26Z","updated_at":"2015-09-27T10:25:26Z","author_association":"CONTRIBUTOR","body":"You have a few options.  You can disable term stats completely by setting [`index_options`](https://www.elastic.co/guide/en/elasticsearch/reference/2.0/index-options.html) to `docs`.\n\nYou can use BM25 similarity and [tune `k1` and `b`](https://www.elastic.co/guide/en/elasticsearch/guide/current/pluggable-similarites.html#bm25-tunability) to control term frequency saturation and field length normalization.\n\nUse a constant score query per term, wrapped in a `bool` query (with `disable_coord` set to `true`).\n\nYou're already using function score, so you could just filter on the terms you're interested in and score each one with the `weight` you desire.\n\nAlternatively, use the `weight` and  `boost_mode` parameters in function score to tune how query weights are combined with your function score weights.\n\nWrite your own custom similarity that does exactly what you want.\n\ni think there are enough options here that we don't need to further complicate the match query.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/143796098","html_url":"https://github.com/elastic/elasticsearch/issues/13806#issuecomment-143796098","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/13806","id":143796098,"node_id":"MDEyOklzc3VlQ29tbWVudDE0Mzc5NjA5OA==","user":{"login":"jpotisch","id":583171,"node_id":"MDQ6VXNlcjU4MzE3MQ==","avatar_url":"https://avatars0.githubusercontent.com/u/583171?v=4","gravatar_id":"","url":"https://api.github.com/users/jpotisch","html_url":"https://github.com/jpotisch","followers_url":"https://api.github.com/users/jpotisch/followers","following_url":"https://api.github.com/users/jpotisch/following{/other_user}","gists_url":"https://api.github.com/users/jpotisch/gists{/gist_id}","starred_url":"https://api.github.com/users/jpotisch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jpotisch/subscriptions","organizations_url":"https://api.github.com/users/jpotisch/orgs","repos_url":"https://api.github.com/users/jpotisch/repos","events_url":"https://api.github.com/users/jpotisch/events{/privacy}","received_events_url":"https://api.github.com/users/jpotisch/received_events","type":"User","site_admin":false},"created_at":"2015-09-28T16:24:11Z","updated_at":"2015-09-28T16:24:11Z","author_association":"NONE","body":"@clintongormley thanks for the info. I definitely don't want to gum up the works if this is already possible. I will look into the options you describe but based on your reply I want to be sure I explained this clearly. You mentioned using `constant_score` but that would collapse all those scores down to the same value (value of `boost` or default of 1), no? And re: `function_score` I don't want to \"filter on the terms [I'm] interested in\", I want to include everything.\n\nI'm not looking to filter results or get precise weighting across multiple `should` clauses, I'm trying to get a score that tells me how many search terms matched the searched record, without normalizing for term frequency, etc. Something along the lines of having the search terms `a b c d` produce a score of:\n- 1 against the field `\"A\"`\n- 2 against the record `\"A B x y z\"`\n- 4 against the record `\"A x B x C x D foo bar guacamole\"`\n- etc.\n\nMy apologies if my initial description was misleading, or if I've misunderstood your reply. I will of course defer to you completely on this but I just want to make sure we're not talking past each other.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/144070838","html_url":"https://github.com/elastic/elasticsearch/issues/13806#issuecomment-144070838","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/13806","id":144070838,"node_id":"MDEyOklzc3VlQ29tbWVudDE0NDA3MDgzOA==","user":{"login":"clintongormley","id":56599,"node_id":"MDQ6VXNlcjU2NTk5","avatar_url":"https://avatars0.githubusercontent.com/u/56599?v=4","gravatar_id":"","url":"https://api.github.com/users/clintongormley","html_url":"https://github.com/clintongormley","followers_url":"https://api.github.com/users/clintongormley/followers","following_url":"https://api.github.com/users/clintongormley/following{/other_user}","gists_url":"https://api.github.com/users/clintongormley/gists{/gist_id}","starred_url":"https://api.github.com/users/clintongormley/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/clintongormley/subscriptions","organizations_url":"https://api.github.com/users/clintongormley/orgs","repos_url":"https://api.github.com/users/clintongormley/repos","events_url":"https://api.github.com/users/clintongormley/events{/privacy}","received_events_url":"https://api.github.com/users/clintongormley/received_events","type":"User","site_admin":false},"created_at":"2015-09-29T14:04:38Z","updated_at":"2015-09-29T14:04:38Z","author_association":"CONTRIBUTOR","body":"Here's what I mean:\n\nYou can tune BM25 to ignore term frequency (k1) and field length normalization (b) as follows:\n\n```\nPUT t\n{\n  \"similarity\": {\n    \"only_idf\": {\n      \"type\": \"BM25\",\n      \"k1\": 0,\n      \"b\": 0\n    }\n  },\n  \"mappings\": {\n    \"my_type\": {\n      \"properties\": {\n        \"field\": {\n          \"type\": \"string\",\n          \"similarity\": \"only_idf\"\n        }\n      }\n    }\n  }\n}\n\nPOST t/my_type/_bulk\n{\"index\": {}}\n{\"field\": \"A\"}\n{\"index\": {}}\n{\"field\": \"A B x y z\"}\n{\"index\": {}}\n{\"field\": \"A x B x C x D foo bar guacamole\"}\n```\n\nThis query will add up the IDF for each matching term (you mentioned the requirement in your second comment to differentiate between high and low quality terms):\n\n```\nGET t/_search\n{\n  \"query\": {\n    \"bool\": {\n      \"disable_coord\": true,\n      \"should\": [\n        {\n          \"term\": {\n            \"field\": \"a\"\n          }\n        },\n        {\n          \"term\": {\n            \"field\": \"b\"\n          }\n        },\n        {\n          \"term\": {\n            \"field\": \"c\"\n          }\n        },\n        {\n          \"term\": {\n            \"field\": \"d\"\n          }\n        }\n      ]\n    }\n  }\n}\n```\n\nYou can use constant scores to count each match as 1 (although the final score for each document is normalised so you get 0.5, 1, and 2, instead of 1, 2, and 4:\n\n```\nGET t/_search\n{\n  \"query\": {\n    \"bool\": {\n      \"disable_coord\": true,\n      \"should\": [\n        {\n          \"constant_score\": {\n            \"filter\": {\n              \"term\": {\n                \"field\": \"a\"\n              }\n            }\n          }\n        },\n        {\n          \"constant_score\": {\n            \"filter\": {\n              \"term\": {\n                \"field\": \"b\"\n              }\n            }\n          }\n        },\n        {\n          \"constant_score\": {\n            \"filter\": {\n              \"term\": {\n                \"field\": \"c\"\n              }\n            }\n          }\n        },\n        {\n          \"constant_score\": {\n            \"filter\": {\n              \"term\": {\n                \"field\": \"d\"\n              }\n            }\n          }\n        }\n      ]\n    }\n  }\n}\n```\n\nAnd here's a function score query which gives you 1, 2, and 4:\n\n```\nGET t/_search\n{\n  \"query\": {\n    \"function_score\": {\n      \"query\": {\n        \"match\": {\n          \"field\": \"a b c d\"\n        }\n      },\n      \"boost_mode\": \"replace\",\n      \"score_mode\": \"sum\",\n      \"functions\": [\n        {\n          \"filter\": {\n            \"term\": {\n              \"field\": \"a\"\n            }\n          },\n          \"weight\": 1\n        },\n        {\n          \"filter\": {\n            \"term\": {\n              \"field\": \"b\"\n            }\n          },\n          \"weight\": 1\n        },\n        {\n          \"filter\": {\n            \"term\": {\n              \"field\": \"c\"\n            }\n          },\n          \"weight\": 1\n        },\n        {\n          \"filter\": {\n            \"term\": {\n              \"field\": \"d\"\n            }\n          },\n          \"weight\": 1\n        }\n      ]\n    }\n  }\n}\n```\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/144550175","html_url":"https://github.com/elastic/elasticsearch/issues/13806#issuecomment-144550175","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/13806","id":144550175,"node_id":"MDEyOklzc3VlQ29tbWVudDE0NDU1MDE3NQ==","user":{"login":"jpotisch","id":583171,"node_id":"MDQ6VXNlcjU4MzE3MQ==","avatar_url":"https://avatars0.githubusercontent.com/u/583171?v=4","gravatar_id":"","url":"https://api.github.com/users/jpotisch","html_url":"https://github.com/jpotisch","followers_url":"https://api.github.com/users/jpotisch/followers","following_url":"https://api.github.com/users/jpotisch/following{/other_user}","gists_url":"https://api.github.com/users/jpotisch/gists{/gist_id}","starred_url":"https://api.github.com/users/jpotisch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jpotisch/subscriptions","organizations_url":"https://api.github.com/users/jpotisch/orgs","repos_url":"https://api.github.com/users/jpotisch/repos","events_url":"https://api.github.com/users/jpotisch/events{/privacy}","received_events_url":"https://api.github.com/users/jpotisch/received_events","type":"User","site_admin":false},"created_at":"2015-09-30T21:39:57Z","updated_at":"2015-09-30T21:39:57Z","author_association":"NONE","body":"Thanks @clintongormley. This is _exceedingly_ helpful. I didn't realize I'd effectively have to shatter my search term into individual `should` clauses (`\"field\": \"a\"`, `\"field\": \"b\"`, etc.) So I guess I need to tokenize my search terms on white space and build the query dynamically, one `should` array item per term?\n\nAnd I didn't mean I need to distinguish between high and low quality _terms_ (like `the` vs. `guacamole`), I meant I want to distinguish high quality matches (all my search terms match) from low quality matches (some terms were found, some were not). For example if I search for `a b`, the record `a b c d` would be a high quality match, as it contains all my search terms, and would have a score of 2 using your function_score query.\n\nMy concern is that the query `a b c d` against the record `a b` would also produce a score of 2 even though half my search terms missed. To be clear I still want them in the results, I'd just want them to score lower. But now that I think it through I wonder if this actually would cause issues in practice. I don't actually care about correctly ranking results for search `a b` against those for search `a b c d`, I only care that all results that contain `a` and `b` and `c` and `d` are ranked identically at the top, followed by all records that are missing one term, then missing two, all the way down to the `minimum_should_match` I specify.\n\nAny parting words of advice/caution regarding the above? Otherwise you're free to go. ;-) (And regardless, I owe you a beer or three!)\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/145062557","html_url":"https://github.com/elastic/elasticsearch/issues/13806#issuecomment-145062557","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/13806","id":145062557,"node_id":"MDEyOklzc3VlQ29tbWVudDE0NTA2MjU1Nw==","user":{"login":"clintongormley","id":56599,"node_id":"MDQ6VXNlcjU2NTk5","avatar_url":"https://avatars0.githubusercontent.com/u/56599?v=4","gravatar_id":"","url":"https://api.github.com/users/clintongormley","html_url":"https://github.com/clintongormley","followers_url":"https://api.github.com/users/clintongormley/followers","following_url":"https://api.github.com/users/clintongormley/following{/other_user}","gists_url":"https://api.github.com/users/clintongormley/gists{/gist_id}","starred_url":"https://api.github.com/users/clintongormley/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/clintongormley/subscriptions","organizations_url":"https://api.github.com/users/clintongormley/orgs","repos_url":"https://api.github.com/users/clintongormley/repos","events_url":"https://api.github.com/users/clintongormley/events{/privacy}","received_events_url":"https://api.github.com/users/clintongormley/received_events","type":"User","site_admin":false},"created_at":"2015-10-02T15:28:40Z","updated_at":"2015-10-02T15:28:40Z","author_association":"CONTRIBUTOR","body":"> My concern is that the query a b c d against the record a b would also produce a score of 2 even though half my search terms missed. To be clear I still want them in the results, I'd just want them to score lower. \n\nThat's where query coordination comes in handy  (ie the thing I disabled with `disable_coord`).  See https://www.elastic.co/guide/en/elasticsearch/guide/current/practical-scoring-function.html#coord for more\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/197676795","html_url":"https://github.com/elastic/elasticsearch/issues/13806#issuecomment-197676795","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/13806","id":197676795,"node_id":"MDEyOklzc3VlQ29tbWVudDE5NzY3Njc5NQ==","user":{"login":"q11112345","id":10358392,"node_id":"MDQ6VXNlcjEwMzU4Mzky","avatar_url":"https://avatars3.githubusercontent.com/u/10358392?v=4","gravatar_id":"","url":"https://api.github.com/users/q11112345","html_url":"https://github.com/q11112345","followers_url":"https://api.github.com/users/q11112345/followers","following_url":"https://api.github.com/users/q11112345/following{/other_user}","gists_url":"https://api.github.com/users/q11112345/gists{/gist_id}","starred_url":"https://api.github.com/users/q11112345/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/q11112345/subscriptions","organizations_url":"https://api.github.com/users/q11112345/orgs","repos_url":"https://api.github.com/users/q11112345/repos","events_url":"https://api.github.com/users/q11112345/events{/privacy}","received_events_url":"https://api.github.com/users/q11112345/received_events","type":"User","site_admin":false},"created_at":"2016-03-17T03:32:08Z","updated_at":"2016-03-17T06:52:07Z","author_association":"NONE","body":"what if i cant analyze the query string myself ?\nfor query string: \"iphone5s\"\ni need the analyzer analyzing the query string and having the same effect as jpotisch need.\n\nfor example:\nquery string: \"iphone5s\"\nterms analyzed by index analyzer: \"iphone\" \"5s\"\nscore result expecting: 2, 1 or 0\n\ncan this be possible?\n@clintongormley \n\nand the best is that i can know which term is matched to the document in script score, then i can do something to adjust the weight of different term, \ni may build up a mapping from term to weight in script.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/355680273","html_url":"https://github.com/elastic/elasticsearch/issues/13806#issuecomment-355680273","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/13806","id":355680273,"node_id":"MDEyOklzc3VlQ29tbWVudDM1NTY4MDI3Mw==","user":{"login":"hainingren","id":24967278,"node_id":"MDQ6VXNlcjI0OTY3Mjc4","avatar_url":"https://avatars0.githubusercontent.com/u/24967278?v=4","gravatar_id":"","url":"https://api.github.com/users/hainingren","html_url":"https://github.com/hainingren","followers_url":"https://api.github.com/users/hainingren/followers","following_url":"https://api.github.com/users/hainingren/following{/other_user}","gists_url":"https://api.github.com/users/hainingren/gists{/gist_id}","starred_url":"https://api.github.com/users/hainingren/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hainingren/subscriptions","organizations_url":"https://api.github.com/users/hainingren/orgs","repos_url":"https://api.github.com/users/hainingren/repos","events_url":"https://api.github.com/users/hainingren/events{/privacy}","received_events_url":"https://api.github.com/users/hainingren/received_events","type":"User","site_admin":false},"created_at":"2018-01-05T22:15:58Z","updated_at":"2018-01-05T22:16:47Z","author_association":"NONE","body":"@clintongormley Thanks for your illuminating post. Do you think the tuned BM25 will be faster (search performance wise) than writing filter queries inline? Thanks again!\r\n  ","performed_via_github_app":null}]