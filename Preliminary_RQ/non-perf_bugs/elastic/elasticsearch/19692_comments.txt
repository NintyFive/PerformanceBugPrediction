[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/236295030","html_url":"https://github.com/elastic/elasticsearch/issues/19692#issuecomment-236295030","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19692","id":236295030,"node_id":"MDEyOklzc3VlQ29tbWVudDIzNjI5NTAzMA==","user":{"login":"nik9000","id":215970,"node_id":"MDQ6VXNlcjIxNTk3MA==","avatar_url":"https://avatars2.githubusercontent.com/u/215970?v=4","gravatar_id":"","url":"https://api.github.com/users/nik9000","html_url":"https://github.com/nik9000","followers_url":"https://api.github.com/users/nik9000/followers","following_url":"https://api.github.com/users/nik9000/following{/other_user}","gists_url":"https://api.github.com/users/nik9000/gists{/gist_id}","starred_url":"https://api.github.com/users/nik9000/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/nik9000/subscriptions","organizations_url":"https://api.github.com/users/nik9000/orgs","repos_url":"https://api.github.com/users/nik9000/repos","events_url":"https://api.github.com/users/nik9000/events{/privacy}","received_events_url":"https://api.github.com/users/nik9000/received_events","type":"User","site_admin":false},"created_at":"2016-07-29T21:13:12Z","updated_at":"2016-07-29T21:13:12Z","author_association":"CONTRIBUTOR","body":"I don't know what is up for sure. @tlrx might know more so I've pinged him.\n\nI will say that step 3 of your process is generally a bad idea - it is much much much more efficient to delete the a whole index rather than to delete all of the documents from it. On the other hand if you are only removing parts of it, well, know that that isn't a particularly efficient operation. If you are ok with that then cool.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/236303379","html_url":"https://github.com/elastic/elasticsearch/issues/19692#issuecomment-236303379","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19692","id":236303379,"node_id":"MDEyOklzc3VlQ29tbWVudDIzNjMwMzM3OQ==","user":{"login":"aewhite","id":4342706,"node_id":"MDQ6VXNlcjQzNDI3MDY=","avatar_url":"https://avatars1.githubusercontent.com/u/4342706?v=4","gravatar_id":"","url":"https://api.github.com/users/aewhite","html_url":"https://github.com/aewhite","followers_url":"https://api.github.com/users/aewhite/followers","following_url":"https://api.github.com/users/aewhite/following{/other_user}","gists_url":"https://api.github.com/users/aewhite/gists{/gist_id}","starred_url":"https://api.github.com/users/aewhite/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/aewhite/subscriptions","organizations_url":"https://api.github.com/users/aewhite/orgs","repos_url":"https://api.github.com/users/aewhite/repos","events_url":"https://api.github.com/users/aewhite/events{/privacy}","received_events_url":"https://api.github.com/users/aewhite/received_events","type":"User","site_admin":false},"created_at":"2016-07-29T21:54:09Z","updated_at":"2016-07-29T21:54:09Z","author_association":"NONE","body":"To be clear, we are not using delete-by-query to delete all documents in an index. The point of this process is to move related documents from a large index into a dedicated index. \n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/236423424","html_url":"https://github.com/elastic/elasticsearch/issues/19692#issuecomment-236423424","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19692","id":236423424,"node_id":"MDEyOklzc3VlQ29tbWVudDIzNjQyMzQyNA==","user":{"login":"bleskes","id":1006375,"node_id":"MDQ6VXNlcjEwMDYzNzU=","avatar_url":"https://avatars1.githubusercontent.com/u/1006375?v=4","gravatar_id":"","url":"https://api.github.com/users/bleskes","html_url":"https://github.com/bleskes","followers_url":"https://api.github.com/users/bleskes/followers","following_url":"https://api.github.com/users/bleskes/following{/other_user}","gists_url":"https://api.github.com/users/bleskes/gists{/gist_id}","starred_url":"https://api.github.com/users/bleskes/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bleskes/subscriptions","organizations_url":"https://api.github.com/users/bleskes/orgs","repos_url":"https://api.github.com/users/bleskes/repos","events_url":"https://api.github.com/users/bleskes/events{/privacy}","received_events_url":"https://api.github.com/users/bleskes/received_events","type":"User","site_admin":false},"created_at":"2016-07-31T10:51:43Z","updated_at":"2016-07-31T10:51:43Z","author_association":"MEMBER","body":"@aewhite these things can be very difficult to trace down and depend on very small details. Can chance you can give us a concrete reproduction or at the very least the exact API calls you used?\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/236425923","html_url":"https://github.com/elastic/elasticsearch/issues/19692#issuecomment-236425923","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19692","id":236425923,"node_id":"MDEyOklzc3VlQ29tbWVudDIzNjQyNTkyMw==","user":{"login":"aewhite","id":4342706,"node_id":"MDQ6VXNlcjQzNDI3MDY=","avatar_url":"https://avatars1.githubusercontent.com/u/4342706?v=4","gravatar_id":"","url":"https://api.github.com/users/aewhite","html_url":"https://github.com/aewhite","followers_url":"https://api.github.com/users/aewhite/followers","following_url":"https://api.github.com/users/aewhite/following{/other_user}","gists_url":"https://api.github.com/users/aewhite/gists{/gist_id}","starred_url":"https://api.github.com/users/aewhite/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/aewhite/subscriptions","organizations_url":"https://api.github.com/users/aewhite/orgs","repos_url":"https://api.github.com/users/aewhite/repos","events_url":"https://api.github.com/users/aewhite/events{/privacy}","received_events_url":"https://api.github.com/users/aewhite/received_events","type":"User","site_admin":false},"created_at":"2016-07-31T11:54:08Z","updated_at":"2016-07-31T11:54:08Z","author_association":"NONE","body":"I have not been able replicate it outside of our production environment but I suspect the volume in that environment plays a big role. We are ingesting thousands of documents per second (sometime up to 100k/s). And when we do these document migrations, the volume is in the millions. \n\nAs to the exact delete-by-query, it is built using the following code:\n\n```\n        final DeleteByQueryRequestBuilder deleteByQueryRequestBuilder = DeleteByQueryAction.INSTANCE\n                .newRequestBuilder(client.getRawClient())\n                .setIndices(indexName)\n                .setTypes(\"post\", \"analytic\")\n                .setQuery(QueryBuilders.boolQuery()\n                                       .must(QueryBuilders.termQuery(\"internal.container_id\", containerId)));\n\n        deleteByQueryRequestBuilder.request().size(DELETE_BY_QUERY_BATCH_SIZE);\n\n        final DeleteByQueryResponse deleteByQueryResponse = deleteByQueryRequestBuilder\n                .execute()\n                .actionGet();\n```\n\nThe steps describe for (1) and (2) above are a bit more involved code-wise but the end calls to ES are very basic. Aliases are removed from one index and added to the other in a single command. The reindex calls are split up by types but are otherwise similar to the delete by query code above. \n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/236513893","html_url":"https://github.com/elastic/elasticsearch/issues/19692#issuecomment-236513893","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19692","id":236513893,"node_id":"MDEyOklzc3VlQ29tbWVudDIzNjUxMzg5Mw==","user":{"login":"tlrx","id":642733,"node_id":"MDQ6VXNlcjY0MjczMw==","avatar_url":"https://avatars1.githubusercontent.com/u/642733?v=4","gravatar_id":"","url":"https://api.github.com/users/tlrx","html_url":"https://github.com/tlrx","followers_url":"https://api.github.com/users/tlrx/followers","following_url":"https://api.github.com/users/tlrx/following{/other_user}","gists_url":"https://api.github.com/users/tlrx/gists{/gist_id}","starred_url":"https://api.github.com/users/tlrx/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/tlrx/subscriptions","organizations_url":"https://api.github.com/users/tlrx/orgs","repos_url":"https://api.github.com/users/tlrx/repos","events_url":"https://api.github.com/users/tlrx/events{/privacy}","received_events_url":"https://api.github.com/users/tlrx/received_events","type":"User","site_admin":false},"created_at":"2016-08-01T07:59:30Z","updated_at":"2016-08-01T07:59:30Z","author_association":"MEMBER","body":"Unfortunately the Delete-By-Query plugin in version 2.x lacks of logging traces when a delete request failed but most of the time this is caused by a missing document, ie a document has been found during the search/scan/scroll phase but has been deleted or updated before the effective delete request is executed. Are you in such a case? \n\nAlso, do you see any difference in docs count in shards before executing the delete-by-query request?\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/236907057","html_url":"https://github.com/elastic/elasticsearch/issues/19692#issuecomment-236907057","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19692","id":236907057,"node_id":"MDEyOklzc3VlQ29tbWVudDIzNjkwNzA1Nw==","user":{"login":"aewhite","id":4342706,"node_id":"MDQ6VXNlcjQzNDI3MDY=","avatar_url":"https://avatars1.githubusercontent.com/u/4342706?v=4","gravatar_id":"","url":"https://api.github.com/users/aewhite","html_url":"https://github.com/aewhite","followers_url":"https://api.github.com/users/aewhite/followers","following_url":"https://api.github.com/users/aewhite/following{/other_user}","gists_url":"https://api.github.com/users/aewhite/gists{/gist_id}","starred_url":"https://api.github.com/users/aewhite/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/aewhite/subscriptions","organizations_url":"https://api.github.com/users/aewhite/orgs","repos_url":"https://api.github.com/users/aewhite/repos","events_url":"https://api.github.com/users/aewhite/events{/privacy}","received_events_url":"https://api.github.com/users/aewhite/received_events","type":"User","site_admin":false},"created_at":"2016-08-02T13:40:08Z","updated_at":"2016-08-02T13:40:08Z","author_association":"NONE","body":"I have another update and I'll answer some Qs.\n\nWe ran into this issue again this morning. However, this time there is no difference in the number of documents (or even their _id field), but there is a difference in the versions of the documents. \n\nQuick background: we use external versioning based on a timestamping system to ensure that various system doesn't overwrite new data with outdated data. \n\nThe version differences across the shards is tiny (<100ms on average) and it appears to be a toss-up as to which shard has the greatest _version.  It's not unusual for us to see rapid fire updates/inserts to the same document due to the nature of the data we collect and our processes. \n\nThis makes me wonder if the problem is in step (1). Even though the alias switch is atomic, are they transactionally consistent for replication? Though, I can see how update-by-query might still be a candidate. \n\n@tlrx to answer your questions:\n\nFirst, at the time we issue a delete-by-query on an set of documents, all aliases that would point to that data have been reassigned to a new index. We never issue a delete-by-query to a set of documents that could be updated (all writes go through aliases that are tightly controlled).\n\nAs to the state of the index before the query, sadly we don't have insights into this and I think it might be hard given the state I described above with equal doc counts but different versions. This is part of an automated process so I rarely get to see the system between steps (1) and (3) of my original description. And even even if I could look, I don't know how to find version difference across shards for millions of documents without exporting/sorting and comparing them. \n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/236924388","html_url":"https://github.com/elastic/elasticsearch/issues/19692#issuecomment-236924388","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19692","id":236924388,"node_id":"MDEyOklzc3VlQ29tbWVudDIzNjkyNDM4OA==","user":{"login":"aewhite","id":4342706,"node_id":"MDQ6VXNlcjQzNDI3MDY=","avatar_url":"https://avatars1.githubusercontent.com/u/4342706?v=4","gravatar_id":"","url":"https://api.github.com/users/aewhite","html_url":"https://github.com/aewhite","followers_url":"https://api.github.com/users/aewhite/followers","following_url":"https://api.github.com/users/aewhite/following{/other_user}","gists_url":"https://api.github.com/users/aewhite/gists{/gist_id}","starred_url":"https://api.github.com/users/aewhite/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/aewhite/subscriptions","organizations_url":"https://api.github.com/users/aewhite/orgs","repos_url":"https://api.github.com/users/aewhite/repos","events_url":"https://api.github.com/users/aewhite/events{/privacy}","received_events_url":"https://api.github.com/users/aewhite/received_events","type":"User","site_admin":false},"created_at":"2016-08-02T14:37:12Z","updated_at":"2016-08-02T14:37:12Z","author_association":"NONE","body":"Ok, more updates. I tracked down the exact versions that were in conflict and when they were inserted. Nearly all of the conflicts cluster around a time when the index was being hit heavily (100k inserts per second). All of the steps I described above happened hours later. Therefore, this appears to be related to write consistency under heavy volume. \n\nI checked the server logs (master and the shard primary and replica hosts) and nothing is reported out of the ordinary for that high-insert time. \n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/236949470","html_url":"https://github.com/elastic/elasticsearch/issues/19692#issuecomment-236949470","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19692","id":236949470,"node_id":"MDEyOklzc3VlQ29tbWVudDIzNjk0OTQ3MA==","user":{"login":"nik9000","id":215970,"node_id":"MDQ6VXNlcjIxNTk3MA==","avatar_url":"https://avatars2.githubusercontent.com/u/215970?v=4","gravatar_id":"","url":"https://api.github.com/users/nik9000","html_url":"https://github.com/nik9000","followers_url":"https://api.github.com/users/nik9000/followers","following_url":"https://api.github.com/users/nik9000/following{/other_user}","gists_url":"https://api.github.com/users/nik9000/gists{/gist_id}","starred_url":"https://api.github.com/users/nik9000/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/nik9000/subscriptions","organizations_url":"https://api.github.com/users/nik9000/orgs","repos_url":"https://api.github.com/users/nik9000/repos","events_url":"https://api.github.com/users/nik9000/events{/privacy}","received_events_url":"https://api.github.com/users/nik9000/received_events","type":"User","site_admin":false},"created_at":"2016-08-02T15:53:50Z","updated_at":"2016-08-02T15:53:50Z","author_association":"CONTRIBUTOR","body":"> Therefore, this appears to be related to write consistency under heavy volume.\n\nYou **should** be able to make _sure_ this isn't caused by delete-by-query/alias swapping by walking an index that you haven't used that against and doing gets, bouncing from replica to primary. You can do that with [_preference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-preference.html).\n\nAre you willing to give that a shot?\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/237030506","html_url":"https://github.com/elastic/elasticsearch/issues/19692#issuecomment-237030506","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19692","id":237030506,"node_id":"MDEyOklzc3VlQ29tbWVudDIzNzAzMDUwNg==","user":{"login":"bleskes","id":1006375,"node_id":"MDQ6VXNlcjEwMDYzNzU=","avatar_url":"https://avatars1.githubusercontent.com/u/1006375?v=4","gravatar_id":"","url":"https://api.github.com/users/bleskes","html_url":"https://github.com/bleskes","followers_url":"https://api.github.com/users/bleskes/followers","following_url":"https://api.github.com/users/bleskes/following{/other_user}","gists_url":"https://api.github.com/users/bleskes/gists{/gist_id}","starred_url":"https://api.github.com/users/bleskes/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bleskes/subscriptions","organizations_url":"https://api.github.com/users/bleskes/orgs","repos_url":"https://api.github.com/users/bleskes/repos","events_url":"https://api.github.com/users/bleskes/events{/privacy}","received_events_url":"https://api.github.com/users/bleskes/received_events","type":"User","site_admin":false},"created_at":"2016-08-02T20:19:14Z","updated_at":"2016-08-02T20:19:14Z","author_association":"MEMBER","body":"> This makes me wonder if the problem is in step (1). Even though the alias switch is atomic, are they transactionally consistent for replication? \n\nThey should be resolved before the right is started on the primary, yes.\n\n> The version differences across the shards is tiny (<100ms on average) and it appears to be a toss-up as to which shard has the greatest _version\n\nIt sounds like you found document mismatch before the delete by query has run? can you elaborate on what your exactly mean with \"<100ms on average\"? are these difference between primary and replica? Or they on index A or index B?\n\nAlso, can you share the reindexing commands and the normal indexing command you use?\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/237047294","html_url":"https://github.com/elastic/elasticsearch/issues/19692#issuecomment-237047294","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19692","id":237047294,"node_id":"MDEyOklzc3VlQ29tbWVudDIzNzA0NzI5NA==","user":{"login":"aewhite","id":4342706,"node_id":"MDQ6VXNlcjQzNDI3MDY=","avatar_url":"https://avatars1.githubusercontent.com/u/4342706?v=4","gravatar_id":"","url":"https://api.github.com/users/aewhite","html_url":"https://github.com/aewhite","followers_url":"https://api.github.com/users/aewhite/followers","following_url":"https://api.github.com/users/aewhite/following{/other_user}","gists_url":"https://api.github.com/users/aewhite/gists{/gist_id}","starred_url":"https://api.github.com/users/aewhite/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/aewhite/subscriptions","organizations_url":"https://api.github.com/users/aewhite/orgs","repos_url":"https://api.github.com/users/aewhite/repos","events_url":"https://api.github.com/users/aewhite/events{/privacy}","received_events_url":"https://api.github.com/users/aewhite/received_events","type":"User","site_admin":false},"created_at":"2016-08-02T21:18:32Z","updated_at":"2016-08-02T21:18:32Z","author_association":"NONE","body":"@nik9000 I have started trying to find the problem for document sets that haven't been moved but these indexes are large (1B+ documents) and are actively being written to so it's hard to prove that a version mismatch from the time I read shard A to shard B isn't from normal processes. We're talking trying to find ~60 documents out of at least 7.5M documents in an index with 1B documents that has 1k inserts per second on the low end and 100k/s during peak processing time. \n\n@bleskes it does look like the problem exists before the delete-by-query ran but I just haven't found proof of that yet. \n\n>  can you elaborate on what your exactly mean with \"<100ms on average\"? are these difference between primary and replica? Or they on index A or index B?\n\nSure, so the differences were between the primary and the replicate. Basically my method was to query shard X primary and replica separately using the preference API, export their ids and versions, sort by id and compare them. What I saw was that documents on the primary and the replica had slightly different versions. Usually |version.primary - version.replica| < 100. As to which one had the greater version seemed random. \n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/237049587","html_url":"https://github.com/elastic/elasticsearch/issues/19692#issuecomment-237049587","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19692","id":237049587,"node_id":"MDEyOklzc3VlQ29tbWVudDIzNzA0OTU4Nw==","user":{"login":"bleskes","id":1006375,"node_id":"MDQ6VXNlcjEwMDYzNzU=","avatar_url":"https://avatars1.githubusercontent.com/u/1006375?v=4","gravatar_id":"","url":"https://api.github.com/users/bleskes","html_url":"https://github.com/bleskes","followers_url":"https://api.github.com/users/bleskes/followers","following_url":"https://api.github.com/users/bleskes/following{/other_user}","gists_url":"https://api.github.com/users/bleskes/gists{/gist_id}","starred_url":"https://api.github.com/users/bleskes/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bleskes/subscriptions","organizations_url":"https://api.github.com/users/bleskes/orgs","repos_url":"https://api.github.com/users/bleskes/repos","events_url":"https://api.github.com/users/bleskes/events{/privacy}","received_events_url":"https://api.github.com/users/bleskes/received_events","type":"User","site_admin":false},"created_at":"2016-08-02T21:27:00Z","updated_at":"2016-08-02T21:27:00Z","author_association":"MEMBER","body":">  I saw was that documents on the primary and the replica had slightly different versions. \n\nOK. Thanks. This helps. Are these index A or B?\n\nCan you share the API calls you use for indexing and reindexing?\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/237054396","html_url":"https://github.com/elastic/elasticsearch/issues/19692#issuecomment-237054396","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19692","id":237054396,"node_id":"MDEyOklzc3VlQ29tbWVudDIzNzA1NDM5Ng==","user":{"login":"aewhite","id":4342706,"node_id":"MDQ6VXNlcjQzNDI3MDY=","avatar_url":"https://avatars1.githubusercontent.com/u/4342706?v=4","gravatar_id":"","url":"https://api.github.com/users/aewhite","html_url":"https://github.com/aewhite","followers_url":"https://api.github.com/users/aewhite/followers","following_url":"https://api.github.com/users/aewhite/following{/other_user}","gists_url":"https://api.github.com/users/aewhite/gists{/gist_id}","starred_url":"https://api.github.com/users/aewhite/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/aewhite/subscriptions","organizations_url":"https://api.github.com/users/aewhite/orgs","repos_url":"https://api.github.com/users/aewhite/repos","events_url":"https://api.github.com/users/aewhite/events{/privacy}","received_events_url":"https://api.github.com/users/aewhite/received_events","type":"User","site_admin":false},"created_at":"2016-08-02T21:41:48Z","updated_at":"2016-08-02T21:43:28Z","author_association":"NONE","body":"The version difference were on index A, the source index. Ie, the delete-by-query would not delete those documents because I assume it detected version difference.\n\nReindex call:\n\n```\n    private ReindexRequestBuilder buildReindexRequest(final String container,\n                                                      final String type, final String fromIndex, final String toIndex) {\n        final ReindexRequestBuilder reindexRequestBuilder = ReindexAction.INSTANCE.newRequestBuilder(client.getRawClient())\n                                                                   .source(fromIndex)\n                                                                   .destination(toIndex)\n                                                                   .abortOnVersionConflict(false)\n                                                                   .filter(QueryBuilders.boolQuery()\n                                                                                        .must(QueryBuilders.termQuery(\"internal.container_id\", container))\n                                                                                        .must(QueryBuilders.typeQuery(type)));\n\n        reindexRequestBuilder.source().setSize(REINDEX_SCROLL_BATCH_SIZE);\n        reindexRequestBuilder.destination().setVersionType(VersionType.EXTERNAL);\n        reindexRequestBuilder.destination().setRouting(\"discard\");\n        return reindexRequestBuilder;\n    }\n```\n\nIndex call A (realtime updates):\n\n```\nfinal UpdateRequest updateRequest = new UpdateRequestBuilder(client, UpdateAction.INSTANCE)\n                .setType(\"post\")\n                .setIndex(createContainerWriteAliasName(containerId))\n                .setId(DOC_ID_GENERATOR.generateDocId(compositePostBuilder, containerId))\n                .setDoc(jsonBytes)\n                .setVersionType(VersionType.FORCE)\n                .setVersion(compositePostBuilder.getCanonicalConversation().getVersion())\n                .setDocAsUpsert(true)\n                .request();\n```\n\nIndex call B (batch updates):\n\n```\n        final IndexRequestBuilder indexRequestBuilder = transportClient.prepareIndex(writeAliasName, type)\n                                                                       .setId(postIndexRequest.getDocumentId())\n                                                                       .setVersionType(VersionType.EXTERNAL_GTE)\n                                                                       .setVersion(postIndexRequest.getVersion())\n                                                                       .setSource(postIndexRequest.getDocument().toByteArray());\n```\n\nThe use of force in the realtime system is by design since that data represents the latest and greatest version of a document. Batch processes will take a realtime document and attempt to enrich it which may give it a higher version number but we never want it to overwrite the latest realtime data. \n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/237055840","html_url":"https://github.com/elastic/elasticsearch/issues/19692#issuecomment-237055840","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19692","id":237055840,"node_id":"MDEyOklzc3VlQ29tbWVudDIzNzA1NTg0MA==","user":{"login":"nik9000","id":215970,"node_id":"MDQ6VXNlcjIxNTk3MA==","avatar_url":"https://avatars2.githubusercontent.com/u/215970?v=4","gravatar_id":"","url":"https://api.github.com/users/nik9000","html_url":"https://github.com/nik9000","followers_url":"https://api.github.com/users/nik9000/followers","following_url":"https://api.github.com/users/nik9000/following{/other_user}","gists_url":"https://api.github.com/users/nik9000/gists{/gist_id}","starred_url":"https://api.github.com/users/nik9000/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/nik9000/subscriptions","organizations_url":"https://api.github.com/users/nik9000/orgs","repos_url":"https://api.github.com/users/nik9000/repos","events_url":"https://api.github.com/users/nik9000/events{/privacy}","received_events_url":"https://api.github.com/users/nik9000/received_events","type":"User","site_admin":false},"created_at":"2016-08-02T21:47:33Z","updated_at":"2016-08-02T21:47:33Z","author_association":"CONTRIBUTOR","body":"`FORCE`....\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/237056361","html_url":"https://github.com/elastic/elasticsearch/issues/19692#issuecomment-237056361","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19692","id":237056361,"node_id":"MDEyOklzc3VlQ29tbWVudDIzNzA1NjM2MQ==","user":{"login":"nik9000","id":215970,"node_id":"MDQ6VXNlcjIxNTk3MA==","avatar_url":"https://avatars2.githubusercontent.com/u/215970?v=4","gravatar_id":"","url":"https://api.github.com/users/nik9000","html_url":"https://github.com/nik9000","followers_url":"https://api.github.com/users/nik9000/followers","following_url":"https://api.github.com/users/nik9000/following{/other_user}","gists_url":"https://api.github.com/users/nik9000/gists{/gist_id}","starred_url":"https://api.github.com/users/nik9000/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/nik9000/subscriptions","organizations_url":"https://api.github.com/users/nik9000/orgs","repos_url":"https://api.github.com/users/nik9000/repos","events_url":"https://api.github.com/users/nik9000/events{/privacy}","received_events_url":"https://api.github.com/users/nik9000/received_events","type":"User","site_admin":false},"created_at":"2016-08-02T21:49:37Z","updated_at":"2016-08-02T21:49:37Z","author_association":"CONTRIBUTOR","body":"The trouble with force is that it does this. If any of your updates arrive out of order then the `FORCE` will squash them.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/237057599","html_url":"https://github.com/elastic/elasticsearch/issues/19692#issuecomment-237057599","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19692","id":237057599,"node_id":"MDEyOklzc3VlQ29tbWVudDIzNzA1NzU5OQ==","user":{"login":"aewhite","id":4342706,"node_id":"MDQ6VXNlcjQzNDI3MDY=","avatar_url":"https://avatars1.githubusercontent.com/u/4342706?v=4","gravatar_id":"","url":"https://api.github.com/users/aewhite","html_url":"https://github.com/aewhite","followers_url":"https://api.github.com/users/aewhite/followers","following_url":"https://api.github.com/users/aewhite/following{/other_user}","gists_url":"https://api.github.com/users/aewhite/gists{/gist_id}","starred_url":"https://api.github.com/users/aewhite/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/aewhite/subscriptions","organizations_url":"https://api.github.com/users/aewhite/orgs","repos_url":"https://api.github.com/users/aewhite/repos","events_url":"https://api.github.com/users/aewhite/events{/privacy}","received_events_url":"https://api.github.com/users/aewhite/received_events","type":"User","site_admin":false},"created_at":"2016-08-02T21:54:26Z","updated_at":"2016-08-02T21:54:26Z","author_association":"NONE","body":"I want it to squish them... just consistently squish, not half squish. \n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/237060619","html_url":"https://github.com/elastic/elasticsearch/issues/19692#issuecomment-237060619","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19692","id":237060619,"node_id":"MDEyOklzc3VlQ29tbWVudDIzNzA2MDYxOQ==","user":{"login":"aewhite","id":4342706,"node_id":"MDQ6VXNlcjQzNDI3MDY=","avatar_url":"https://avatars1.githubusercontent.com/u/4342706?v=4","gravatar_id":"","url":"https://api.github.com/users/aewhite","html_url":"https://github.com/aewhite","followers_url":"https://api.github.com/users/aewhite/followers","following_url":"https://api.github.com/users/aewhite/following{/other_user}","gists_url":"https://api.github.com/users/aewhite/gists{/gist_id}","starred_url":"https://api.github.com/users/aewhite/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/aewhite/subscriptions","organizations_url":"https://api.github.com/users/aewhite/orgs","repos_url":"https://api.github.com/users/aewhite/repos","events_url":"https://api.github.com/users/aewhite/events{/privacy}","received_events_url":"https://api.github.com/users/aewhite/received_events","type":"User","site_admin":false},"created_at":"2016-08-02T22:06:34Z","updated_at":"2016-08-02T22:06:34Z","author_association":"NONE","body":"I want to also be 100% clear that when I issue the delete-by-query that there is NO data being indexed that would cause a conflict, by that point the alias has already been updated. The delete by query leaves the index in this weird inconsistent state after being ran (and it was probably in this state before delete-by-query was ever ran).\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/237061492","html_url":"https://github.com/elastic/elasticsearch/issues/19692#issuecomment-237061492","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19692","id":237061492,"node_id":"MDEyOklzc3VlQ29tbWVudDIzNzA2MTQ5Mg==","user":{"login":"nik9000","id":215970,"node_id":"MDQ6VXNlcjIxNTk3MA==","avatar_url":"https://avatars2.githubusercontent.com/u/215970?v=4","gravatar_id":"","url":"https://api.github.com/users/nik9000","html_url":"https://github.com/nik9000","followers_url":"https://api.github.com/users/nik9000/followers","following_url":"https://api.github.com/users/nik9000/following{/other_user}","gists_url":"https://api.github.com/users/nik9000/gists{/gist_id}","starred_url":"https://api.github.com/users/nik9000/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/nik9000/subscriptions","organizations_url":"https://api.github.com/users/nik9000/orgs","repos_url":"https://api.github.com/users/nik9000/repos","events_url":"https://api.github.com/users/nik9000/events{/privacy}","received_events_url":"https://api.github.com/users/nik9000/received_events","type":"User","site_admin":false},"created_at":"2016-08-02T22:10:05Z","updated_at":"2016-08-02T22:10:05Z","author_association":"CONTRIBUTOR","body":"> it was probably in this state before delete-by-query was ever ran)\n\nI'm fairly certain this is caused by `FORCE`.\n\nSay you have two requests to the same document at the same time, both with `FORCE`. The vast, vast majority of the time the first one will be executed first on the primary and then on the replicas and then the second one will be executed on the primary and then on the replicas. But, sometimes, just to make your life hard, executing that first request is delayed on the primary. Maybe there is a network burble, maybe there is some kind of recovery event. If that happens then the primary and replicas will be out of sync. And it'll look like what you described with the replicas having almost the same version but not quite. The javadocs actually [warn](https://github.com/elastic/elasticsearch/blob/2.4/core/src/main/java/org/elasticsearch/index/VersionType.java#L181) about it, but I think we should make it more prevalent.\n\nAs for your batch enrichment jobs.... hmm. I see why you have force, but it is causing trouble. I guess you could have the batch jobs only increment the version by 1, but that isn't all that reliable. `EXTERNAL_GTE` is also not really a good option because it has similar ordering issues.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/237062688","html_url":"https://github.com/elastic/elasticsearch/issues/19692#issuecomment-237062688","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19692","id":237062688,"node_id":"MDEyOklzc3VlQ29tbWVudDIzNzA2MjY4OA==","user":{"login":"aewhite","id":4342706,"node_id":"MDQ6VXNlcjQzNDI3MDY=","avatar_url":"https://avatars1.githubusercontent.com/u/4342706?v=4","gravatar_id":"","url":"https://api.github.com/users/aewhite","html_url":"https://github.com/aewhite","followers_url":"https://api.github.com/users/aewhite/followers","following_url":"https://api.github.com/users/aewhite/following{/other_user}","gists_url":"https://api.github.com/users/aewhite/gists{/gist_id}","starred_url":"https://api.github.com/users/aewhite/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/aewhite/subscriptions","organizations_url":"https://api.github.com/users/aewhite/orgs","repos_url":"https://api.github.com/users/aewhite/repos","events_url":"https://api.github.com/users/aewhite/events{/privacy}","received_events_url":"https://api.github.com/users/aewhite/received_events","type":"User","site_admin":false},"created_at":"2016-08-02T22:14:59Z","updated_at":"2016-08-02T22:14:59Z","author_association":"NONE","body":"So, I read that as \"you may lose newer version of a document\" and I am 100% ok with that. I did not read \"this may make your index inconsistent\" which is vastly different in my book. \n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/237165679","html_url":"https://github.com/elastic/elasticsearch/issues/19692#issuecomment-237165679","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19692","id":237165679,"node_id":"MDEyOklzc3VlQ29tbWVudDIzNzE2NTY3OQ==","user":{"login":"bleskes","id":1006375,"node_id":"MDQ6VXNlcjEwMDYzNzU=","avatar_url":"https://avatars1.githubusercontent.com/u/1006375?v=4","gravatar_id":"","url":"https://api.github.com/users/bleskes","html_url":"https://github.com/bleskes","followers_url":"https://api.github.com/users/bleskes/followers","following_url":"https://api.github.com/users/bleskes/following{/other_user}","gists_url":"https://api.github.com/users/bleskes/gists{/gist_id}","starred_url":"https://api.github.com/users/bleskes/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bleskes/subscriptions","organizations_url":"https://api.github.com/users/bleskes/orgs","repos_url":"https://api.github.com/users/bleskes/repos","events_url":"https://api.github.com/users/bleskes/events{/privacy}","received_events_url":"https://api.github.com/users/bleskes/received_events","type":"User","site_admin":false},"created_at":"2016-08-03T07:39:04Z","updated_at":"2016-08-03T07:39:04Z","author_association":"MEMBER","body":"@aewhite thank you very much for explaining the details. The way you use the versioning is not as intended (it assumes some external source of truth that is always correct and is always consistent). See [this blog post](https://www.elastic.co/blog/elasticsearch-versioning-support) for details.\n\nI totally agree that we didn't document the dangers of `FORCE` strongly enough.  I leave this issue open as the right \"fix\" is documentation.\n\nAlso in hindsight I think this just a too dangerous feature. I opened #19769 to discuss its removal.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/237216134","html_url":"https://github.com/elastic/elasticsearch/issues/19692#issuecomment-237216134","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19692","id":237216134,"node_id":"MDEyOklzc3VlQ29tbWVudDIzNzIxNjEzNA==","user":{"login":"aewhite","id":4342706,"node_id":"MDQ6VXNlcjQzNDI3MDY=","avatar_url":"https://avatars1.githubusercontent.com/u/4342706?v=4","gravatar_id":"","url":"https://api.github.com/users/aewhite","html_url":"https://github.com/aewhite","followers_url":"https://api.github.com/users/aewhite/followers","following_url":"https://api.github.com/users/aewhite/following{/other_user}","gists_url":"https://api.github.com/users/aewhite/gists{/gist_id}","starred_url":"https://api.github.com/users/aewhite/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/aewhite/subscriptions","organizations_url":"https://api.github.com/users/aewhite/orgs","repos_url":"https://api.github.com/users/aewhite/repos","events_url":"https://api.github.com/users/aewhite/events{/privacy}","received_events_url":"https://api.github.com/users/aewhite/received_events","type":"User","site_admin":false},"created_at":"2016-08-03T11:51:37Z","updated_at":"2016-08-03T11:51:37Z","author_association":"NONE","body":"I'm not sure I agree here. We do have an external source that is the source of truth and it is always consistent (HBase). That is exactly why we use FORCE. \n\nWhat's strange to me most consistent replication systems use a monotonically increasing 0-gap id system for transactions and replicas _must_ reply them in order or the whole system rolls back. If ES doesn't do this then even EXTERNAL_GTE isn't consistent since two updates with different versions could do non idempotent operations on a document.\n\nWithout FORCE, I'm not sure what our options will be for eventual consistency. \n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/237219554","html_url":"https://github.com/elastic/elasticsearch/issues/19692#issuecomment-237219554","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19692","id":237219554,"node_id":"MDEyOklzc3VlQ29tbWVudDIzNzIxOTU1NA==","user":{"login":"nik9000","id":215970,"node_id":"MDQ6VXNlcjIxNTk3MA==","avatar_url":"https://avatars2.githubusercontent.com/u/215970?v=4","gravatar_id":"","url":"https://api.github.com/users/nik9000","html_url":"https://github.com/nik9000","followers_url":"https://api.github.com/users/nik9000/followers","following_url":"https://api.github.com/users/nik9000/following{/other_user}","gists_url":"https://api.github.com/users/nik9000/gists{/gist_id}","starred_url":"https://api.github.com/users/nik9000/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/nik9000/subscriptions","organizations_url":"https://api.github.com/users/nik9000/orgs","repos_url":"https://api.github.com/users/nik9000/repos","events_url":"https://api.github.com/users/nik9000/events{/privacy}","received_events_url":"https://api.github.com/users/nik9000/received_events","type":"User","site_admin":false},"created_at":"2016-08-03T12:09:16Z","updated_at":"2016-08-03T12:09:16Z","author_association":"CONTRIBUTOR","body":"Es doesn't impose an ordering on the operations right now. You'll see\nsequence numbers mentioned on GitHub every once in a while and the intent\nis to have them do that sort of thing. For now the only ordering\nelasticsearch has is per document, specified by version type. Force and\nexternal_gte both have problems because they throw out the normal\nconstraints.\n\nOn Aug 3, 2016 7:57 AM, \"Andrew White\" notifications@github.com wrote:\n\n> I'm not sure I agree here. We do have an external source that is the\n> source of truth and it is always consistent (HBase). That is exactly why we\n> use FORCE.\n> \n> What's strange to me most consistent replication systems use a\n> monotonically increasing 0-gap id system for transactions and replicas\n> _must_ reply them in order or the whole system rolls back. If ES doesn't\n> do this then even EXTERNAL_GTE isn't consistent since two updates with\n> different versions could do non idempotent operations on a document.\n> \n> Without FORCE, I'm not sure what our options will be for eventual\n> consistency.\n> \n> —\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> https://github.com/elastic/elasticsearch/issues/19692#issuecomment-237216134,\n> or mute the thread\n> https://github.com/notifications/unsubscribe-auth/AANLogiwufGOoAWDs0EWG-GFlmWspOjtks5qcIDOgaJpZM4JYhYF\n> .\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/237223763","html_url":"https://github.com/elastic/elasticsearch/issues/19692#issuecomment-237223763","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19692","id":237223763,"node_id":"MDEyOklzc3VlQ29tbWVudDIzNzIyMzc2Mw==","user":{"login":"bleskes","id":1006375,"node_id":"MDQ6VXNlcjEwMDYzNzU=","avatar_url":"https://avatars1.githubusercontent.com/u/1006375?v=4","gravatar_id":"","url":"https://api.github.com/users/bleskes","html_url":"https://github.com/bleskes","followers_url":"https://api.github.com/users/bleskes/followers","following_url":"https://api.github.com/users/bleskes/following{/other_user}","gists_url":"https://api.github.com/users/bleskes/gists{/gist_id}","starred_url":"https://api.github.com/users/bleskes/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bleskes/subscriptions","organizations_url":"https://api.github.com/users/bleskes/orgs","repos_url":"https://api.github.com/users/bleskes/repos","events_url":"https://api.github.com/users/bleskes/events{/privacy}","received_events_url":"https://api.github.com/users/bleskes/received_events","type":"User","site_admin":false},"created_at":"2016-08-03T12:30:41Z","updated_at":"2016-08-03T12:30:41Z","author_association":"MEMBER","body":"This all comes from the fact that ES uses versions to support out of order and concurrent indexing operations on the replicas. `FORCE` breaks those violations which is why it leaves your replicas in an inconsistent state and that's exactly why it's a super expert settings (which I think in hindsight should be removed - and I added it :)  ) \n\n`EXTERNAL_GTE` is only to be used for deletes where the external version doesn't see delete as an operation and increments it's version. If all other writes use external, it is safe to use (a concurrent write with a lower or equal version should be deleted, a newer write with a higher version will not be overwritten).\n\n> I'm not sure I agree here. We do have an external source that is the source of truth and it is always consistent (HBase). That is exactly why we use FORCE.\n\nIn that case you should not use updates but rather do complete indexing with your version set to `EXTERNAL` all the time.  If your deletes are versioned as well (I do hope they are :)) , you should use `EXTERNAL` there as well. I don't see the need for a `FORCE` in this case?\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/237289985","html_url":"https://github.com/elastic/elasticsearch/issues/19692#issuecomment-237289985","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19692","id":237289985,"node_id":"MDEyOklzc3VlQ29tbWVudDIzNzI4OTk4NQ==","user":{"login":"aewhite","id":4342706,"node_id":"MDQ6VXNlcjQzNDI3MDY=","avatar_url":"https://avatars1.githubusercontent.com/u/4342706?v=4","gravatar_id":"","url":"https://api.github.com/users/aewhite","html_url":"https://github.com/aewhite","followers_url":"https://api.github.com/users/aewhite/followers","following_url":"https://api.github.com/users/aewhite/following{/other_user}","gists_url":"https://api.github.com/users/aewhite/gists{/gist_id}","starred_url":"https://api.github.com/users/aewhite/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/aewhite/subscriptions","organizations_url":"https://api.github.com/users/aewhite/orgs","repos_url":"https://api.github.com/users/aewhite/repos","events_url":"https://api.github.com/users/aewhite/events{/privacy}","received_events_url":"https://api.github.com/users/aewhite/received_events","type":"User","site_admin":false},"created_at":"2016-08-03T16:29:33Z","updated_at":"2016-08-03T16:29:33Z","author_association":"NONE","body":"The reason for `FORCE` is because we have the following work flow:\n\n```\nexternal source -> collection -> ES <-----------\n                              -> HBase -> batch | \n\n```\n\nBatch can transform the document and thus give it a more up-to-date (ie larger) version. When we get an updated version of the document for collection we want to force any data in this document to override existing data (that is what I thought `FORCE` did). The kicker here is that the document coming from collection may have a lower version than the batch generated version and unless we precede all inserts with deletes, those new documents will not be indexed due to version conflicts. \n\nOur backend system takes all versions and changes to a document into consideration so it is eventually consistent, but it's also lagging behind realtime with the latest and greatest info. The reason for the update vs a fresh index is because realtime updates are usually small and don't invalidate enrichments. Blowing away expensive enrichments just because we have a newer source document would be a very bad user experience for us. \n\nThe versioning system we settled on was carefully designed to be eventually consistent while allowing realtime updates to volatile fields. However, this design was built on the assumption that ES had strict ordering of CRUD operations between primaries and replicas. \n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/237690909","html_url":"https://github.com/elastic/elasticsearch/issues/19692#issuecomment-237690909","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19692","id":237690909,"node_id":"MDEyOklzc3VlQ29tbWVudDIzNzY5MDkwOQ==","user":{"login":"bleskes","id":1006375,"node_id":"MDQ6VXNlcjEwMDYzNzU=","avatar_url":"https://avatars1.githubusercontent.com/u/1006375?v=4","gravatar_id":"","url":"https://api.github.com/users/bleskes","html_url":"https://github.com/bleskes","followers_url":"https://api.github.com/users/bleskes/followers","following_url":"https://api.github.com/users/bleskes/following{/other_user}","gists_url":"https://api.github.com/users/bleskes/gists{/gist_id}","starred_url":"https://api.github.com/users/bleskes/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bleskes/subscriptions","organizations_url":"https://api.github.com/users/bleskes/orgs","repos_url":"https://api.github.com/users/bleskes/repos","events_url":"https://api.github.com/users/bleskes/events{/privacy}","received_events_url":"https://api.github.com/users/bleskes/received_events","type":"User","site_admin":false},"created_at":"2016-08-04T21:35:27Z","updated_at":"2016-08-05T18:40:17Z","author_association":"MEMBER","body":"I'm very sorry to hear you have built a system based on the premise that `FORCE` works differently. Sadly what it does is to disable the built-in version support and allows you to dictate both on the primay and replica (when the request arrives there) what the version should be - no constraints what so ever. This is of course why it's dangerous and don't support concurrency. \n\nThe only versioning-based solution that will work for your case is `EXTERNAL` which is designed to keep ES in sync with an external system that resolves all conflicts and serves as the source of truth (see the blog post I mentioned). Now for you, this doesn't work as your external system takes too long to resolve.\n\nWhat you can consider is using update scripts for all indexing where you manually decide which fields to keep and which to throw away based on your custom business logic. It does come with an obvious (potentially acceptable!)  overhead. \n\nI don't see any other option right now, with the current feature set in ES.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/237698883","html_url":"https://github.com/elastic/elasticsearch/issues/19692#issuecomment-237698883","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19692","id":237698883,"node_id":"MDEyOklzc3VlQ29tbWVudDIzNzY5ODg4Mw==","user":{"login":"aewhite","id":4342706,"node_id":"MDQ6VXNlcjQzNDI3MDY=","avatar_url":"https://avatars1.githubusercontent.com/u/4342706?v=4","gravatar_id":"","url":"https://api.github.com/users/aewhite","html_url":"https://github.com/aewhite","followers_url":"https://api.github.com/users/aewhite/followers","following_url":"https://api.github.com/users/aewhite/following{/other_user}","gists_url":"https://api.github.com/users/aewhite/gists{/gist_id}","starred_url":"https://api.github.com/users/aewhite/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/aewhite/subscriptions","organizations_url":"https://api.github.com/users/aewhite/orgs","repos_url":"https://api.github.com/users/aewhite/repos","events_url":"https://api.github.com/users/aewhite/events{/privacy}","received_events_url":"https://api.github.com/users/aewhite/received_events","type":"User","site_admin":false},"created_at":"2016-08-04T22:10:31Z","updated_at":"2016-08-04T22:10:31Z","author_association":"NONE","body":"Thanks, we are currently researching alternative versioning/update strategies and/or code changes to introduce strict ordering of replicated operations in the ES code base. \n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/239144564","html_url":"https://github.com/elastic/elasticsearch/issues/19692#issuecomment-239144564","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19692","id":239144564,"node_id":"MDEyOklzc3VlQ29tbWVudDIzOTE0NDU2NA==","user":{"login":"clintongormley","id":56599,"node_id":"MDQ6VXNlcjU2NTk5","avatar_url":"https://avatars0.githubusercontent.com/u/56599?v=4","gravatar_id":"","url":"https://api.github.com/users/clintongormley","html_url":"https://github.com/clintongormley","followers_url":"https://api.github.com/users/clintongormley/followers","following_url":"https://api.github.com/users/clintongormley/following{/other_user}","gists_url":"https://api.github.com/users/clintongormley/gists{/gist_id}","starred_url":"https://api.github.com/users/clintongormley/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/clintongormley/subscriptions","organizations_url":"https://api.github.com/users/clintongormley/orgs","repos_url":"https://api.github.com/users/clintongormley/repos","events_url":"https://api.github.com/users/clintongormley/events{/privacy}","received_events_url":"https://api.github.com/users/clintongormley/received_events","type":"User","site_admin":false},"created_at":"2016-08-11T12:17:14Z","updated_at":"2016-08-11T12:17:14Z","author_association":"CONTRIBUTOR","body":"Closing in favour of #19769\n","performed_via_github_app":null}]