[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/66458189","html_url":"https://github.com/elastic/elasticsearch/issues/8870#issuecomment-66458189","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/8870","id":66458189,"node_id":"MDEyOklzc3VlQ29tbWVudDY2NDU4MTg5","user":{"login":"OlegYch","id":268312,"node_id":"MDQ6VXNlcjI2ODMxMg==","avatar_url":"https://avatars1.githubusercontent.com/u/268312?v=4","gravatar_id":"","url":"https://api.github.com/users/OlegYch","html_url":"https://github.com/OlegYch","followers_url":"https://api.github.com/users/OlegYch/followers","following_url":"https://api.github.com/users/OlegYch/following{/other_user}","gists_url":"https://api.github.com/users/OlegYch/gists{/gist_id}","starred_url":"https://api.github.com/users/OlegYch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/OlegYch/subscriptions","organizations_url":"https://api.github.com/users/OlegYch/orgs","repos_url":"https://api.github.com/users/OlegYch/repos","events_url":"https://api.github.com/users/OlegYch/events{/privacy}","received_events_url":"https://api.github.com/users/OlegYch/received_events","type":"User","site_admin":false},"created_at":"2014-12-10T14:25:47Z","updated_at":"2014-12-10T14:25:47Z","author_association":"NONE","body":"what about fields with different path (but same name) and different mapping in one type?\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/66458573","html_url":"https://github.com/elastic/elasticsearch/issues/8870#issuecomment-66458573","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/8870","id":66458573,"node_id":"MDEyOklzc3VlQ29tbWVudDY2NDU4NTcz","user":{"login":"clintongormley","id":56599,"node_id":"MDQ6VXNlcjU2NTk5","avatar_url":"https://avatars0.githubusercontent.com/u/56599?v=4","gravatar_id":"","url":"https://api.github.com/users/clintongormley","html_url":"https://github.com/clintongormley","followers_url":"https://api.github.com/users/clintongormley/followers","following_url":"https://api.github.com/users/clintongormley/following{/other_user}","gists_url":"https://api.github.com/users/clintongormley/gists{/gist_id}","starred_url":"https://api.github.com/users/clintongormley/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/clintongormley/subscriptions","organizations_url":"https://api.github.com/users/clintongormley/orgs","repos_url":"https://api.github.com/users/clintongormley/repos","events_url":"https://api.github.com/users/clintongormley/events{/privacy}","received_events_url":"https://api.github.com/users/clintongormley/received_events","type":"User","site_admin":false},"created_at":"2014-12-10T14:28:41Z","updated_at":"2014-12-10T14:28:41Z","author_association":"CONTRIBUTOR","body":"@OlegYch Since we will no longer support short names, only the full path is used to identify a field, so it is only the path that matters.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/66461353","html_url":"https://github.com/elastic/elasticsearch/issues/8870#issuecomment-66461353","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/8870","id":66461353,"node_id":"MDEyOklzc3VlQ29tbWVudDY2NDYxMzUz","user":{"login":"OlegYch","id":268312,"node_id":"MDQ6VXNlcjI2ODMxMg==","avatar_url":"https://avatars1.githubusercontent.com/u/268312?v=4","gravatar_id":"","url":"https://api.github.com/users/OlegYch","html_url":"https://github.com/OlegYch","followers_url":"https://api.github.com/users/OlegYch/followers","following_url":"https://api.github.com/users/OlegYch/following{/other_user}","gists_url":"https://api.github.com/users/OlegYch/gists{/gist_id}","starred_url":"https://api.github.com/users/OlegYch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/OlegYch/subscriptions","organizations_url":"https://api.github.com/users/OlegYch/orgs","repos_url":"https://api.github.com/users/OlegYch/repos","events_url":"https://api.github.com/users/OlegYch/events{/privacy}","received_events_url":"https://api.github.com/users/OlegYch/received_events","type":"User","site_admin":false},"created_at":"2014-12-10T14:47:16Z","updated_at":"2014-12-10T14:47:16Z","author_association":"NONE","body":"we are using 'mapping types' precisely to store different kinds of documents in the same index (so that we can use parent/child queries)\nso far prefixing field path with _type worked fine for us\nthis change would mean that we would lose ability to use parent/child queries if there happens to be a conflict, as they would have to be in different indexes\nthe conflicts will probably be rare, and we could probably change documents schema if they arise, but a better way to prevent or diagnose the conflicts than an exception on put would be nice\ni'm also wondering if there is no way to somehow append field type to its name internally (like one would do to resolve conflicts manually)?\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/66465295","html_url":"https://github.com/elastic/elasticsearch/issues/8870#issuecomment-66465295","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/8870","id":66465295,"node_id":"MDEyOklzc3VlQ29tbWVudDY2NDY1Mjk1","user":{"login":"clintongormley","id":56599,"node_id":"MDQ6VXNlcjU2NTk5","avatar_url":"https://avatars0.githubusercontent.com/u/56599?v=4","gravatar_id":"","url":"https://api.github.com/users/clintongormley","html_url":"https://github.com/clintongormley","followers_url":"https://api.github.com/users/clintongormley/followers","following_url":"https://api.github.com/users/clintongormley/following{/other_user}","gists_url":"https://api.github.com/users/clintongormley/gists{/gist_id}","starred_url":"https://api.github.com/users/clintongormley/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/clintongormley/subscriptions","organizations_url":"https://api.github.com/users/clintongormley/orgs","repos_url":"https://api.github.com/users/clintongormley/repos","events_url":"https://api.github.com/users/clintongormley/events{/privacy}","received_events_url":"https://api.github.com/users/clintongormley/received_events","type":"User","site_admin":false},"created_at":"2014-12-10T15:12:07Z","updated_at":"2014-12-10T15:12:07Z","author_association":"CONTRIBUTOR","body":"> the conflicts will probably be rare, and we could probably change documents schema if they arise, but a better way to prevent or diagnose the conflicts than an exception on put would be nice\n> i'm also wondering if there is no way to somehow append field type to its name internally (like one would do to resolve conflicts manually)?\n\nAs you said, conflicts are rare (for most people).  Normally a field with the same name refers to the same type of data.  The alternative (eg prefixing the field name with the type) would create much more sparsity in the index, and would impact every cross-type query (as multiple fields would need to be queried).  Right now, we have opted for making the common case correct and efficient.  However, we have left the APIs as they are in case, sometime in the future, we manage to figure out a cleverer way of handling conflicting field definitions.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/68257922","html_url":"https://github.com/elastic/elasticsearch/issues/8870#issuecomment-68257922","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/8870","id":68257922,"node_id":"MDEyOklzc3VlQ29tbWVudDY4MjU3OTIy","user":{"login":"rore","id":571498,"node_id":"MDQ6VXNlcjU3MTQ5OA==","avatar_url":"https://avatars2.githubusercontent.com/u/571498?v=4","gravatar_id":"","url":"https://api.github.com/users/rore","html_url":"https://github.com/rore","followers_url":"https://api.github.com/users/rore/followers","following_url":"https://api.github.com/users/rore/following{/other_user}","gists_url":"https://api.github.com/users/rore/gists{/gist_id}","starred_url":"https://api.github.com/users/rore/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/rore/subscriptions","organizations_url":"https://api.github.com/users/rore/orgs","repos_url":"https://api.github.com/users/rore/repos","events_url":"https://api.github.com/users/rore/events{/privacy}","received_events_url":"https://api.github.com/users/rore/received_events","type":"User","site_admin":false},"created_at":"2014-12-29T13:40:01Z","updated_at":"2014-12-29T13:40:01Z","author_association":"NONE","body":"For the record, I want to raise here again our objection to the way this change is planned. \n\nWe have several use cases in which we have an index with custom types that have custom fields. Types are not pre-defined and fields are not pre-defined. There's high potential of fields with the same name under different types, including fields with the same name that have different field type (and it happens). We have a lot of this kind of data. \n\nThis modeling was aligned with the way Types where presented by Elasticsearch (and still are - in our last meetup Types where referred to by Boaz as equivalent to \"tables\").\n\nSo with this change we will be enforced to either hard-code the type as a prefix for all fields ourselves, or encapsulate all documents with a root \"type\" node. It can be done but is ugly, requires patchy handling and also reindexing all data. \n\nA better option that will allow such use cases is having a setting on the index level to configure field type isolation. So if we know that we need field type isolation (and we don't have cross-type searches and are willing to pay the overhead), we can set it to \"type\" level, and internally fields will be prefixed by the type.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/68259068","html_url":"https://github.com/elastic/elasticsearch/issues/8870#issuecomment-68259068","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/8870","id":68259068,"node_id":"MDEyOklzc3VlQ29tbWVudDY4MjU5MDY4","user":{"login":"clintongormley","id":56599,"node_id":"MDQ6VXNlcjU2NTk5","avatar_url":"https://avatars0.githubusercontent.com/u/56599?v=4","gravatar_id":"","url":"https://api.github.com/users/clintongormley","html_url":"https://github.com/clintongormley","followers_url":"https://api.github.com/users/clintongormley/followers","following_url":"https://api.github.com/users/clintongormley/following{/other_user}","gists_url":"https://api.github.com/users/clintongormley/gists{/gist_id}","starred_url":"https://api.github.com/users/clintongormley/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/clintongormley/subscriptions","organizations_url":"https://api.github.com/users/clintongormley/orgs","repos_url":"https://api.github.com/users/clintongormley/repos","events_url":"https://api.github.com/users/clintongormley/events{/privacy}","received_events_url":"https://api.github.com/users/clintongormley/received_events","type":"User","site_admin":false},"created_at":"2014-12-29T13:57:21Z","updated_at":"2014-12-29T13:57:21Z","author_association":"CONTRIBUTOR","body":"Hi @rore \n\n> There's high potential of fields with the same name under different types, including fields with the same name that have different field type (and it happens). We have a lot of this kind of data.\n\nIf you have this, then your data is essentially broken today, and you can end up with incorrect results, exceptions, or even corrupt indices.  \n\nThe first thing that we're trying to do is to make everything safe and predictable.   We are leaving the mapping APIs as they are so that, in the future, we may be able to revisit this decision and provide more alternatives.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/83198774","html_url":"https://github.com/elastic/elasticsearch/issues/8870#issuecomment-83198774","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/8870","id":83198774,"node_id":"MDEyOklzc3VlQ29tbWVudDgzMTk4Nzc0","user":{"login":"shivangshah","id":2624839,"node_id":"MDQ6VXNlcjI2MjQ4Mzk=","avatar_url":"https://avatars1.githubusercontent.com/u/2624839?v=4","gravatar_id":"","url":"https://api.github.com/users/shivangshah","html_url":"https://github.com/shivangshah","followers_url":"https://api.github.com/users/shivangshah/followers","following_url":"https://api.github.com/users/shivangshah/following{/other_user}","gists_url":"https://api.github.com/users/shivangshah/gists{/gist_id}","starred_url":"https://api.github.com/users/shivangshah/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/shivangshah/subscriptions","organizations_url":"https://api.github.com/users/shivangshah/orgs","repos_url":"https://api.github.com/users/shivangshah/repos","events_url":"https://api.github.com/users/shivangshah/events{/privacy}","received_events_url":"https://api.github.com/users/shivangshah/received_events","type":"User","site_admin":false},"created_at":"2015-03-18T21:57:00Z","updated_at":"2015-03-18T21:57:00Z","author_association":"NONE","body":"Going on the record here, we have the exact same usecase as @rore mentioned above. The details of the usecase can be found here as well : http://stackoverflow.com/questions/29041509/field-names-with-the-same-name-across-types-having-different-index-type-in-elast/29053553#29053553\n\nTL;DR: Our types and fields per each type are not regulated at the Application level. Customers can create new types and corresponding new fields dynamically (or remove them) and we can't control it. \n\nThe ideal scenario here will be: while indexing a document ES already asks for the type, so during indexing atleast there shouldn't be any problem and ES should handle indexing the fields per type. However during searching, if a type is not provided but only the field name, it should pickup the default mapping for that index (maybe that will be another feature) and thats the type it will use to search. \n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/83202751","html_url":"https://github.com/elastic/elasticsearch/issues/8870#issuecomment-83202751","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/8870","id":83202751,"node_id":"MDEyOklzc3VlQ29tbWVudDgzMjAyNzUx","user":{"login":"shivangshah","id":2624839,"node_id":"MDQ6VXNlcjI2MjQ4Mzk=","avatar_url":"https://avatars1.githubusercontent.com/u/2624839?v=4","gravatar_id":"","url":"https://api.github.com/users/shivangshah","html_url":"https://github.com/shivangshah","followers_url":"https://api.github.com/users/shivangshah/followers","following_url":"https://api.github.com/users/shivangshah/following{/other_user}","gists_url":"https://api.github.com/users/shivangshah/gists{/gist_id}","starred_url":"https://api.github.com/users/shivangshah/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/shivangshah/subscriptions","organizations_url":"https://api.github.com/users/shivangshah/orgs","repos_url":"https://api.github.com/users/shivangshah/repos","events_url":"https://api.github.com/users/shivangshah/events{/privacy}","received_events_url":"https://api.github.com/users/shivangshah/received_events","type":"User","site_admin":false},"created_at":"2015-03-18T22:04:36Z","updated_at":"2015-03-18T22:04:36Z","author_association":"NONE","body":"Also, we CANNOT have an index per type because you have no idea how many types are going to get create per customer (and ofcouse you can have thousands of customers). So now, in that case, in one index you can have multiple \"types\". Now lets say a type is \"customer\" and another type is \"Company\". They both can easily have a field name called \"random\" which can be of different core types. Moving the types to \"index\" level essentially makes ALL the field names and their core types unique to the index. This essentially makes each index specific to each type (in the fear of not conflicting the field names especially when you don't know what customers are going to create) which means that number of indexes almost equal to number of types. If a customer has 40 types and you have 1000 customers, that's 40K index. Almost impossible to maintain.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/83217507","html_url":"https://github.com/elastic/elasticsearch/issues/8870#issuecomment-83217507","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/8870","id":83217507,"node_id":"MDEyOklzc3VlQ29tbWVudDgzMjE3NTA3","user":{"login":"kaidad","id":4431581,"node_id":"MDQ6VXNlcjQ0MzE1ODE=","avatar_url":"https://avatars2.githubusercontent.com/u/4431581?v=4","gravatar_id":"","url":"https://api.github.com/users/kaidad","html_url":"https://github.com/kaidad","followers_url":"https://api.github.com/users/kaidad/followers","following_url":"https://api.github.com/users/kaidad/following{/other_user}","gists_url":"https://api.github.com/users/kaidad/gists{/gist_id}","starred_url":"https://api.github.com/users/kaidad/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/kaidad/subscriptions","organizations_url":"https://api.github.com/users/kaidad/orgs","repos_url":"https://api.github.com/users/kaidad/repos","events_url":"https://api.github.com/users/kaidad/events{/privacy}","received_events_url":"https://api.github.com/users/kaidad/received_events","type":"User","site_admin":false},"created_at":"2015-03-18T22:54:25Z","updated_at":"2015-03-18T22:54:25Z","author_association":"NONE","body":"We are in the exact same position as @shivangshah and @rore. It really feels like the abstraction around doctype is completely broken if it doesn't provide isolation at the mapping level.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/83225837","html_url":"https://github.com/elastic/elasticsearch/issues/8870#issuecomment-83225837","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/8870","id":83225837,"node_id":"MDEyOklzc3VlQ29tbWVudDgzMjI1ODM3","user":{"login":"AshwinJay","id":222056,"node_id":"MDQ6VXNlcjIyMjA1Ng==","avatar_url":"https://avatars2.githubusercontent.com/u/222056?v=4","gravatar_id":"","url":"https://api.github.com/users/AshwinJay","html_url":"https://github.com/AshwinJay","followers_url":"https://api.github.com/users/AshwinJay/followers","following_url":"https://api.github.com/users/AshwinJay/following{/other_user}","gists_url":"https://api.github.com/users/AshwinJay/gists{/gist_id}","starred_url":"https://api.github.com/users/AshwinJay/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/AshwinJay/subscriptions","organizations_url":"https://api.github.com/users/AshwinJay/orgs","repos_url":"https://api.github.com/users/AshwinJay/repos","events_url":"https://api.github.com/users/AshwinJay/events{/privacy}","received_events_url":"https://api.github.com/users/AshwinJay/received_events","type":"User","site_admin":false},"created_at":"2015-03-18T23:42:35Z","updated_at":"2015-03-18T23:42:35Z","author_association":"NONE","body":"It came as a shock to us to see that this seemingly basic feature is broken. This is the equivalent of saying that the 2 SQL statements in an RDBMS are not valid because the data type of `time` conflicts with another table:\n\n`CREATE TABLE employee_timesheet ( time datetime, ... );`\n\n`CREATE TABLE stop_watch ( time int, ... );`\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/93698358","html_url":"https://github.com/elastic/elasticsearch/issues/8870#issuecomment-93698358","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/8870","id":93698358,"node_id":"MDEyOklzc3VlQ29tbWVudDkzNjk4MzU4","user":{"login":"gondar","id":252896,"node_id":"MDQ6VXNlcjI1Mjg5Ng==","avatar_url":"https://avatars3.githubusercontent.com/u/252896?v=4","gravatar_id":"","url":"https://api.github.com/users/gondar","html_url":"https://github.com/gondar","followers_url":"https://api.github.com/users/gondar/followers","following_url":"https://api.github.com/users/gondar/following{/other_user}","gists_url":"https://api.github.com/users/gondar/gists{/gist_id}","starred_url":"https://api.github.com/users/gondar/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/gondar/subscriptions","organizations_url":"https://api.github.com/users/gondar/orgs","repos_url":"https://api.github.com/users/gondar/repos","events_url":"https://api.github.com/users/gondar/events{/privacy}","received_events_url":"https://api.github.com/users/gondar/received_events","type":"User","site_admin":false},"created_at":"2015-04-16T10:05:18Z","updated_at":"2015-04-16T10:05:18Z","author_association":"NONE","body":"@clintongormley The way you describe it seems that default data model for logstash is broken then. In logstash multiple differing logs types are all placed in the same index (per day). If you enforce that all the same names need to have the same type you are effectively enforcing the same schema for all different logs from different sources.\n\n@jordansissel any comments on that?\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/93700294","html_url":"https://github.com/elastic/elasticsearch/issues/8870#issuecomment-93700294","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/8870","id":93700294,"node_id":"MDEyOklzc3VlQ29tbWVudDkzNzAwMjk0","user":{"login":"rore","id":571498,"node_id":"MDQ6VXNlcjU3MTQ5OA==","avatar_url":"https://avatars2.githubusercontent.com/u/571498?v=4","gravatar_id":"","url":"https://api.github.com/users/rore","html_url":"https://github.com/rore","followers_url":"https://api.github.com/users/rore/followers","following_url":"https://api.github.com/users/rore/following{/other_user}","gists_url":"https://api.github.com/users/rore/gists{/gist_id}","starred_url":"https://api.github.com/users/rore/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/rore/subscriptions","organizations_url":"https://api.github.com/users/rore/orgs","repos_url":"https://api.github.com/users/rore/repos","events_url":"https://api.github.com/users/rore/events{/privacy}","received_events_url":"https://api.github.com/users/rore/received_events","type":"User","site_admin":false},"created_at":"2015-04-16T10:15:22Z","updated_at":"2015-04-16T10:15:22Z","author_association":"NONE","body":"@gondar Awesome point. \n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/93801719","html_url":"https://github.com/elastic/elasticsearch/issues/8870#issuecomment-93801719","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/8870","id":93801719,"node_id":"MDEyOklzc3VlQ29tbWVudDkzODAxNzE5","user":{"login":"polyfractal","id":1224228,"node_id":"MDQ6VXNlcjEyMjQyMjg=","avatar_url":"https://avatars1.githubusercontent.com/u/1224228?v=4","gravatar_id":"","url":"https://api.github.com/users/polyfractal","html_url":"https://github.com/polyfractal","followers_url":"https://api.github.com/users/polyfractal/followers","following_url":"https://api.github.com/users/polyfractal/following{/other_user}","gists_url":"https://api.github.com/users/polyfractal/gists{/gist_id}","starred_url":"https://api.github.com/users/polyfractal/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/polyfractal/subscriptions","organizations_url":"https://api.github.com/users/polyfractal/orgs","repos_url":"https://api.github.com/users/polyfractal/repos","events_url":"https://api.github.com/users/polyfractal/events{/privacy}","received_events_url":"https://api.github.com/users/polyfractal/received_events","type":"User","site_admin":false},"created_at":"2015-04-16T17:54:12Z","updated_at":"2015-04-16T17:54:12Z","author_association":"MEMBER","body":"> This is the equivalent of saying that the 2 SQL statements in an RDBMS are not valid because the data type of time conflicts with another table\n\n@AshwinJay This is not actually equivalent, since RDBMS tables do not share schemas.  You hear people relating tables to Elasticsearch types, because conceptually they are similar.  But schematically, tables are closer to Elasticsearch indices.  \n\nThere isn't really a good SQL example for Elasticsearch types.  The equivalent is closer to creating two columns with the same name but different types inside a single table ... which RDBMS won't allow either.  Elasticsearch has allowed it, but the behavior is trappy and dangerous at times.\n\n> However during searching, if a type is not provided but only the field name, it should pickup the default mapping for that index (maybe that will be another feature) and thats the type it will use to search.\n\nThis is where the trappy behavior comes into play (it's also the current behavior).  There are two broad categories, aggregations and search.\n- Aggregations have their own \"un-inversion\" logic which will take a field's inverted index and hydrate it into memory.  To be efficient (computationally and memory), this process needs all data to be of the same type.  E.g. numerics use delta compression and variable integer blocks, while strings use ordinals maps.  You simply can't put two different data types into the same data structure.  Presently field data will just explode if you try... you can see many of the isues referencing this ticket deal with this very issue.  But there is no good way to fix this.  You'd have to hold separate data structures for different types, but that introduces gaps which ruins how the data structures work\n- For search, queries are built based on the field's mappings.  So if you have a field mapped as a `long` and query it with a Range, that decomposes to a `NumericRangeQuery` which is then used to search across all the docs.  Now imagine that `NumericRangeQuery` encounters a string field during the process ... the options are to either ignore that field or just explode.  Neither are good choices, althoug omitting it is the \"better\" of the two (and current behavior).  There is really no efficient way to \"do the right thing\" when there are multiple data types in a single field.\n\nI think it's important to note that this isn't just trappy at search time, it can also break things at index time:\n- Doc values use different compression schemes for different data types as well, and Lucene enforces a single type-per-field for doc values so it can use a single compression scheme.\n- If norms are disabled on one field, Lucene will disable it for the other same-named fields.\n- Lucene enforces the \"lowest-common-denominator\" index options between two different fields, and will downgrade as necessary.  So things like frequencies (scoring), positions (phrase queries) and offsets (postings highlighter) might be disabled depending on the conflict.\n\nPlease keep in mind that these changes aren't because we dislike the functionality, but because the functionality can be unsafe (and surprising in many cases).\n\n> They both can easily have a field name called \"random\" which can be of different core types.\n\nI think the easy solution is to just prefix custom fields from a customer with some unique customer ID prefix?  This is essentially the \"fix\" if Elasticsearch were to do it internally, except the \"fix\" makes the general-case much worse for most users.\n\n>  If you enforce that all the same names need to have the same type you are effectively enforcing the same schema for all different logs from different sources.\n\n@gondar I'm curious, how often do you have the same name but different types in log message extractions?  E.g. how often is `message` a string in one log, but a float in another?  I would have guessed that your Logstash pipeline would have normalized the values into a structured format that is consistent (even if coming from disparate sources)?\n\nI don't have a ton of operational log experience myself, so this question is 100% curiosity :)\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/94025625","html_url":"https://github.com/elastic/elasticsearch/issues/8870#issuecomment-94025625","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/8870","id":94025625,"node_id":"MDEyOklzc3VlQ29tbWVudDk0MDI1NjI1","user":{"login":"shivangshah","id":2624839,"node_id":"MDQ6VXNlcjI2MjQ4Mzk=","avatar_url":"https://avatars1.githubusercontent.com/u/2624839?v=4","gravatar_id":"","url":"https://api.github.com/users/shivangshah","html_url":"https://github.com/shivangshah","followers_url":"https://api.github.com/users/shivangshah/followers","following_url":"https://api.github.com/users/shivangshah/following{/other_user}","gists_url":"https://api.github.com/users/shivangshah/gists{/gist_id}","starred_url":"https://api.github.com/users/shivangshah/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/shivangshah/subscriptions","organizations_url":"https://api.github.com/users/shivangshah/orgs","repos_url":"https://api.github.com/users/shivangshah/repos","events_url":"https://api.github.com/users/shivangshah/events{/privacy}","received_events_url":"https://api.github.com/users/shivangshah/received_events","type":"User","site_admin":false},"created_at":"2015-04-17T16:50:11Z","updated_at":"2015-04-17T16:50:11Z","author_association":"NONE","body":"@polyfractal Out of curiosity, I am really interested in knowing what are your thoughts on the usage of \"type\" in elasticsearch now because essentially, per index, build blocks are pretty much fields and other than grouping them in \"types\" there is no usecase (atleast none that I can think of). Also, if that's going to be case, what's the purpose of providing a type during indexing a document anymore when literally NOTHING is dependent on type other than maybe faster queries based on type filters (which can easily be achieved by just having a type field in your document itself rather than having ES take care of it and worry about all the things discussed above)\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/94059301","html_url":"https://github.com/elastic/elasticsearch/issues/8870#issuecomment-94059301","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/8870","id":94059301,"node_id":"MDEyOklzc3VlQ29tbWVudDk0MDU5MzAx","user":{"login":"rjernst","id":289412,"node_id":"MDQ6VXNlcjI4OTQxMg==","avatar_url":"https://avatars3.githubusercontent.com/u/289412?v=4","gravatar_id":"","url":"https://api.github.com/users/rjernst","html_url":"https://github.com/rjernst","followers_url":"https://api.github.com/users/rjernst/followers","following_url":"https://api.github.com/users/rjernst/following{/other_user}","gists_url":"https://api.github.com/users/rjernst/gists{/gist_id}","starred_url":"https://api.github.com/users/rjernst/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/rjernst/subscriptions","organizations_url":"https://api.github.com/users/rjernst/orgs","repos_url":"https://api.github.com/users/rjernst/repos","events_url":"https://api.github.com/users/rjernst/events{/privacy}","received_events_url":"https://api.github.com/users/rjernst/received_events","type":"User","site_admin":false},"created_at":"2015-04-17T19:36:29Z","updated_at":"2015-04-17T19:38:32Z","author_association":"MEMBER","body":"> maybe faster queries based on type filters (which can easily be achieved by just having a type field in your document itself rather than having ES take care of it and worry about all the things discussed above)\n\n@shivangshah This is all types ever were. They are a shortcut for sets of fields, and the fact that the system (currently) allows conflicts is a bug.\n\nTypes have a couple uses:\n- The mechanism for specifying parent/child relationships\n- Decreased file handles when fields are common (meaning the same name) across different types (mapping types, not data types...i really wish we could revamp this terminology b/c it is _very_ confusing to talk about)\n\nThere are also some performance optimizations that can happen on queries for a subset of types, by sorting on type at index time, which is planned for #8873 (and which cannot be attained using separate indexes).\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/94270193","html_url":"https://github.com/elastic/elasticsearch/issues/8870#issuecomment-94270193","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/8870","id":94270193,"node_id":"MDEyOklzc3VlQ29tbWVudDk0MjcwMTkz","user":{"login":"timbunce","id":62403,"node_id":"MDQ6VXNlcjYyNDAz","avatar_url":"https://avatars2.githubusercontent.com/u/62403?v=4","gravatar_id":"","url":"https://api.github.com/users/timbunce","html_url":"https://github.com/timbunce","followers_url":"https://api.github.com/users/timbunce/followers","following_url":"https://api.github.com/users/timbunce/following{/other_user}","gists_url":"https://api.github.com/users/timbunce/gists{/gist_id}","starred_url":"https://api.github.com/users/timbunce/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/timbunce/subscriptions","organizations_url":"https://api.github.com/users/timbunce/orgs","repos_url":"https://api.github.com/users/timbunce/repos","events_url":"https://api.github.com/users/timbunce/events{/privacy}","received_events_url":"https://api.github.com/users/timbunce/received_events","type":"User","site_admin":false},"created_at":"2015-04-19T12:04:45Z","updated_at":"2015-04-19T12:04:45Z","author_association":"NONE","body":"Is there some way to detect and report inconsistent mappings across types?\nE.g., has someone written a script to do this that people could run on their indices?\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/96221366","html_url":"https://github.com/elastic/elasticsearch/issues/8870#issuecomment-96221366","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/8870","id":96221366,"node_id":"MDEyOklzc3VlQ29tbWVudDk2MjIxMzY2","user":{"login":"clintongormley","id":56599,"node_id":"MDQ6VXNlcjU2NTk5","avatar_url":"https://avatars0.githubusercontent.com/u/56599?v=4","gravatar_id":"","url":"https://api.github.com/users/clintongormley","html_url":"https://github.com/clintongormley","followers_url":"https://api.github.com/users/clintongormley/followers","following_url":"https://api.github.com/users/clintongormley/following{/other_user}","gists_url":"https://api.github.com/users/clintongormley/gists{/gist_id}","starred_url":"https://api.github.com/users/clintongormley/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/clintongormley/subscriptions","organizations_url":"https://api.github.com/users/clintongormley/orgs","repos_url":"https://api.github.com/users/clintongormley/repos","events_url":"https://api.github.com/users/clintongormley/events{/privacy}","received_events_url":"https://api.github.com/users/clintongormley/received_events","type":"User","site_admin":false},"created_at":"2015-04-25T15:23:37Z","updated_at":"2015-04-25T15:23:37Z","author_association":"CONTRIBUTOR","body":"@timbunce such a script is planned as part of the migration advisory plugin https://github.com/elastic/elasticsearch/issues/10214\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/115422085","html_url":"https://github.com/elastic/elasticsearch/issues/8870#issuecomment-115422085","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/8870","id":115422085,"node_id":"MDEyOklzc3VlQ29tbWVudDExNTQyMjA4NQ==","user":{"login":"jhansen-tt","id":10874004,"node_id":"MDQ6VXNlcjEwODc0MDA0","avatar_url":"https://avatars0.githubusercontent.com/u/10874004?v=4","gravatar_id":"","url":"https://api.github.com/users/jhansen-tt","html_url":"https://github.com/jhansen-tt","followers_url":"https://api.github.com/users/jhansen-tt/followers","following_url":"https://api.github.com/users/jhansen-tt/following{/other_user}","gists_url":"https://api.github.com/users/jhansen-tt/gists{/gist_id}","starred_url":"https://api.github.com/users/jhansen-tt/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jhansen-tt/subscriptions","organizations_url":"https://api.github.com/users/jhansen-tt/orgs","repos_url":"https://api.github.com/users/jhansen-tt/repos","events_url":"https://api.github.com/users/jhansen-tt/events{/privacy}","received_events_url":"https://api.github.com/users/jhansen-tt/received_events","type":"User","site_admin":false},"created_at":"2015-06-25T22:43:50Z","updated_at":"2015-06-25T22:43:50Z","author_association":"NONE","body":"+1.  This has been a major pain ever since I started using ES, and still happens in 1.6.  Deleting the type alone doesn't fix the problem -- I have to completely delete the entire index and re-index everything, and then sometimes the problem goes away.  I do set up a strict mapping before I index anything.  It really feels to be a timing thing between the shards.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/115423329","html_url":"https://github.com/elastic/elasticsearch/issues/8870#issuecomment-115423329","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/8870","id":115423329,"node_id":"MDEyOklzc3VlQ29tbWVudDExNTQyMzMyOQ==","user":{"login":"jordansissel","id":131818,"node_id":"MDQ6VXNlcjEzMTgxOA==","avatar_url":"https://avatars1.githubusercontent.com/u/131818?v=4","gravatar_id":"","url":"https://api.github.com/users/jordansissel","html_url":"https://github.com/jordansissel","followers_url":"https://api.github.com/users/jordansissel/followers","following_url":"https://api.github.com/users/jordansissel/following{/other_user}","gists_url":"https://api.github.com/users/jordansissel/gists{/gist_id}","starred_url":"https://api.github.com/users/jordansissel/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jordansissel/subscriptions","organizations_url":"https://api.github.com/users/jordansissel/orgs","repos_url":"https://api.github.com/users/jordansissel/repos","events_url":"https://api.github.com/users/jordansissel/events{/privacy}","received_events_url":"https://api.github.com/users/jordansissel/received_events","type":"User","site_admin":false},"created_at":"2015-06-25T22:53:03Z","updated_at":"2015-06-25T22:54:05Z","author_association":"CONTRIBUTOR","body":"> it seems that default data model for logstash is broken then.\n\nMaybe? This only impacts users who have the same field name mapped to different data types under different document types in the same index. I don't know how many users this affects. Given Logstash has had this behavior (by default a daily index) for many years and given the anecdote that I can't recall much reports of this problem from Logstash users in those years, I'm not sure how big a problem this will be for Logstash users.\n\nI will confess that prior to this ticket, my assumptions were that type mappings were fully independent even if they shared field names (w/ different mappings) - I know accept this as incorrect, but I don't know great an impact this has had against Logstash users at this time.\n\n> If you enforce that all the same names need to have the same type you are effectively enforcing the same schema for all different logs from different sources.\n\nThese are two different things. One constraint \"Fields in the same index but on different document types must have the same mapping\" is not the same as saying \"the same schema must exist for all documents in the same index regardless of type - the conflict is only when two fields occupy the same name but different mappings in one index.\n\nMore research is needed for the Logstash side of things, but it's possible we may want to change the default index to include the 'type' field from Logstash (it'll be a backwards-compatibility-breaking change, if we do this). Hopefully the script from https://github.com/elastic/elasticsearch/issues/10214 will help users figure out how this will impact them before upgrading, and we can address further from there.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/115425949","html_url":"https://github.com/elastic/elasticsearch/issues/8870#issuecomment-115425949","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/8870","id":115425949,"node_id":"MDEyOklzc3VlQ29tbWVudDExNTQyNTk0OQ==","user":{"login":"jhansen-tt","id":10874004,"node_id":"MDQ6VXNlcjEwODc0MDA0","avatar_url":"https://avatars0.githubusercontent.com/u/10874004?v=4","gravatar_id":"","url":"https://api.github.com/users/jhansen-tt","html_url":"https://github.com/jhansen-tt","followers_url":"https://api.github.com/users/jhansen-tt/followers","following_url":"https://api.github.com/users/jhansen-tt/following{/other_user}","gists_url":"https://api.github.com/users/jhansen-tt/gists{/gist_id}","starred_url":"https://api.github.com/users/jhansen-tt/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jhansen-tt/subscriptions","organizations_url":"https://api.github.com/users/jhansen-tt/orgs","repos_url":"https://api.github.com/users/jhansen-tt/repos","events_url":"https://api.github.com/users/jhansen-tt/events{/privacy}","received_events_url":"https://api.github.com/users/jhansen-tt/received_events","type":"User","site_admin":false},"created_at":"2015-06-25T23:08:21Z","updated_at":"2015-06-25T23:08:21Z","author_association":"NONE","body":"After reading this:\n\nhttps://www.elastic.co/guide/en/elasticsearch/reference/1.3/mapping.html\n\nI think this should be taken out of the docs:\n    In practice though, this restriction is almost never an issue.\n\nIt looks like this is probably my issue, but I think the documentation should be updated to say that using different mapping characteristics on fields with the same name across multiple types is not supported, because some searches fall apart completely, such as sorting.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/118179580","html_url":"https://github.com/elastic/elasticsearch/issues/8870#issuecomment-118179580","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/8870","id":118179580,"node_id":"MDEyOklzc3VlQ29tbWVudDExODE3OTU4MA==","user":{"login":"monowai","id":2443042,"node_id":"MDQ6VXNlcjI0NDMwNDI=","avatar_url":"https://avatars1.githubusercontent.com/u/2443042?v=4","gravatar_id":"","url":"https://api.github.com/users/monowai","html_url":"https://github.com/monowai","followers_url":"https://api.github.com/users/monowai/followers","following_url":"https://api.github.com/users/monowai/following{/other_user}","gists_url":"https://api.github.com/users/monowai/gists{/gist_id}","starred_url":"https://api.github.com/users/monowai/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/monowai/subscriptions","organizations_url":"https://api.github.com/users/monowai/orgs","repos_url":"https://api.github.com/users/monowai/repos","events_url":"https://api.github.com/users/monowai/events{/privacy}","received_events_url":"https://api.github.com/users/monowai/received_events","type":"User","site_admin":false},"created_at":"2015-07-02T22:00:11Z","updated_at":"2015-07-02T22:00:11Z","author_association":"NONE","body":"Indexes can have the same field name with a different type. Doesn't this change move the query problem out of the index/type level and up in to the index? It seems to me that I had a query spanning indexes I'd still have the same fieldname+datatype conflict problem.\n\nIs there any merit in resolving this as part of the query DSL? If you have conflicting field+datatypes then could the query allow the caller to specify which field+datatype they wanted ignoring docs that don't match the criteria.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/118198127","html_url":"https://github.com/elastic/elasticsearch/issues/8870#issuecomment-118198127","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/8870","id":118198127,"node_id":"MDEyOklzc3VlQ29tbWVudDExODE5ODEyNw==","user":{"login":"rjernst","id":289412,"node_id":"MDQ6VXNlcjI4OTQxMg==","avatar_url":"https://avatars3.githubusercontent.com/u/289412?v=4","gravatar_id":"","url":"https://api.github.com/users/rjernst","html_url":"https://github.com/rjernst","followers_url":"https://api.github.com/users/rjernst/followers","following_url":"https://api.github.com/users/rjernst/following{/other_user}","gists_url":"https://api.github.com/users/rjernst/gists{/gist_id}","starred_url":"https://api.github.com/users/rjernst/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/rjernst/subscriptions","organizations_url":"https://api.github.com/users/rjernst/orgs","repos_url":"https://api.github.com/users/rjernst/repos","events_url":"https://api.github.com/users/rjernst/events{/privacy}","received_events_url":"https://api.github.com/users/rjernst/received_events","type":"User","site_admin":false},"created_at":"2015-07-03T00:06:54Z","updated_at":"2015-07-03T00:06:54Z","author_association":"MEMBER","body":"@monowai The important thing about #8871 was making field types consistent _within_ an index. You are correct that across indexes, the problem can still exist. However, whether this is an error case depends on the query. If the query is not parseable in one of the indexes, an exception would be raised. This was already the case, but now it should be consistently raised, while before mixed field types within an index could have masked the problem (depending on the order the document types were loaded within mappings).\n","performed_via_github_app":null}]