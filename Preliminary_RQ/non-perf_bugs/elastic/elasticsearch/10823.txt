{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/10823","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/10823/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/10823/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/10823/events","html_url":"https://github.com/elastic/elasticsearch/issues/10823","id":71244185,"node_id":"MDU6SXNzdWU3MTI0NDE4NQ==","number":10823,"title":"Vectorize API","user":{"login":"alexksikes","id":43475,"node_id":"MDQ6VXNlcjQzNDc1","avatar_url":"https://avatars2.githubusercontent.com/u/43475?v=4","gravatar_id":"","url":"https://api.github.com/users/alexksikes","html_url":"https://github.com/alexksikes","followers_url":"https://api.github.com/users/alexksikes/followers","following_url":"https://api.github.com/users/alexksikes/following{/other_user}","gists_url":"https://api.github.com/users/alexksikes/gists{/gist_id}","starred_url":"https://api.github.com/users/alexksikes/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alexksikes/subscriptions","organizations_url":"https://api.github.com/users/alexksikes/orgs","repos_url":"https://api.github.com/users/alexksikes/repos","events_url":"https://api.github.com/users/alexksikes/events{/privacy}","received_events_url":"https://api.github.com/users/alexksikes/received_events","type":"User","site_admin":false},"labels":[{"id":146832564,"node_id":"MDU6TGFiZWwxNDY4MzI1NjQ=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/:Search/Search","name":":Search/Search","color":"0e8a16","default":false,"description":"Search-related issues that do not fall into other categories"},{"id":23172,"node_id":"MDU6TGFiZWwyMzE3Mg==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/%3Efeature","name":">feature","color":"006b75","default":false,"description":null},{"id":158399402,"node_id":"MDU6TGFiZWwxNTgzOTk0MDI=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/Meta","name":"Meta","color":"e11d21","default":false,"description":null},{"id":113234020,"node_id":"MDU6TGFiZWwxMTMyMzQwMjA=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/stalled","name":"stalled","color":"fef2c0","default":false,"description":null}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":10,"created_at":"2015-04-27T10:26:37Z","updated_at":"2018-02-14T13:44:20Z","closed_at":"2016-10-26T08:20:11Z","author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"The vectorize API operates on top of the Term Vectors API and on `_source` in order to return a document-term matrix according to some user given specification. In a document-term (or term-document matrix), the rows correspond to documents in an index and the columns correspond to terms, or more precisely to some numerical value associated with each term such as tf or tf-idf.\n## Defining the Doc-Term Matrix\n\nFirst a vectorizer has to be registered. A vectorizer defines the shape and entries of the desired outputted matrix.\n\n```\nPUT /index/.vectorizer/my_vectorizer\n{\n    \"vectorizer\": [\n        {\n            \"field\": \"text\",\n            \"span\": [ ... list of terms ...],\n            \"value\": \"term_freq\"\n        },\n        {\n            \"field\": \"field_numeric_1\",\n            \"span\": 1\n        },\n        {\n            \"field\" : \"field_numeric_2\",\n            \"span\": 1,\n            \"script\": \"if _value > 0.5 then 1 else 0\"\n        },\n        {\n            \"field\": \"field_numeric_3\",\n            \"span\": 5\n        },\n        {\n            \"field\": \"label\",\n            \"span\": 1,\n            \"script\": \"if _value == \"yes\" then 1 else 0\"\n        }\n    ]\n}\n```\n\nIn this example, the first entry defines a first list of columns whose values are the term frequencies of the terms given in `span` in this order. The next column is simply defined as the value of the numerical field named `field_numeric_1`. For the next column, we binarize the numerical value at the field using a script. Next we assign 5 columns for the first 5 values in the multi-valued numerical field `field_numeric_3`. Last but not least, the last column is binarized as well and could be used as the target label for learning.\n\nMore precisely:\n- `field`: Name of the field in the index to which a mapping from field values to real values should be applied.\n- `span`: For numerical fields, specifies a number of columns to be assigned in the resulting vector. For string fields, specifies a list of terms, each term occupying a column in the vector if present in the document.\n- `value`: For numerical fields, defaults to the value at the field. For string fields, defaults to term frequency. For the later case other values are possible such as document frequency, or payload.\n- `script`: Allows for any field value transformation such as thresholding, categorizing, etc ...\n## Retrieving Vectors\n\nWe can now use the vectorize API:\n\n```\nGET /index/type/id/_vectorize&vectorizer=my_vectorizer\n\nResponse:\n\n{\n    \"shape\": [1, 9],\n    \"vector\": [\n        {\"3\": 5, \"5\": 2, \"6\": 0.55, 7\": 1, \"8\": 0}\n    ]\n}\n```\n\nThe matrix returned is in a sparse format, together with its dimension. This vector can then be loaded in memory in your favorite statistical environments, or fed to a machine learning package. The parameters are exactly the same as the term vectors API with the additional `vectorizer` parameter. A vectorizer could also be provided inline, meaning as part of the request.\n\n```\nGET /index/type/id/_vectorize\n{\n    \"vectorizer\": [\n        {\n            \"field\": \"text\",\n            \"span\": [ ... list of terms ...],\n            \"value\": \"term_freq\"\n        },\n        {\n            \"field\": \"label\",\n            \"span\": 1,\n            \"script\": \"if _value == \"yes\" then 1 else 0\"\n        }\n    ]\n}\n```\n\nIn order to retrieve more than one vector, use the `_mvectorize` API:\n\n```\nGET /index/type/_mvectorize\n{\n    \"docs\": [\n    {\n        \"_index\": \"index\",\n        \"_type\": \"type\",\n        \"_id\": \"id\",\n        \"vectorizer\": my_vectorizer\n    },\n    {\n        \"_index\": \"index\",\n        \"_type\": \"type\",\n        \"_id\": \"id2\",\n        \"vectorizer\": my_vectorizer\n    }\n   ]\n}\n\nResponse:\n\n{\n    \"shape\": [2, 9],\n    \"vector\": [\n        {\"3\": 5, \"5\": 2, \"6\": 0.55, 7\": 1, \"8\": 0},\n        {\"0\": 2, \"3\": 1, \"6\": 0.21, 7\": 1, \"8\": 1}\n    ]\n}\n```\n\nHere different vectorizers could have been chosen. In this case, the vectors are stacked up, columns over columns, with the largest vector defining the dimension of the matrix.\n## Generating Datasets\n\nFinally, we can obtain a dataset by using a new search type called `vectorize` together with a scroll:\n\n```\nGET /index/type/_search?search_type=vectorize&scroll=1m\n{\n    \"query\": { \"match_all\": {}},\n    \"size\":  1000,\n\n    \"from\": 0,\n    \"step\": 1,\n    \"sample\": \"10%\",\n\n    \"vectorizer\": \"my_vectorizer\",\n    \"slice\": start:stop:step\n}\n\nAfter submitting the scroll request, we get the response:\n\n{\n    \"shape\": [1000, 9],\n    \"vector: [\n        {\"3\": 5, \"5\": 2, \"6\": 0.55, 7\": 1, \"8\": 0},\n        {\"0\": 2, \"3\": 1, \"6\": 0.21, 7\": 1, \"8\": 1},\n        {\"3\": 5, \"3\": 5, \"6\": 0.45, 7\": 0, \"8\": 0},\n        {\"3\": 5, \"5\": 3, \"6\": 0.56, 7\": 0, \"8\": 1},\n        ...\n    ]\n}\n```\n\nHere `slice` allows us to only select some columns in this matrix. The `from`, `step` or `sample` retain documents starting after having processed a given number of documents and at every chosen step, or with x% chances. These options are useful in order to generate datasets such as a training and test set.\n","closed_by":{"login":"s1monw","id":973334,"node_id":"MDQ6VXNlcjk3MzMzNA==","avatar_url":"https://avatars0.githubusercontent.com/u/973334?v=4","gravatar_id":"","url":"https://api.github.com/users/s1monw","html_url":"https://github.com/s1monw","followers_url":"https://api.github.com/users/s1monw/followers","following_url":"https://api.github.com/users/s1monw/following{/other_user}","gists_url":"https://api.github.com/users/s1monw/gists{/gist_id}","starred_url":"https://api.github.com/users/s1monw/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/s1monw/subscriptions","organizations_url":"https://api.github.com/users/s1monw/orgs","repos_url":"https://api.github.com/users/s1monw/repos","events_url":"https://api.github.com/users/s1monw/events{/privacy}","received_events_url":"https://api.github.com/users/s1monw/received_events","type":"User","site_admin":false},"performed_via_github_app":null}