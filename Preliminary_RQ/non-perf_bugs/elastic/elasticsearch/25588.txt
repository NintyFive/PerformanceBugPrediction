{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/25588","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/25588/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/25588/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/25588/events","html_url":"https://github.com/elastic/elasticsearch/issues/25588","id":241185670,"node_id":"MDU6SXNzdWUyNDExODU2NzA=","number":25588,"title":"Named Views in ElasticSearch as an alternative to Filtered Aliases","user":{"login":"tmpaul06","id":7438946,"node_id":"MDQ6VXNlcjc0Mzg5NDY=","avatar_url":"https://avatars3.githubusercontent.com/u/7438946?v=4","gravatar_id":"","url":"https://api.github.com/users/tmpaul06","html_url":"https://github.com/tmpaul06","followers_url":"https://api.github.com/users/tmpaul06/followers","following_url":"https://api.github.com/users/tmpaul06/following{/other_user}","gists_url":"https://api.github.com/users/tmpaul06/gists{/gist_id}","starred_url":"https://api.github.com/users/tmpaul06/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/tmpaul06/subscriptions","organizations_url":"https://api.github.com/users/tmpaul06/orgs","repos_url":"https://api.github.com/users/tmpaul06/repos","events_url":"https://api.github.com/users/tmpaul06/events{/privacy}","received_events_url":"https://api.github.com/users/tmpaul06/received_events","type":"User","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":1,"created_at":"2017-07-07T07:52:55Z","updated_at":"2017-07-07T10:37:35Z","closed_at":"2017-07-07T10:37:35Z","author_association":"NONE","active_lock_reason":null,"body":"<!-- Feature request -->\r\n## Named views\r\n\r\nI am creating ticket to discuss the possibility of creating \"named\" views in ElasticSearch. I'm aware of filtered aliases, but ran into a lot of problems with the approach. I will try to express the need for such a feature with an use case that I have encountered in the past.\r\n\r\n### Use case\r\n\r\nGiven an external input of a large number of id or id like fields, define a view over an ElasticSearch index. The external input can be a CSV file, or a JSON passed in from another database. It can be a terms filter or an ids filter or a more complex combination of other filters.\r\n\r\nI am highlighting some discussions from ES discuss threads other than my own to support the above mentioned use case.\r\n* https://github.com/elastic/elasticsearch/issues/23281\r\n* https://discuss.elastic.co/t/filtered-aliases-and-huge-ids-terms-filter/58844\r\n\r\n### Why not use aliases ?\r\n\r\nThere are two main reasons why I think aliases should not be used as views.\r\n\r\n1. The first one is conceptual. An alias is typically used to point to a different version of the \"same\" index. It could be new changes to the data, adding more documents, but a filtered subset of the index is conceptually not an `alias` of the index.\r\n\r\n    Also if aliases are used as views, hitting the index alias query will return the filtered aliases for that index. If there are several filtered aliases created for a single index, each with millions of fields, the get_alias request will explode in terms of size. (Ran into this problem with ES 5.2.2)\r\n\r\n    We faced this exact issue with large terms filter using filtered aliases.\r\n\r\n2. Different views can be computed on a single index alias. This allows having two different computed views of historical and current data side-by-side. A view is more granular than an alias. A filter created for a view can be combined with several other filters to perform set like operations on the index.\r\n\r\n### Assumptions\r\n1. The filter can be cached. But there is no guarantee that it will remain in memory during query execution. If evicted, it will simply be recomputed similar to existing filters.\r\n\r\n2. The view will be computed infrequently, i.e the filters themselves will change infrequently. In the event of a change in the filter, the view will be recomputed (by making an explicit call to ES hereafter called the **update_view** operation or during query time).\r\n\r\n3. The filter can contain a large number of term or id based field values. If it is too big to fit in one request, the filter can be computed with batched requests. (Similar to update_view).\r\n\r\n4. Each cached filter will be for a given index and doc_type.\r\n\r\n5. A view can be queried against using a named filter called **view query**\r\n```javascript\r\n// GET /_search\r\n{\r\n    \"query\": {\r\n        \"constant_score\" : {\r\n            \"filter\" : {\r\n                \"view\" : \"my_named_view\"\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nor by explicitly quering against a view\r\n```\r\ncurl -XGET /_view/my_named_view -d ....\r\n\r\nand\r\n\r\ncurl -XPUT /_view/my_named_view - d... // Updated filter\r\n```\r\n\r\n### Questions\r\n1. It is possible to use the existing filter cache to implement this ?  A named view would simply be then a named filter. The name references the stored/cached bitset.\r\n2. Are there any problems/challenges due to the distributed nature ?\r\n\r\nIn short, I would like to create a subset of an index and refer to it by name in queries rather than sending in large term filters for each query. There is no additional metadata that I can add to the documents to avoid sending the large number of term filters, because the collection of the values in the filter are created externally, e.g from a CSV file, or even a random sample of id fields in the index.\r\n\r\nI understand that creating filtered aliases with large number of term filters is kind of an anti-pattern, but the alternative is to create a separate index for a given subset of documents. The reindexing time + space used by the document subset is prohibitive for our use case.\r\n\r\nCurrent ES version: `5.2.0`\r\n\r\nDoes this look like an sensible idea ?\r\n\r\n","closed_by":{"login":"jimczi","id":15977469,"node_id":"MDQ6VXNlcjE1OTc3NDY5","avatar_url":"https://avatars0.githubusercontent.com/u/15977469?v=4","gravatar_id":"","url":"https://api.github.com/users/jimczi","html_url":"https://github.com/jimczi","followers_url":"https://api.github.com/users/jimczi/followers","following_url":"https://api.github.com/users/jimczi/following{/other_user}","gists_url":"https://api.github.com/users/jimczi/gists{/gist_id}","starred_url":"https://api.github.com/users/jimczi/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jimczi/subscriptions","organizations_url":"https://api.github.com/users/jimczi/orgs","repos_url":"https://api.github.com/users/jimczi/repos","events_url":"https://api.github.com/users/jimczi/events{/privacy}","received_events_url":"https://api.github.com/users/jimczi/received_events","type":"User","site_admin":false},"performed_via_github_app":null}