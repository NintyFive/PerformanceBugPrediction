{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/12282","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/12282/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/12282/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/12282/events","html_url":"https://github.com/elastic/elasticsearch/issues/12282","id":95332443,"node_id":"MDU6SXNzdWU5NTMzMjQ0Mw==","number":12282,"title":"ElasticsearchIntegrationTest.flushAndRefresh() not flushing (committing?) dynamic mappings","user":{"login":"mikerott","id":857712,"node_id":"MDQ6VXNlcjg1NzcxMg==","avatar_url":"https://avatars2.githubusercontent.com/u/857712?v=4","gravatar_id":"","url":"https://api.github.com/users/mikerott","html_url":"https://github.com/mikerott","followers_url":"https://api.github.com/users/mikerott/followers","following_url":"https://api.github.com/users/mikerott/following{/other_user}","gists_url":"https://api.github.com/users/mikerott/gists{/gist_id}","starred_url":"https://api.github.com/users/mikerott/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikerott/subscriptions","organizations_url":"https://api.github.com/users/mikerott/orgs","repos_url":"https://api.github.com/users/mikerott/repos","events_url":"https://api.github.com/users/mikerott/events{/privacy}","received_events_url":"https://api.github.com/users/mikerott/received_events","type":"User","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":1,"created_at":"2015-07-16T02:21:40Z","updated_at":"2015-07-16T06:53:51Z","closed_at":"2015-07-16T06:53:51Z","author_association":"NONE","active_lock_reason":null,"body":"Perhaps an odd scenario here, but it's affecting my test stability.  Basically, the problem is that when I do, in sequence:\n- bulkRequest of a dynamic document\n- flushAndRefresh()\n- bulkRequest of a second dynamic document\n- flushAndRefresh()\n- GetMappingsRequest to find all the new keys that have now appeared\n\nDepending on the `@Seed` I've chosen, or whether I put a `Thread.sleep(1000)` after the second `flushAndRefresh()`, I may or may not find the two new keys from my two bulkRequests.\n- Expected:  flushAndRefresh() would commit the dynamic documents in the bulkRequest and update the mappings\n- Actual:  the documents are committed but the mappings are not\n\nThe code:\n\n```\n        Client localClient = ElasticsearchIntegrationTest.client();\n\n        BulkRequestBuilder bulkRequest = localClient.prepareBulk();\n\n        IndexRequestBuilder indexRequest = localClient.prepareIndex(DEFAULT_INDEX, \"logs\")\n                .setSource(\"{mykey1:\\\"value\\\"}\").setOpType(OpType.CREATE);\n\n        bulkRequest.add(indexRequest).execute().get();\n\n        flushAndRefresh(DEFAULT_INDEX);\n\n        IndexRequestBuilder indexRequest2 = localClient.prepareIndex(DEFAULT_INDEX, \"logs\")\n                .setSource(\"{mykey2:\\\"value\\\"}\").setOpType(OpType.CREATE);\n\n        bulkRequest.add(indexRequest2).execute().get();\n\n        flushAndRefresh(DEFAULT_INDEX);\n\n        // Get the dynamically created mappings for the custom charts\n        GetMappingsRequest getMappingsRequest = new GetMappingsRequest();\n        getMappingsRequest.indices(DEFAULT_INDEX).types(\"logs\");\n        GetMappingsResponse getMappingsResponse = localClient.admin().indices().getMappings(getMappingsRequest).actionGet();\n        ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> mappingsByIndex = getMappingsResponse.getMappings();\n\n        // it's a dynamic mapping, so we should find a property named 'mykey1' and 'mykey2'\n        int foundCount = 0;\n\n        // Loop is necessary due to elasticsearch API, but we're always only searching one index\n        for (ObjectObjectCursor<String, ImmutableOpenMap<String, MappingMetaData>> indexEntry : mappingsByIndex) {\n\n            if (indexEntry.value.isEmpty()) {\n                continue;\n            }\n\n            // Again, the loop is necessary because of the API, but we're only looping through the custom data mapping\n            for (ObjectObjectCursor<String, MappingMetaData> typeEntry : indexEntry.value) {\n                JSONObject allMappings = JSONObject.parse(typeEntry.value.source().toString());\n                JSONObject currentMapping = (JSONObject)allMappings.get(\"logs\");\n                JSONObject mappingProperties = (JSONObject)currentMapping.get(\"properties\");\n\n                for (Object mappingKey : mappingProperties.keySet()) {\n                    String mappingKeyString = (String)mappingKey;\n                    if (mappingKeyString.equals(\"mykey1\") || mappingKeyString.equals(\"mykey2\")) {\n                        foundCount++;\n                    }\n                }\n            }\n        }\n\n        assertEquals(\"property keys were not found by looking at the mappings even though I called flushAndRefresh()\", 2, foundCount);\n```\n\nRecreate project here:  https://github.com/mikerott/eb_issue_12282\n","closed_by":{"login":"bleskes","id":1006375,"node_id":"MDQ6VXNlcjEwMDYzNzU=","avatar_url":"https://avatars1.githubusercontent.com/u/1006375?v=4","gravatar_id":"","url":"https://api.github.com/users/bleskes","html_url":"https://github.com/bleskes","followers_url":"https://api.github.com/users/bleskes/followers","following_url":"https://api.github.com/users/bleskes/following{/other_user}","gists_url":"https://api.github.com/users/bleskes/gists{/gist_id}","starred_url":"https://api.github.com/users/bleskes/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bleskes/subscriptions","organizations_url":"https://api.github.com/users/bleskes/orgs","repos_url":"https://api.github.com/users/bleskes/repos","events_url":"https://api.github.com/users/bleskes/events{/privacy}","received_events_url":"https://api.github.com/users/bleskes/received_events","type":"User","site_admin":false},"performed_via_github_app":null}