{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/12326","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/12326/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/12326/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/12326/events","html_url":"https://github.com/elastic/elasticsearch/issues/12326","id":95840300,"node_id":"MDU6SXNzdWU5NTg0MDMwMA==","number":12326,"title":"Intensity Highlighting","user":{"login":"alexksikes","id":43475,"node_id":"MDQ6VXNlcjQzNDc1","avatar_url":"https://avatars2.githubusercontent.com/u/43475?v=4","gravatar_id":"","url":"https://api.github.com/users/alexksikes","html_url":"https://github.com/alexksikes","followers_url":"https://api.github.com/users/alexksikes/followers","following_url":"https://api.github.com/users/alexksikes/following{/other_user}","gists_url":"https://api.github.com/users/alexksikes/gists{/gist_id}","starred_url":"https://api.github.com/users/alexksikes/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alexksikes/subscriptions","organizations_url":"https://api.github.com/users/alexksikes/orgs","repos_url":"https://api.github.com/users/alexksikes/repos","events_url":"https://api.github.com/users/alexksikes/events{/privacy}","received_events_url":"https://api.github.com/users/alexksikes/received_events","type":"User","site_admin":false},"labels":[{"id":111549183,"node_id":"MDU6TGFiZWwxMTE1NDkxODM=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/:Search/Highlighting","name":":Search/Highlighting","color":"0e8a16","default":false,"description":"How a query matched a document"},{"id":23172,"node_id":"MDU6TGFiZWwyMzE3Mg==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/%3Efeature","name":">feature","color":"006b75","default":false,"description":null},{"id":158399402,"node_id":"MDU6TGFiZWwxNTgzOTk0MDI=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/Meta","name":"Meta","color":"e11d21","default":false,"description":null}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":3,"created_at":"2015-07-18T16:55:38Z","updated_at":"2018-06-29T11:17:13Z","closed_at":"2018-03-22T17:00:18Z","author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"## Introduction\n\nOn queries composed of many terms, for example when using More Like This (MLT) or an [Item Query](https://github.com/elastic/elasticsearch/issues/12293), it is often quite desirable to explain the results returned. This helps users form a mental model about the underlying matching algorithm, and subsequently removes some of the magic around these types of queries.\n\nCurrently, developers have two out of the box options in order to provide such a functionality: [explain](https://www.elastic.co/guide/en/elasticsearch/reference/master/search-explain.html) and [highlighting](https://www.elastic.co/guide/en/elasticsearch/reference/master/search-request-highlighting.html). Explain is useful for debugging, but has some unfortunate performance implications. Its output is also quite verbose. Highlighting is useful to show the matched keywords in context, but it only provides a partial understanding of scoring.\n\nWhat we would need instead is something in between highlighting and explain. Something which would not only highlight the terms in context but also provide the level of importance that term had in scoring each document. This would provide a best of both worlds solution. In fact, the idea isn't new! Lucene already provides a GradientFormatter, though it is not used at the moment in Elasticsearch.\n\nLet us further illustrate our point with an example.\n## Example\n\nIn the example below, the user has asked for movies similar to the movie Terminator 2. Under the hood an MLT query was triggered which then generated a query composed of the salient terms in the requested document. The matching terms are then highlighted within each returned document, but with some additional hints as to their level of importance in scoring. The greater the intensity of the highlight, the more important that term is in computing the score of the document.\n\n![itensity_highlighter2](https://cloud.githubusercontent.com/assets/43475/8762299/59560490-2d75-11e5-8ae8-16a89278e8d1.png)\n\nIn this example, we can see that the first movie has less terms matching the query than the second movie. However, these terms are highlighted with greater intensities, which explains why that movie is ranked higher in the result set. If the user did not have the intensity of the highlight, he could be puzzled as to why this is the case. For example, he could wrongly assume that more terms matching means greater scoring. Here we not only know why the document matched, but also how the score was probably computed (which terms participated in the scoring and to what extent). \n## API usage\n\nWe could return all the per-query-term scores, but maybe such an output would be too verbose, and too close to just using explain. Instead, and this is not set in stone, we could highlight the terms in context with style. In order to do so, we can introduce a `with_intensities` option which would take an integer representing the number of possible intensities.\n\nHere is how the above example could have been generated:\n\n``` json\nGET /tmdb/movies/_search\n{\n  \"query\": {\n    \"more_like_this\": {\n      \"like\": {\n        \"_id\": 280\n      }\n    }\n  },\n  \"highlight\": {\n    \"fields\": {\n      \"plot\": {\n        \"number_of_fragments\": 0,\n        \"with_intensities\": 4\n      }\n    }\n  }\n}\n```\n\nAnd the response:\n\n``` json\n{\n  ...\n  \"hits\": {\n    \"total\": 3,\n    \"max_score\": 10.2301,\n    \"hits\": [\n      {\n        ...\n        \"highlight\": {\n          \"plot\": [\"It's been 10 years since John <em class=\\\"hlt4\\\">Connor</em> saved Earth from\n<em class=\\\"hlt3\\\">Judgment Day</em>, and he's now living under the radar, steering\nclear of using anything <em class=\\\"hlt4\\\">Skynet</em> can trace. That is, until he\nencounters T-X, a <em class=\\\"hlt1\\\">robotic</em> <em class=\\\"hlt2\\\">assassin</em> ordered\nto finish what <em class=\\\"hlt4\\\">T-1000</em> started. Good thing <em class=\\\"hlt4\\\">Connor</em>'s\nformer nemesis, the <em class=\\\"hlt4\\\">Terminator</em>, is back to aid the now-adult\n<em class=\\\"hlt4\\\">Connor</em> â€¦ just like he promised.\"]\n        }\n      },\n      ...\n    ]\n  }\n}\n```\n## Implementation Notes\n\nAs previously mentioned, Lucene does provide a GradientFormatter and a SpanGradientFormatter which can be used with the plain highlighter. Another possibility would include adding the option to retain the per-query-term scores to plain highlighter and/or to fast vector highlighter, that is retaining the scores which were used to compute the score given to each fragment. There are roughly the same term scores which were used to compute the score of the document before highlighting.\n","closed_by":{"login":"jimczi","id":15977469,"node_id":"MDQ6VXNlcjE1OTc3NDY5","avatar_url":"https://avatars0.githubusercontent.com/u/15977469?v=4","gravatar_id":"","url":"https://api.github.com/users/jimczi","html_url":"https://github.com/jimczi","followers_url":"https://api.github.com/users/jimczi/followers","following_url":"https://api.github.com/users/jimczi/following{/other_user}","gists_url":"https://api.github.com/users/jimczi/gists{/gist_id}","starred_url":"https://api.github.com/users/jimczi/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jimczi/subscriptions","organizations_url":"https://api.github.com/users/jimczi/orgs","repos_url":"https://api.github.com/users/jimczi/repos","events_url":"https://api.github.com/users/jimczi/events{/privacy}","received_events_url":"https://api.github.com/users/jimczi/received_events","type":"User","site_admin":false},"performed_via_github_app":null}