{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/41536","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/41536/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/41536/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/41536/events","html_url":"https://github.com/elastic/elasticsearch/issues/41536","id":437232088,"node_id":"MDU6SXNzdWU0MzcyMzIwODg=","number":41536,"title":"Retain history for peer recovery using leases","user":{"login":"DaveCTurner","id":5058284,"node_id":"MDQ6VXNlcjUwNTgyODQ=","avatar_url":"https://avatars3.githubusercontent.com/u/5058284?v=4","gravatar_id":"","url":"https://api.github.com/users/DaveCTurner","html_url":"https://github.com/DaveCTurner","followers_url":"https://api.github.com/users/DaveCTurner/followers","following_url":"https://api.github.com/users/DaveCTurner/following{/other_user}","gists_url":"https://api.github.com/users/DaveCTurner/gists{/gist_id}","starred_url":"https://api.github.com/users/DaveCTurner/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/DaveCTurner/subscriptions","organizations_url":"https://api.github.com/users/DaveCTurner/orgs","repos_url":"https://api.github.com/users/DaveCTurner/repos","events_url":"https://api.github.com/users/DaveCTurner/events{/privacy}","received_events_url":"https://api.github.com/users/DaveCTurner/received_events","type":"User","site_admin":false},"labels":[{"id":152510590,"node_id":"MDU6TGFiZWwxNTI1MTA1OTA=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/:Distributed/Recovery","name":":Distributed/Recovery","color":"0e8a16","default":false,"description":"Anything around constructing a new shard, either from a local or a remote source."},{"id":23174,"node_id":"MDU6TGFiZWwyMzE3NA==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/%3Eenhancement","name":">enhancement","color":"4a4ea8","default":false,"description":null},{"id":158399402,"node_id":"MDU6TGFiZWwxNTgzOTk0MDI=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/Meta","name":"Meta","color":"e11d21","default":false,"description":null},{"id":1434538947,"node_id":"MDU6TGFiZWwxNDM0NTM4OTQ3","url":"https://api.github.com/repos/elastic/elasticsearch/labels/v7.4.0","name":"v7.4.0","color":"dddddd","default":false,"description":""}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":2,"created_at":"2019-04-25T14:30:43Z","updated_at":"2019-09-03T15:40:25Z","closed_at":"2019-09-03T15:40:12Z","author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"The goal is that we can perform an operations-based recovery for all \"reasonable\" shard copies _C_:\r\n\r\n- There is a peer recovery retention lease _L_ corresponding with _C_.\r\n- Every in-sync shard copy has a complete history of operations above the retained seqno of _L_.\r\n- The retained seqno _r_ of _L_ is no greater than the local checkpoint of the last safe commit of _C_.\r\n\r\nReasonable shard copies comprise all the copies that are currently being tracked, as well as all the copies that \"might be a recovery target\": if the shard is not fully allocated then any copy that has been tracked in the last `index.soft_deletes.retention_lease.period` (i.e. `12h`) might reasonably be a recovery target.\r\n\r\nWe also require that history is eventually released: in a stable cluster, for every operation with seqno _s_ below the MSN of a replication group, eventually there are no leases that retain _s_:\r\n\r\n- Every active shard copy eventually advances its LCPoSC past _s_.\r\n- Every lease for an active shard copy eventually also passes _s_.\r\n- Every inactive shard copy eventually either becomes active or else its lease expires.\r\n\r\nConcretely, this should ensure that operations-based recoveries are possible in the following cases (subject to the copy being allocated back to the same node):\r\n\r\n- a shard copy _C_ is offline for a short period (<`12h`)\r\n  - even if the primary is relocated or a replica is promoted to primary while _C_ is offline.\r\n  - even if _C_ was part of a closed/frozen/readonly index that was opened while _C_ was offline\r\n    - but not if the index was closed/frozen again before _C_ comes back\r\n    - TBD: maybe we are ok with this being a file-based recovery?\r\n- a full-cluster restart\r\n\r\n---\r\n\r\nThis breaks into a few conceptually-separate pieces:\r\n\r\n- [x] Adjust peer recovery to start by recovering the target using the local translog as far as (the local copy of) the global checkpoint (#43463)\r\n  - this means we can discard history that is behind every known global checkpoint\r\n  - replicas already share with the primary the necessary information about the movement of the global checkpoint\r\n\r\n- [x] Create peer recovery retention leases to retain the history needed by each shard (#43190, #43632)\r\n  - For primary, on primary activation\r\n  - For replicas, during peer recovery\r\n  - retention leases don't _guarantee_ that history is retained by every copy\r\n\r\n- [x] Lazily create retention leases for tracked shards that don't exist because the primary was relocated from an older version. (#44009)\r\n\r\n- [x] Advance existing peer recovery retention leases according to the history information exposed by each shard copy. (#43751, #43898)\r\n\r\n- [x] Make peer recovery work together with retention leases (#44853)\r\n  - Use the existence of a retention lease as the deciding factor for performing an ops-based recovery\r\n  - Reinstate recovery from history stored in Lucene if soft deletes are enabled\r\n\r\n- [x] Tests should randomly set the lease expiry time very low sometimes to ensure that everything still works if leases are expiring. (#44067)\r\n\r\n- [x] Discard translog more enthusiastically now that we don't need to retain it any more (#45473)\r\n- [x] Expire leases based on more than time - if a file-based recovery would clearly be cheaper than an ops-based recovery then we may as well throw a lease away (#45208)\r\n\r\nFollowup work, out-of-scope for the feature branches.\r\n\r\n- Adjust translog retention\r\n  - Should we retain translog generations according to retention leases too?\r\n  - Trim translog files eagerly during the \"verify-before-close\" step for closed/frozen indices (#43156)\r\n  - Properly support peer-recovery retention leases on indices that are not using soft deletes too.\r\n\r\n- [ ] Make the `ReplicaShardAllocator` sensitive to leases, so that it prefers to select a location for each replica that only needs an ops-based recovery.  (relates #42518)\r\n\r\n- [x] Seqno-based synced flush: if a copy has LCP == MSN then it needs no recovery. (relates #42518)\r\n\r\n\r\n---\r\n\r\nBWC issues: during a rolling upgrade, we may migrate a primary onto a new node without first establishing the appropriate leases. They can't be established before or during this promotion, so we must weaken the assertions so that they only apply to sufficiently-newly-created indices. We will still establish leases properly during peer recovery, and can establish them lazily on older indices, but they may not retain all the right history when first created.\r\n\r\nClosed replicated indices issues: a closed index permits no replicated actions, but should not need any history to be retained. We cannot replay history into a closed index, so all recoveries must be file-based, so there's no real need for leases; moreover any existing PRRLs will not be retaining any history. We cannot assert that all the copies of a replicated closed index have a corresponding lease without performing replicated write actions to create such leases as we create new replicas, and nor can we assert that there are no leases on a replicated closed index since again this would  require replicated write actions. We elect to ignore PRRLs on closed indices: they might exist, but they might not, and either way is fine.","closed_by":{"login":"DaveCTurner","id":5058284,"node_id":"MDQ6VXNlcjUwNTgyODQ=","avatar_url":"https://avatars3.githubusercontent.com/u/5058284?v=4","gravatar_id":"","url":"https://api.github.com/users/DaveCTurner","html_url":"https://github.com/DaveCTurner","followers_url":"https://api.github.com/users/DaveCTurner/followers","following_url":"https://api.github.com/users/DaveCTurner/following{/other_user}","gists_url":"https://api.github.com/users/DaveCTurner/gists{/gist_id}","starred_url":"https://api.github.com/users/DaveCTurner/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/DaveCTurner/subscriptions","organizations_url":"https://api.github.com/users/DaveCTurner/orgs","repos_url":"https://api.github.com/users/DaveCTurner/repos","events_url":"https://api.github.com/users/DaveCTurner/events{/privacy}","received_events_url":"https://api.github.com/users/DaveCTurner/received_events","type":"User","site_admin":false},"performed_via_github_app":null}