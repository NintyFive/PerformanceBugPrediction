{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/38646","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/38646/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/38646/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/38646/events","html_url":"https://github.com/elastic/elasticsearch/issues/38646","id":408294219,"node_id":"MDU6SXNzdWU0MDgyOTQyMTk=","number":38646,"title":"MockWebServer incompatible with HttpClient closing on TLSv1.3","user":{"login":"jaymode","id":4339958,"node_id":"MDQ6VXNlcjQzMzk5NTg=","avatar_url":"https://avatars1.githubusercontent.com/u/4339958?v=4","gravatar_id":"","url":"https://api.github.com/users/jaymode","html_url":"https://github.com/jaymode","followers_url":"https://api.github.com/users/jaymode/followers","following_url":"https://api.github.com/users/jaymode/following{/other_user}","gists_url":"https://api.github.com/users/jaymode/gists{/gist_id}","starred_url":"https://api.github.com/users/jaymode/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jaymode/subscriptions","organizations_url":"https://api.github.com/users/jaymode/orgs","repos_url":"https://api.github.com/users/jaymode/repos","events_url":"https://api.github.com/users/jaymode/events{/privacy}","received_events_url":"https://api.github.com/users/jaymode/received_events","type":"User","site_admin":false},"labels":[{"id":912838655,"node_id":"MDU6TGFiZWw5MTI4Mzg2NTU=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/:Security/Network","name":":Security/Network","color":"0e8a16","default":false,"description":"SSL/TLS, Security for NIO/Netty"},{"id":60445228,"node_id":"MDU6TGFiZWw2MDQ0NTIyOA==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/%3Etest","name":">test","color":"5319e7","default":false,"description":"Issues or PRs that are addressing/adding tests"},{"id":1967499607,"node_id":"MDU6TGFiZWwxOTY3NDk5NjA3","url":"https://api.github.com/repos/elastic/elasticsearch/labels/Team:Security","name":"Team:Security","color":"fef2c0","default":false,"description":"Meta label for security team"}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":3,"created_at":"2019-02-08T19:35:09Z","updated_at":"2020-11-19T17:46:20Z","closed_at":"2020-11-19T17:46:20Z","author_association":"MEMBER","active_lock_reason":null,"body":"The MockWebServer used by certain tests is incompatible with the way that HttpClient closes connections, when TLSv1.3 is in use AND the entire response has not been consumed. The [HttpClient connection close code](https://github.com/apache/httpcomponents-core/blob/fb82948b2e3241ccb09501a0daaf646f4106d1b8/httpcore/src/main/java/org/apache/http/impl/BHttpConnectionBase.java#L314-L334) does some manual manipulation of the socket prior to calling `close()`. Ultimately a close_notify is sent by the client and then the server attempts to respond to it, but the TLSv1.3 SSLEngine never produces any bytes and doesn't transition back to the closed state, so the MockWebServer ends up in an endless loop.\r\n\r\nThis behavior is ultimately all within JDK code on the server side; fortunately there are workarounds that we can use for tests.\r\n\r\n1. Consume the whole response\r\n2. Use `Socket#close` instead of the HttpClient closing code by creating our own connection, connection factory and connection manager\r\n\r\nI plan to send this issue to the OpenJDK mailing list with the following as a minimal reproduction.\r\n\r\n<details>\r\n\r\n```java\r\nimport com.sun.net.httpserver.HttpsConfigurator;\r\nimport com.sun.net.httpserver.HttpsParameters;\r\nimport com.sun.net.httpserver.HttpsServer;\r\n\r\nimport javax.net.ssl.HandshakeCompletedEvent;\r\nimport javax.net.ssl.HandshakeCompletedListener;\r\nimport javax.net.ssl.KeyManagerFactory;\r\nimport javax.net.ssl.SSLContext;\r\nimport javax.net.ssl.SSLSocket;\r\nimport javax.net.ssl.SSLSocketFactory;\r\nimport javax.net.ssl.TrustManagerFactory;\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStream;\r\nimport java.net.InetAddress;\r\nimport java.net.InetSocketAddress;\r\nimport java.nio.charset.StandardCharsets;\r\nimport java.security.KeyStore;\r\n\r\npublic class HttpsServerEndlessLoop {\r\n\r\n    public static void main(String[] args) throws Exception {\r\n        final SSLContext sslContext = getSSLContext();\r\n        InetSocketAddress address = new InetSocketAddress(InetAddress.getLoopbackAddress().getHostAddress(), 0);\r\n        HttpsServer httpsServer = HttpsServer.create(address, 0);\r\n        httpsServer.setHttpsConfigurator(new HttpsConfigurator(sslContext) {\r\n            @Override\r\n            public void configure (HttpsParameters params) {\r\n            }\r\n        });\r\n        httpsServer.createContext(\"/\", s -> {\r\n            try {\r\n                final byte[] body = \"<body>\".getBytes(StandardCharsets.UTF_8);\r\n                s.sendResponseHeaders(200, body.length);\r\n                s.getResponseBody().write(body);\r\n            } finally {\r\n                s.close();\r\n            }\r\n        });\r\n        httpsServer.start();\r\n\r\n        SSLSocketFactory socketFactory = sslContext.getSocketFactory();\r\n        SSLSocket sslSocket = (SSLSocket)\r\n            socketFactory.createSocket(httpsServer.getAddress().getHostString(), httpsServer.getAddress().getPort());\r\n        sslSocket.addHandshakeCompletedListener(new HandshakeCompletedListener() {\r\n            @Override\r\n            public void handshakeCompleted(HandshakeCompletedEvent event) {\r\n                System.out.println(\"handshake of initial socket completed with session: \" + event.getSession());\r\n            }\r\n        });\r\n\r\n        sslSocket.startHandshake();\r\n        final String httpGetLine = \"GET / HTTP/1.1\\r\\n\\r\\n\";\r\n        OutputStream os = sslSocket.getOutputStream();\r\n        os.write(httpGetLine.getBytes(StandardCharsets.UTF_8));\r\n        BufferedReader reader = new BufferedReader(new InputStreamReader(sslSocket.getInputStream(), StandardCharsets.UTF_8));\r\n        // only read the first line before closing, but if all lines are read the issue doesn't happen\r\n        System.out.println(reader.readLine());\r\n\r\n        try {\r\n            try {\r\n                try {\r\n                    sslSocket.shutdownOutput();\r\n                } catch (final IOException e) {\r\n                    System.out.println(\"exception while shutting down output: \");\r\n                    e.printStackTrace();\r\n                }\r\n                try {\r\n                    sslSocket.shutdownInput();\r\n                } catch (final IOException e) {\r\n                    System.out.println(\"exception while shutting down input: \");\r\n                    e.printStackTrace();\r\n                }\r\n            } catch (final UnsupportedOperationException ignore) {\r\n                // if one isn't supported, the other one isn't either\r\n            }\r\n        } finally {\r\n            sslSocket.close();\r\n        }\r\n\r\n        sslSocket = (SSLSocket)\r\n            socketFactory.createSocket(httpsServer.getAddress().getHostString(), httpsServer.getAddress().getPort());\r\n        sslSocket.addHandshakeCompletedListener(new HandshakeCompletedListener() {\r\n            @Override\r\n            public void handshakeCompleted(HandshakeCompletedEvent event) {\r\n                System.out.println(\"handshake of second socket completed with session: \" + event.getSession());\r\n            }\r\n        });\r\n\r\n        // never get past here!\r\n        sslSocket.startHandshake();\r\n\r\n        sslSocket.close();\r\n        httpsServer.stop(0);\r\n    }\r\n\r\n    private static SSLContext getSSLContext() throws Exception {\r\n        KeyStore keyStore = KeyStore.getInstance(\"JKS\");\r\n        try (InputStream is = HttpsServerEndlessLoop.class.getResourceAsStream(\"/test.jks\")) {\r\n            keyStore.load(is, \"test\".toCharArray());\r\n        }\r\n        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\r\n        keyManagerFactory.init(keyStore, \"test\".toCharArray());\r\n        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\r\n        trustManagerFactory.init(keyStore);\r\n\r\n        SSLContext sslContext = SSLContext.getInstance(\"TLSv1.3\");\r\n        sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), null);\r\n        return sslContext;\r\n    }\r\n}\r\n```\r\n\r\n\r\n</details>\r\n","closed_by":{"login":"jaymode","id":4339958,"node_id":"MDQ6VXNlcjQzMzk5NTg=","avatar_url":"https://avatars1.githubusercontent.com/u/4339958?v=4","gravatar_id":"","url":"https://api.github.com/users/jaymode","html_url":"https://github.com/jaymode","followers_url":"https://api.github.com/users/jaymode/followers","following_url":"https://api.github.com/users/jaymode/following{/other_user}","gists_url":"https://api.github.com/users/jaymode/gists{/gist_id}","starred_url":"https://api.github.com/users/jaymode/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jaymode/subscriptions","organizations_url":"https://api.github.com/users/jaymode/orgs","repos_url":"https://api.github.com/users/jaymode/repos","events_url":"https://api.github.com/users/jaymode/events{/privacy}","received_events_url":"https://api.github.com/users/jaymode/received_events","type":"User","site_admin":false},"performed_via_github_app":null}