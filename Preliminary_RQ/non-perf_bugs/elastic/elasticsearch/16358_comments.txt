[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/186947393","html_url":"https://github.com/elastic/elasticsearch/issues/16358#issuecomment-186947393","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/16358","id":186947393,"node_id":"MDEyOklzc3VlQ29tbWVudDE4Njk0NzM5Mw==","user":{"login":"bleskes","id":1006375,"node_id":"MDQ6VXNlcjEwMDYzNzU=","avatar_url":"https://avatars1.githubusercontent.com/u/1006375?v=4","gravatar_id":"","url":"https://api.github.com/users/bleskes","html_url":"https://github.com/bleskes","followers_url":"https://api.github.com/users/bleskes/followers","following_url":"https://api.github.com/users/bleskes/following{/other_user}","gists_url":"https://api.github.com/users/bleskes/gists{/gist_id}","starred_url":"https://api.github.com/users/bleskes/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bleskes/subscriptions","organizations_url":"https://api.github.com/users/bleskes/orgs","repos_url":"https://api.github.com/users/bleskes/repos","events_url":"https://api.github.com/users/bleskes/events{/privacy}","received_events_url":"https://api.github.com/users/bleskes/received_events","type":"User","site_admin":false},"created_at":"2016-02-21T23:52:43Z","updated_at":"2016-02-21T23:52:43Z","author_association":"MEMBER","body":"Discussing the cause issue (index delete while node is off the cluster) I think we should consider this in a different way, which may help in the normal use case (non-shared FS) as well.  Dangling indices are added as a safety guard against the case where a cluster goes down (or the master nodes) and because of mis configuration or because of bad operation practices (kill all masters, start fresh ones with a different data folders). In these cases the new master publishes a cluster state which is empty and we don't want to delete the data. These days we have a cluster UUID as part of the cluster meta data. That uuid is created once and never change in the duration of the cluster.  That means that we can detect deletion while node left if:\n\n1) Store the cluster uuid in the index meta data, so we know the cluster this index belongs to.\n2) When a node gets a cluster state from a master and it doesn't contain the index it has on disk, the node can check whether the index used to be belong to the same cluster (by uuid) . If it is, we know it's deleted.\n3) If the uuid in the index is different than the uuid in the cluster, we import it.\n\nHow does this sound?\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/186961890","html_url":"https://github.com/elastic/elasticsearch/issues/16358#issuecomment-186961890","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/16358","id":186961890,"node_id":"MDEyOklzc3VlQ29tbWVudDE4Njk2MTg5MA==","user":{"login":"dakrone","id":19060,"node_id":"MDQ6VXNlcjE5MDYw","avatar_url":"https://avatars3.githubusercontent.com/u/19060?v=4","gravatar_id":"","url":"https://api.github.com/users/dakrone","html_url":"https://github.com/dakrone","followers_url":"https://api.github.com/users/dakrone/followers","following_url":"https://api.github.com/users/dakrone/following{/other_user}","gists_url":"https://api.github.com/users/dakrone/gists{/gist_id}","starred_url":"https://api.github.com/users/dakrone/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dakrone/subscriptions","organizations_url":"https://api.github.com/users/dakrone/orgs","repos_url":"https://api.github.com/users/dakrone/repos","events_url":"https://api.github.com/users/dakrone/events{/privacy}","received_events_url":"https://api.github.com/users/dakrone/received_events","type":"User","site_admin":false},"created_at":"2016-02-22T01:31:46Z","updated_at":"2016-02-22T01:31:46Z","author_association":"MEMBER","body":"> How does this sound?\n\nI think this sounds great!\n","performed_via_github_app":null}]