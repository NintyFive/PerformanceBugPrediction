[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/290395060","html_url":"https://github.com/elastic/elasticsearch/issues/23818#issuecomment-290395060","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/23818","id":290395060,"node_id":"MDEyOklzc3VlQ29tbWVudDI5MDM5NTA2MA==","user":{"login":"jpountz","id":299848,"node_id":"MDQ6VXNlcjI5OTg0OA==","avatar_url":"https://avatars2.githubusercontent.com/u/299848?v=4","gravatar_id":"","url":"https://api.github.com/users/jpountz","html_url":"https://github.com/jpountz","followers_url":"https://api.github.com/users/jpountz/followers","following_url":"https://api.github.com/users/jpountz/following{/other_user}","gists_url":"https://api.github.com/users/jpountz/gists{/gist_id}","starred_url":"https://api.github.com/users/jpountz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jpountz/subscriptions","organizations_url":"https://api.github.com/users/jpountz/orgs","repos_url":"https://api.github.com/users/jpountz/repos","events_url":"https://api.github.com/users/jpountz/events{/privacy}","received_events_url":"https://api.github.com/users/jpountz/received_events","type":"User","site_admin":false},"created_at":"2017-03-30T12:25:32Z","updated_at":"2017-03-30T12:25:32Z","author_association":"CONTRIBUTOR","body":"It does not mean that nothing should be done, but I can see some similarities with the `significant_terms` aggregation, since this is looking at things that occur significantly more in a foreground set than in a background set.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/290397627","html_url":"https://github.com/elastic/elasticsearch/issues/23818#issuecomment-290397627","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/23818","id":290397627,"node_id":"MDEyOklzc3VlQ29tbWVudDI5MDM5NzYyNw==","user":{"login":"skearns64","id":1406684,"node_id":"MDQ6VXNlcjE0MDY2ODQ=","avatar_url":"https://avatars1.githubusercontent.com/u/1406684?v=4","gravatar_id":"","url":"https://api.github.com/users/skearns64","html_url":"https://github.com/skearns64","followers_url":"https://api.github.com/users/skearns64/followers","following_url":"https://api.github.com/users/skearns64/following{/other_user}","gists_url":"https://api.github.com/users/skearns64/gists{/gist_id}","starred_url":"https://api.github.com/users/skearns64/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/skearns64/subscriptions","organizations_url":"https://api.github.com/users/skearns64/orgs","repos_url":"https://api.github.com/users/skearns64/repos","events_url":"https://api.github.com/users/skearns64/events{/privacy}","received_events_url":"https://api.github.com/users/skearns64/received_events","type":"User","site_admin":false},"created_at":"2017-03-30T12:37:30Z","updated_at":"2017-03-30T12:37:30Z","author_association":"CONTRIBUTOR","body":"I've done similar things for low cardinality fields (low-mid hundreds of distinct values). Applying the use-case to data representing \"running processes on a server captured from metricbeat,\" I defined the problem as \"alert me when there is a process name that has been seen in the last hour, that wasn't seen in the previous 30 days\". \r\nIt's not a scalable solution, but I used an approach with a terms agg -> date range filter with 2 filters: (now to now-1h and now-1h to now-90d). Then used a simple script in Watcher to check for terms that had hits in the last hour, but not the prior 90 days. This approach requires that you have the terms agg returning all value, which is why this only works for really low-cardinality fields, and isn't a good solution for most cases.\r\n\r\nI would have happily used an aggregation like the one described here instead of my hacky approach.\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/290398511","html_url":"https://github.com/elastic/elasticsearch/issues/23818#issuecomment-290398511","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/23818","id":290398511,"node_id":"MDEyOklzc3VlQ29tbWVudDI5MDM5ODUxMQ==","user":{"login":"gingerwizard","id":12695796,"node_id":"MDQ6VXNlcjEyNjk1Nzk2","avatar_url":"https://avatars0.githubusercontent.com/u/12695796?v=4","gravatar_id":"","url":"https://api.github.com/users/gingerwizard","html_url":"https://github.com/gingerwizard","followers_url":"https://api.github.com/users/gingerwizard/followers","following_url":"https://api.github.com/users/gingerwizard/following{/other_user}","gists_url":"https://api.github.com/users/gingerwizard/gists{/gist_id}","starred_url":"https://api.github.com/users/gingerwizard/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/gingerwizard/subscriptions","organizations_url":"https://api.github.com/users/gingerwizard/orgs","repos_url":"https://api.github.com/users/gingerwizard/repos","events_url":"https://api.github.com/users/gingerwizard/events{/privacy}","received_events_url":"https://api.github.com/users/gingerwizard/received_events","type":"User","site_admin":false},"created_at":"2017-03-30T12:41:17Z","updated_at":"2017-03-30T12:41:22Z","author_association":"NONE","body":"@skearns64 yes the approach you describe works for low cardinality fields. The approach outlined above (two stage query execution) discussed with @clintongormley works better for higher cardinality fields in theory - and is thus more scalable - provided the matching set is low.  ","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/317061802","html_url":"https://github.com/elastic/elasticsearch/issues/23818#issuecomment-317061802","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/23818","id":317061802,"node_id":"MDEyOklzc3VlQ29tbWVudDMxNzA2MTgwMg==","user":{"login":"nirmalc","id":3236895,"node_id":"MDQ6VXNlcjMyMzY4OTU=","avatar_url":"https://avatars2.githubusercontent.com/u/3236895?v=4","gravatar_id":"","url":"https://api.github.com/users/nirmalc","html_url":"https://github.com/nirmalc","followers_url":"https://api.github.com/users/nirmalc/followers","following_url":"https://api.github.com/users/nirmalc/following{/other_user}","gists_url":"https://api.github.com/users/nirmalc/gists{/gist_id}","starred_url":"https://api.github.com/users/nirmalc/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/nirmalc/subscriptions","organizations_url":"https://api.github.com/users/nirmalc/orgs","repos_url":"https://api.github.com/users/nirmalc/repos","events_url":"https://api.github.com/users/nirmalc/events{/privacy}","received_events_url":"https://api.github.com/users/nirmalc/received_events","type":"User","site_admin":false},"created_at":"2017-07-21T17:25:02Z","updated_at":"2017-07-21T17:25:02Z","author_association":"CONTRIBUTOR","body":"To find exclusive terms , my approach was to patch significant_terms as @jpountz  suggests here. Added a \"min_score\" and \"max_score\" in Percentage heuristics . min_score: 1.0 would result in \"distinct\" terms.\r\n\r\nhttps://github.com/nirmalc/elasticsearch/commit/6e2272503557046f4a89737998a953546c43205c\r\n\r\nI can submit a PR if this approach makes sense.\r\n\r\n```\r\ncurl -H \"Content-type: application/json\" -XPOST localhost:9200/_search?pretty=true  -d '{ \"query\" : { \"term\" : { \"fred\": \"t32\"} }, \"aggs\" : { \"test\": { \"significant_terms\": { \"field\" : \"fred.keyword\" , \"min_doc_count\" : 1, \"percentage\" : { \"min_score\" : 1 } }}}}'\r\n```","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/319720991","html_url":"https://github.com/elastic/elasticsearch/issues/23818#issuecomment-319720991","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/23818","id":319720991,"node_id":"MDEyOklzc3VlQ29tbWVudDMxOTcyMDk5MQ==","user":{"login":"nirmalc","id":3236895,"node_id":"MDQ6VXNlcjMyMzY4OTU=","avatar_url":"https://avatars2.githubusercontent.com/u/3236895?v=4","gravatar_id":"","url":"https://api.github.com/users/nirmalc","html_url":"https://github.com/nirmalc","followers_url":"https://api.github.com/users/nirmalc/followers","following_url":"https://api.github.com/users/nirmalc/following{/other_user}","gists_url":"https://api.github.com/users/nirmalc/gists{/gist_id}","starred_url":"https://api.github.com/users/nirmalc/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/nirmalc/subscriptions","organizations_url":"https://api.github.com/users/nirmalc/orgs","repos_url":"https://api.github.com/users/nirmalc/repos","events_url":"https://api.github.com/users/nirmalc/events{/privacy}","received_events_url":"https://api.github.com/users/nirmalc/received_events","type":"User","site_admin":false},"created_at":"2017-08-02T16:12:12Z","updated_at":"2017-08-02T16:12:12Z","author_association":"CONTRIBUTOR","body":"submitted PR as it may be useful in some cases  to have min/max  ","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/372628254","html_url":"https://github.com/elastic/elasticsearch/issues/23818#issuecomment-372628254","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/23818","id":372628254,"node_id":"MDEyOklzc3VlQ29tbWVudDM3MjYyODI1NA==","user":{"login":"colings86","id":236731,"node_id":"MDQ6VXNlcjIzNjczMQ==","avatar_url":"https://avatars0.githubusercontent.com/u/236731?v=4","gravatar_id":"","url":"https://api.github.com/users/colings86","html_url":"https://github.com/colings86","followers_url":"https://api.github.com/users/colings86/followers","following_url":"https://api.github.com/users/colings86/following{/other_user}","gists_url":"https://api.github.com/users/colings86/gists{/gist_id}","starred_url":"https://api.github.com/users/colings86/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/colings86/subscriptions","organizations_url":"https://api.github.com/users/colings86/orgs","repos_url":"https://api.github.com/users/colings86/repos","events_url":"https://api.github.com/users/colings86/events{/privacy}","received_events_url":"https://api.github.com/users/colings86/received_events","type":"User","site_admin":false},"created_at":"2018-03-13T11:05:18Z","updated_at":"2018-03-13T11:05:18Z","author_association":"MEMBER","body":"@elastic/es-search-aggs ","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/394507385","html_url":"https://github.com/elastic/elasticsearch/issues/23818#issuecomment-394507385","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/23818","id":394507385,"node_id":"MDEyOklzc3VlQ29tbWVudDM5NDUwNzM4NQ==","user":{"login":"polyfractal","id":1224228,"node_id":"MDQ6VXNlcjEyMjQyMjg=","avatar_url":"https://avatars1.githubusercontent.com/u/1224228?v=4","gravatar_id":"","url":"https://api.github.com/users/polyfractal","html_url":"https://github.com/polyfractal","followers_url":"https://api.github.com/users/polyfractal/followers","following_url":"https://api.github.com/users/polyfractal/following{/other_user}","gists_url":"https://api.github.com/users/polyfractal/gists{/gist_id}","starred_url":"https://api.github.com/users/polyfractal/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/polyfractal/subscriptions","organizations_url":"https://api.github.com/users/polyfractal/orgs","repos_url":"https://api.github.com/users/polyfractal/repos","events_url":"https://api.github.com/users/polyfractal/events{/privacy}","received_events_url":"https://api.github.com/users/polyfractal/received_events","type":"User","site_admin":false},"created_at":"2018-06-04T21:35:25Z","updated_at":"2018-06-04T21:35:33Z","author_association":"MEMBER","body":"This could probably be done (somewhat) scalably, in a single-pass fashion using a set and a bloom filter. \r\n\r\nRough algo:\r\n\r\n1. Query decides if the doc matches the criteria or not.  \r\n  a. If matches, add to bloom filter, remove from set if it exists\r\n  b. If doesn't match, check if it is in bloom filter, if not add to set\r\n\r\nAnd that's it.  At the end, the set of terms are the terms that are _likely_ not in the set that matched the query.  It gives you the approximate right outer join, but because of the bloom filter semantics it may be missing some terms.\r\n\r\nMight be more complicated than that to work with depth_ vs breadth_first, but that's the general idea.\r\n\r\nMemory requirements are a bit dicier, being bloom size + size of set.  Would be fairly easy to limit however (bloom size is known, hard cap on set size).\r\n\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/665756287","html_url":"https://github.com/elastic/elasticsearch/issues/23818#issuecomment-665756287","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/23818","id":665756287,"node_id":"MDEyOklzc3VlQ29tbWVudDY2NTc1NjI4Nw==","user":{"login":"polyfractal","id":1224228,"node_id":"MDQ6VXNlcjEyMjQyMjg=","avatar_url":"https://avatars1.githubusercontent.com/u/1224228?v=4","gravatar_id":"","url":"https://api.github.com/users/polyfractal","html_url":"https://github.com/polyfractal","followers_url":"https://api.github.com/users/polyfractal/followers","following_url":"https://api.github.com/users/polyfractal/following{/other_user}","gists_url":"https://api.github.com/users/polyfractal/gists{/gist_id}","starred_url":"https://api.github.com/users/polyfractal/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/polyfractal/subscriptions","organizations_url":"https://api.github.com/users/polyfractal/orgs","repos_url":"https://api.github.com/users/polyfractal/repos","events_url":"https://api.github.com/users/polyfractal/events{/privacy}","received_events_url":"https://api.github.com/users/polyfractal/received_events","type":"User","site_admin":false},"created_at":"2020-07-29T16:08:20Z","updated_at":"2020-07-29T16:08:20Z","author_association":"MEMBER","body":"We're going to close this since there hasn't been much interest over the years.  We did have a chat, and it might be possible to implement either A) as I suggested above, or B) by tweaking sig-terms agg to \"threshold\" background frequencies.  I.e. if a term has zero frequency in the background set but positive in the foreground, it would satisfy the request.\r\n\r\nWe're not sure if it's worth pursuing so closing for now... but happy to re-open if we find more support for such a feature :)","performed_via_github_app":null}]