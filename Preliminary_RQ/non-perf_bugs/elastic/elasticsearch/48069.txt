{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/48069","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/48069/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/48069/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/48069/events","html_url":"https://github.com/elastic/elasticsearch/issues/48069","id":507318242,"node_id":"MDU6SXNzdWU1MDczMTgyNDI=","number":48069,"title":"Metric Selector aggregation","user":{"login":"polyfractal","id":1224228,"node_id":"MDQ6VXNlcjEyMjQyMjg=","avatar_url":"https://avatars1.githubusercontent.com/u/1224228?v=4","gravatar_id":"","url":"https://api.github.com/users/polyfractal","html_url":"https://github.com/polyfractal","followers_url":"https://api.github.com/users/polyfractal/followers","following_url":"https://api.github.com/users/polyfractal/following{/other_user}","gists_url":"https://api.github.com/users/polyfractal/gists{/gist_id}","starred_url":"https://api.github.com/users/polyfractal/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/polyfractal/subscriptions","organizations_url":"https://api.github.com/users/polyfractal/orgs","repos_url":"https://api.github.com/users/polyfractal/repos","events_url":"https://api.github.com/users/polyfractal/events{/privacy}","received_events_url":"https://api.github.com/users/polyfractal/received_events","type":"User","site_admin":false},"labels":[{"id":141141324,"node_id":"MDU6TGFiZWwxNDExNDEzMjQ=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/:Analytics/Aggregations","name":":Analytics/Aggregations","color":"0e8a16","default":false,"description":"Aggregations"},{"id":23172,"node_id":"MDU6TGFiZWwyMzE3Mg==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/%3Efeature","name":">feature","color":"006b75","default":false,"description":null}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":2,"created_at":"2019-10-15T15:22:49Z","updated_at":"2020-02-14T12:13:53Z","closed_at":"2020-02-14T12:13:53Z","author_association":"MEMBER","active_lock_reason":null,"body":"I'd like to propose an aggregation that \"selects\" a metric from a document according to some kind of ordering criteria on a second field.  For example, you may want the most recent latency value within a date_histogram bucket: in this case, the \"metric\" is the `latency` field, and the ordering criteria is `timestamp DESC, size: 1`.  \r\n\r\nThis is a fairly common use-case which is difficult to accomplish today.  `top_hits` can give you the information, but it fetches an entire document and is not compatible with pipeline aggregations.  It is also fairly expensive if many values/documents are being fetched.  You can sometimes get the required information with clever usages of other aggs (like a `max` agg, or scripting) to pull out the document you're looking for, but they are fragile and hacky approaches.\r\n\r\nThe WeightedAvg agg added support for multiple ValuesSources, so a \"metric selector\" should not be too difficult to implement.\r\n\r\nAll naming is tentative, open to better suggestions! :)\r\n\r\n### Request Syntax\r\n```js\r\nGET _search\r\n{\r\n  \"aggs\": {\r\n    \"timeline\": {\r\n      \"date_histogram\": {\r\n        \"field\": \"date\",\r\n        \"calendar_interval\": \"hour\"\r\n      },\r\n      \"aggs\": {\r\n        \"most_recent\": {\r\n          \"metric_selector\": {\r\n            \"metric\": {\r\n              \"field\": \"latency\",\r\n              // \"script\": ...\r\n              // \"format\": ...,\r\n              // \"value_type\": ...\r\n            },\r\n            \"sort\": {\r\n              \"field\": \"date\",\r\n              // \"script\": ...\r\n              // \"format\": ...,\r\n              // \"value_type\": ...\r\n            },\r\n            \"order\": \"asc | desc\",\r\n            \"size\": 1,\r\n            \"multi_value_mode\": \"min | max | sum | avg\"\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n| Parameter  | Description | |\r\n| ------------- | ------------- | ------------- |\r\n| `metric`  | The metric field that we wish to extract from a document  | Required |\r\n| `sort`  | The field that we wish to sort and select the `metric` by | Required |\r\n| `order`  | How we should order the `sort` field? Ascending or descending | Required |\r\n| `size`  | The number of `<sort, metric>` tuples that should be returned | Optional, default: `1` |\r\n| `multi_value_mode`  | How should multi-valued `metric` fields be collapsed into a single value? |  Optional: default `avg` |\r\n\r\n### Response\r\n\r\n```json\r\n{\r\n  \"aggregations\" : {\r\n    \"timeline\" : {\r\n      \"buckets\" : [\r\n        {\r\n          \"key_as_string\" : \"2019-01-01T05:00:00.000Z\",\r\n          \"key\" : 1546318800000,\r\n          \"doc_count\" : 3,\r\n          \"most_recent\" : [\r\n            {\r\n              \"sort\": 1546340340000,\r\n              \"sort_as_string\": \"2019-01-01T05:59:00.000Z\",\r\n              \"value\": 123\r\n            },\r\n            {\r\n              \"sort\": 1546338600000,\r\n              \"sort\": \"2019-01-01T05:30:00.000Z\",\r\n              \"value\": 19\r\n            }\r\n          ]\r\n        },\r\n        {\r\n          \"key_as_string\" : \"2019-01-01T06:00:00.000Z\",\r\n          \"key\" : 1546322400000,\r\n          \"doc_count\" : 1,\r\n          \"most_recent\" : [\r\n            {\r\n              \"sort\": 1546341000000,\r\n              \"sort\": \"2019-01-01T06:10:00.000Z\",\r\n              \"value\": 9999\r\n            },\r\n            {\r\n              \"sort\": 1546340700000,\r\n              \"sort\": \"2019-01-01T06:05:00.000Z\",\r\n              \"value\": 2233\r\n            }\r\n          ]\r\n        }\r\n      ]\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nNote how the `sort` values are ordered descending per-bucket, and it returns a single metric value for each sort value.  There may be 1000 documents in a bucket, but unlike other aggregations this actually returns `n` individual values from the documents themselves.  If there are ties, there would be multiple objects with the same `sort`.\r\n\r\n### Misc\r\n\r\n- I have a [crude prototype](https://github.com/polyfractal/elasticsearch/commit/02996899ad7ea6adbf0014a4e7e7c2f7682a94ea) which demonstrates the feasibility.\r\n- We will need some kind of limit on `size` to prevent abuses.  It should be fairly easy to track in a breaker, so that might be sufficient.  I would feel better if there was a hard/soft limit though :)  Like top_hits, this should be used to fetch a handful of values not an entire index\r\n- We should support sorting on non-numeric fields too (`keyword`, etc).\r\n- I'm less sure we need to support non-numeric metrics.  I think starting with numerics-only is fine\r\n- We can probably optimize the no-parent scenario with a BKD lookup similar to how min/max work today.  Not necessary for the first iteration\r\n- As long as we only support `asc`/`desc` (e.g. the min or max values of a field), we shouldn't run into top-n accuracy issues like `terms` agg can have.  Each shard will always send it's `n` min/max values and the coordinator will assemble a global min/max list.  It might be that all top `n` values have the same sort key and others are omitted, but this is not incorrect since we are displaying individual results and not grouping.\r\n\r\n/cc @costin @colings86 ","closed_by":{"login":"nik9000","id":215970,"node_id":"MDQ6VXNlcjIxNTk3MA==","avatar_url":"https://avatars2.githubusercontent.com/u/215970?v=4","gravatar_id":"","url":"https://api.github.com/users/nik9000","html_url":"https://github.com/nik9000","followers_url":"https://api.github.com/users/nik9000/followers","following_url":"https://api.github.com/users/nik9000/following{/other_user}","gists_url":"https://api.github.com/users/nik9000/gists{/gist_id}","starred_url":"https://api.github.com/users/nik9000/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/nik9000/subscriptions","organizations_url":"https://api.github.com/users/nik9000/orgs","repos_url":"https://api.github.com/users/nik9000/repos","events_url":"https://api.github.com/users/nik9000/events{/privacy}","received_events_url":"https://api.github.com/users/nik9000/received_events","type":"User","site_admin":false},"performed_via_github_app":null}