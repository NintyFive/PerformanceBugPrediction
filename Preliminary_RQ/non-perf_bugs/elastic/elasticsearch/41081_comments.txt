[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/481880188","html_url":"https://github.com/elastic/elasticsearch/issues/41081#issuecomment-481880188","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/41081","id":481880188,"node_id":"MDEyOklzc3VlQ29tbWVudDQ4MTg4MDE4OA==","user":{"login":"elasticmachine","id":15837671,"node_id":"MDQ6VXNlcjE1ODM3Njcx","avatar_url":"https://avatars3.githubusercontent.com/u/15837671?v=4","gravatar_id":"","url":"https://api.github.com/users/elasticmachine","html_url":"https://github.com/elasticmachine","followers_url":"https://api.github.com/users/elasticmachine/followers","following_url":"https://api.github.com/users/elasticmachine/following{/other_user}","gists_url":"https://api.github.com/users/elasticmachine/gists{/gist_id}","starred_url":"https://api.github.com/users/elasticmachine/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/elasticmachine/subscriptions","organizations_url":"https://api.github.com/users/elasticmachine/orgs","repos_url":"https://api.github.com/users/elasticmachine/repos","events_url":"https://api.github.com/users/elasticmachine/events{/privacy}","received_events_url":"https://api.github.com/users/elasticmachine/received_events","type":"User","site_admin":false},"created_at":"2019-04-10T21:49:27Z","updated_at":"2019-04-10T21:49:27Z","author_association":"COLLABORATOR","body":"Pinging @elastic/es-distributed","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/486281243","html_url":"https://github.com/elastic/elasticsearch/issues/41081#issuecomment-486281243","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/41081","id":486281243,"node_id":"MDEyOklzc3VlQ29tbWVudDQ4NjI4MTI0Mw==","user":{"login":"dnhatn","id":13474362,"node_id":"MDQ6VXNlcjEzNDc0MzYy","avatar_url":"https://avatars3.githubusercontent.com/u/13474362?v=4","gravatar_id":"","url":"https://api.github.com/users/dnhatn","html_url":"https://github.com/dnhatn","followers_url":"https://api.github.com/users/dnhatn/followers","following_url":"https://api.github.com/users/dnhatn/following{/other_user}","gists_url":"https://api.github.com/users/dnhatn/gists{/gist_id}","starred_url":"https://api.github.com/users/dnhatn/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dnhatn/subscriptions","organizations_url":"https://api.github.com/users/dnhatn/orgs","repos_url":"https://api.github.com/users/dnhatn/repos","events_url":"https://api.github.com/users/dnhatn/events{/privacy}","received_events_url":"https://api.github.com/users/dnhatn/received_events","type":"User","site_admin":false},"created_at":"2019-04-24T15:04:57Z","updated_at":"2019-04-24T15:04:57Z","author_association":"MEMBER","body":"Thanks very much for your interest in Elasticsearch.\r\n\r\nThe proposing option can make translog unrecoverable in a scenario where the checkpoint is fsynced but the content file. With the new option, after a write operation is processed, we (1) append an operation to the content file, (2) flush the content file, (3) update and flush the checkpoint (write a new file then rename it). If operating system fsync the checkpoint then crashes before it can persist the content file then translog is broken. The problem is that OS can freely choose to fsync the checkpoint before the content file regardless of the flushing order.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/487017712","html_url":"https://github.com/elastic/elasticsearch/issues/41081#issuecomment-487017712","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/41081","id":487017712,"node_id":"MDEyOklzc3VlQ29tbWVudDQ4NzAxNzcxMg==","user":{"login":"itiyamas","id":45985097,"node_id":"MDQ6VXNlcjQ1OTg1MDk3","avatar_url":"https://avatars3.githubusercontent.com/u/45985097?v=4","gravatar_id":"","url":"https://api.github.com/users/itiyamas","html_url":"https://github.com/itiyamas","followers_url":"https://api.github.com/users/itiyamas/followers","following_url":"https://api.github.com/users/itiyamas/following{/other_user}","gists_url":"https://api.github.com/users/itiyamas/gists{/gist_id}","starred_url":"https://api.github.com/users/itiyamas/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/itiyamas/subscriptions","organizations_url":"https://api.github.com/users/itiyamas/orgs","repos_url":"https://api.github.com/users/itiyamas/repos","events_url":"https://api.github.com/users/itiyamas/events{/privacy}","received_events_url":"https://api.github.com/users/itiyamas/received_events","type":"User","site_admin":false},"created_at":"2019-04-26T10:59:17Z","updated_at":"2019-04-26T11:00:29Z","author_association":"NONE","body":"We can work out ways to implement it, given you agree with the overall idea. Please note that this is heavily dependent on the type of filesystem and OS. Hence, the new option shouldn't mention durability against JVM restarts, just that it doesn't do an fsync but ensures that the writes to page cache are successful.\r\n\r\nOne possible way to think about the implementation:\r\nWrite checkpoint to 2 files- the older one continues to be written the same way as earlier while the new one is written at the end of every request. The checkpoint stores the total number of operations and translog offset that is expected. During recovery, you ensure that translog is written up to that offset- else fallback to the periodically fsynced checkpoint file.\r\n\r\nI hope this will solve the problem for cases where filesystem ensures atomicity and consistency, leading to translog entries not being corrupted, but only lost- which can be easily verified by the offset in the file.\r\n\r\nBerkley DB gives similar guarantees: http://www.mathematik.uni-ulm.de/help/BerkeleyDB/api_c/env_set_flags.html\r\n\r\nCheck options: DB_TXN_NOSYNC(if the application or system fails ) and DB_TXN_WRITE_NOSYNC (if system fails)\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/487024213","html_url":"https://github.com/elastic/elasticsearch/issues/41081#issuecomment-487024213","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/41081","id":487024213,"node_id":"MDEyOklzc3VlQ29tbWVudDQ4NzAyNDIxMw==","user":{"login":"itiyamas","id":45985097,"node_id":"MDQ6VXNlcjQ1OTg1MDk3","avatar_url":"https://avatars3.githubusercontent.com/u/45985097?v=4","gravatar_id":"","url":"https://api.github.com/users/itiyamas","html_url":"https://github.com/itiyamas","followers_url":"https://api.github.com/users/itiyamas/followers","following_url":"https://api.github.com/users/itiyamas/following{/other_user}","gists_url":"https://api.github.com/users/itiyamas/gists{/gist_id}","starred_url":"https://api.github.com/users/itiyamas/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/itiyamas/subscriptions","organizations_url":"https://api.github.com/users/itiyamas/orgs","repos_url":"https://api.github.com/users/itiyamas/repos","events_url":"https://api.github.com/users/itiyamas/events{/privacy}","received_events_url":"https://api.github.com/users/itiyamas/received_events","type":"User","site_admin":false},"created_at":"2019-04-26T11:27:01Z","updated_at":"2019-04-26T11:27:01Z","author_association":"NONE","body":"Pinging @dnhatn ","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/487082248","html_url":"https://github.com/elastic/elasticsearch/issues/41081#issuecomment-487082248","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/41081","id":487082248,"node_id":"MDEyOklzc3VlQ29tbWVudDQ4NzA4MjI0OA==","user":{"login":"dnhatn","id":13474362,"node_id":"MDQ6VXNlcjEzNDc0MzYy","avatar_url":"https://avatars3.githubusercontent.com/u/13474362?v=4","gravatar_id":"","url":"https://api.github.com/users/dnhatn","html_url":"https://github.com/dnhatn","followers_url":"https://api.github.com/users/dnhatn/followers","following_url":"https://api.github.com/users/dnhatn/following{/other_user}","gists_url":"https://api.github.com/users/dnhatn/gists{/gist_id}","starred_url":"https://api.github.com/users/dnhatn/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dnhatn/subscriptions","organizations_url":"https://api.github.com/users/dnhatn/orgs","repos_url":"https://api.github.com/users/dnhatn/repos","events_url":"https://api.github.com/users/dnhatn/events{/privacy}","received_events_url":"https://api.github.com/users/dnhatn/received_events","type":"User","site_admin":false},"created_at":"2019-04-26T14:42:08Z","updated_at":"2019-04-26T14:42:08Z","author_association":"MEMBER","body":"> Write checkpoint to 2 files\r\n> else fallback to the periodically fsynced checkpoint file.\r\n\r\nThis approach is quite complicated and error-prone for we have to guess and recover the checkpoint.\r\n\r\nWe prefer to keep translog simple and easy to reasoning/test because it is crucial for the consistency and resiliency of the system. Therefore, I don't think this is the right direction at least for now.","performed_via_github_app":null}]