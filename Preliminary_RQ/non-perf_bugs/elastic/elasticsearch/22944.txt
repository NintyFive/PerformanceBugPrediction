{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/22944","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/22944/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/22944/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/22944/events","html_url":"https://github.com/elastic/elasticsearch/issues/22944","id":204999404,"node_id":"MDU6SXNzdWUyMDQ5OTk0MDQ=","number":22944,"title":"Layered aliases","user":{"login":"bra-fsn","id":820331,"node_id":"MDQ6VXNlcjgyMDMzMQ==","avatar_url":"https://avatars2.githubusercontent.com/u/820331?v=4","gravatar_id":"","url":"https://api.github.com/users/bra-fsn","html_url":"https://github.com/bra-fsn","followers_url":"https://api.github.com/users/bra-fsn/followers","following_url":"https://api.github.com/users/bra-fsn/following{/other_user}","gists_url":"https://api.github.com/users/bra-fsn/gists{/gist_id}","starred_url":"https://api.github.com/users/bra-fsn/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bra-fsn/subscriptions","organizations_url":"https://api.github.com/users/bra-fsn/orgs","repos_url":"https://api.github.com/users/bra-fsn/repos","events_url":"https://api.github.com/users/bra-fsn/events{/privacy}","received_events_url":"https://api.github.com/users/bra-fsn/received_events","type":"User","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":2,"created_at":"2017-02-02T21:19:48Z","updated_at":"2017-02-03T09:36:05Z","closed_at":"2017-02-03T09:01:05Z","author_association":"NONE","active_lock_reason":null,"body":"To help reindexing data in elasticsearch without downtime it would be good to have layered aliases.\r\nThis alias could have an index in the upper layer, which means if there is data in the upper layer, it always wins over the lower layer.\r\n\r\nIf index A is the lower layer and index B is the upper:\r\n- issuing a get to the alias would first check the doc in B -returning it if it's present- and if nothing was found, fall back to A\r\n- doing an index request to the alias would also first check the document's presence in B, then A and act accordingly (getting the modification always into B, leaving A untouched, assuming the reindex process won't overwrite the newly modified doc)\r\n- updating documents would behave the same: first check B, if nothing found, check A, if there is a doc, make the modifications and index it into B\r\n- deletes should be propagated to the lower layer too, so reindex won't reintroduce already deleted documents.\r\n\r\nWith this feature it would be possible to reindex indexes without any downtime by presenting an upper layer into an alias and start to reindex old data from A to B (leaving out already modified docs in B).","closed_by":{"login":"clintongormley","id":56599,"node_id":"MDQ6VXNlcjU2NTk5","avatar_url":"https://avatars0.githubusercontent.com/u/56599?v=4","gravatar_id":"","url":"https://api.github.com/users/clintongormley","html_url":"https://github.com/clintongormley","followers_url":"https://api.github.com/users/clintongormley/followers","following_url":"https://api.github.com/users/clintongormley/following{/other_user}","gists_url":"https://api.github.com/users/clintongormley/gists{/gist_id}","starred_url":"https://api.github.com/users/clintongormley/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/clintongormley/subscriptions","organizations_url":"https://api.github.com/users/clintongormley/orgs","repos_url":"https://api.github.com/users/clintongormley/repos","events_url":"https://api.github.com/users/clintongormley/events{/privacy}","received_events_url":"https://api.github.com/users/clintongormley/received_events","type":"User","site_admin":false},"performed_via_github_app":null}