{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/123","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/123/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/123/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/123/events","html_url":"https://github.com/elastic/elasticsearch/issues/123","id":166657,"node_id":"MDU6SXNzdWUxNjY2NTc=","number":123,"title":"multi_field not returning for default field for certain type","user":{"login":"tootedom","id":211070,"node_id":"MDQ6VXNlcjIxMTA3MA==","avatar_url":"https://avatars3.githubusercontent.com/u/211070?v=4","gravatar_id":"","url":"https://api.github.com/users/tootedom","html_url":"https://github.com/tootedom","followers_url":"https://api.github.com/users/tootedom/followers","following_url":"https://api.github.com/users/tootedom/following{/other_user}","gists_url":"https://api.github.com/users/tootedom/gists{/gist_id}","starred_url":"https://api.github.com/users/tootedom/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/tootedom/subscriptions","organizations_url":"https://api.github.com/users/tootedom/orgs","repos_url":"https://api.github.com/users/tootedom/repos","events_url":"https://api.github.com/users/tootedom/events{/privacy}","received_events_url":"https://api.github.com/users/tootedom/received_events","type":"User","site_admin":false},"labels":[{"id":23173,"node_id":"MDU6TGFiZWwyMzE3Mw==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/%3Ebug","name":">bug","color":"b60205","default":false,"description":null},{"id":29489,"node_id":"MDU6TGFiZWwyOTQ4OQ==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/v0.07.0","name":"v0.07.0","color":"DDDDDD","default":false,"description":null}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":1,"created_at":"2010-04-07T11:20:40Z","updated_at":"2010-04-07T14:11:17Z","closed_at":"2010-04-07T14:11:17Z","author_association":"NONE","active_lock_reason":null,"body":"Background to this is issue is discussed here\n\nhttp://groups.google.com/a/elasticsearch.com/group/users/browse_thread/thread/3e20079f0225b531/978c64ecbb017adf#978c64ecbb017adf\n\nWhat seems to be happening is that the for the default field in a multi_field type, doesn't seem to hit the appropriate JsonFieldMapper for the type in question (or so I what appears to be happening when attempting to breakpoint debug it).\n\nSo taking the following two mappings, for the date and string type:\n- /integration-test-multifield-date-mapping.json\n\n<pre>\n    {\n        \"datetest\" : {\n            \"properties\" : {\n                \"date\" : {\n                    \"type\" : \"multi_field\",\n                    \"fields\" : {\n                        \"date\" : { type : \"date\", index : \"analyzed\" },            \n                        \"orig\" : { type : \"date\", index : \"analyzed\" },                     \n                        \"untouched\" : {type: \"date\",index : \"not_analyzed\"}\n                    }\n                }\n            }\n        }\n    }\n</pre>\n\n- /integration-test-multifield-string-mapping.json\n\n<pre>\n    {\n        \"stringtest\" : {\n            \"properties\" : {\n                \"string\" : {\n                    \"type\" : \"multi_field\",\n                    \"fields\" : {\n                        \"string\" : { type : \"string\", index : \"analyzed\" },            \n                        \"orig\" : { type : \"string\", index : \"analyzed\" },                     \n                        \"untouched\" : {type: \"string\", index : \"not_analyzed\"}\n                    }\n                }\n            }\n        }\n    }\n</pre>\n\n\nand the following code:\n\nSetup of test (it's in junit):\n\n<pre>\n    private final Logger logger = Loggers.getLogger(getClass());\n\n    private static Server server;\n\n        @BeforeClass\n    public static void setupServer() {\n        server = serverBuilder().settings(\n                settingsBuilder().put(\"node.local\", true)).server();\n    }\n\n    @AfterClass\n    public static void closeServer() {\n        server.close();\n    }\n\n    @Before\n    public void createIndex() {\n        logger.info(\"creating index [test]\");\n        server.client().admin().indices().create(\n                createIndexRequest(\"test\").settings(\n                        settingsBuilder().put(\"index.numberOfReplicas\", 0).put(\n                                \"index.numberOfShards\", 1))).actionGet();\n        logger.info(\"Running Cluster Health\");\n        ClusterHealthResponse clusterHealth = server.client().admin().cluster()\n                .health(clusterHealth().waitForGreenStatus()).actionGet();\n        logger.info(\"Done Cluster Health, status \" + clusterHealth.status());\n        assertThat(clusterHealth.timedOut(), equalTo(false));\n        assertThat(clusterHealth.status(), equalTo(ClusterHealthStatus.GREEN));\n    }\n\n    @After\n    public void deleteIndex() {\n        logger.info(\"deleting index [test]\");\n        server.client().admin().indices().delete(deleteIndexRequest(\"test\"))\n                .actionGet();\n    }\n    \n</pre>\n\n\nThe two test methods:\n- String\n\n<pre>\n        @Test\n    public void typeStringMultiFieldTest() throws IOException\n    {\n    \n        String mapping = copyToStringFromClasspath(\"/integration-test-multifield-string-mapping.json\");\n        System.out.println(\"Mapping:\");\n        System.out.println(\"========\");\n        System.out.println(mapping);\n        String val = \"20100406\";\n        \n        server.client().admin().indices().putMapping(putMappingRequest(\"test\").mappingSource(mapping)).actionGet();\n\n        server.client().index(indexRequest(\"test\").type(\"stringtest\").id(\"1\")\n                .source(jsonBuilder().startObject().field(\"string\", val).endObject())).actionGet();\n        \n        server.client().admin().indices().refresh(refreshRequest()).actionGet();\n       \n        CountResponse countResponse1 = server.client().count(countRequest(\"test\").querySource(fieldQuery(\"string\", val))).actionGet();\n        System.out.println(\"string:\" + countResponse1.count());\n            \n        CountResponse countResponse2 = server.client().count(countRequest(\"test\").querySource(fieldQuery(\"string.string\", val))).actionGet();\n        System.out.println(\"string.string:\" + countResponse2.count());\n\n        CountResponse countResponse4 = server.client().count(countRequest(\"test\").querySource(fieldQuery(\"string.orig\", val))).actionGet();\n        System.out.println(\"string.orig:\" + countResponse4.count());\n        \n        CountResponse countResponse3 = server.client().count(countRequest(\"test\").querySource(fieldQuery(\"string.untouched\", val))).actionGet();\n        System.out.println(\"string.untouched:\" + countResponse3.count());\n            \n\n        \n    }\n</pre>\n\n- Date test\n\n<pre>\n    @Test\n    public void typeDateMultiFieldTest() throws IOException\n    {\n    \n        String mapping = copyToStringFromClasspath(\"/integration-test-multifield-date-mapping.json\");\n        System.out.println(\"Mapping:\");\n        System.out.println(\"========\");\n        System.out.println(mapping);\n        String val =  \"20100406\";\n        \n        server.client().admin().indices().putMapping(putMappingRequest(\"test\").mappingSource(mapping)).actionGet();\n\n        server.client().index(indexRequest(\"test\").type(\"datetest\").id(\"1\")\n                .source(jsonBuilder().startObject().field(\"date\", val).endObject())).actionGet();\n        \n        server.client().admin().indices().refresh(refreshRequest()).actionGet();\n       \n        CountResponse countResponse4 = server.client().count(countRequest(\"test\").querySource(fieldQuery(\"date\", val))).actionGet();\n        System.out.println(\"date:\" + countResponse4.count());       \n        \n        CountResponse countResponse1 = server.client().count(countRequest(\"test\").querySource(fieldQuery(\"date.date\", val))).actionGet();\n        System.out.println(\"date.date:\" + countResponse1.count());\n            \n        CountResponse countResponse2 = server.client().count(countRequest(\"test\").querySource(fieldQuery(\"date.orig\", val))).actionGet();\n        System.out.println(\"date.orig:\" + countResponse2.count());\n\n        CountResponse countResponse3 = server.client().count(countRequest(\"test\").querySource(fieldQuery(\"date.untouched\", val))).actionGet();\n        System.out.println(\"date.untouched:\" + countResponse3.count());\n            \n\n    }\n    \n</pre>\n\n\nString prints:\n\n<pre>\n    string:1\n    string.string:0\n    string.orig:1\n    string.untouched:1\n</pre>\n\n\nDate prints:\n\n<pre>\n    date:0\n    date.date:0\n    date.orig:1\n    date.untouched:1\n</pre>\n\n\nShowing that a fieldQuery on default \"date\" does not return, but does return for \"date.orig\".  \nThis is not the case for the string type, where field query on \"string\" does return, as does \"string.orig\"\n\nThis is with the latest 0.6.0-SNAPSHOT (pulling from maven), at the time of this message.\n\n/dom\n(Apologies if the formatting of this issue codes hey wire - I'll try to fix if so)\n\np.s. The entire test class is as follows:\n\n<pre>\npackage org.elasticsearch.plugin.attachments.test;\n\nimport static org.elasticsearch.client.Requests.clusterHealth;\nimport static org.elasticsearch.client.Requests.countRequest;\nimport static org.elasticsearch.client.Requests.createIndexRequest;\nimport static org.elasticsearch.client.Requests.deleteIndexRequest;\nimport static org.elasticsearch.client.Requests.indexRequest;\nimport static org.elasticsearch.client.Requests.putMappingRequest;\nimport static org.elasticsearch.client.Requests.refreshRequest;\nimport static org.elasticsearch.index.query.json.JsonQueryBuilders.fieldQuery;\nimport static org.elasticsearch.server.ServerBuilder.serverBuilder;\nimport static org.elasticsearch.util.io.Streams.copyToBytesFromClasspath;\nimport static org.elasticsearch.util.io.Streams.copyToStringFromClasspath;\nimport static org.elasticsearch.util.json.JsonBuilder.jsonBuilder;\nimport static org.elasticsearch.util.settings.ImmutableSettings.settingsBuilder;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.Matchers.equalTo;\n\nimport java.io.IOException;\n\nimport org.elasticsearch.action.admin.cluster.health.ClusterHealthResponse;\nimport org.elasticsearch.action.admin.cluster.health.ClusterHealthStatus;\nimport org.elasticsearch.action.count.CountResponse;\nimport org.elasticsearch.server.Server;\nimport org.elasticsearch.util.logging.Loggers;\nimport org.junit.After;\nimport org.junit.AfterClass;\nimport org.junit.Before;\nimport org.junit.BeforeClass;\nimport org.junit.Test;\nimport org.slf4j.Logger;\n\npublic class JsonFieldMapperTest {\n\n    private final Logger logger = Loggers.getLogger(getClass());\n\n    private static Server server;\n    \n    @BeforeClass\n    public static void setupServer() {\n        server = serverBuilder().settings(\n                settingsBuilder().put(\"node.local\", true)).server();\n    }\n\n    @AfterClass\n    public static void closeServer() {\n        server.close();\n    }\n\n    @Before\n    public void createIndex() {\n        logger.info(\"creating index [test]\");\n        server.client().admin().indices().create(\n                createIndexRequest(\"test\").settings(\n                        settingsBuilder().put(\"index.numberOfReplicas\", 0).put(\n                                \"index.numberOfShards\", 1))).actionGet();\n        logger.info(\"Running Cluster Health\");\n        ClusterHealthResponse clusterHealth = server.client().admin().cluster()\n                .health(clusterHealth().waitForGreenStatus()).actionGet();\n        logger.info(\"Done Cluster Health, status \" + clusterHealth.status());\n        assertThat(clusterHealth.timedOut(), equalTo(false));\n        assertThat(clusterHealth.status(), equalTo(ClusterHealthStatus.GREEN));\n    }\n\n    @After\n    public void deleteIndex() {\n        logger.info(\"deleting index [test]\");\n        server.client().admin().indices().delete(deleteIndexRequest(\"test\"))\n                .actionGet();\n    }\n\n@Test\n    public void typeDateMultiFieldTest() throws IOException\n    {\n    \n        String mapping = copyToStringFromClasspath(\"/integration-test-multifield-date-mapping.json\");\n        System.out.println(\"Mapping:\");\n        System.out.println(\"========\");\n        System.out.println(mapping);\n        String val =  \"20100406\";\n        \n        server.client().admin().indices().putMapping(putMappingRequest(\"test\").mappingSource(mapping)).actionGet();\n\n        server.client().index(indexRequest(\"test\").type(\"datetest\").id(\"1\")\n                .source(jsonBuilder().startObject().field(\"date\", val).endObject())).actionGet();\n        \n        server.client().admin().indices().refresh(refreshRequest()).actionGet();\n       \n        CountResponse countResponse4 = server.client().count(countRequest(\"test\").querySource(fieldQuery(\"date\", val))).actionGet();\n        System.out.println(\"date:\" + countResponse4.count());       \n        \n        CountResponse countResponse1 = server.client().count(countRequest(\"test\").querySource(fieldQuery(\"date.date\", val))).actionGet();\n        System.out.println(\"date.date:\" + countResponse1.count());\n            \n        CountResponse countResponse2 = server.client().count(countRequest(\"test\").querySource(fieldQuery(\"date.orig\", val))).actionGet();\n        System.out.println(\"date.orig:\" + countResponse2.count());\n\n        CountResponse countResponse3 = server.client().count(countRequest(\"test\").querySource(fieldQuery(\"date.untouched\", val))).actionGet();\n        System.out.println(\"date.untouched:\" + countResponse3.count());\n            \n\n    }\n    \n    @Test\n    public void typeStringMultiFieldTest() throws IOException\n    {\n    \n        String mapping = copyToStringFromClasspath(\"/integration-test-multifield-string-mapping.json\");\n        System.out.println(\"Mapping:\");\n        System.out.println(\"========\");\n        System.out.println(mapping);\n        String val = \"20100406\";\n        \n        server.client().admin().indices().putMapping(putMappingRequest(\"test\").mappingSource(mapping)).actionGet();\n\n        server.client().index(indexRequest(\"test\").type(\"stringtest\").id(\"1\")\n                .source(jsonBuilder().startObject().field(\"string\", val).endObject())).actionGet();\n        \n        server.client().admin().indices().refresh(refreshRequest()).actionGet();\n       \n        CountResponse countResponse1 = server.client().count(countRequest(\"test\").querySource(fieldQuery(\"string\", val))).actionGet();\n        System.out.println(\"string:\" + countResponse1.count());\n            \n        CountResponse countResponse2 = server.client().count(countRequest(\"test\").querySource(fieldQuery(\"string.string\", val))).actionGet();\n        System.out.println(\"string.string:\" + countResponse2.count());\n\n        CountResponse countResponse4 = server.client().count(countRequest(\"test\").querySource(fieldQuery(\"string.orig\", val))).actionGet();\n        System.out.println(\"string.orig:\" + countResponse4.count());\n        \n        CountResponse countResponse3 = server.client().count(countRequest(\"test\").querySource(fieldQuery(\"string.untouched\", val))).actionGet();\n        System.out.println(\"string.untouched:\" + countResponse3.count());\n            \n\n        \n    }\n}\n</pre>\n","closed_by":null,"performed_via_github_app":null}