{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/10722","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/10722/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/10722/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/10722/events","html_url":"https://github.com/elastic/elasticsearch/issues/10722","id":70116835,"node_id":"MDU6SXNzdWU3MDExNjgzNQ==","number":10722,"title":"Percolation requests can be executed before all percolator queries are loaded","user":{"login":"antonha","id":1942422,"node_id":"MDQ6VXNlcjE5NDI0MjI=","avatar_url":"https://avatars0.githubusercontent.com/u/1942422?v=4","gravatar_id":"","url":"https://api.github.com/users/antonha","html_url":"https://github.com/antonha","followers_url":"https://api.github.com/users/antonha/followers","following_url":"https://api.github.com/users/antonha/following{/other_user}","gists_url":"https://api.github.com/users/antonha/gists{/gist_id}","starred_url":"https://api.github.com/users/antonha/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/antonha/subscriptions","organizations_url":"https://api.github.com/users/antonha/orgs","repos_url":"https://api.github.com/users/antonha/repos","events_url":"https://api.github.com/users/antonha/events{/privacy}","received_events_url":"https://api.github.com/users/antonha/received_events","type":"User","site_admin":false},"labels":[{"id":156502592,"node_id":"MDU6TGFiZWwxNTY1MDI1OTI=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/:Search/Percolator","name":":Search/Percolator","color":"0e8a16","default":false,"description":"Reverse search: find queries that match a document"}],"state":"closed","locked":false,"assignee":{"login":"martijnvg","id":580421,"node_id":"MDQ6VXNlcjU4MDQyMQ==","avatar_url":"https://avatars3.githubusercontent.com/u/580421?v=4","gravatar_id":"","url":"https://api.github.com/users/martijnvg","html_url":"https://github.com/martijnvg","followers_url":"https://api.github.com/users/martijnvg/followers","following_url":"https://api.github.com/users/martijnvg/following{/other_user}","gists_url":"https://api.github.com/users/martijnvg/gists{/gist_id}","starred_url":"https://api.github.com/users/martijnvg/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/martijnvg/subscriptions","organizations_url":"https://api.github.com/users/martijnvg/orgs","repos_url":"https://api.github.com/users/martijnvg/repos","events_url":"https://api.github.com/users/martijnvg/events{/privacy}","received_events_url":"https://api.github.com/users/martijnvg/received_events","type":"User","site_admin":false},"assignees":[{"login":"martijnvg","id":580421,"node_id":"MDQ6VXNlcjU4MDQyMQ==","avatar_url":"https://avatars3.githubusercontent.com/u/580421?v=4","gravatar_id":"","url":"https://api.github.com/users/martijnvg","html_url":"https://github.com/martijnvg","followers_url":"https://api.github.com/users/martijnvg/followers","following_url":"https://api.github.com/users/martijnvg/following{/other_user}","gists_url":"https://api.github.com/users/martijnvg/gists{/gist_id}","starred_url":"https://api.github.com/users/martijnvg/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/martijnvg/subscriptions","organizations_url":"https://api.github.com/users/martijnvg/orgs","repos_url":"https://api.github.com/users/martijnvg/repos","events_url":"https://api.github.com/users/martijnvg/events{/privacy}","received_events_url":"https://api.github.com/users/martijnvg/received_events","type":"User","site_admin":false}],"milestone":null,"comments":5,"created_at":"2015-04-22T12:54:15Z","updated_at":"2015-06-23T18:12:48Z","closed_at":"2015-06-23T18:12:47Z","author_association":"NONE","active_lock_reason":null,"body":"The percolator can sometimes fail to match queries right after shard recovery. Version observed in: 1.5.1. \n\nThe percolator keeps all queries in an in-memory collection (shard by shard), which it reads from the index at startup. This is done by registering a listener to the IndicesLifecycle, with the listener loads the queries when afterIndexShardPostRecovery is called. \n\nThis seems to not block the shard to be reported as initialised, so sometimes this is not completed before the cluster returns a yellow status. Thus, if a request comes in _before_ all queries have been loaded into the in-memory structure, the response will erroneously say that there were no matches.\n\nI've been unable to create a predictively failing test for this. This test _sometimes_ exposes the error (by not passing). For me, it fails every 5-6th time:\n\n```\npackage org.elasticsearch.test.integration;\n\nimport org.elasticsearch.action.admin.cluster.health.ClusterHealthResponse;\nimport org.elasticsearch.action.percolate.PercolateRequestBuilder;\nimport org.elasticsearch.action.percolate.PercolateResponse;\nimport org.elasticsearch.action.percolate.PercolateSourceBuilder;\nimport org.elasticsearch.client.Client;\nimport org.elasticsearch.client.Requests;\nimport org.elasticsearch.common.settings.ImmutableSettings;\nimport org.elasticsearch.common.settings.Settings;\nimport org.elasticsearch.percolator.PercolatorService;\nimport org.testng.annotations.AfterClass;\nimport org.testng.annotations.Test;\n\nimport java.io.IOException;\nimport java.util.concurrent.ExecutionException;\n\nimport static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;\nimport static org.elasticsearch.index.query.QueryBuilders.matchQuery;\nimport static org.hamcrest.CoreMatchers.equalTo;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.MatcherAssert.assertThat;\n\n/**\n *\n */\npublic class RecoveryTests extends AbstractNodesTests {\n    @AfterClass\n    public void closeNodes() {\n        closeAllNodesAndClear();\n    }\n\n    @Test(enabled = true)\n    public void testRestartNode() throws IOException, ExecutionException, InterruptedException {\n        Settings extraSettings = ImmutableSettings.settingsBuilder()\n                .put(\"index.gateway.type\", \"local\").build();\n\n        logger.info(\"--> Starting one nodes\");\n        startNode(\"node1\", extraSettings);\n        Client client = client(\"node1\");\n\n        logger.info(\"--> Add dummy doc\");\n        client.admin().indices().prepareDelete(\"_all\").execute().actionGet();\n        client.prepareIndex(\"test\", \"type\", \"1\").setSource(\"field\", \"value\").execute().actionGet();\n\n        logger.info(\"--> Register query\");\n        client.prepareIndex(\"test\", PercolatorService.TYPE_NAME, \"1\")\n                .setSource(jsonBuilder()\n                                .startObject()\n                                .field(\"query\", matchQuery(\"field\", \"b\"))\n                                .field(\"id\", 1)\n                                .field(\"group\", \"g1\")\n                                .field(\"query_hash\", \"hash1\")\n                                .endObject()\n                ).setRefresh(true).execute().actionGet();\n        logger.info(\"--> Restarting node\");\n        closeNode(\"node1\");\n        startNode(\"node1\", extraSettings);\n        client = client(\"node1\");\n        logger.info(\"Waiting for cluster health to be yellow\");\n        waitForYellowIndices(client);\n\n        logger.info(\"--> Percolate doc with field=b\");\n        PercolateResponse response = new PercolateRequestBuilder(client).setIndices(\"test\").setDocumentType(\"type\")\n                .setSource(new PercolateSourceBuilder().setDoc(PercolateSourceBuilder.docBuilder().setDoc(jsonBuilder().startObject().field(\"_id\", \"1\").field(\"field\", \"b\").endObject())))\n                .execute().actionGet();\n\n        assertThat(response.getCount(), is(1l));\n\n        logger.info(\"--> Restarting node again (This will trigger another code-path since translog is flushed)\");\n        closeNode(\"node1\");\n        startNode(\"node1\", extraSettings);\n        client = client(\"node1\");\n        logger.info(\"Waiting for cluster health to be yellow\");\n        waitForYellowIndices(client);\n\n        logger.info(\"--> Percolate doc with field=b\");\n        response = new PercolateRequestBuilder(client).setIndices(\"test\").setDocumentType(\"type\")\n                .setSource(new PercolateSourceBuilder().setDoc(PercolateSourceBuilder.docBuilder().setDoc(jsonBuilder().startObject().field(\"_id\", \"1\").field(\"field\", \"b\").endObject())))\n                .execute().actionGet();\n\n        assertThat(response.getCount(), is(1l));\n\n    }\n\n    private void waitForYellowIndices(Client client) {\n        ClusterHealthResponse health = client.admin().cluster().health(Requests.clusterHealthRequest(new String[]{}).waitForYellowStatus().waitForActiveShards(5)).actionGet();\n        assertThat(health.isTimedOut(), equalTo(false));\n    }\n}\n\n```\n\nThere are tests similar to this one for the percolator, which are supposed to test the same thing. From what I understand though, those are very particular about the cluster setup.. might it be that they can't catch this issue?\n","closed_by":{"login":"clintongormley","id":56599,"node_id":"MDQ6VXNlcjU2NTk5","avatar_url":"https://avatars0.githubusercontent.com/u/56599?v=4","gravatar_id":"","url":"https://api.github.com/users/clintongormley","html_url":"https://github.com/clintongormley","followers_url":"https://api.github.com/users/clintongormley/followers","following_url":"https://api.github.com/users/clintongormley/following{/other_user}","gists_url":"https://api.github.com/users/clintongormley/gists{/gist_id}","starred_url":"https://api.github.com/users/clintongormley/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/clintongormley/subscriptions","organizations_url":"https://api.github.com/users/clintongormley/orgs","repos_url":"https://api.github.com/users/clintongormley/repos","events_url":"https://api.github.com/users/clintongormley/events{/privacy}","received_events_url":"https://api.github.com/users/clintongormley/received_events","type":"User","site_admin":false},"performed_via_github_app":null}