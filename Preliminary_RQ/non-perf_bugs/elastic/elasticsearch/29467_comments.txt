[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/380394696","html_url":"https://github.com/elastic/elasticsearch/issues/29467#issuecomment-380394696","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/29467","id":380394696,"node_id":"MDEyOklzc3VlQ29tbWVudDM4MDM5NDY5Ng==","user":{"login":"elasticmachine","id":15837671,"node_id":"MDQ6VXNlcjE1ODM3Njcx","avatar_url":"https://avatars3.githubusercontent.com/u/15837671?v=4","gravatar_id":"","url":"https://api.github.com/users/elasticmachine","html_url":"https://github.com/elasticmachine","followers_url":"https://api.github.com/users/elasticmachine/followers","following_url":"https://api.github.com/users/elasticmachine/following{/other_user}","gists_url":"https://api.github.com/users/elasticmachine/gists{/gist_id}","starred_url":"https://api.github.com/users/elasticmachine/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/elasticmachine/subscriptions","organizations_url":"https://api.github.com/users/elasticmachine/orgs","repos_url":"https://api.github.com/users/elasticmachine/repos","events_url":"https://api.github.com/users/elasticmachine/events{/privacy}","received_events_url":"https://api.github.com/users/elasticmachine/received_events","type":"User","site_admin":false},"created_at":"2018-04-11T09:50:43Z","updated_at":"2018-04-11T09:50:43Z","author_association":"COLLABORATOR","body":"Pinging @elastic/es-search-aggs","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/380449134","html_url":"https://github.com/elastic/elasticsearch/issues/29467#issuecomment-380449134","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/29467","id":380449134,"node_id":"MDEyOklzc3VlQ29tbWVudDM4MDQ0OTEzNA==","user":{"login":"spinscale","id":667544,"node_id":"MDQ6VXNlcjY2NzU0NA==","avatar_url":"https://avatars2.githubusercontent.com/u/667544?v=4","gravatar_id":"","url":"https://api.github.com/users/spinscale","html_url":"https://github.com/spinscale","followers_url":"https://api.github.com/users/spinscale/followers","following_url":"https://api.github.com/users/spinscale/following{/other_user}","gists_url":"https://api.github.com/users/spinscale/gists{/gist_id}","starred_url":"https://api.github.com/users/spinscale/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/spinscale/subscriptions","organizations_url":"https://api.github.com/users/spinscale/orgs","repos_url":"https://api.github.com/users/spinscale/repos","events_url":"https://api.github.com/users/spinscale/events{/privacy}","received_events_url":"https://api.github.com/users/spinscale/received_events","type":"User","site_admin":false},"created_at":"2018-04-11T13:20:43Z","updated_at":"2018-04-11T13:20:43Z","author_association":"MEMBER","body":"+1 on the second approach, if we decide to do this - this allows us either to use ingest processors or have a completely external NER. Using lucene analyzers also would mean, that we have to keep the models in all Elasticsearch data nodes.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/380749357","html_url":"https://github.com/elastic/elasticsearch/issues/29467#issuecomment-380749357","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/29467","id":380749357,"node_id":"MDEyOklzc3VlQ29tbWVudDM4MDc0OTM1Nw==","user":{"login":"markharwood","id":170925,"node_id":"MDQ6VXNlcjE3MDkyNQ==","avatar_url":"https://avatars0.githubusercontent.com/u/170925?v=4","gravatar_id":"","url":"https://api.github.com/users/markharwood","html_url":"https://github.com/markharwood","followers_url":"https://api.github.com/users/markharwood/followers","following_url":"https://api.github.com/users/markharwood/following{/other_user}","gists_url":"https://api.github.com/users/markharwood/gists{/gist_id}","starred_url":"https://api.github.com/users/markharwood/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/markharwood/subscriptions","organizations_url":"https://api.github.com/users/markharwood/orgs","repos_url":"https://api.github.com/users/markharwood/repos","events_url":"https://api.github.com/users/markharwood/events{/privacy}","received_events_url":"https://api.github.com/users/markharwood/received_events","type":"User","site_admin":false},"created_at":"2018-04-12T10:06:23Z","updated_at":"2018-04-12T10:06:23Z","author_association":"CONTRIBUTOR","body":"I've experimented with the example of object-based representations of text strings in JSON (with `text` and `inject_tokens` properties) and can see that there's some potential issues. \r\nI had to modify TextFieldMapper to accept object-based strings for indexing and for highlighting to work I had to hack the `SourceLookup.extractRawValues` method to look for `body.text` in the source map if the user asked for the `body` field to be highlighted . It's not clear to me how users should refer to the `body` field when making requests for highlighting or source filtering etc - should they refer to `body` string fields or `body.text`? Also, the majority of the time in things like `hits` or `top_hits` aggs the users are unlikely to be interested in seeing all the `inject_tokens` echoed back as part of the source - these are more of an indexing detail for the search engine rather than useful information for the end user.\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/380956047","html_url":"https://github.com/elastic/elasticsearch/issues/29467#issuecomment-380956047","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/29467","id":380956047,"node_id":"MDEyOklzc3VlQ29tbWVudDM4MDk1NjA0Nw==","user":{"login":"mayya-sharipova","id":5738841,"node_id":"MDQ6VXNlcjU3Mzg4NDE=","avatar_url":"https://avatars1.githubusercontent.com/u/5738841?v=4","gravatar_id":"","url":"https://api.github.com/users/mayya-sharipova","html_url":"https://github.com/mayya-sharipova","followers_url":"https://api.github.com/users/mayya-sharipova/followers","following_url":"https://api.github.com/users/mayya-sharipova/following{/other_user}","gists_url":"https://api.github.com/users/mayya-sharipova/gists{/gist_id}","starred_url":"https://api.github.com/users/mayya-sharipova/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mayya-sharipova/subscriptions","organizations_url":"https://api.github.com/users/mayya-sharipova/orgs","repos_url":"https://api.github.com/users/mayya-sharipova/repos","events_url":"https://api.github.com/users/mayya-sharipova/events{/privacy}","received_events_url":"https://api.github.com/users/mayya-sharipova/received_events","type":"User","site_admin":false},"created_at":"2018-04-12T21:54:32Z","updated_at":"2018-04-12T21:54:32Z","author_association":"CONTRIBUTOR","body":"@markharwood very interesting issue and usecase.\r\n\r\nAlso +1 for the second approach. \r\n\r\n It would be cool if we can add even the type of token:\r\n```json\r\n\"inject_tokens\" : [\r\n          {\r\n                \"token\": \"Donald Trump Jr\",\r\n                \"offset\": 0,\r\n                \"length\": 16,\r\n                \"type\":  \"person\"\r\n          }\r\n    ]\r\n```\r\nHave you thought about designing a special type of query for this, something like this:\r\n```json\r\n\"query\": {\r\n    \"entity\" : { \"person\" : \"Donald Trump Jr\" } \r\n  }\r\n````\r\n\r\nAbout the implementation details:  it would be cool if we can add an additional tokeStream to a field besides the one traditionally analyzed. The custom similarity modules can combine both tokenStreams in a custom way. \r\nI have heard similar requests about possible ways to index vector embeddings with a field content. Some people are using payload for this, but it doesn't scale well. \r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/381089257","html_url":"https://github.com/elastic/elasticsearch/issues/29467#issuecomment-381089257","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/29467","id":381089257,"node_id":"MDEyOklzc3VlQ29tbWVudDM4MTA4OTI1Nw==","user":{"login":"markharwood","id":170925,"node_id":"MDQ6VXNlcjE3MDkyNQ==","avatar_url":"https://avatars0.githubusercontent.com/u/170925?v=4","gravatar_id":"","url":"https://api.github.com/users/markharwood","html_url":"https://github.com/markharwood","followers_url":"https://api.github.com/users/markharwood/followers","following_url":"https://api.github.com/users/markharwood/following{/other_user}","gists_url":"https://api.github.com/users/markharwood/gists{/gist_id}","starred_url":"https://api.github.com/users/markharwood/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/markharwood/subscriptions","organizations_url":"https://api.github.com/users/markharwood/orgs","repos_url":"https://api.github.com/users/markharwood/repos","events_url":"https://api.github.com/users/markharwood/events{/privacy}","received_events_url":"https://api.github.com/users/markharwood/received_events","type":"User","site_admin":false},"created_at":"2018-04-13T10:05:18Z","updated_at":"2018-04-16T09:41:18Z","author_association":"CONTRIBUTOR","body":">It would be cool if we can add even the type of token:\r\n\r\nYep, anything a regular Token produced by internal analysis can contain should be on the table.\r\nI don't think we do anything with Token type info at query time but that's probably for another issue.\r\n\r\n>it would be cool if we can add an additional tokeStream to a field besides the one traditionally analyzed.\r\n\r\nMy assumption is that we'd have to emit one fused TokenStream at index time containing a combo of the internally-generated tokens and the externally-provided ones.\r\n\r\nAlso, anything that re-analyzes _source text strings at query time will need to repeat this stream-fusing logic. Candidates may include:\r\n\r\n* UnifiedHighlighter \r\n* SignificantText agg\r\n* MoreLikeThis Query\r\n* org.elasticsearch.xpack.ml.job.categorization.CategorizationAnalyzer\r\n\r\nI'm not sure how best to handle this - either rely on persisted tokenisation e.g. TermVectors for these classes to work properly or try abstract the way TokenStreams are obtained from a fusion of on-the-fly Lucene text analysis and the externally-provided tokens.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/381954432","html_url":"https://github.com/elastic/elasticsearch/issues/29467#issuecomment-381954432","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/29467","id":381954432,"node_id":"MDEyOklzc3VlQ29tbWVudDM4MTk1NDQzMg==","user":{"login":"markharwood","id":170925,"node_id":"MDQ6VXNlcjE3MDkyNQ==","avatar_url":"https://avatars0.githubusercontent.com/u/170925?v=4","gravatar_id":"","url":"https://api.github.com/users/markharwood","html_url":"https://github.com/markharwood","followers_url":"https://api.github.com/users/markharwood/followers","following_url":"https://api.github.com/users/markharwood/following{/other_user}","gists_url":"https://api.github.com/users/markharwood/gists{/gist_id}","starred_url":"https://api.github.com/users/markharwood/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/markharwood/subscriptions","organizations_url":"https://api.github.com/users/markharwood/orgs","repos_url":"https://api.github.com/users/markharwood/repos","events_url":"https://api.github.com/users/markharwood/events{/privacy}","received_events_url":"https://api.github.com/users/markharwood/received_events","type":"User","site_admin":false},"created_at":"2018-04-17T11:20:36Z","updated_at":"2018-04-17T11:24:33Z","author_association":"CONTRIBUTOR","body":"I discussed this with @jpountz @jimczi @romseygeek and others and the suggestion was that we should ideally store the externally-provided entity tokens in a separate \"annotations\" field rather than splicing them directly into the tokens of the text field. These annotations should be thought of as similar to the `fields` sub-properties in a field mapping - alternative ways of indexing the original JSON text. Let's call both of these concepts \"indexed variants\" or **IV fields** for the moment.\r\n\r\nThere are a number of existing challenges with support for IV fields which we might choose to address in spin-off issues:\r\n1) Highlighters need to be able to highlight the original text using one or more selected IV fields that contain the tokens used by the user in the query\r\n2) Positional queries (Spans or the new interval queries) need to support finding \"X near Y\" where tokens X and Y may be stored in different IV fields. \r\n3) Other forms of query-time analysis such as the `significant_text` aggregation, the `MoreLikeThis` query or ML's CategorizationAnalyzer may need to support the selection of one or more IV fields.\r\n\r\nIn 1) and 3) above, the new \"annotations\" IV field would break all their existing assumptions about how to get hold of a token stream for original JSON strings. It is not enough for them to pass the original text to the field's Analyzer for it to re-tokenize. The \"annotations\" IV field would require callers to pass a different context to retrieve the externally-provided list of tokens. This context might be a Map of the source data, some Lucene object like `Document` - it's unclear to me how we would abstract this more cleanly - especially when we consider the \"TermVectors\" alternatives for providing any pre-stored tokens.\r\nIt is perhaps also worth formalising the connection between the annotations field and the source text to which it relates. Maybe with a special definition in the mapping. This would help us validate that when highlighting the `foo_text` JSON field, the \"foo_annotations\" field is an appropriate choice of IV field whose positions and offsets still relate to the foo_text content.\r\n\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/382055272","html_url":"https://github.com/elastic/elasticsearch/issues/29467#issuecomment-382055272","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/29467","id":382055272,"node_id":"MDEyOklzc3VlQ29tbWVudDM4MjA1NTI3Mg==","user":{"login":"markharwood","id":170925,"node_id":"MDQ6VXNlcjE3MDkyNQ==","avatar_url":"https://avatars0.githubusercontent.com/u/170925?v=4","gravatar_id":"","url":"https://api.github.com/users/markharwood","html_url":"https://github.com/markharwood","followers_url":"https://api.github.com/users/markharwood/followers","following_url":"https://api.github.com/users/markharwood/following{/other_user}","gists_url":"https://api.github.com/users/markharwood/gists{/gist_id}","starred_url":"https://api.github.com/users/markharwood/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/markharwood/subscriptions","organizations_url":"https://api.github.com/users/markharwood/orgs","repos_url":"https://api.github.com/users/markharwood/repos","events_url":"https://api.github.com/users/markharwood/events{/privacy}","received_events_url":"https://api.github.com/users/markharwood/received_events","type":"User","site_admin":false},"created_at":"2018-04-17T16:25:22Z","updated_at":"2018-04-17T16:25:22Z","author_association":"CONTRIBUTOR","body":"Damn.  If we adopt the \"separate field\" approach to storing entity annotations (as suggested in my previous comment) then we can't use positional queries like span/interval. These queries measure token proximity using position increments, not character offsets. Using a separate field to store entity annotations would mean that it would be impossible to record position inc values that tied up with those tokens record in the text field.\r\n\r\nFor the record - the highlighting and positional query capabilities I would hope to enable are demonstrated here: https://youtu.be/kbK3D_pULd4\r\n\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/382677340","html_url":"https://github.com/elastic/elasticsearch/issues/29467#issuecomment-382677340","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/29467","id":382677340,"node_id":"MDEyOklzc3VlQ29tbWVudDM4MjY3NzM0MA==","user":{"login":"jpountz","id":299848,"node_id":"MDQ6VXNlcjI5OTg0OA==","avatar_url":"https://avatars2.githubusercontent.com/u/299848?v=4","gravatar_id":"","url":"https://api.github.com/users/jpountz","html_url":"https://github.com/jpountz","followers_url":"https://api.github.com/users/jpountz/followers","following_url":"https://api.github.com/users/jpountz/following{/other_user}","gists_url":"https://api.github.com/users/jpountz/gists{/gist_id}","starred_url":"https://api.github.com/users/jpountz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jpountz/subscriptions","organizations_url":"https://api.github.com/users/jpountz/orgs","repos_url":"https://api.github.com/users/jpountz/repos","events_url":"https://api.github.com/users/jpountz/events{/privacy}","received_events_url":"https://api.github.com/users/jpountz/received_events","type":"User","site_admin":false},"created_at":"2018-04-19T09:50:41Z","updated_at":"2018-04-19T09:50:41Z","author_association":"CONTRIBUTOR","body":">  If we adopt the \"separate field\" approach to storing entity annotations (as suggested in my previous comment) then we can't use positional queries like span/interval.\r\n\r\nI'm not sure this is a blocker. For instance I could imagine that we could merge-sort two token streams in order to reconstitute one that has both the raw tokens and extracted entities. I vaguely remember @romseygeek talking about something like that but could be wrong.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/383515600","html_url":"https://github.com/elastic/elasticsearch/issues/29467#issuecomment-383515600","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/29467","id":383515600,"node_id":"MDEyOklzc3VlQ29tbWVudDM4MzUxNTYwMA==","user":{"login":"markharwood","id":170925,"node_id":"MDQ6VXNlcjE3MDkyNQ==","avatar_url":"https://avatars0.githubusercontent.com/u/170925?v=4","gravatar_id":"","url":"https://api.github.com/users/markharwood","html_url":"https://github.com/markharwood","followers_url":"https://api.github.com/users/markharwood/followers","following_url":"https://api.github.com/users/markharwood/following{/other_user}","gists_url":"https://api.github.com/users/markharwood/gists{/gist_id}","starred_url":"https://api.github.com/users/markharwood/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/markharwood/subscriptions","organizations_url":"https://api.github.com/users/markharwood/orgs","repos_url":"https://api.github.com/users/markharwood/repos","events_url":"https://api.github.com/users/markharwood/events{/privacy}","received_events_url":"https://api.github.com/users/markharwood/received_events","type":"User","site_admin":false},"created_at":"2018-04-23T09:38:21Z","updated_at":"2018-04-23T09:46:40Z","author_association":"CONTRIBUTOR","body":"### Inline vs external tagging styles\r\nNLP tools such as  [Apache UIMA](https://uima.apache.org) and [GATE](https://gate.ac.uk/) can export a rich-text format of annotated text where any annotations are in-lined around selected text by introducing special markup (traditionally XML) to identify items of interest. This is similar to how HTML uses `<a href=\"foo.com\">` tags to introduce hyperlinks around selected text. The advantage is that no position offset information is required which [can be brittle](https://github.com/elastic/elasticsearch/issues/29631#issuecomment-383098822) when different character encodings are used between systems. The disadvantage is that XML-like structures may be [hard to express in JSON](https://issues.apache.org/jira/browse/UIMA-3969). Perhaps the `{{...}}` style of escaping annotations text popularised by HTML templating engines may be another approach. \r\nWhichever escaping format is used, this approach would rely on elasticsearch supporting a new `rich text` format which keeps both text and annotations together.\r\n\r\nThe alternative format  is offset-and-length based annotations such as those provided by [OpenCalais](https://docs-developers.thomsonreuters.com/1524474659825/37706/wwhelp/wwhimpl/js/html/wwhelp.htm#href=Open%20Calais%20API%20User%20Guide/Open%20Calais%20API%20User%20Guide.1.058.html#pID0E045B0HA) where any annotations are listed separately from the text using tags, positions and offsets to reference areas of the original text where entities were discovered. This approach would rely on elasticsearch supporting a new \"annotations\" field type and defining the text field to which it relates in the mapping.\r\n\r\n\r\n\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/383625909","html_url":"https://github.com/elastic/elasticsearch/issues/29467#issuecomment-383625909","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/29467","id":383625909,"node_id":"MDEyOklzc3VlQ29tbWVudDM4MzYyNTkwOQ==","user":{"login":"mbarretta","id":1015404,"node_id":"MDQ6VXNlcjEwMTU0MDQ=","avatar_url":"https://avatars3.githubusercontent.com/u/1015404?v=4","gravatar_id":"","url":"https://api.github.com/users/mbarretta","html_url":"https://github.com/mbarretta","followers_url":"https://api.github.com/users/mbarretta/followers","following_url":"https://api.github.com/users/mbarretta/following{/other_user}","gists_url":"https://api.github.com/users/mbarretta/gists{/gist_id}","starred_url":"https://api.github.com/users/mbarretta/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mbarretta/subscriptions","organizations_url":"https://api.github.com/users/mbarretta/orgs","repos_url":"https://api.github.com/users/mbarretta/repos","events_url":"https://api.github.com/users/mbarretta/events{/privacy}","received_events_url":"https://api.github.com/users/mbarretta/received_events","type":"User","site_admin":false},"created_at":"2018-04-23T15:53:36Z","updated_at":"2018-04-23T15:53:36Z","author_association":"NONE","body":"Another approach I've seen in the past was a graph-style annotation schema that took the raw text as a single field and attached various low-level analytics (tokens, mainly) as nodes pointing to offsets of that text and higher-level analytics (SBs, POS, ultimately entities) pointing to the lower-level nodes or to \"beginning\" and \"ending\" nodes.\r\n\r\nThe spec for it is here:\r\nhttps://github.com/pagi-org/spec/blob/master/pagi.md","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/384230860","html_url":"https://github.com/elastic/elasticsearch/issues/29467#issuecomment-384230860","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/29467","id":384230860,"node_id":"MDEyOklzc3VlQ29tbWVudDM4NDIzMDg2MA==","user":{"login":"markharwood","id":170925,"node_id":"MDQ6VXNlcjE3MDkyNQ==","avatar_url":"https://avatars0.githubusercontent.com/u/170925?v=4","gravatar_id":"","url":"https://api.github.com/users/markharwood","html_url":"https://github.com/markharwood","followers_url":"https://api.github.com/users/markharwood/followers","following_url":"https://api.github.com/users/markharwood/following{/other_user}","gists_url":"https://api.github.com/users/markharwood/gists{/gist_id}","starred_url":"https://api.github.com/users/markharwood/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/markharwood/subscriptions","organizations_url":"https://api.github.com/users/markharwood/orgs","repos_url":"https://api.github.com/users/markharwood/repos","events_url":"https://api.github.com/users/markharwood/events{/privacy}","received_events_url":"https://api.github.com/users/markharwood/received_events","type":"User","site_admin":false},"created_at":"2018-04-25T09:53:37Z","updated_at":"2018-04-25T09:53:37Z","author_association":"CONTRIBUTOR","body":"Not heard of pagi before, thanks Mike.\r\nMy gut feel is that we should aim for simplicity here and **not** try support\r\na) overlapping annotations in the text\r\nb) annotation type hierarchies (eg person ->organisation) \r\nc) annotation relationships (e.g. text declares annotation 1 has \"employed_by\" relationship with nearby annotation 2)\r\nd) multiple annotation properties e.g. person annotations possibly having \"name\", \"age\", \"gender\" attributes etc\r\n\r\nThe simplest option is to support an annotation as a single Token (string + pos + offset + len) whose string value serves as both a (hopefully) unique ID and human-readable label. The [dandelion](https://github.com/ZarHenry96/elasticsearch-dandelion-plugin) NER plugin for example uses Wikipedia URLs as a string that is both a unique ID and a human-readable string which contains the entity name.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/384359134","html_url":"https://github.com/elastic/elasticsearch/issues/29467#issuecomment-384359134","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/29467","id":384359134,"node_id":"MDEyOklzc3VlQ29tbWVudDM4NDM1OTEzNA==","user":{"login":"markharwood","id":170925,"node_id":"MDQ6VXNlcjE3MDkyNQ==","avatar_url":"https://avatars0.githubusercontent.com/u/170925?v=4","gravatar_id":"","url":"https://api.github.com/users/markharwood","html_url":"https://github.com/markharwood","followers_url":"https://api.github.com/users/markharwood/followers","following_url":"https://api.github.com/users/markharwood/following{/other_user}","gists_url":"https://api.github.com/users/markharwood/gists{/gist_id}","starred_url":"https://api.github.com/users/markharwood/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/markharwood/subscriptions","organizations_url":"https://api.github.com/users/markharwood/orgs","repos_url":"https://api.github.com/users/markharwood/repos","events_url":"https://api.github.com/users/markharwood/events{/privacy}","received_events_url":"https://api.github.com/users/markharwood/received_events","type":"User","site_admin":false},"created_at":"2018-04-25T16:58:13Z","updated_at":"2018-04-25T17:06:00Z","author_association":"CONTRIBUTOR","body":"@jpountz @jimczi  We had a meeting on this and came up with the following decisions:\r\n\r\n#### 1) Annotated text should be presented inline using tags\r\nA new field type is required (\"annotated_text\"?) which accepts strings that are interspersed with markup e.g.\r\n\r\n    \"text\" : \"They met with <a type=`person` value=`Donald Trump Jr.`>Don junior</a> and ...\"\r\n\r\nThe exact tag-escaping mechanism was not decided (thoughts, @clintongormley ?) but it should allow users to express a `type` and a `value` which would be indexed as a single token at the same offset and position as the text it surrounds. The value would be indexed as-is so not lower-cased or otherwise formatted. The `type` information may appear as a payload or possibly a prefix on the value (as yet undecided).\r\nThe advantage of the in-line tagging format is that external clients would not have to pass any offsets and lengths for annotations which can be problematic when translating between client and server character encodings. In-line tags also mean we will not support overlapping tokens.\r\n\r\n#### 2) Annotations are additional tokens indexed into the same \"text\" index field\r\nEntity annotations can be thought of as synonyms that expand on the text tokens recorded during analysis. Advantages of putting them in the same text field rather than a separate \"text.annotations\" indexed field are:\r\na) existing highlighters work with a single token-stream and not a fusion of multiple indexed fields\r\nb) Positional `interval` queries also only work with a single indexed field.\r\nThe disadvantage is that traditional text-based queries may unexpectedly highlight/match annotation-introduced tokens. We felt this could be mitigated if the annotations tokens adopted a convention like type-prefixing that would ensure there weren't unintentional matches.\r\n\r\n#### 3) May only work with one choice of Highlighter impl\r\nThe challenge of working on the text of a field that contains both text and annotation markup may mean that we have to \"special case\" the new annotated_text fields so that they only work with one highlighter impl - possibly a variant of the unified highlighter\r\n\r\n#### 4) Punted for later releases:\r\na) We won't be allowing in-text annotations to declare \"copy_to\" commands for any structured keyword fields. This is a convenience for clients that would be hard for us to implement and they do have a work-around. Clients could instead pass JSON source that included identical person names in the text annotations and the structured `person` keyword field.\r\n\r\nb) We won't be offering a means to ask for `hits` in results that return the  text field without the annotation markup.  I can see people might want it but we'd need to work out a way to make this clean.\r\n\r\nc) MoreLikeThis and Significant Text agg both try to identify statistically significant items in text, doing so using re-analysis. Whether this should include any annotations is perhaps open to interpretation so we did not decide on a policy or any additional user-facing controls that might be needed here.\r\n\r\n\r\n\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/385393246","html_url":"https://github.com/elastic/elasticsearch/issues/29467#issuecomment-385393246","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/29467","id":385393246,"node_id":"MDEyOklzc3VlQ29tbWVudDM4NTM5MzI0Ng==","user":{"login":"markharwood","id":170925,"node_id":"MDQ6VXNlcjE3MDkyNQ==","avatar_url":"https://avatars0.githubusercontent.com/u/170925?v=4","gravatar_id":"","url":"https://api.github.com/users/markharwood","html_url":"https://github.com/markharwood","followers_url":"https://api.github.com/users/markharwood/followers","following_url":"https://api.github.com/users/markharwood/following{/other_user}","gists_url":"https://api.github.com/users/markharwood/gists{/gist_id}","starred_url":"https://api.github.com/users/markharwood/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/markharwood/subscriptions","organizations_url":"https://api.github.com/users/markharwood/orgs","repos_url":"https://api.github.com/users/markharwood/repos","events_url":"https://api.github.com/users/markharwood/events{/privacy}","received_events_url":"https://api.github.com/users/markharwood/received_events","type":"User","site_admin":false},"created_at":"2018-04-30T13:09:20Z","updated_at":"2018-05-01T16:28:09Z","author_association":"CONTRIBUTOR","body":"I've opted for encoding annotations in text using a markdown style syntax.\r\nSo the original text appears in between `[ ] `  followed by a url-like syntax in between`( )` used to describe the entity value and type e.g.\r\n\r\n     \"text\" : \"They met with [Don junior](type=person&value=Donald%20Trump%20Jr) and ...\"\r\n\r\nNote that the `type` and `value` of the entity are url-encoded parameters. \r\nNote also markdown is a permissive syntax meaning that regular uses of `[` in the text don't have to be escaped and it is only when the use of these characters matches the pattern `[...](...)` that it is interpreted as being a URL, or in our case, an entity reference.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/389800840","html_url":"https://github.com/elastic/elasticsearch/issues/29467#issuecomment-389800840","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/29467","id":389800840,"node_id":"MDEyOklzc3VlQ29tbWVudDM4OTgwMDg0MA==","user":{"login":"markharwood","id":170925,"node_id":"MDQ6VXNlcjE3MDkyNQ==","avatar_url":"https://avatars0.githubusercontent.com/u/170925?v=4","gravatar_id":"","url":"https://api.github.com/users/markharwood","html_url":"https://github.com/markharwood","followers_url":"https://api.github.com/users/markharwood/followers","following_url":"https://api.github.com/users/markharwood/following{/other_user}","gists_url":"https://api.github.com/users/markharwood/gists{/gist_id}","starred_url":"https://api.github.com/users/markharwood/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/markharwood/subscriptions","organizations_url":"https://api.github.com/users/markharwood/orgs","repos_url":"https://api.github.com/users/markharwood/repos","events_url":"https://api.github.com/users/markharwood/events{/privacy}","received_events_url":"https://api.github.com/users/markharwood/received_events","type":"User","site_admin":false},"created_at":"2018-05-17T09:15:04Z","updated_at":"2018-05-17T09:15:26Z","author_association":"CONTRIBUTOR","body":"I'd like to add the option of injecting multiple annotation tokens for a given piece of text.\r\n\r\n![image](https://user-images.githubusercontent.com/170925/40167539-34da7754-59b9-11e8-9d9c-35bfb6228948.png)\r\n\r\n\r\ne.g. in the highlighted text above I want a token to identify both the `person` and the `role`.\r\n\r\nThe question is how to encode multiple tokens in the annotation's markdown-like syntax. I can think of 3 approaches:\r\n\r\n1) Simple key/value pairs\r\nIn this syntax the token `type` and `value` are collapsed into simple key/value pairs:\r\n \r\n     `he paid [John](person=John+Smith&role=payee)`\r\n\r\n2) Multiple numbered token properties\r\nIn this syntax the type and value (and potentially other attributes) for each token are associated using numbers\r\n\r\n    `he paid [John](type1=person&value1=John+Smith&type2=role&value2=payee)`\r\n\r\n3) More complex encoding\r\nWe could introduce extra escaping into the url-like syntax to have comma-delimited list of annotation attributes or perhaps use JSON curly braces instead of the (url) syntax e.g. `paid [John]{...}`\r\n\r\nI like the simplicity of 1) but it does preclude having any token attributes other than `type` and `value` - we couldn't for instance introduce anything that added payload information in future. \r\nCurrently we only use `value` in the search index - the `type` part of a token only has potential use in clients rendering this text in type-specific ways.\r\n\r\n### Proposal \r\nWe should reserve `[](...)` syntax for the simple key/value syntax and use `[]{...}` for any advanced JSON-like syntax we may come up with in future. ","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/390176768","html_url":"https://github.com/elastic/elasticsearch/issues/29467#issuecomment-390176768","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/29467","id":390176768,"node_id":"MDEyOklzc3VlQ29tbWVudDM5MDE3Njc2OA==","user":{"login":"markharwood","id":170925,"node_id":"MDQ6VXNlcjE3MDkyNQ==","avatar_url":"https://avatars0.githubusercontent.com/u/170925?v=4","gravatar_id":"","url":"https://api.github.com/users/markharwood","html_url":"https://github.com/markharwood","followers_url":"https://api.github.com/users/markharwood/followers","following_url":"https://api.github.com/users/markharwood/following{/other_user}","gists_url":"https://api.github.com/users/markharwood/gists{/gist_id}","starred_url":"https://api.github.com/users/markharwood/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/markharwood/subscriptions","organizations_url":"https://api.github.com/users/markharwood/orgs","repos_url":"https://api.github.com/users/markharwood/repos","events_url":"https://api.github.com/users/markharwood/events{/privacy}","received_events_url":"https://api.github.com/users/markharwood/received_events","type":"User","site_admin":false},"created_at":"2018-05-18T11:19:48Z","updated_at":"2018-05-18T11:19:48Z","author_association":"CONTRIBUTOR","body":"\"Copy_to\" from annotations to structured keyword fields looks like it may be tricky. \r\n\r\nCopy_to impl works by passing the same JSON property text to multiple fields (see DocumentParser.parseCopy(field, parseContext) ). Each target field currently reparses the original JSON string (text-plus-markup). Ideally we'd pass only parsed annotation token values to keyword fields based on the token type  e.g.\r\n\r\n\t{\r\n\t\t\"my_annotated_field\": {\r\n\t\t\t\"type\": \"annotated_text\",\r\n\t\t\t\"copy_annotation_types_to\": {\r\n\t\t\t\t\"person\": \"my_entities_keyword_field\",\r\n\t\t\t\t\"role\": \"my_roles_keyword_field\"\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\nAdding this would require a change to DocumentParser to allow annotated fields to pass back \"virtual\" document properties that are just the annotation token values presented to target fields as if they were there in the original JSON. \r\n\r\n### Proposal\r\nCopying annotations to structured fields looks too messy to attempt inside elasticsearch. Maybe an ingest pipeline processor that understands the annotation markup syntax is a better way to copy these fields values around. Certainly tools like our [open NLP ](https://github.com/spinscale/elasticsearch-ingest-opennlp) already do this kind of copy-to type logic when extracting entities from the raw text. In future that tool and others like it will likely automate the process of both marking up the annotated text and copying discoveries to structured fields in the JSON. Any human-authored docs may still get it wrong (e.g. forgetting to add an annotation value to a related structured field) but I expect the majority of value-copying will be done automatically by upstream tools in practice.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/390182932","html_url":"https://github.com/elastic/elasticsearch/issues/29467#issuecomment-390182932","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/29467","id":390182932,"node_id":"MDEyOklzc3VlQ29tbWVudDM5MDE4MjkzMg==","user":{"login":"jimczi","id":15977469,"node_id":"MDQ6VXNlcjE1OTc3NDY5","avatar_url":"https://avatars0.githubusercontent.com/u/15977469?v=4","gravatar_id":"","url":"https://api.github.com/users/jimczi","html_url":"https://github.com/jimczi","followers_url":"https://api.github.com/users/jimczi/followers","following_url":"https://api.github.com/users/jimczi/following{/other_user}","gists_url":"https://api.github.com/users/jimczi/gists{/gist_id}","starred_url":"https://api.github.com/users/jimczi/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jimczi/subscriptions","organizations_url":"https://api.github.com/users/jimczi/orgs","repos_url":"https://api.github.com/users/jimczi/repos","events_url":"https://api.github.com/users/jimczi/events{/privacy}","received_events_url":"https://api.github.com/users/jimczi/received_events","type":"User","site_admin":false},"created_at":"2018-05-18T11:50:00Z","updated_at":"2018-05-18T11:50:00Z","author_association":"MEMBER","body":"We could also create extra fields directly in `my_annotated_field`, it could be per annotation type `my_annotated_field.person`, `my_annotated_field.role` or a single field `my_annotated_field.annotations` and add the type as a prefix in annotation `person#madonna` ?\r\nI think this field should be able to handle the indexation of the text **and** the annotations in a `doc_values` field automatically otherwise you'll need to handle the format in a lot of places. ","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/390222597","html_url":"https://github.com/elastic/elasticsearch/issues/29467#issuecomment-390222597","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/29467","id":390222597,"node_id":"MDEyOklzc3VlQ29tbWVudDM5MDIyMjU5Nw==","user":{"login":"markharwood","id":170925,"node_id":"MDQ6VXNlcjE3MDkyNQ==","avatar_url":"https://avatars0.githubusercontent.com/u/170925?v=4","gravatar_id":"","url":"https://api.github.com/users/markharwood","html_url":"https://github.com/markharwood","followers_url":"https://api.github.com/users/markharwood/followers","following_url":"https://api.github.com/users/markharwood/following{/other_user}","gists_url":"https://api.github.com/users/markharwood/gists{/gist_id}","starred_url":"https://api.github.com/users/markharwood/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/markharwood/subscriptions","organizations_url":"https://api.github.com/users/markharwood/orgs","repos_url":"https://api.github.com/users/markharwood/repos","events_url":"https://api.github.com/users/markharwood/events{/privacy}","received_events_url":"https://api.github.com/users/markharwood/received_events","type":"User","site_admin":false},"created_at":"2018-05-18T14:20:40Z","updated_at":"2018-05-18T14:20:40Z","author_association":"CONTRIBUTOR","body":">and add the type as a prefix in annotation\r\n\r\nIt certainly would be nice to exploit the type information in the annotation tokens.\r\nThis is something I think is generally missing in our existing mapping definitions - client tools such as Kibana don't appreciate that the values found in, say, the `from` keyword field can also be used in the `to` keyword field because the tokens both represent the same **entity type** (email address). \r\n\r\nNothing in the mappings declares these fields' tokens are interchangeable. I'd like to see this entity-type information in the mapping alongside the existing choice of storage-type (eg keyword).\r\nGeneric clients like Kibana could then understand how discoveries in one field were exploitable in other fields for search or highlighting purposes. \r\nAnnotated tokens are perhaps the first place in elasticsearch where an idea of **entity type** (person, organisation etc) is introduced independently of the type associated with the field that contains it. It  would be nice to carry this \"entity type\" info further into our mappings.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/396522447","html_url":"https://github.com/elastic/elasticsearch/issues/29467#issuecomment-396522447","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/29467","id":396522447,"node_id":"MDEyOklzc3VlQ29tbWVudDM5NjUyMjQ0Nw==","user":{"login":"markharwood","id":170925,"node_id":"MDQ6VXNlcjE3MDkyNQ==","avatar_url":"https://avatars0.githubusercontent.com/u/170925?v=4","gravatar_id":"","url":"https://api.github.com/users/markharwood","html_url":"https://github.com/markharwood","followers_url":"https://api.github.com/users/markharwood/followers","following_url":"https://api.github.com/users/markharwood/following{/other_user}","gists_url":"https://api.github.com/users/markharwood/gists{/gist_id}","starred_url":"https://api.github.com/users/markharwood/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/markharwood/subscriptions","organizations_url":"https://api.github.com/users/markharwood/orgs","repos_url":"https://api.github.com/users/markharwood/repos","events_url":"https://api.github.com/users/markharwood/events{/privacy}","received_events_url":"https://api.github.com/users/markharwood/received_events","type":"User","site_admin":false},"created_at":"2018-06-12T09:14:22Z","updated_at":"2018-06-12T09:14:22Z","author_association":"CONTRIBUTOR","body":"I think when highlighting an annotated_text field it will be useful to return hit information using the annotation syntax.\r\n### Benefits\r\n1) Rather than plain `<em></em>` tags we can pass extra \"hit\" information in the url-parameter like syntax such as the actual search term that matched and possibly scoring weights. An example hit for a search for \"tesla\" might be marked up as follows: `brand new [Tesla](_hit.term=tesla&_hit.score=3.32) launched`. \r\n2) It would also be useful to return any other non-matching annotations from the original text e.g. in this Wikipedia example below the only thing highlighted in yellow is the searched text but the original JSON contains multiple people annotations which would be useful to have marked up in the client too:\r\n![image](https://user-images.githubusercontent.com/170925/41280446-dd6bae3e-6e26-11e8-9176-7a50510222fd.png)\r\n\r\nA sophisticated client (Kibana?) could make good use of all this extra metadata embedded in the text, rendering results with hyperlinks, different colours, font-weights etc. \r\n\r\n### Downsides\r\n* Would potentially be confusing in that the usual \"pre\" and \"post\" tag settings sent in search highlight requests would not apply - maybe we should throw an error if passed for use on an annotated text field?\r\n* Would clients still want an option to return plain-text with the `<em>` tags for the convenience of displaying as HTML? Annotated text markup needs some client-side parsing before it can be rendered nicely (however, the same is true of viewing the raw content of a doc anyway).\r\n\r\n### Approach\r\nThe implementation would be a special PassageFormatter for the existing UnifiedHighlighter.\r\nWhen mixing search terms and pre-existing annotations in the final markup the rules would have to be as follows:\r\n* Search terms that _exactly_ overlap an existing annotation will mix `_hit.*` attributes into the url-like syntax (the assumption being existing annotation attributes won't name-clash with `_hit.*` attributes)\r\n* Search terms that _partially_ overlap an existing annotation will take precedence and replace any existing annotation\r\n* Search terms that are distinct from any annotations will just inject the appropriate `_hit.*` markup\r\n\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/407050820","html_url":"https://github.com/elastic/elasticsearch/issues/29467#issuecomment-407050820","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/29467","id":407050820,"node_id":"MDEyOklzc3VlQ29tbWVudDQwNzA1MDgyMA==","user":{"login":"markharwood","id":170925,"node_id":"MDQ6VXNlcjE3MDkyNQ==","avatar_url":"https://avatars0.githubusercontent.com/u/170925?v=4","gravatar_id":"","url":"https://api.github.com/users/markharwood","html_url":"https://github.com/markharwood","followers_url":"https://api.github.com/users/markharwood/followers","following_url":"https://api.github.com/users/markharwood/following{/other_user}","gists_url":"https://api.github.com/users/markharwood/gists{/gist_id}","starred_url":"https://api.github.com/users/markharwood/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/markharwood/subscriptions","organizations_url":"https://api.github.com/users/markharwood/orgs","repos_url":"https://api.github.com/users/markharwood/repos","events_url":"https://api.github.com/users/markharwood/events{/privacy}","received_events_url":"https://api.github.com/users/markharwood/received_events","type":"User","site_admin":false},"created_at":"2018-07-23T13:04:52Z","updated_at":"2018-07-23T13:04:52Z","author_association":"CONTRIBUTOR","body":"### Type-less annotations are now possible\r\nTo make life simple it is now possible to have annotations of this form:\r\n\r\n    [Cook](Tim+Cook&CEO) announced the new iphone\r\n\r\nIn this case the annotation values (`Tim Cook` and `CEO`) are just separated using `&` characters and injected directly into the token stream.  We no longer require this `type=value` syntax:\r\n\r\n    [Cook](person=Tim+Cook&role=CEO) announced the new iphone\r\n\r\nThe above syntax is still supported because, even though the types (`person` and `role`) are not used at all by the elasticsearch server, a client may have use for these when rendering the text and may want to use person icons etc.\r\n\r\nThe docs now promote the \"type-less\" syntax which should help remove [some of the confusion](https://github.com/elastic/elasticsearch/pull/30364#pullrequestreview-128000632) around how any type information may or may not be used or not in the indexing process.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/411359364","html_url":"https://github.com/elastic/elasticsearch/issues/29467#issuecomment-411359364","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/29467","id":411359364,"node_id":"MDEyOklzc3VlQ29tbWVudDQxMTM1OTM2NA==","user":{"login":"markharwood","id":170925,"node_id":"MDQ6VXNlcjE3MDkyNQ==","avatar_url":"https://avatars0.githubusercontent.com/u/170925?v=4","gravatar_id":"","url":"https://api.github.com/users/markharwood","html_url":"https://github.com/markharwood","followers_url":"https://api.github.com/users/markharwood/followers","following_url":"https://api.github.com/users/markharwood/following{/other_user}","gists_url":"https://api.github.com/users/markharwood/gists{/gist_id}","starred_url":"https://api.github.com/users/markharwood/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/markharwood/subscriptions","organizations_url":"https://api.github.com/users/markharwood/orgs","repos_url":"https://api.github.com/users/markharwood/repos","events_url":"https://api.github.com/users/markharwood/events{/privacy}","received_events_url":"https://api.github.com/users/markharwood/received_events","type":"User","site_admin":false},"created_at":"2018-08-08T10:22:22Z","updated_at":"2018-08-08T10:36:56Z","author_association":"CONTRIBUTOR","body":"(Following up on https://github.com/elastic/elasticsearch/pull/30364#issuecomment-411266742 )\r\n\r\n>It seems like the main use case for the simple format `([the company](Apple+Inc.))` is to provide a resolved entity. Here it makes sense to index the value without a special prefix\r\n\r\nThere's always potential for annotations (resolved or otherwise) to clash with text tokens  eg our own `[the company](elastic)`\r\n\r\n\r\n### How people search\r\n> itd be most natural to just search for `location=Beirut`\r\n\r\nOne thing to note is I expect people don't naturally type these tokens into searches. The query parsers we have assume free-text and would mangle the input. \r\nRather, I see people selecting tokens offered up in structured drop-downs, histograms etc and wanting to use those in queries, highlighting the sections of text that provide the context/evidence of where these locations were mentioned in results. If you have a Kibana bar chart of \"top location.keyword values\" it's frankly ugly if the bars are labelled `location=X` and `location=Y`. The \"location\" part is already implicit in your choice of structured field for the bar chart.\r\n\r\n### Typed tokens are a broader issue than annotated_text\r\nSpeaking more generally, we have work to do in adding more type info to fields. Even with structured data there is nothing that tells a generic tool like Kibana that tokens used in the `fromEmail` field have currency in the `toEmail` field and can be used interchangeably when exploring data, drawing graphs etc. We know they are both `keyword` fields, just like the `user-agent` field but have no clue that the type of tokens they store are `emailAddress` and are compatible. It may be worth branching an issue for this.\r\n\r\n### Proposal\r\nI suggest we drop the support for typed annotations and go with the type-less syntax in the first cut.\r\nBecause user values are url-encoded we shouldn't see any \"=\" characters in text markup meaning we can always safely introduce a typed key=value syntax later once we've figured out how best to handle typed annotations and the idea of token-typing more generally. \r\nThe challenge of escaping annotation values to avoid clashes with text tokens (or not, if that's desirable) is then a user responsibility. They don't have to second-guess how we might mangle any type info into indexed tokens (they'd need to recreate that scheme when they include the values in a structured field like `people` that sits alongside the `annotated_text` field and is used for aggregations).","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/411627969","html_url":"https://github.com/elastic/elasticsearch/issues/29467#issuecomment-411627969","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/29467","id":411627969,"node_id":"MDEyOklzc3VlQ29tbWVudDQxMTYyNzk2OQ==","user":{"login":"jtibshirani","id":7461306,"node_id":"MDQ6VXNlcjc0NjEzMDY=","avatar_url":"https://avatars3.githubusercontent.com/u/7461306?v=4","gravatar_id":"","url":"https://api.github.com/users/jtibshirani","html_url":"https://github.com/jtibshirani","followers_url":"https://api.github.com/users/jtibshirani/followers","following_url":"https://api.github.com/users/jtibshirani/following{/other_user}","gists_url":"https://api.github.com/users/jtibshirani/gists{/gist_id}","starred_url":"https://api.github.com/users/jtibshirani/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jtibshirani/subscriptions","organizations_url":"https://api.github.com/users/jtibshirani/orgs","repos_url":"https://api.github.com/users/jtibshirani/repos","events_url":"https://api.github.com/users/jtibshirani/events{/privacy}","received_events_url":"https://api.github.com/users/jtibshirani/received_events","type":"User","site_admin":false},"created_at":"2018-08-09T03:49:03Z","updated_at":"2018-08-09T04:44:26Z","author_association":"MEMBER","body":"> Rather, I see people selecting tokens offered up in structured drop-downs, histograms etc and wanting to use those in queries...\r\n\r\nGot it, I don't think I had the whole workflow straight in my head. To clarify my original comment, I wasn't imagining that the user would input the token `location=Beirut` directly, but rather that there would be some query processing step that would produce these tokens (maybe the same annotation pipeline is even run over the text of the query).\r\n\r\n> I suggest we drop the support for typed annotations and go with the type-less syntax in the first cut.\r\n\r\nThis makes sense to me -- it seems nice to keep the first version simple and focused. Users won't get ideas like I did about adding all other sorts of annotations :)","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/411699254","html_url":"https://github.com/elastic/elasticsearch/issues/29467#issuecomment-411699254","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/29467","id":411699254,"node_id":"MDEyOklzc3VlQ29tbWVudDQxMTY5OTI1NA==","user":{"login":"markharwood","id":170925,"node_id":"MDQ6VXNlcjE3MDkyNQ==","avatar_url":"https://avatars0.githubusercontent.com/u/170925?v=4","gravatar_id":"","url":"https://api.github.com/users/markharwood","html_url":"https://github.com/markharwood","followers_url":"https://api.github.com/users/markharwood/followers","following_url":"https://api.github.com/users/markharwood/following{/other_user}","gists_url":"https://api.github.com/users/markharwood/gists{/gist_id}","starred_url":"https://api.github.com/users/markharwood/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/markharwood/subscriptions","organizations_url":"https://api.github.com/users/markharwood/orgs","repos_url":"https://api.github.com/users/markharwood/repos","events_url":"https://api.github.com/users/markharwood/events{/privacy}","received_events_url":"https://api.github.com/users/markharwood/received_events","type":"User","site_admin":false},"created_at":"2018-08-09T09:37:50Z","updated_at":"2018-08-09T09:37:50Z","author_association":"CONTRIBUTOR","body":">maybe the same annotation pipeline is even run over the text of the query\r\n\r\nThat could be tricky. The analyzer expects annotation values in the `[Foo bar](Bar&Baz)` format and the characters `[](&}` are already reserved characters in parsers such as the Lucene query syntax. Relying on arcane query syntax/parsers doesn't seem like the way forward for me.\r\n[Here](https://youtu.be/E2GwKotUZAU?t=1m54s) is an example where the query is expressed by dragging the annotation hyperlink directly out of a document's text into a visual query builder. I think there's more work to be done in visually emphasizing the difference between \"thing\" and \"string\" clauses but the idea of using visual query builders makes more sense to me.\r\n\r\n>Users won't get ideas\r\n\r\nIdeas are great! Feels right to see where we they lead us next if we start with just the simple approach.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/412889026","html_url":"https://github.com/elastic/elasticsearch/issues/29467#issuecomment-412889026","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/29467","id":412889026,"node_id":"MDEyOklzc3VlQ29tbWVudDQxMjg4OTAyNg==","user":{"login":"jpountz","id":299848,"node_id":"MDQ6VXNlcjI5OTg0OA==","avatar_url":"https://avatars2.githubusercontent.com/u/299848?v=4","gravatar_id":"","url":"https://api.github.com/users/jpountz","html_url":"https://github.com/jpountz","followers_url":"https://api.github.com/users/jpountz/followers","following_url":"https://api.github.com/users/jpountz/following{/other_user}","gists_url":"https://api.github.com/users/jpountz/gists{/gist_id}","starred_url":"https://api.github.com/users/jpountz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jpountz/subscriptions","organizations_url":"https://api.github.com/users/jpountz/orgs","repos_url":"https://api.github.com/users/jpountz/repos","events_url":"https://api.github.com/users/jpountz/events{/privacy}","received_events_url":"https://api.github.com/users/jpountz/received_events","type":"User","site_admin":false},"created_at":"2018-08-14T14:21:28Z","updated_at":"2018-08-14T14:21:28Z","author_association":"CONTRIBUTOR","body":"> I suggest we drop the support for typed annotations and go with the type-less syntax in the first cut.\r\n\r\n+1\r\n\r\n> The challenge of escaping annotation values to avoid clashes with text tokens (or not, if that's desirable) is then a user responsibility.\r\n\r\nAgreed, but then let's make the docs give examples with a format that reduces clashes, eg. `[the company]{company:Elastic}` rather than `[the company]{Elastic}`.\r\n\r\n> Because user values are url-encoded we shouldn't see any \"=\" characters in text markup meaning we can always safely introduce a typed key=value syntax later\r\n\r\nThat feels like a dangerous assumption to me. Let's reject equals signs explicitly?","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/412901293","html_url":"https://github.com/elastic/elasticsearch/issues/29467#issuecomment-412901293","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/29467","id":412901293,"node_id":"MDEyOklzc3VlQ29tbWVudDQxMjkwMTI5Mw==","user":{"login":"markharwood","id":170925,"node_id":"MDQ6VXNlcjE3MDkyNQ==","avatar_url":"https://avatars0.githubusercontent.com/u/170925?v=4","gravatar_id":"","url":"https://api.github.com/users/markharwood","html_url":"https://github.com/markharwood","followers_url":"https://api.github.com/users/markharwood/followers","following_url":"https://api.github.com/users/markharwood/following{/other_user}","gists_url":"https://api.github.com/users/markharwood/gists{/gist_id}","starred_url":"https://api.github.com/users/markharwood/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/markharwood/subscriptions","organizations_url":"https://api.github.com/users/markharwood/orgs","repos_url":"https://api.github.com/users/markharwood/repos","events_url":"https://api.github.com/users/markharwood/events{/privacy}","received_events_url":"https://api.github.com/users/markharwood/received_events","type":"User","site_admin":false},"created_at":"2018-08-14T14:56:13Z","updated_at":"2018-08-14T14:56:13Z","author_association":"CONTRIBUTOR","body":">Let's reject equals signs explicitly?\r\n\r\nThe issue here is we don't tend to reject noisily - the syntax is somewhat permissive in that we don't throw errors if we find `[..]` and don't have a corresponding `(...)`. Do we decide to get picky about use of `[...](x=y)` markup?\r\n\r\nI guess the options are:\r\n1) Reject annotation with error\r\n2) Reject annotation with no error\r\n3) Ignore any `key` part of a `key=value` pair.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/417016283","html_url":"https://github.com/elastic/elasticsearch/issues/29467#issuecomment-417016283","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/29467","id":417016283,"node_id":"MDEyOklzc3VlQ29tbWVudDQxNzAxNjI4Mw==","user":{"login":"markharwood","id":170925,"node_id":"MDQ6VXNlcjE3MDkyNQ==","avatar_url":"https://avatars0.githubusercontent.com/u/170925?v=4","gravatar_id":"","url":"https://api.github.com/users/markharwood","html_url":"https://github.com/markharwood","followers_url":"https://api.github.com/users/markharwood/followers","following_url":"https://api.github.com/users/markharwood/following{/other_user}","gists_url":"https://api.github.com/users/markharwood/gists{/gist_id}","starred_url":"https://api.github.com/users/markharwood/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/markharwood/subscriptions","organizations_url":"https://api.github.com/users/markharwood/orgs","repos_url":"https://api.github.com/users/markharwood/repos","events_url":"https://api.github.com/users/markharwood/events{/privacy}","received_events_url":"https://api.github.com/users/markharwood/received_events","type":"User","site_admin":false},"created_at":"2018-08-29T16:26:52Z","updated_at":"2018-08-29T16:26:52Z","author_association":"CONTRIBUTOR","body":"### Re-think: clients want types\r\nI had a chat with @colings86 and we agreed annotation type **is** [useful to client apps](https://github.com/elastic/elasticsearch/pull/30364#issuecomment-415338872). \r\nMore generally, structured fields could also use some [entity type metadata](https://github.com/elastic/kibana/issues/22486) - hopefully the annotation's idea of token type would align with entity types assigned to structured fields. Knowing an annotation is type \"movieID\" would, for example invite drill-downs on a structured field known to hold entities of the type \"movieID\".\r\n\r\n### How to handle types in annotations?\r\nColin and I assumed that `type=value` would still be the syntax to use in the annotation markup e.g. `person=Donald+Trump` but the question remains what if anything elasticsearch does with this type info. We need to pick from one of these possible options:\r\n\r\nOption No. | Indexed value | Indexing notes | Example client searches\r\n---- | ---- | ------- | ------ \r\n1 | `person=Donald Trump`| The type information is ignored by elasticsearch and considered part of the value | new TermQuery(\"text\", \"person=Donald Trump\") <br><br> new SpanTermQuery (\"text\",  \"person=DonaldTrump\") \r\n2 | `Donald Trump`| The \"person=\" type information is stripped by elasticsearch.  | new TermQuery(\"text\", \"Donald Trump\") <br><br> new SpanTermQuery (\"text\",  \"DonaldTrump\") \r\n3 | ??? (hidden, subject to change)| Elasticsearch encodes type info with the value but clients must use new TermQuery and SpanTermQuery variants designed to hide the implementation details of how type is encoded with the value in the index | new AnnotatedTermQuery(\"text\", \"person\", \"Donald Trump\") <br><br>new AnnotatedSpanTermQuery(\"text\", \"person\", \"Donald Trump\")\r\n\r\nOption 1 is pretty transparent. However, clients would need to remember when drilling down from structured-fields to prefix the selected values (eg `Donald Trump`) with the field's entity type (eg `person`). Note also that the idea of a field having an [\"entity type\" is not something Kibana knows about currently](https://github.com/elastic/kibana/issues/22486).\r\n\r\nOption 2 is less work for clients (no prefixing of values is required) but suffers in that searches for annotation terms may over-match with text tokens or annotations of different types. Much depends on the global uniqueness of the choice of annotation values. In the case of Wikipedia, article IDs are always unique across types anyway e.g `Mastodon` vs `Mastodon (band)`. Clashes with Wikipedia article IDs and regular indexed text tokens were minimal - only one of the 500k+ person article IDs clashed with indexed plain-text values and that was a producer called [1.8.7](https://en.wikipedia.org/wiki/1.8.7) who clashed with an article on Ruby version 1.8.7. \r\n \r\nOption 3 is similar to option 1 but buys some flexibility in the choice of type-encoding strategy at the cost of needing specialised query classes that encapsulate this decision. \r\n\r\nCan we pick one of these strategies @jpountz @jimczi @colings86 so we can put this to bed?\r\n\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/417280816","html_url":"https://github.com/elastic/elasticsearch/issues/29467#issuecomment-417280816","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/29467","id":417280816,"node_id":"MDEyOklzc3VlQ29tbWVudDQxNzI4MDgxNg==","user":{"login":"markharwood","id":170925,"node_id":"MDQ6VXNlcjE3MDkyNQ==","avatar_url":"https://avatars0.githubusercontent.com/u/170925?v=4","gravatar_id":"","url":"https://api.github.com/users/markharwood","html_url":"https://github.com/markharwood","followers_url":"https://api.github.com/users/markharwood/followers","following_url":"https://api.github.com/users/markharwood/following{/other_user}","gists_url":"https://api.github.com/users/markharwood/gists{/gist_id}","starred_url":"https://api.github.com/users/markharwood/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/markharwood/subscriptions","organizations_url":"https://api.github.com/users/markharwood/orgs","repos_url":"https://api.github.com/users/markharwood/repos","events_url":"https://api.github.com/users/markharwood/events{/privacy}","received_events_url":"https://api.github.com/users/markharwood/received_events","type":"User","site_admin":false},"created_at":"2018-08-30T11:06:20Z","updated_at":"2018-08-30T11:06:20Z","author_association":"CONTRIBUTOR","body":"My vote for the above is option 2 - stripping types. The other options use type in the index and rely on a client that holds and understands entity types for each field - I don't think Kibana is going to be that smart in the short term.\r\nI propose the docs still offer \"untyped\" examples of markup and the code stays as-is, stripping any  type info from values (which in my view is the least-worst of the validation choices outlined in https://github.com/elastic/elasticsearch/issues/29467#issuecomment-412901293) \r\n\r\nIf elasticsearch decides to do something funky with types in future (in terms of index-encoding), then we have already reserved the right to do that in a non-BWC way with the use of the `experimental` marker on this feature.\r\n\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/417698556","html_url":"https://github.com/elastic/elasticsearch/issues/29467#issuecomment-417698556","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/29467","id":417698556,"node_id":"MDEyOklzc3VlQ29tbWVudDQxNzY5ODU1Ng==","user":{"login":"markharwood","id":170925,"node_id":"MDQ6VXNlcjE3MDkyNQ==","avatar_url":"https://avatars0.githubusercontent.com/u/170925?v=4","gravatar_id":"","url":"https://api.github.com/users/markharwood","html_url":"https://github.com/markharwood","followers_url":"https://api.github.com/users/markharwood/followers","following_url":"https://api.github.com/users/markharwood/following{/other_user}","gists_url":"https://api.github.com/users/markharwood/gists{/gist_id}","starred_url":"https://api.github.com/users/markharwood/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/markharwood/subscriptions","organizations_url":"https://api.github.com/users/markharwood/orgs","repos_url":"https://api.github.com/users/markharwood/repos","events_url":"https://api.github.com/users/markharwood/events{/privacy}","received_events_url":"https://api.github.com/users/markharwood/received_events","type":"User","site_admin":false},"created_at":"2018-08-31T15:22:37Z","updated_at":"2018-08-31T15:22:37Z","author_association":"CONTRIBUTOR","body":"Had a chat with @jpountz and we agreed that a type system for annotations should come later (hopefully sharing the notion of [entity types](https://github.com/elastic/kibana/issues/22486) from metadata also used in `keyword` fields).\r\n\r\nIn the interim we said we should reject as malformed any documents that have annotations using the `[foo](key=value)` syntax rather than the `[foo](value)` syntax.\r\n\r\nOK with this, @colings86 ?\r\n ","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/417709133","html_url":"https://github.com/elastic/elasticsearch/issues/29467#issuecomment-417709133","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/29467","id":417709133,"node_id":"MDEyOklzc3VlQ29tbWVudDQxNzcwOTEzMw==","user":{"login":"colings86","id":236731,"node_id":"MDQ6VXNlcjIzNjczMQ==","avatar_url":"https://avatars0.githubusercontent.com/u/236731?v=4","gravatar_id":"","url":"https://api.github.com/users/colings86","html_url":"https://github.com/colings86","followers_url":"https://api.github.com/users/colings86/followers","following_url":"https://api.github.com/users/colings86/following{/other_user}","gists_url":"https://api.github.com/users/colings86/gists{/gist_id}","starred_url":"https://api.github.com/users/colings86/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/colings86/subscriptions","organizations_url":"https://api.github.com/users/colings86/orgs","repos_url":"https://api.github.com/users/colings86/repos","events_url":"https://api.github.com/users/colings86/events{/privacy}","received_events_url":"https://api.github.com/users/colings86/received_events","type":"User","site_admin":false},"created_at":"2018-08-31T15:56:24Z","updated_at":"2018-08-31T15:56:24Z","author_association":"MEMBER","body":"Sounds good to me  ","performed_via_github_app":null}]