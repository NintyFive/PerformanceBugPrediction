{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/12293","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/12293/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/12293/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/12293/events","html_url":"https://github.com/elastic/elasticsearch/issues/12293","id":95461584,"node_id":"MDU6SXNzdWU5NTQ2MTU4NA==","number":12293,"title":"Item Query (the API)","user":{"login":"alexksikes","id":43475,"node_id":"MDQ6VXNlcjQzNDc1","avatar_url":"https://avatars2.githubusercontent.com/u/43475?v=4","gravatar_id":"","url":"https://api.github.com/users/alexksikes","html_url":"https://github.com/alexksikes","followers_url":"https://api.github.com/users/alexksikes/followers","following_url":"https://api.github.com/users/alexksikes/following{/other_user}","gists_url":"https://api.github.com/users/alexksikes/gists{/gist_id}","starred_url":"https://api.github.com/users/alexksikes/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alexksikes/subscriptions","organizations_url":"https://api.github.com/users/alexksikes/orgs","repos_url":"https://api.github.com/users/alexksikes/repos","events_url":"https://api.github.com/users/alexksikes/events{/privacy}","received_events_url":"https://api.github.com/users/alexksikes/received_events","type":"User","site_admin":false},"labels":[{"id":146832564,"node_id":"MDU6TGFiZWwxNDY4MzI1NjQ=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/:Search/Search","name":":Search/Search","color":"0e8a16","default":false,"description":"Search-related issues that do not fall into other categories"},{"id":23172,"node_id":"MDU6TGFiZWwyMzE3Mg==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/%3Efeature","name":">feature","color":"006b75","default":false,"description":null},{"id":158399402,"node_id":"MDU6TGFiZWwxNTgzOTk0MDI=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/Meta","name":"Meta","color":"e11d21","default":false,"description":null}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":11,"created_at":"2015-07-16T15:36:26Z","updated_at":"2019-04-02T12:46:57Z","closed_at":"2019-04-02T12:46:56Z","author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"## Introduction\n\nIn this issue we will present the API for [Item Query](https://github.com/elastic/elasticsearch/issues/11814). Item Query is a different implementation of More Like This (MLT) which is purely based on the [term vectors API](https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-termvectors.html). It could be described as a more powerful and generalized MLT. Item Query performs similarity search in three distinct steps. First, the user specifies a set of document input(s). Second, the documents are translated into vectors that best describe each of these documents. We call these vectors characteristic vectors, because they are sought to characterize each item. Third, a query is generated from the terms in the characteristic vectors and is executed. So to summarize, Item Query goes from documents (or items) to terms, and from terms to a query. The API gives the user complete control over each of these steps:\n\n``` javascript\n{\n  \"item_query\": {\n    \"items\": {\n      ... how items are specified ...\n    },\n    \"terms\": {\n      ... how terms are selected for every item ...\n    }\n    \"query\": {\n      ... how the query is formed from the terms ...\n    }\n  }\n}\n```\n\nWe will describe each of these parameters in more detail in the following sections. But first let us mention that only `items`, also shorthanded `item` if there is only one item, is required. All the other parameters use sensible defaults. Following is an example query with some explanations.\n\n``` javascript\n{\n  \"item_query\": {\n    \"items\": {\n      \"item_1\": {\n        \"_index\": \"index\",\n        \"_type\": \"type\",\n        \"_id\": \"1\"\n      },\n      \"item_2\": {\n        \"_index\": \"index\",\n        \"_type\": \"type\",\n        \"_id\": \"2\",\n      }\n    },\n    \"query\": {\n      \"combination\": \"2*item_1 + item_2\",\n      \"min_should_match\": \"30%\"\n    }\n  }\n}\n```\n\nHere the user has specified two items from which he would like to find similar items (or documents). To do so he has specified the `_index`, `_type` and `_id` of each item. He has additionally given them the name item_1 and item_2 respectively. From these items a characteristic vector is generated and combined according the rule \"2*item_1 + item_2\". We will describe the `combination` rule in more detail. But basically this lets us write any linear combination of the characteristic vectors, so we could model things like: \"I like item_1 twice more than item_2\", or \"I like item_1 but dislike stuff from item_2\". From the result of this operation, only the best terms are kept and then used to generate a boolean `OR` query with the given `min_should_match`. This query is then executed and the top matching documents are returned to the user as usual.\n\nWe now describe in more detail the `items`, `terms` and `query` parameters.\n## The `items` parameter\n\nThe `items` parameter can be specified as an array of document inputs, or as an object of named document inputs to be used for combination. We can also use the shorthand notation `item` followed by a single document specification if there is only one item. Each document input correspond to the parameters of the [term vectors API](https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-termvectors.htm). The main parameters are:\n\n| Parameter | Description | Required | Default |\n| --- | --- | --- | --- |\n| _index | index where to fetch item | if not in context | context |\n| _type | type where to fetch or parse item | if not in context | context |\n| _id | item id | if no `doc` | none |\n| doc | artificial doc | if no `_id` | none |\n\nSomething important to mention is that like text queries (`like_text` in MLT) are supported with [artificial documents](https://www.elastic.co/guide/en/elasticsearch/reference/1.6/docs-termvectors.html#docs-termvectors-artificial-doc). Other per item parameters include `fields`, `filter`, `dfs` or `per_field_analyzer` and are used to override the settings in the `terms` parameter if need be.\n## The `terms` parameter\n\nThe `terms` parameter is optional. It specifies top level parameters as to how to generate the characteristic vectors of each item. It corresponds to the `parameters` of the [multi-term vectors API](https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-multi-termvectors.html). The main parameters are:\n\n| Parameter | Description | Default |\n| --- | --- | --- |\n| fields | fields to fetch the terms from | * |\n| filter | terms filtering parameter | MLT like |\n| per_field_analyzer | overrides analyzer at the field | analyzer at the field |\n| dfs | whether to use dfs for exact scoring | false |\n\nBy default the `filter` parameter selects the best term in a similar fashion to MLT, that is using the same defaults. Under the hood this uses the [terms filtering feature](https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-termvectors.html#_terms_filtering) of the term vectors API.\n## The `query` parameter\n\nThe `query` parameter is optional. It corresponds to the same [query formation parameters](https://www.elastic.co/guide/en/elasticsearch/reference/master/query-dsl-mlt-query.html#_query_formation_parameters) as MLT, with the same defaults.\n\n| Parameter | Description | Default |\n| --- | --- | --- |\n| minimum_should_match | number of terms that must match | 30% |\n| boost_terms | boost each term by score \\* boost factor | 0 (deactivated) |\n| include | include input documents | false |\n| combination | linear combination of the characteristic vectors | sum of the vectors |\n\nAll the parameters are straight forward. The `combination` parameter requires more explanation and is probably best described with an example. Something to note though is that, like all the parameters of `query`, this parameter is optional and defaults to simply summing the entries of the resulting characteristic vectors. Let us go through an example to better explain this parameter.\n\nFrom the previous query, suppose the characteristic vectors for item_1 and item_2 would look like this:\n\nVector for item_1:\n\n| term_a | term_b | term_c |\n| --- | --- | --- |\n| 1 | 2.5 | 0.5 |\n\nVector for item_2:\n\n| term_a | term_c | term_d |\n| --- | --- | --- |\n| 1 | 3 | 7 |\n\nUnder the combination rule \"2*item_1 + item_2\" this would give us:\n\n| term_a | term_b | term_c | term_d |\n| --- | --- | --- | --- |\n| 2*1 + 1 = 3 | 2*2.5 = 5 | 2*0.5 + 3 = 4 | 7 |\n\nWhich would then subsequently result in the following final characteristic vector being chosen:\n\n| term_b | term_c | term_d |\n| --- | --- | --- |\n| 5 | 4 | 7 |\n\nWe could also have written something like \"2*item_1 - item_2\" to model dislikes. In this case, the possibly negative entries are just ignored, and therefore will not be part of the final generated query.\n## Conclusion\n\nTo summarize an item query could be as simple as:\n\n``` javascript\n{\n  \"item_query\": {\n    \"item\": {\n      \"_index\": \"index\",\n      \"_type\": \"type\",\n      \"_id\": \"1\"\n    }\n  }\n}\n```\n\nOr as complicated as:\n\n``` javascript\n{\n  \"item_query\": {\n    \"items\": {\n      \"item_1\": {\n        \"_index\": \"index\",\n        \"_type\": \"type\",\n        \"_id\": \"1\"\n      },\n      \"item_2\": {\n        \"_index\": \"index\",\n        \"_type\": \"type\",\n        \"_id\": \"2\"\n      },\n      \"item_3\": {\n        \"_index\": \"index\",\n        \"_type\": \"type\",\n        \"doc\": {\n          \"plot\": \"A human-looking indestructible cyborg is sent from 2029 to 1984 to assassinate a waitress\"\n        }\n      }\n    },\n    \"terms\": {\n      \"fields\": [\n        \"plot\",\n        \"title\"\n      ],\n      \"filter\": {\n        \"max_num_terms\": 100,\n        \"min_doc_freq\": 1\n      }\n    },\n    \"query\": {\n      \"combination\": \"item_1 + item_2 - 3*item_3\",\n      \"min_should_match\": \"30%\"\n    }\n  }\n}\n```\n\nThe API gives complete control over each step from item specification to query generation. It is as simple to use as MLT, while at the same time powerful enough to perform sophisticated nearest neighbor type of searches.\n","closed_by":{"login":"jimczi","id":15977469,"node_id":"MDQ6VXNlcjE1OTc3NDY5","avatar_url":"https://avatars0.githubusercontent.com/u/15977469?v=4","gravatar_id":"","url":"https://api.github.com/users/jimczi","html_url":"https://github.com/jimczi","followers_url":"https://api.github.com/users/jimczi/followers","following_url":"https://api.github.com/users/jimczi/following{/other_user}","gists_url":"https://api.github.com/users/jimczi/gists{/gist_id}","starred_url":"https://api.github.com/users/jimczi/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jimczi/subscriptions","organizations_url":"https://api.github.com/users/jimczi/orgs","repos_url":"https://api.github.com/users/jimczi/repos","events_url":"https://api.github.com/users/jimczi/events{/privacy}","received_events_url":"https://api.github.com/users/jimczi/received_events","type":"User","site_admin":false},"performed_via_github_app":null}