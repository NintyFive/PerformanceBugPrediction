[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/533269316","html_url":"https://github.com/elastic/elasticsearch/issues/46887#issuecomment-533269316","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/46887","id":533269316,"node_id":"MDEyOklzc3VlQ29tbWVudDUzMzI2OTMxNg==","user":{"login":"elasticmachine","id":15837671,"node_id":"MDQ6VXNlcjE1ODM3Njcx","avatar_url":"https://avatars3.githubusercontent.com/u/15837671?v=4","gravatar_id":"","url":"https://api.github.com/users/elasticmachine","html_url":"https://github.com/elasticmachine","followers_url":"https://api.github.com/users/elasticmachine/followers","following_url":"https://api.github.com/users/elasticmachine/following{/other_user}","gists_url":"https://api.github.com/users/elasticmachine/gists{/gist_id}","starred_url":"https://api.github.com/users/elasticmachine/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/elasticmachine/subscriptions","organizations_url":"https://api.github.com/users/elasticmachine/orgs","repos_url":"https://api.github.com/users/elasticmachine/repos","events_url":"https://api.github.com/users/elasticmachine/events{/privacy}","received_events_url":"https://api.github.com/users/elasticmachine/received_events","type":"User","site_admin":false},"created_at":"2019-09-19T19:13:10Z","updated_at":"2019-09-19T19:13:10Z","author_association":"COLLABORATOR","body":"Pinging @elastic/es-security","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/533555748","html_url":"https://github.com/elastic/elasticsearch/issues/46887#issuecomment-533555748","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/46887","id":533555748,"node_id":"MDEyOklzc3VlQ29tbWVudDUzMzU1NTc0OA==","user":{"login":"bytebilly","id":52658645,"node_id":"MDQ6VXNlcjUyNjU4NjQ1","avatar_url":"https://avatars0.githubusercontent.com/u/52658645?v=4","gravatar_id":"","url":"https://api.github.com/users/bytebilly","html_url":"https://github.com/bytebilly","followers_url":"https://api.github.com/users/bytebilly/followers","following_url":"https://api.github.com/users/bytebilly/following{/other_user}","gists_url":"https://api.github.com/users/bytebilly/gists{/gist_id}","starred_url":"https://api.github.com/users/bytebilly/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bytebilly/subscriptions","organizations_url":"https://api.github.com/users/bytebilly/orgs","repos_url":"https://api.github.com/users/bytebilly/repos","events_url":"https://api.github.com/users/bytebilly/events{/privacy}","received_events_url":"https://api.github.com/users/bytebilly/received_events","type":"User","site_admin":false},"created_at":"2019-09-20T13:33:41Z","updated_at":"2019-09-20T13:33:41Z","author_association":"NONE","body":"@cjcenizal yes this makes sense to me.\r\nCurrently, a possible workaround to retrieve the entire list is to call the existing API with all the realms that are configured in the system. I'm not sure if there is a way to obtain the list of realms, but this would not require any backend change in the API code.\r\n\r\nA couple of thoughts we could consider as part of this discussion:\r\n1. add the \"owner\" of the key (principal+realm?) to the response for each entry\r\n1. make it work with the `manage_own_api_key`, transparently filtering results based on permissions\r\n1. paginate results, if we feel this list could be too long for a single response","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/534412903","html_url":"https://github.com/elastic/elasticsearch/issues/46887#issuecomment-534412903","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/46887","id":534412903,"node_id":"MDEyOklzc3VlQ29tbWVudDUzNDQxMjkwMw==","user":{"login":"tvernum","id":2244393,"node_id":"MDQ6VXNlcjIyNDQzOTM=","avatar_url":"https://avatars0.githubusercontent.com/u/2244393?v=4","gravatar_id":"","url":"https://api.github.com/users/tvernum","html_url":"https://github.com/tvernum","followers_url":"https://api.github.com/users/tvernum/followers","following_url":"https://api.github.com/users/tvernum/following{/other_user}","gists_url":"https://api.github.com/users/tvernum/gists{/gist_id}","starred_url":"https://api.github.com/users/tvernum/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/tvernum/subscriptions","organizations_url":"https://api.github.com/users/tvernum/orgs","repos_url":"https://api.github.com/users/tvernum/repos","events_url":"https://api.github.com/users/tvernum/events{/privacy}","received_events_url":"https://api.github.com/users/tvernum/received_events","type":"User","site_admin":false},"created_at":"2019-09-24T06:36:16Z","updated_at":"2019-09-24T06:36:16Z","author_association":"CONTRIBUTOR","body":"@bizybot will sort this out. It was an oversight due to making the GET and DELETE APIs support the same set of parameters, and intentionally not wanting an DELETE-everything API.\r\n\r\n> 1. add the \"owner\" of the key (principal+realm?) to the response for each entry\r\n\r\nWe do that already. If you look at the `GET` response in the [example section of the docs](https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-api-key.html#security-api-get-api-key-example), it has `username` and `realm`.\r\n\r\n> 2.  make it work with the manage_own_api_key, transparently filtering results based on permissions\r\n\r\nIt is intentional that we don't so this. We essentially have 2 APIs (though for reasons of history, it's 1 API with an optional parameter).\r\nIf you specify `owner=true` it automatically filters to only show your API keys (if you have access to API keys)\r\nif you specify `owner=false` (or don't specify it at all, because `false` is the default), it attempts to show API keys for all owners (if you have access to do so).\r\n\r\nWe try very hard to have APIs that do what they say, and give you errors if you are not permitted to do so, rather than having APIs that significantly change behaviour depending on your access level.\r\nfor the `GET` API that's not so bad, but for the `DELETE` API, having it delete your keys if you had `manage_own_api_key` but delete everyone's keys if you have `manage_api_key` is the sort of unexpected behaviour we don't want.\r\n  \r\n> 3.  paginate results, if we feel this list could be too long for a single response\r\n\r\nThis is a problem today (and not just for API keys, it's also true for listing users).\r\nInterally we do a scroll and collect all the results within the `GET` API. At some point that will exceed a reasonable usage of memory, and we ought not to do that, but exposing scroll-ids over the security index is a problem (technically we have protections there, but I have a strong preference not to rely on them as our only line of defense). \r\nWhen we introduce \"system indices\" and switch the security index across it might be safe enough to hand out an opaque scroll id over than index that isn't accessible via the search APIs. \r\n","performed_via_github_app":null}]