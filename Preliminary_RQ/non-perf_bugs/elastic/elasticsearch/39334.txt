{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/39334","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/39334/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/39334/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/39334/events","html_url":"https://github.com/elastic/elasticsearch/issues/39334","id":413721864,"node_id":"MDU6SXNzdWU0MTM3MjE4NjQ=","number":39334,"title":"Support for automatic release of index block once disk frees up","user":{"login":"Bukhtawar","id":12809319,"node_id":"MDQ6VXNlcjEyODA5MzE5","avatar_url":"https://avatars0.githubusercontent.com/u/12809319?v=4","gravatar_id":"","url":"https://api.github.com/users/Bukhtawar","html_url":"https://github.com/Bukhtawar","followers_url":"https://api.github.com/users/Bukhtawar/followers","following_url":"https://api.github.com/users/Bukhtawar/following{/other_user}","gists_url":"https://api.github.com/users/Bukhtawar/gists{/gist_id}","starred_url":"https://api.github.com/users/Bukhtawar/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Bukhtawar/subscriptions","organizations_url":"https://api.github.com/users/Bukhtawar/orgs","repos_url":"https://api.github.com/users/Bukhtawar/repos","events_url":"https://api.github.com/users/Bukhtawar/events{/privacy}","received_events_url":"https://api.github.com/users/Bukhtawar/received_events","type":"User","site_admin":false},"labels":[{"id":837246479,"node_id":"MDU6TGFiZWw4MzcyNDY0Nzk=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/:Distributed/Allocation","name":":Distributed/Allocation","color":"0e8a16","default":false,"description":"All issues relating to the decision making around placing a shard (both master logic & on the nodes)"},{"id":110815527,"node_id":"MDU6TGFiZWwxMTA4MTU1Mjc=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/help%20wanted","name":"help wanted","color":"207de5","default":true,"description":"adoptme"}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":11,"created_at":"2019-02-23T18:18:05Z","updated_at":"2019-08-07T09:55:29Z","closed_at":"2019-08-07T09:55:29Z","author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"### The Problem\r\nThe `DiskThresholdMonitor` in Elasticsearch monitors for disk utilization across nodes periodically based on `cluster.info.update.interval` and ends up putting a `INDEX_READ_ONLY_ALLOW_DELETE_BLOCK` on every index that has atleast one shard on a node that breaches `cluster.routing.allocation.disk.watermark.flood_stage` but leaves those indices in the same state even after disk frees up, putting the onus on the end user to manually unblock those indices. This issue has been initiated as a part of #24299([comment](https://github.com/elastic/elasticsearch/issues/24299#issuecomment-465707036)) \r\n\r\n\r\n### Proposed Solution\r\nThe master is already checking for disk utilization across nodes to see if nodes are going over the `flood` threshold. So if we find any index block in the cluster state that should no longer be blocked based on the latest run of the disk monitor we should go ahead unblock those indices. The solution should mark index block which breach the threshold as `INDEX_READ_ONLY_ALLOW_DELETE_BLOCK` and the unblock the ones which already have blocks based on `state.getBlocks().indexBlocked(ClusterBlockLevel.WRITE, index)` but no longer match the indices. The only challenge would be to distinguish a customer requested block for `SETTING_READ_ONLY_ALLOW_DELETE` vs the one added by the disk monitor. To solve this we can either introduce a parameter in the request and a separate block to mark the indices from monitor differently. \r\n","closed_by":{"login":"DaveCTurner","id":5058284,"node_id":"MDQ6VXNlcjUwNTgyODQ=","avatar_url":"https://avatars3.githubusercontent.com/u/5058284?v=4","gravatar_id":"","url":"https://api.github.com/users/DaveCTurner","html_url":"https://github.com/DaveCTurner","followers_url":"https://api.github.com/users/DaveCTurner/followers","following_url":"https://api.github.com/users/DaveCTurner/following{/other_user}","gists_url":"https://api.github.com/users/DaveCTurner/gists{/gist_id}","starred_url":"https://api.github.com/users/DaveCTurner/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/DaveCTurner/subscriptions","organizations_url":"https://api.github.com/users/DaveCTurner/orgs","repos_url":"https://api.github.com/users/DaveCTurner/repos","events_url":"https://api.github.com/users/DaveCTurner/events{/privacy}","received_events_url":"https://api.github.com/users/DaveCTurner/received_events","type":"User","site_admin":false},"performed_via_github_app":null}