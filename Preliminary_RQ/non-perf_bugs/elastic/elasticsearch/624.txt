{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/624","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/624/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/624/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/624/events","html_url":"https://github.com/elastic/elasticsearch/issues/624","id":524625,"node_id":"MDU6SXNzdWU1MjQ2MjU=","number":624,"title":"Percolator","user":{"login":"kimchy","id":41300,"node_id":"MDQ6VXNlcjQxMzAw","avatar_url":"https://avatars1.githubusercontent.com/u/41300?v=4","gravatar_id":"","url":"https://api.github.com/users/kimchy","html_url":"https://github.com/kimchy","followers_url":"https://api.github.com/users/kimchy/followers","following_url":"https://api.github.com/users/kimchy/following{/other_user}","gists_url":"https://api.github.com/users/kimchy/gists{/gist_id}","starred_url":"https://api.github.com/users/kimchy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/kimchy/subscriptions","organizations_url":"https://api.github.com/users/kimchy/orgs","repos_url":"https://api.github.com/users/kimchy/repos","events_url":"https://api.github.com/users/kimchy/events{/privacy}","received_events_url":"https://api.github.com/users/kimchy/received_events","type":"User","site_admin":false},"labels":[{"id":23172,"node_id":"MDU6TGFiZWwyMzE3Mg==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/%3Efeature","name":">feature","color":"006b75","default":false,"description":null},{"id":65354,"node_id":"MDU6TGFiZWw2NTM1NA==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/v0.15.0","name":"v0.15.0","color":"ededed","default":false,"description":null}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":2,"created_at":"2011-01-13T14:19:50Z","updated_at":"2011-02-08T20:18:48Z","closed_at":"2011-01-13T22:20:52Z","author_association":"MEMBER","active_lock_reason":null,"body":"The percolator allows to register queries against an index, and then send `percolate` requests which include a doc, and getting back the queries that match on that doc out of the set of registered queries.\n\nThink of it as the revert operation of what ES does by nature. Instead of sending docs, indexing them, and then running queries. One sends queries, registers them, and then sends docs and finds out which queries match that doc.\n\nAs an example, a user can register an interest (a query) on all tweets that contain the word \"elasticsearch\". For every tweet, one can percolate the tweet against all registered user queries, and find out which ones matched.\n## Quick Sample\n\nFirst, create an index we will work with:\n\n```\ncurl -XPUT localhost:9200/test\n```\n\nNext, we will register a percolator query with a specific name called `kuku` against the `test` index:\n\n```\ncurl -XPUT localhost:9200/_percolator/test/kuku -d '{\n    \"query\" : {\n        \"term\" : {\n            \"field1\" : \"value1\"\n        }\n    }\n}'\n```\n\nAnd now, we can percolate a document and see which queries match on it (note, its not really indexed!):\n\n```\ncurl -XGET localhost:9200/test/type1/_percolate -d '{\n    \"doc\" : {\n        \"field1\" : \"value1\"\n    }\n}'\n```\n\nAnd the matches are part of the response:\n\n```\n{\"ok\":true,\"matches\":[\"kuku\"]}\n```\n## Filtering Executed Queries\n\nSince the registered percolator queries are just docs in an index, one can filter the queries that will be used to percolate a doc. For example, we can add a `color` field to the registered query:\n\n```\ncurl -XPUT localhost:9200/_percolator/test/kuku -d '{\n    \"color\" : \"blue\"\n    \"query\" : {\n        \"term\" : {\n            \"field1\" : \"value1\"\n        }\n    }\n}'\n```\n\nAnd then, we can percolate a doc that only matches on blue colors:\n\n```\ncurl -XGET localhost:9200/test/type1/_percolate -d '{\n    \"doc\" : {\n        \"field1\" : \"value1\"\n    },\n    \"query\" : {\n        \"term\" : {\n            \"color\" : \"blue\"\n        }\n    }\n}'\n```\n## How to Works\n\nThe `_percolator` which holds the repository of registered queries is just a another index in ES. The query is registered under a concrete index that exists (or will exist) in ES. That index name is represented as the type in the `_percolator` index (a bit confusing, I know...).\n\nThe fact that the queries are stored as docs in another index (`_percolator`) gives us both the persistency nature of it, and the ability to filter out queries to execute using another query :).\n\nThe `_percolator` index uses the `index.auto_expand_replica` setting to make sure that each data node will have access _locally_ to the registered queries, allowing for fast query executing to filter out queries to run against a percolated doc.\n\nThe `percolate` API uses the whole number of shards as percolating processing \"engines\", both primaries and replicas. In our above case, if the `test` index has 2 shards with 1 replica, 4 shards will round robing in handing percolate requests. (dynamically) increasing the number of replicas will increase the number of percolation power.\n\nNote, percolate request will prefer to be executed locally, and will not try and round robin across shards if a shard exists locally on a node that received a request (for example, from HTTP). Its important to do some roundrobin in the client code among ES nodes (in any case its recommended).\n","closed_by":null,"performed_via_github_app":null}