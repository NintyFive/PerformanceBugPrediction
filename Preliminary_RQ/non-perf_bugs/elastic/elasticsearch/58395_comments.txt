[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/647108733","html_url":"https://github.com/elastic/elasticsearch/issues/58395#issuecomment-647108733","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/58395","id":647108733,"node_id":"MDEyOklzc3VlQ29tbWVudDY0NzEwODczMw==","user":{"login":"elasticmachine","id":15837671,"node_id":"MDQ6VXNlcjE1ODM3Njcx","avatar_url":"https://avatars3.githubusercontent.com/u/15837671?v=4","gravatar_id":"","url":"https://api.github.com/users/elasticmachine","html_url":"https://github.com/elasticmachine","followers_url":"https://api.github.com/users/elasticmachine/followers","following_url":"https://api.github.com/users/elasticmachine/following{/other_user}","gists_url":"https://api.github.com/users/elasticmachine/gists{/gist_id}","starred_url":"https://api.github.com/users/elasticmachine/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/elasticmachine/subscriptions","organizations_url":"https://api.github.com/users/elasticmachine/orgs","repos_url":"https://api.github.com/users/elasticmachine/repos","events_url":"https://api.github.com/users/elasticmachine/events{/privacy}","received_events_url":"https://api.github.com/users/elasticmachine/received_events","type":"User","site_admin":false},"created_at":"2020-06-21T10:21:22Z","updated_at":"2020-06-21T10:21:22Z","author_association":"COLLABORATOR","body":"Pinging @elastic/ml-core (:ml)","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/649012963","html_url":"https://github.com/elastic/elasticsearch/issues/58395#issuecomment-649012963","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/58395","id":649012963,"node_id":"MDEyOklzc3VlQ29tbWVudDY0OTAxMjk2Mw==","user":{"login":"benwtrent","id":4357155,"node_id":"MDQ6VXNlcjQzNTcxNTU=","avatar_url":"https://avatars3.githubusercontent.com/u/4357155?v=4","gravatar_id":"","url":"https://api.github.com/users/benwtrent","html_url":"https://github.com/benwtrent","followers_url":"https://api.github.com/users/benwtrent/followers","following_url":"https://api.github.com/users/benwtrent/following{/other_user}","gists_url":"https://api.github.com/users/benwtrent/gists{/gist_id}","starred_url":"https://api.github.com/users/benwtrent/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/benwtrent/subscriptions","organizations_url":"https://api.github.com/users/benwtrent/orgs","repos_url":"https://api.github.com/users/benwtrent/repos","events_url":"https://api.github.com/users/benwtrent/events{/privacy}","received_events_url":"https://api.github.com/users/benwtrent/received_events","type":"User","site_admin":false},"created_at":"2020-06-24T19:12:11Z","updated_at":"2020-06-24T19:27:54Z","author_association":"MEMBER","body":"@droberts195 \r\n\r\n> Then the datafeed would call flush with wait_for_completion=false. The key benefit would be that subsequent iterations of the datafeed could run while renormalizations triggered by the previous flush chugged away in the background. The datafeed would no longer pointlessly block waiting for renormalizations to complete.\r\n\r\nWhat if we made the flush in the datafeed job asynchronous? This way the datafeed job thread can continue and handle the flush response in a callback. \r\n\r\nWe do need the latest finalized bucket in the datafeed to calculate the missing data. So, we could make flush asynchronous, protected with some mutexes and the datafeed should be able to continue executing.\r\n\r\nEDIT:\r\n\r\nActually, if the issue is waiting for the renormalizer, why not add an internal flag that skips that waiting?\r\n\r\nKeep it synchronous\r\n\r\nKeep the datafeed waiting for the flush to complete.\r\n\r\nHave the flush NOT wait for renormalization.\r\n\r\n","performed_via_github_app":null}]