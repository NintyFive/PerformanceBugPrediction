[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/602307810","html_url":"https://github.com/elastic/elasticsearch/issues/53939#issuecomment-602307810","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/53939","id":602307810,"node_id":"MDEyOklzc3VlQ29tbWVudDYwMjMwNzgxMA==","user":{"login":"elasticmachine","id":15837671,"node_id":"MDQ6VXNlcjE1ODM3Njcx","avatar_url":"https://avatars3.githubusercontent.com/u/15837671?v=4","gravatar_id":"","url":"https://api.github.com/users/elasticmachine","html_url":"https://github.com/elasticmachine","followers_url":"https://api.github.com/users/elasticmachine/followers","following_url":"https://api.github.com/users/elasticmachine/following{/other_user}","gists_url":"https://api.github.com/users/elasticmachine/gists{/gist_id}","starred_url":"https://api.github.com/users/elasticmachine/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/elasticmachine/subscriptions","organizations_url":"https://api.github.com/users/elasticmachine/orgs","repos_url":"https://api.github.com/users/elasticmachine/repos","events_url":"https://api.github.com/users/elasticmachine/events{/privacy}","received_events_url":"https://api.github.com/users/elasticmachine/received_events","type":"User","site_admin":false},"created_at":"2020-03-23T00:42:37Z","updated_at":"2020-03-23T00:42:37Z","author_association":"COLLABORATOR","body":"Pinging @elastic/es-security (:Security/Authorization)","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/609769599","html_url":"https://github.com/elastic/elasticsearch/issues/53939#issuecomment-609769599","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/53939","id":609769599,"node_id":"MDEyOklzc3VlQ29tbWVudDYwOTc2OTU5OQ==","user":{"login":"ywangd","id":2344308,"node_id":"MDQ6VXNlcjIzNDQzMDg=","avatar_url":"https://avatars3.githubusercontent.com/u/2344308?v=4","gravatar_id":"","url":"https://api.github.com/users/ywangd","html_url":"https://github.com/ywangd","followers_url":"https://api.github.com/users/ywangd/followers","following_url":"https://api.github.com/users/ywangd/following{/other_user}","gists_url":"https://api.github.com/users/ywangd/gists{/gist_id}","starred_url":"https://api.github.com/users/ywangd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ywangd/subscriptions","organizations_url":"https://api.github.com/users/ywangd/orgs","repos_url":"https://api.github.com/users/ywangd/repos","events_url":"https://api.github.com/users/ywangd/events{/privacy}","received_events_url":"https://api.github.com/users/ywangd/received_events","type":"User","site_admin":false},"created_at":"2020-04-06T12:40:32Z","updated_at":"2020-04-06T12:40:32Z","author_association":"MEMBER","body":"Authorization is performed on each node. While we can reduce the size required by API key cache on each node by adding more nodes (with sticky sessions), the role cache on each node will likely need to cater for all keys. This is another reason that role cache could use further optimisation.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/643021514","html_url":"https://github.com/elastic/elasticsearch/issues/53939#issuecomment-643021514","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/53939","id":643021514,"node_id":"MDEyOklzc3VlQ29tbWVudDY0MzAyMTUxNA==","user":{"login":"ywangd","id":2344308,"node_id":"MDQ6VXNlcjIzNDQzMDg=","avatar_url":"https://avatars3.githubusercontent.com/u/2344308?v=4","gravatar_id":"","url":"https://api.github.com/users/ywangd","html_url":"https://github.com/ywangd","followers_url":"https://api.github.com/users/ywangd/followers","following_url":"https://api.github.com/users/ywangd/following{/other_user}","gists_url":"https://api.github.com/users/ywangd/gists{/gist_id}","starred_url":"https://api.github.com/users/ywangd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ywangd/subscriptions","organizations_url":"https://api.github.com/users/ywangd/orgs","repos_url":"https://api.github.com/users/ywangd/repos","events_url":"https://api.github.com/users/ywangd/events{/privacy}","received_events_url":"https://api.github.com/users/ywangd/received_events","type":"User","site_admin":false},"created_at":"2020-06-12T01:56:04Z","updated_at":"2020-06-12T14:35:57Z","author_association":"MEMBER","body":"A straightforward approach (and possibly minimum effort) is to cache a API key role by `ApiKeyRoleDescriptors`. Note that `ApiKeyRoleDescriptors` has a field of `apiKeyId` which should be excluded from `equals` and `hashCode` for it to be reusable across different keys.\r\n\r\nThe current `roleCache` is keyed by `RoleKey`, which is not compatible with `ApiKeyRoleDescriptors`. A separate `apiKeyRoleCache` is required (along with other necessary supporting code). Caching this way is mostly helpful when large number of keys share the same role, but wil likely be worse when their roles are all distinct, in which case the keys (`ApiKeyRoleDescriptors`) could be more expensive than the current `RoleKey` object.\r\n\r\nTo ensure equality of two sets of role descriptors, it is necessary to compare every element of it to be sure. Other than comparing the `ApiKeyRoleDescriptors` object directly, we could also compare their in string representation. This could be faster for operations like `Cache#get`, but any benefit could be offset'd by having to perform `ApiKeyRoleDescriptors#toString` beforehand. A better way around it is make the string format available during authentication process and use it for caching purpose, and only deserialised it when it is necessary to build the `Role` object. This however requires changes to API key document handling during the authentication process, which will be discussed in #53940.\r\n\r\nUsing either `ApiKeyRoleDescriptors` or its string representation as cache key is still not idea since the key is large and could in theory be _unbounded_ because it is user input. This concern really calls for something like API key template or cloneable API key so that the cache key could be either `Tuple<TemplateId, Version>` or `clonedFromId`. Without it, an alternative to reduce the key size is obviously hashing. We could compute a hash for `ApiKeyRoleDescriptors` and use the hash as the key. This would introduce additional hashing cost. But if we could settle with something simple, e.g. sha256, it may not be a big issue.","performed_via_github_app":null}]