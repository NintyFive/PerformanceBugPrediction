{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/25674","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/25674/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/25674/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/25674/events","html_url":"https://github.com/elastic/elasticsearch/issues/25674","id":242382110,"node_id":"MDU6SXNzdWUyNDIzODIxMTA=","number":25674,"title":"Point in time reader context for multiple (scroll) queries","user":{"login":"jimczi","id":15977469,"node_id":"MDQ6VXNlcjE1OTc3NDY5","avatar_url":"https://avatars0.githubusercontent.com/u/15977469?v=4","gravatar_id":"","url":"https://api.github.com/users/jimczi","html_url":"https://github.com/jimczi","followers_url":"https://api.github.com/users/jimczi/followers","following_url":"https://api.github.com/users/jimczi/following{/other_user}","gists_url":"https://api.github.com/users/jimczi/gists{/gist_id}","starred_url":"https://api.github.com/users/jimczi/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jimczi/subscriptions","organizations_url":"https://api.github.com/users/jimczi/orgs","repos_url":"https://api.github.com/users/jimczi/repos","events_url":"https://api.github.com/users/jimczi/events{/privacy}","received_events_url":"https://api.github.com/users/jimczi/received_events","type":"User","site_admin":false},"labels":[{"id":146832564,"node_id":"MDU6TGFiZWwxNDY4MzI1NjQ=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/:Search/Search","name":":Search/Search","color":"0e8a16","default":false,"description":"Search-related issues that do not fall into other categories"},{"id":23172,"node_id":"MDU6TGFiZWwyMzE3Mg==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/%3Efeature","name":">feature","color":"006b75","default":false,"description":null},{"id":110557212,"node_id":"MDU6TGFiZWwxMTA1NTcyMTI=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/high%20hanging%20fruit","name":"high hanging fruit","color":"fc6149","default":false,"description":null}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":4,"created_at":"2017-07-12T13:34:39Z","updated_at":"2019-04-08T11:18:38Z","closed_at":"2019-04-08T11:18:37Z","author_association":"MEMBER","active_lock_reason":null,"body":"Currently a scroll context is a point in time snapshot of a set of indices associated with a query.\r\nEach successive scroll query on this context moves the query forward until the query is exhausted. This is very useful when a single operation is performed (eg. reindexing) but when multiple scrolls are needed it is difficult to synchronize them efficiently.\r\nFor instance a multi-pass algorithm that needs to scan the data multiple times would have to use different scrolls to extract the results from ES and each pass could return different results. \r\nSimilarly if a batch of queries need to be executed, the only way to make sure that they will see the same documents is to freeze the indices and to use a different scroll for each of them.\r\n\r\nSo instead of coupling a scroll context with a set of shards **and** a query we could create shareable reader context with no query associated. One or multiple users could then reference this reader to perform different queries using the `_search` endpoint. \r\n\r\nSo for instance:\r\n\r\n````\r\nGET index1,index2,index3/_create_context\r\n````\r\n\r\n... creates a reader context for index1, index2 and index3 and returns the context id for this reader.\r\n\r\nThen the context id can be used in a search query to retrieve results associated with this context:\r\n\r\n````\r\nGET _search\r\n{\r\n    \"context_id\": \"DXF1ZXJ5QW5...\",\r\n    \"query\": { ... }\r\n}\r\n````\r\n\r\n... but instead of using the `_scroll` endpoint to paginate through this query we could leverage `search_after` and let the user decides how he wants to paginate. `search_after` is difficult to use when the reader can change since it requires a tie breaker but inside a specific context `search_after` can simply use the `docID/shardID` as efficient tie breakers (no need to use `_id` or anything that needs extra memory) so any sort would be eligible to `sort_after`.\r\n\r\nAlso the reader context could have the same restriction than a scroll query regarding expiration. The only change would be that different queries could hit the same context so each of them would concurrently extend the context if needed.\r\n","closed_by":{"login":"jimczi","id":15977469,"node_id":"MDQ6VXNlcjE1OTc3NDY5","avatar_url":"https://avatars0.githubusercontent.com/u/15977469?v=4","gravatar_id":"","url":"https://api.github.com/users/jimczi","html_url":"https://github.com/jimczi","followers_url":"https://api.github.com/users/jimczi/followers","following_url":"https://api.github.com/users/jimczi/following{/other_user}","gists_url":"https://api.github.com/users/jimczi/gists{/gist_id}","starred_url":"https://api.github.com/users/jimczi/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jimczi/subscriptions","organizations_url":"https://api.github.com/users/jimczi/orgs","repos_url":"https://api.github.com/users/jimczi/repos","events_url":"https://api.github.com/users/jimczi/events{/privacy}","received_events_url":"https://api.github.com/users/jimczi/received_events","type":"User","site_admin":false},"performed_via_github_app":null}