[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/472732045","html_url":"https://github.com/elastic/elasticsearch/issues/40031#issuecomment-472732045","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/40031","id":472732045,"node_id":"MDEyOklzc3VlQ29tbWVudDQ3MjczMjA0NQ==","user":{"login":"elasticmachine","id":15837671,"node_id":"MDQ6VXNlcjE1ODM3Njcx","avatar_url":"https://avatars3.githubusercontent.com/u/15837671?v=4","gravatar_id":"","url":"https://api.github.com/users/elasticmachine","html_url":"https://github.com/elasticmachine","followers_url":"https://api.github.com/users/elasticmachine/followers","following_url":"https://api.github.com/users/elasticmachine/following{/other_user}","gists_url":"https://api.github.com/users/elasticmachine/gists{/gist_id}","starred_url":"https://api.github.com/users/elasticmachine/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/elasticmachine/subscriptions","organizations_url":"https://api.github.com/users/elasticmachine/orgs","repos_url":"https://api.github.com/users/elasticmachine/repos","events_url":"https://api.github.com/users/elasticmachine/events{/privacy}","received_events_url":"https://api.github.com/users/elasticmachine/received_events","type":"User","site_admin":false},"created_at":"2019-03-14T07:18:21Z","updated_at":"2019-03-14T07:18:21Z","author_association":"COLLABORATOR","body":"Pinging @elastic/es-security","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/477451141","html_url":"https://github.com/elastic/elasticsearch/issues/40031#issuecomment-477451141","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/40031","id":477451141,"node_id":"MDEyOklzc3VlQ29tbWVudDQ3NzQ1MTE0MQ==","user":{"login":"bizybot","id":902768,"node_id":"MDQ6VXNlcjkwMjc2OA==","avatar_url":"https://avatars2.githubusercontent.com/u/902768?v=4","gravatar_id":"","url":"https://api.github.com/users/bizybot","html_url":"https://github.com/bizybot","followers_url":"https://api.github.com/users/bizybot/followers","following_url":"https://api.github.com/users/bizybot/following{/other_user}","gists_url":"https://api.github.com/users/bizybot/gists{/gist_id}","starred_url":"https://api.github.com/users/bizybot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bizybot/subscriptions","organizations_url":"https://api.github.com/users/bizybot/orgs","repos_url":"https://api.github.com/users/bizybot/repos","events_url":"https://api.github.com/users/bizybot/events{/privacy}","received_events_url":"https://api.github.com/users/bizybot/received_events","type":"User","site_admin":false},"created_at":"2019-03-28T05:14:01Z","updated_at":"2019-04-23T08:25:53Z","author_association":"CONTRIBUTOR","body":"**Cluster privileges for API keys:**\r\n`manage_api_key` (`cluster:admin/xpack/security/api_key/*`)\r\n  Users with this cluster privilege can:\r\n    - create, invalidate or retrieve API keys.\r\n    - act on _any_ API keys\r\n  This privilege is in-line with our philosophy to have more restricted privileges rather than giving wide access if not required.\r\n\r\n`create_api_key` (`cluster:admin/xpack/security/api_key/create`)\r\n  Users with this cluster privilege can:\r\n    - **only create API key(s)**\r\n  API keys are more like bearer tokens and we expect admins want to have more control on who can create API keys.\r\n\r\n`owner_manage_api_key` (`cluster:admin/xpack/security/api_key/invalidate/my` if we go by Option 1 described below)\r\n  Users with this cluster privilege can:\r\n    - **only invalidate API keys owned by them**\r\n\r\n**Following is the summarization of what is the expected behavior for API keys:-**\r\n\r\n| User &#9660; API Key Action &#9658;  | Create API key | Invalidate API key | GET API key |\r\n|---------------------------------------------|----------------------------|---------------------------------------------------------|--------------------------------------------------|\r\n| User with `all` or `manage_security` or `manage_api_key` privilege | Allow | Allow | Allow |\r\n| User with `create_api_key` privilege | Allow | Deny | Allowed only on owned API keys |\r\n| User with `owner_manage_api_key` privilege | Deny | Allowed only on owned API keys | Allowed only on owned API keys |\r\n| User with no privilege related to API keys | Deny | Deny | Allowed only on owned API keys |\r\n| User authenticated via API keys with no privilege related to API keys | Deny | Deny | Allowed only on owned API keys |\r\n\r\n**Implementation options:**\r\nImplementing this would be challenge as we are trying to restrict action to a set of documents.\r\nWe would want our authorization checks to happen before reaching the APIs.\r\n\r\n_Option I_:\r\nAnother option would be to add new REST endpoint\r\n`GET /_security/api_key/my`\r\n`DELETE /_security/api_key/my`\r\nThis way we make the username/api-key-id compulsory when we call into the APIs thereby restricting the action to authenticated user's API keys.\r\n\r\n_Option II_:\r\nSo when we say `Allowed only on owned API keys`, we need to fetch the API keys for the authenticated user to authorize the user action. For example, User who owns API key and the request comes to invalidate API key by Id, in that case we need to first retrieve the API key(s) owned by this user and then check if the API key id is indeed owned by this user before proceeding with the invalidate action.\r\nThis feels more on the lines of object level security and implementing that does not seem to be viable option, as the design may not do the justice to other scenarios that are more appropriate for OLS.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/484533652","html_url":"https://github.com/elastic/elasticsearch/issues/40031#issuecomment-484533652","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/40031","id":484533652,"node_id":"MDEyOklzc3VlQ29tbWVudDQ4NDUzMzY1Mg==","user":{"login":"albertzaharovits","id":4568420,"node_id":"MDQ6VXNlcjQ1Njg0MjA=","avatar_url":"https://avatars2.githubusercontent.com/u/4568420?v=4","gravatar_id":"","url":"https://api.github.com/users/albertzaharovits","html_url":"https://github.com/albertzaharovits","followers_url":"https://api.github.com/users/albertzaharovits/followers","following_url":"https://api.github.com/users/albertzaharovits/following{/other_user}","gists_url":"https://api.github.com/users/albertzaharovits/gists{/gist_id}","starred_url":"https://api.github.com/users/albertzaharovits/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/albertzaharovits/subscriptions","organizations_url":"https://api.github.com/users/albertzaharovits/orgs","repos_url":"https://api.github.com/users/albertzaharovits/repos","events_url":"https://api.github.com/users/albertzaharovits/events{/privacy}","received_events_url":"https://api.github.com/users/albertzaharovits/received_events","type":"User","site_admin":false},"created_at":"2019-04-18T14:26:51Z","updated_at":"2019-04-19T06:41:39Z","author_association":"CONTRIBUTOR","body":"> There should be a specific privilege to allow a user to create/delete their own API keys.\r\n\r\nI would like to voice my opinion that we should go for a full-blown `ConditionalClusterPrivilege` rather than introducing the ownership model. The general problem with the ownership model is that it leads to credentials being shared between parties that want shared ownership of a pool of tokens. Regarding implementation difficulty, I believe they're on the same level.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/485611854","html_url":"https://github.com/elastic/elasticsearch/issues/40031#issuecomment-485611854","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/40031","id":485611854,"node_id":"MDEyOklzc3VlQ29tbWVudDQ4NTYxMTg1NA==","user":{"login":"bizybot","id":902768,"node_id":"MDQ6VXNlcjkwMjc2OA==","avatar_url":"https://avatars2.githubusercontent.com/u/902768?v=4","gravatar_id":"","url":"https://api.github.com/users/bizybot","html_url":"https://github.com/bizybot","followers_url":"https://api.github.com/users/bizybot/followers","following_url":"https://api.github.com/users/bizybot/following{/other_user}","gists_url":"https://api.github.com/users/bizybot/gists{/gist_id}","starred_url":"https://api.github.com/users/bizybot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bizybot/subscriptions","organizations_url":"https://api.github.com/users/bizybot/orgs","repos_url":"https://api.github.com/users/bizybot/repos","events_url":"https://api.github.com/users/bizybot/events{/privacy}","received_events_url":"https://api.github.com/users/bizybot/received_events","type":"User","site_admin":false},"created_at":"2019-04-23T01:50:50Z","updated_at":"2019-04-23T01:50:50Z","author_association":"CONTRIBUTOR","body":"> I would like to voice my opinion that we should go for a full-blown `ConditionalClusterPrivilege` rather than introducing the ownership model. The general problem with the ownership model is that it leads to credentials being shared between parties that want shared ownership of a pool of tokens. Regarding implementation difficulty, I believe they're on the same level.\r\n\r\nThank you @albertzaharovits for raising this. I agree to the concern raised, though for now we have following:\r\n- administrator account with `manage_api_key` can manage _any_ API keys, agreed that this is wide access and someone wanting to restrict access to a group of API keys would not be possible.\r\n- ownership model allowing users who own the API keys to manage them.\r\n\r\nI did think about using `ConditionalClusterPrivilege` (I think Tim introduced as foundation towards OLS) but was not sure of it as we would need to autowire components so we can do a dynamic query to security index to fetch documents based on the configuration. If I am not mistaken the example you have is allowing access to group of API keys created by different users and using those principal names in `ConditionalClusterPrivilege` when we create role. When the authorization check happens we would use the principal names from the `ConditionalClusterPrivilege`, fetch the documents from index and then check against the request.\r\n\r\nThere could be multiple ways to group API keys, for example, grouping of API keys `by username`, `by user metadata : department`, `by user metadata : group`, `by user metadata : location` etc. Once you look at the way we could group objects, I think of a grouping object construct with a grouping service which allows us to resolve things. This seems more generic service and requires lot of thinking before we consider this or any alternative approach.\r\n\r\n@albertzaharovits @tvernum @jkakavas \r\nIf we all agree, we can work on this as pathway to OLS or we could take this as next step.\r\nAppreciate your inputs, Thank you.\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/486134343","html_url":"https://github.com/elastic/elasticsearch/issues/40031#issuecomment-486134343","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/40031","id":486134343,"node_id":"MDEyOklzc3VlQ29tbWVudDQ4NjEzNDM0Mw==","user":{"login":"albertzaharovits","id":4568420,"node_id":"MDQ6VXNlcjQ1Njg0MjA=","avatar_url":"https://avatars2.githubusercontent.com/u/4568420?v=4","gravatar_id":"","url":"https://api.github.com/users/albertzaharovits","html_url":"https://github.com/albertzaharovits","followers_url":"https://api.github.com/users/albertzaharovits/followers","following_url":"https://api.github.com/users/albertzaharovits/following{/other_user}","gists_url":"https://api.github.com/users/albertzaharovits/gists{/gist_id}","starred_url":"https://api.github.com/users/albertzaharovits/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/albertzaharovits/subscriptions","organizations_url":"https://api.github.com/users/albertzaharovits/orgs","repos_url":"https://api.github.com/users/albertzaharovits/repos","events_url":"https://api.github.com/users/albertzaharovits/events{/privacy}","received_events_url":"https://api.github.com/users/albertzaharovits/received_events","type":"User","site_admin":false},"created_at":"2019-04-24T09:02:05Z","updated_at":"2019-04-24T09:02:05Z","author_association":"CONTRIBUTOR","body":"Apologies for not being clear @bizybot ! I'll try to explain myself better:\r\n\r\nThe `ConditionalClusterPrivilege` is just an enhanced cluster privilege with the added power-up that it can authorize based on the request object's contents. The `ConditionalClusterPrivileges.ManageApplicationPrivileges` is the sole example.\r\n\r\nIn the case of API keys I see there are actions for:\r\n* _creating_ an API key for the self user, binding it to an `apiKeyName` (user specified) and an automatic `apiKeyId`\r\n* _retrieving_ API keys by `users`, `realm`, `apiKeyId`, `apiKeyName`\r\n* _invalidating_ API keys by `users`, `realm`, `apiKeyId`, `apiKeyName`\r\n\r\nFrom my perspective, the privilege under discussion - to create/retrieve/invalidate ones own API keys - makes sense and would be difficult to model it as a `ConditionalClusterPrivilege`, but it just divides the clients into two groups: USERS that can create/retrieve/invalidate API keys for themselves and ADMINS that can retrieve and invalidate by any criteria. Though, given the \"limiting\" roles for the _Create API Key_ action the clients can achieve some multi-tenancy among the ADMIN users (the ones creating API keys). So to be clear, I'm not against this, but to me it sounds more complicated than necessary.\r\n\r\nWhat I was thinking was to have a new type of `ConditionalClusterPrivilege` that narrows all _creating_, _retriving_ and _invalidating_ to a restricted `apiKeyName` space. For example:\r\n\r\n```\r\n{\r\n  \"global\": {\r\n    \"api_key\": {\r\n      \"manage\": [\"some/api_key/namespace/*\"]\r\n    }\r\n  }\r\n}\r\n```\r\nWould permit creating API keys only for this namespace. Retrieving and Invalidating would work only by the same `apiKeyName` namespace (no `users`, `realm`, `apiKeyId` permitted).\r\n\r\nWhat do you think @bizybot @tvernum ? This again is not a substitute for the ownership permission (and that cannot be modeled with `ConditionalClusterPrivilege`) but I think is a more natural way of limiting the privileges of API key admins.\r\n\r\n\r\n\r\n\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/486154727","html_url":"https://github.com/elastic/elasticsearch/issues/40031#issuecomment-486154727","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/40031","id":486154727,"node_id":"MDEyOklzc3VlQ29tbWVudDQ4NjE1NDcyNw==","user":{"login":"tvernum","id":2244393,"node_id":"MDQ6VXNlcjIyNDQzOTM=","avatar_url":"https://avatars0.githubusercontent.com/u/2244393?v=4","gravatar_id":"","url":"https://api.github.com/users/tvernum","html_url":"https://github.com/tvernum","followers_url":"https://api.github.com/users/tvernum/followers","following_url":"https://api.github.com/users/tvernum/following{/other_user}","gists_url":"https://api.github.com/users/tvernum/gists{/gist_id}","starred_url":"https://api.github.com/users/tvernum/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/tvernum/subscriptions","organizations_url":"https://api.github.com/users/tvernum/orgs","repos_url":"https://api.github.com/users/tvernum/repos","events_url":"https://api.github.com/users/tvernum/events{/privacy}","received_events_url":"https://api.github.com/users/tvernum/received_events","type":"User","site_admin":false},"created_at":"2019-04-24T09:54:48Z","updated_at":"2019-04-24T09:54:48Z","author_association":"CONTRIBUTOR","body":"I like your proposal @albertzaharovits, except that I don't think it really solves the problem we have before us right now.\r\n\r\nAs we stand, it is impossible for users to be given access to manage their own API keys, which is a problem because it's a necessary feature for the sorts of use cases we want to support with API keys. Hadoop jobs should be able to create a new key, and then invalidate it when finished. We could just say that the only way to do that is by authenticating with the key itself, but then cleaning up after failed jobs is hard, and it makes the whole feature way too cumbersome.\r\n\r\nThe namespace proposal doesn't easily help because it makes it extraordinarily difficult to satisfy the common case. There is no simple way to say you can create, get and invalidate your own keys. To do that we would need some sort of template so you could set the namespace to `/users/{username}/*`, and even then it feels like a clunky solution to the problem at hand, in order to support things we're not sure we need.\r\n\r\nI'm not tied to any particular implementation, but I am keen to see us solve the problem we know we have, and move on to higher priority work.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/486167378","html_url":"https://github.com/elastic/elasticsearch/issues/40031#issuecomment-486167378","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/40031","id":486167378,"node_id":"MDEyOklzc3VlQ29tbWVudDQ4NjE2NzM3OA==","user":{"login":"albertzaharovits","id":4568420,"node_id":"MDQ6VXNlcjQ1Njg0MjA=","avatar_url":"https://avatars2.githubusercontent.com/u/4568420?v=4","gravatar_id":"","url":"https://api.github.com/users/albertzaharovits","html_url":"https://github.com/albertzaharovits","followers_url":"https://api.github.com/users/albertzaharovits/followers","following_url":"https://api.github.com/users/albertzaharovits/following{/other_user}","gists_url":"https://api.github.com/users/albertzaharovits/gists{/gist_id}","starred_url":"https://api.github.com/users/albertzaharovits/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/albertzaharovits/subscriptions","organizations_url":"https://api.github.com/users/albertzaharovits/orgs","repos_url":"https://api.github.com/users/albertzaharovits/repos","events_url":"https://api.github.com/users/albertzaharovits/events{/privacy}","received_events_url":"https://api.github.com/users/albertzaharovits/received_events","type":"User","site_admin":false},"created_at":"2019-04-24T10:30:52Z","updated_at":"2019-04-24T10:30:52Z","author_association":"CONTRIBUTOR","body":"Fair enough, if the ownership privilege is necessary for Hadoop jobs and the namespace solution is not suitable then I have no case, sorry for rambling besides the point. I am not aware of the use case constraints.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/510455160","html_url":"https://github.com/elastic/elasticsearch/issues/40031#issuecomment-510455160","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/40031","id":510455160,"node_id":"MDEyOklzc3VlQ29tbWVudDUxMDQ1NTE2MA==","user":{"login":"albertzaharovits","id":4568420,"node_id":"MDQ6VXNlcjQ1Njg0MjA=","avatar_url":"https://avatars2.githubusercontent.com/u/4568420?v=4","gravatar_id":"","url":"https://api.github.com/users/albertzaharovits","html_url":"https://github.com/albertzaharovits","followers_url":"https://api.github.com/users/albertzaharovits/followers","following_url":"https://api.github.com/users/albertzaharovits/following{/other_user}","gists_url":"https://api.github.com/users/albertzaharovits/gists{/gist_id}","starred_url":"https://api.github.com/users/albertzaharovits/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/albertzaharovits/subscriptions","organizations_url":"https://api.github.com/users/albertzaharovits/orgs","repos_url":"https://api.github.com/users/albertzaharovits/repos","events_url":"https://api.github.com/users/albertzaharovits/events{/privacy}","received_events_url":"https://api.github.com/users/albertzaharovits/received_events","type":"User","site_admin":false},"created_at":"2019-07-11T11:56:29Z","updated_at":"2019-07-11T11:56:29Z","author_association":"CONTRIBUTOR","body":"As promised, here's what I have as a proposal for API-Key APIs. I will describe the REST interface and then detail how the transport interface might look like.\r\n\r\n* create API-Key (`POST _security/api_key`) stays the same. It creates API keys for the **authenticated principal** calling the API. API keys are created under a user supplied unique name.\r\n* get API-Key (`GET _security/api_key`) works a bit differently. When an **authenticated principal** calls the endpoint **without any parameters**, a list of API-Key **names** (no secret ids) is returned. The names are of that principal only (self). To get the (secret) id of the API-Key given a **name**, call `GET _security/api_key/{api_key_name}` . There are parameters to this API, to specify the user and/or realm. These parameters are available only to the `manage_api_key` administrator. This API is **not** available if the caller is authenticated with an API key. That's because if a user creates several API keys (probably with limited roles), and handles them to services, it would undesirable for one service to be able to retrieve API Keys of other services using this API. We could probably make the API retrieve only that single API key, but it would complicate the interface for very little benefit.\r\n* invalidate API-Key (`DELETE _security/api_key`) also works a bit differently. To invalidate an API-Key by **name** call `DELETE _security/api_key/{api_key_name}`. Invalidation works in the authenticated user's namespace only (cannot invalidate other users keys, unless you specify the `user` request parameter). Invalidation is not available if the principal is that of an API key (I'm unsure about it, I prefer to not complicate the interface without a clear reason). Invalidation also does not work by **id**. The **user** and **realm** request parameters (specified together), which allow to invalidate keys for other users, are available only to the `manage_api_key` administrator.\r\n\r\nHere are a few examples:\r\n* curl -X POST -u joe `_security/api_key?name=key_name_1` -> creates and returns the key (a secret id) , named `key_name_1` for the principal `joe`. (name parameter could be a request body parameter, it is a URL parameter to simplify the examples)\r\ncurl -X POST -u joe `_security/api_key?name=key_name_2`\r\ncurl -X POST -u sally `_security/api_key?name=key_name_1`\r\ncurl -X POST -u sally `_security/api_key?name=key_name_3`\r\n* curl -X GET -u joe `_security/api_key` -> returns `key_name_1` and `key_name_2` in the response body, without the secret ids (the concrete API keys)\r\ncurl -X GET -u sally `_security/api_key` -> returns `key_name_1` and `key_name_3`\r\ncurl -X GET -u joe `_security/api_key/key_name_1` -> returns the secret id (the concrete API) key for `key_name_1`\r\ncurl -X GET -u joe `_security/api_key/key_name_3` -> MISSING\r\ncurl -X GET -u sally `_security/api_key/key_name_3` -> returns the secret id (the concrete API) key for `key_name_3`\r\ncurl -X GET -u joe `_security/api_key?user=joe` -> DENIED\r\ncurl -X GET -u joe `_security/api_key?user=sally` -> DENIED\r\ncurl -X GET -u joe `_security/api_key?realm=whatever` -> DENIED\r\ncurl -X GET -u elastic `_security/api_key?user=sally&realm=whatever` -> **names** `key_name_1` and `key_name_3`\r\ncurl -X GET -u elastic `_security/api_key?realm=whatever` -> **names** `key_name_1` and `key_name_2` for user `joe` and `key_name_1` and `key_name_3` for user `sally`\r\ncurl -X GET -u elastic `_security/api_key` -> EMPTY , elastic does not have any keys of its own\r\ncurl -X GET -u elastic `_security/api_key?user=*` -> all API key names (`key_name_1` and `key_name_2` for user `joe` and `key_name_1` and `key_name_3` for user `sally`)\r\ncurl -X GET -H \"Authentication: Bearer xxxx\" `_security/api_key?...` -> DENIED (any request for GET api key is denied)\r\n* curl -X DELETE -u joe `_security/api_key` -> ERROR (missing parameter)\r\n  curl -X DELETE -u joe `_security/api_key/key_name_1` -> invalidation successful\r\n  curl -X DELETE -u joe `_security/api_key/key_name_1` -> MISSING\r\n  curl -X DELETE -u sally `_security/api_key/key_name_3` -> invalidation successful\r\n  curl -X DELETE -u elastic `_security/api_key/key_name1?user=sally&realm=whatever` -> invalidation successful\r\n  curl -X DELETE -u elastic `_security/api_key/key_name1` -> ERROR (missing parameter)\r\n  curl -X DELETE -H \"Authentication: Bearer xxxx\" `_security/api_key?...` -> DENIED (any request for DELETE api key is denied)\r\n\r\nThe main points:\r\n* if you authenticate with the API key you are not permitted to manage **any** API key. \r\n* API-Key ids are secret, so we avoid to parse them around. When creating the key the client has the name and the secret id. If it loses the public name it cannot recover it, it is useless anyway because it cannot use it for anything useful.\r\n* `user` and `realm` request parameters are permitted only to the `manage_api_key` administrator. Not even if they are used redundantly.\r\n\r\nThe reason to have these limitations is to simplify the transport level interface. I believe these can achieve transport interfaces for GET and DELETE where the **request always contains the `user` and optionally (frequently) the API key `name`**. In many cases the **`user` has to be inferred in the REST handler**, but this is a simple read of the thread context (and not a `has_privilege` call). During the authorization we always compare the principal in the request with the current authentication context. Wildcards (or null values) are permitted for all parameters, but are authorized only for the `manage_api_key` administrator.\r\n\r\nThe grand idea is that we must pass the `user` in the transport request, in all circumstances, to be able to authorize with the current framework that can inspect the request but not filter the response.\r\n\r\nThis deviates quite a bit from the current interface, but I am not attached to it at all, so we could change it anyway to closely follow what we currently have, but I believe we definitely should build around always having the owner `user` of the key in the transport request, without recurring to any `has_privilege` call in the REST handler. ","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/510756819","html_url":"https://github.com/elastic/elasticsearch/issues/40031#issuecomment-510756819","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/40031","id":510756819,"node_id":"MDEyOklzc3VlQ29tbWVudDUxMDc1NjgxOQ==","user":{"login":"bizybot","id":902768,"node_id":"MDQ6VXNlcjkwMjc2OA==","avatar_url":"https://avatars2.githubusercontent.com/u/902768?v=4","gravatar_id":"","url":"https://api.github.com/users/bizybot","html_url":"https://github.com/bizybot","followers_url":"https://api.github.com/users/bizybot/followers","following_url":"https://api.github.com/users/bizybot/following{/other_user}","gists_url":"https://api.github.com/users/bizybot/gists{/gist_id}","starred_url":"https://api.github.com/users/bizybot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bizybot/subscriptions","organizations_url":"https://api.github.com/users/bizybot/orgs","repos_url":"https://api.github.com/users/bizybot/repos","events_url":"https://api.github.com/users/bizybot/events{/privacy}","received_events_url":"https://api.github.com/users/bizybot/received_events","type":"User","site_admin":false},"created_at":"2019-07-12T05:56:51Z","updated_at":"2019-07-12T05:56:51Z","author_association":"CONTRIBUTOR","body":"Thank you @albertzaharovits  for your proposal.\r\n\r\nI went through your comment and I am not very convinced with the proposal.\r\nAlso, I see that in your proposal you consider the API key id to be a secret but it is similar to `username` in case of native users. The actual key is similar to the password which cannot be retrieved by any APIs but only available on the creation of API key. I am not sure if this is the reason that your proposal is proposed the way to get the API key id using the key name and then do stuff.\r\n> API-Key ids are secret, so we avoid to parse them around. When creating the key the client has the name and the secret id. If it loses the public name it cannot recover it, it is useless anyway because it cannot use it for anything useful.\r\n\r\nWhen we create an API key `api_key` is similar to a password that needs to be protected but I am not sure if there is any advantage with API key-id being a secret and complicating the workflow. I am considering the API key id analogous to the user id or REST resource id.\r\n```\r\n{\r\n  \"id\":\"VuaCfGcBCdbkQm-e5aOx\", \r\n  \"name\":\"my-api-key\",\r\n  \"expiration\":1544068612110, \r\n  \"api_key\":\"ui2lp2axTNmsyakw9tvNnw\" \r\n}\r\n```\r\n\r\nI will start with the targeted use case before diving into the API details:-\r\n**a) As an Administrator, I would like to manage API keys of _any_ user and/or _any_ realm.\r\n   (`manage_api_key` privilege)**\r\n\r\n`GET` OR `DELETE` `/_security/api_key`:\r\nThe administrator is likely to use parameters (user or realm or both) when using any of the APIs.\r\nIn a specific case when it wants to use API key-id or name to invalidate an API key then that is allowed as well.\r\n**(With the current behavior I think we do not have any problem here)**\r\n\r\n**b) As a user, I would like to create API key(s) and be able to manage owned API keys\r\n   (`manage_own_api_key`)**\r\n\r\n`GET` OR `DELETE` `/_security/api_key`:\r\nA user is most likely to use (id or name) to retrieve or invalidate API keys and not specify user or realm parameters.\r\nIn the case where it chooses to use the user or realm parameters then we would check if the currently authenticated user has the same `user` and `realm` as the authenticated user's. If not then we will deny access with a _proper error message_.\r\n\r\n**c) As an agent (say device agents of a fleet) using an API key for authentication, I would like to retrieve my (API key) information but not invalidate my API key or any other API keys.** (The API key does not carry information which the agent would want to retrieve later, for example, expiry date)\r\n(Since the API key is used for authentication, this has permission to retrieve _self_, other API invocations will fail because of authorization checks)\r\n\r\nGiven these scenarios and the API behavior do we think that we need to modify the behavior of the API? I would first consider if there is anything in above that causes confusing behavior from the API usage perspective and then consider the alternatives. Thank you.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/510841457","html_url":"https://github.com/elastic/elasticsearch/issues/40031#issuecomment-510841457","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/40031","id":510841457,"node_id":"MDEyOklzc3VlQ29tbWVudDUxMDg0MTQ1Nw==","user":{"login":"albertzaharovits","id":4568420,"node_id":"MDQ6VXNlcjQ1Njg0MjA=","avatar_url":"https://avatars2.githubusercontent.com/u/4568420?v=4","gravatar_id":"","url":"https://api.github.com/users/albertzaharovits","html_url":"https://github.com/albertzaharovits","followers_url":"https://api.github.com/users/albertzaharovits/followers","following_url":"https://api.github.com/users/albertzaharovits/following{/other_user}","gists_url":"https://api.github.com/users/albertzaharovits/gists{/gist_id}","starred_url":"https://api.github.com/users/albertzaharovits/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/albertzaharovits/subscriptions","organizations_url":"https://api.github.com/users/albertzaharovits/orgs","repos_url":"https://api.github.com/users/albertzaharovits/repos","events_url":"https://api.github.com/users/albertzaharovits/events{/privacy}","received_events_url":"https://api.github.com/users/albertzaharovits/received_events","type":"User","site_admin":false},"created_at":"2019-07-12T10:45:25Z","updated_at":"2019-07-12T10:45:25Z","author_association":"CONTRIBUTOR","body":"The discussion on how secret is the API Key Id, and what APIs should be dealing with it, is only tangential to the privilege model. But, from this perspective (of the API design), lets say there is a client possessing **only** the API key **Id** and not the **name**. This can happen if the user or the administrator, creating the keys, decided not to share the name with the client service (it only handed out the **id**).  In my design, the client can use that to call all other APIs but not the API key management APIs (it is denied POST, GET and DELETE whatever the parameters). To manage API keys (as a user or as an administrator) you have to get a hold of the **name**, which you do when you create it (you specify it). This simplifies the interface (no **id** parameter to APIs) and the authorization process as well.\r\n**This is not critically important for the privilege model, but it simplifies, rather than complicates.**\r\n\r\nRe:\r\n> a) As an Administrator, I would like to manage API keys of any user and/or any realm.\r\n(manage_api_key privilege)\r\n\r\nMostly agreed, but there is a crucial detail we need to answer.\r\n\r\n\"Manage\" here is vague. It is \"vague\" because, as I described, GET lists **names** for sets of users (given the **user** and **realm** parameters), but DELETE should not, IMO, bulk revoke API keys. This is again, just a small detail.\r\n\r\nBut, what is **really important** is what keys does the administrator (`manage_api_keys`) sees (GET, and if you insist DELETE) when **no parameters** are passed to the API ?\r\n\r\nI strongly suggest it only sees his own API keys. If he wishes to view every API key in the system he must use the **`user=*`** request parameter. This is important so that, as I said, the transport request interface (for retrieve and invalidate) always contains a `principal` (or a `wildcard`). If we go with the option that the administrator (`manage_api_keys`) sees all the keys in the system, but a normal user (`manage_own_api_keys`) only his own, **for requests with no parameters**, then we have a problem that we mix authorization and application logic.\r\n\r\nRe:\r\n> b) As a user, I would like to create API key(s) and be able to manage owned API keys\r\n(manage_own_api_key)\r\n\r\nAgreed.\r\n\r\nRe:\r\n> c) As an agent (say device agents of a fleet) using an API key for authentication, I would like to retrieve my (API key) information but not invalidate my API key or any other API keys.\r\n\r\nIMO, this is an unnecessary complication. Why would a service wish to view details about its API key? And what are those details, besides expiration time? This is again a small detail, if we want to make this work so be it, but small details add up fast...\r\n\r\n> Given these scenarios and the API behavior do we think that we need to modify the behavior of the API?\r\n\r\nI do not think this. I presented my view of an \"ideal\" REST interface, given the knowledge that we accumulated so far.\r\n\r\nWhat I say we stick by is this:\r\n**Whatever the REST interface, the transport layer request must contain a `principal` and the object (key `name` or `id`). The `principal` can be a wildcard or `null` (equivalent to `*`), BUT it must be set by the REST handler in the most straightforward way, that is, either copying it from the thread context or from the request parameter - there should not be any other calls, either to the APIKeyService or other transport calls, such as `has_privilege`. This way we can always do authorization based on the request and we don't create authorization logic in the REST handler, or the APIKeyService methods. If any REST interface feature pushes against this, we should push back.**\r\n\r\n\r\n\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/511176119","html_url":"https://github.com/elastic/elasticsearch/issues/40031#issuecomment-511176119","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/40031","id":511176119,"node_id":"MDEyOklzc3VlQ29tbWVudDUxMTE3NjExOQ==","user":{"login":"bizybot","id":902768,"node_id":"MDQ6VXNlcjkwMjc2OA==","avatar_url":"https://avatars2.githubusercontent.com/u/902768?v=4","gravatar_id":"","url":"https://api.github.com/users/bizybot","html_url":"https://github.com/bizybot","followers_url":"https://api.github.com/users/bizybot/followers","following_url":"https://api.github.com/users/bizybot/following{/other_user}","gists_url":"https://api.github.com/users/bizybot/gists{/gist_id}","starred_url":"https://api.github.com/users/bizybot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bizybot/subscriptions","organizations_url":"https://api.github.com/users/bizybot/orgs","repos_url":"https://api.github.com/users/bizybot/repos","events_url":"https://api.github.com/users/bizybot/events{/privacy}","received_events_url":"https://api.github.com/users/bizybot/received_events","type":"User","site_admin":false},"created_at":"2019-07-14T06:05:00Z","updated_at":"2019-07-15T02:47:17Z","author_association":"CONTRIBUTOR","body":"Hi @albertzaharovits, Thank you for your comments.\r\n\r\n> lets say there is a client possessing **only** the API key **Id** and not the **name**. This can happen if the user or the administrator, creating the keys, decided not to share the name with the client service (it only handed out the **id**). In my design, the client can use that to call all other APIs but not the API key management APIs (it is denied POST, GET and DELETE whatever the parameters). \r\n\r\nUsually, this is what the clients would have just api-key-id and the actual key for doing operations on the server. It depends on the use case where the API keys are being used. For example, if the administrator wants the remote agents to invalidate their API keys when being uninstalled or if the API key is going to expire then request an API key from a fleet manager. In these scenario's the agent needs to access to APIs (GET or DELETE) to do these operations.\r\n\r\n> To manage API keys (as a user or as an administrator) you have to get a hold of the **name**, which you do when you create it (you specify it). This simplifies the interface (no **id** parameter to APIs) and the authorization process as well.\r\n\r\nI am not sure if this simplifies the interaction much.\r\n\r\n> \"Manage\" here is vague. It is \"vague\" because, as I described, GET lists **names** for sets of users (given the **user** and **realm** parameters), but DELETE should not, IMO, bulk revoke API keys. This is again, just a small detail.\r\n\r\nI think the behavior is in line with the privileges the administrator has in other cases as well like the invalidation of tokens or having the privilege to clear the cache of realms etc. IMO, to invalidate bulk API keys in the event of a leak or just simple recycling can be considered as a requirement.\r\n\r\n> \r\n> But, what is **really important** is what keys does the administrator (`manage_api_keys`) sees (GET, and if you insist DELETE) when **no parameters** are passed to the API ?\r\n> I strongly suggest it only sees his own API keys. If he wishes to view every API key in the system he must use the **`user=*`** request parameter. This is important so that, as I said, the transport request interface (for retrieve and invalidate) always contains a `principal` (or a `wildcard`). If we go with the option that the administrator (`manage_api_keys`) sees all the keys in the system, but a normal user (`manage_own_api_keys`) only his own, **for requests with no parameters**, then we have a problem that we mix authorization and application logic.\r\n\r\nIn my earlier response, I forgot to mention that I agree with this.\r\nIn the current behavior, we need at least one parameter to be specified, I agree to your point if the same API is being used by a user with `manage_api_key` or `manage_own_api_key` privilege, then the behavior could remain consistent where by default if nothing is specified then it always queries/invalidates the API keys owned by the authenticated user.\r\n\r\n> Re:\r\n> \r\n> > c) As an agent (say device agents of a fleet) using an API key for authentication, I would like to retrieve my (API key) information but not invalidate my API key or any other API keys.\r\n> \r\n> IMO, this is an unnecessary complication. Why would a service wish to view details about its API key? And what are those details, besides expiration time? This is again a small detail, if we want to make this work so be it, but small details add up fast...\r\n> \r\n\r\nAs explained my reasoning is based on the above example of an agent where it wants to request for a new API key from the fleet manager when near to expiry this can be helpful for an API key to retrieve its own information or if allowed invalidate itself in the event of the agent is uninstalled.\r\n\r\nI agree to your point of specifying a default value for the `user` parameter when invoking GET or DELETE API. This makes the behavior of the API consistent for a user with either `manage_api_key` or `manage_own_api_key` privilege. ~We can go with the default as `_self` so only API keys which are owned by the authenticated user are allowed by default and allow usage of `*` if one wants to operate on all users.~ This can be a breaking change. We can go with `*` as a default option but for the `manage_own_api_key` this will mean that the user gets an error.\r\n\r\nLooks like we have some agreement on few of the points.\r\nSo with the above discussion following are open questions:\r\n- Do we think that we want to restrict authenticated API key access to API key management APIs?\r\n- Do we want to restrict manage operations of API keys using only `name` and disallow usage of ids?\r\n \r\n(IMO, this need not be the case for both as explained in my reasoning above)\r\nAppreciate your points and the discussion so far to move ahead, Thank you.\r\n\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/511354592","html_url":"https://github.com/elastic/elasticsearch/issues/40031#issuecomment-511354592","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/40031","id":511354592,"node_id":"MDEyOklzc3VlQ29tbWVudDUxMTM1NDU5Mg==","user":{"login":"albertzaharovits","id":4568420,"node_id":"MDQ6VXNlcjQ1Njg0MjA=","avatar_url":"https://avatars2.githubusercontent.com/u/4568420?v=4","gravatar_id":"","url":"https://api.github.com/users/albertzaharovits","html_url":"https://github.com/albertzaharovits","followers_url":"https://api.github.com/users/albertzaharovits/followers","following_url":"https://api.github.com/users/albertzaharovits/following{/other_user}","gists_url":"https://api.github.com/users/albertzaharovits/gists{/gist_id}","starred_url":"https://api.github.com/users/albertzaharovits/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/albertzaharovits/subscriptions","organizations_url":"https://api.github.com/users/albertzaharovits/orgs","repos_url":"https://api.github.com/users/albertzaharovits/repos","events_url":"https://api.github.com/users/albertzaharovits/events{/privacy}","received_events_url":"https://api.github.com/users/albertzaharovits/received_events","type":"User","site_admin":false},"created_at":"2019-07-15T10:47:17Z","updated_at":"2019-07-15T11:25:39Z","author_association":"CONTRIBUTOR","body":"Thanks @bizybot for considering my suggestions!\r\n\r\nI have just realized we return the document id for the API key. I was under the impression that the `id` throughout requests and responses refers to the actual key, hence my argument about `id` being secret. Given that `name` is already a unique global identifier for keys, I wonder what were the requirements to expose the internal implementation detail of document ids? Anyway... if we **must maintain bwc** I have no objection on managing them by both `id` and `name`. A bunch of arguments fall apart. I apologize for my confusion.\r\n\r\nIf users with `manage_api_key` and `manage_own_api_key` have different defaults for the `user` request parameter, so to speak, we are mixing authz logic in the rest handler, which I think we should avoid. Moreover, the fact that we can assume the owner for an opaque identifier, such as the key `name`, avoids the necessity to design a mechanism for the authz framework to retrieve the ownership.\r\n\r\nGiven the BWC constraint, the \"global\" view of key names in the current API, and the owner issue for opaque identifiers, I think a separate \"self\" API is the only choice left.\r\n\r\nBut there are arguments against this as well; the client wouldn't know what endpoint to choose, especially given that they would be having very similar interfaces.\r\n\r\nIn essence we have to surrender some constraint. Stripped down, my proposal was to **always assume a self view of the key namespace** and to **use the `user` and `realm` parameters as selectors of key \"namespace\" rather than parameters for bulk retrieval and invalidation**.\r\nBut as you say, this is almost certainly breaking BWC.\r\n\r\nWhat do you say, if instead of adding a complementary \"self\" API we just rework the key interface in a glorious new one; A new endpoint altogether which should work for `manage_api_key` and `manage_own_api_key`. We maintain the existing `_security/api_key` as a kind of \"low-level\" API which requires elevated permissions. And we encourage clients to use the new interface, if at least because it works with the `manage_own` privilege. What do you think, are we open to this kind of change?\r\n\r\n\r\n\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/515274637","html_url":"https://github.com/elastic/elasticsearch/issues/40031#issuecomment-515274637","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/40031","id":515274637,"node_id":"MDEyOklzc3VlQ29tbWVudDUxNTI3NDYzNw==","user":{"login":"bizybot","id":902768,"node_id":"MDQ6VXNlcjkwMjc2OA==","avatar_url":"https://avatars2.githubusercontent.com/u/902768?v=4","gravatar_id":"","url":"https://api.github.com/users/bizybot","html_url":"https://github.com/bizybot","followers_url":"https://api.github.com/users/bizybot/followers","following_url":"https://api.github.com/users/bizybot/following{/other_user}","gists_url":"https://api.github.com/users/bizybot/gists{/gist_id}","starred_url":"https://api.github.com/users/bizybot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bizybot/subscriptions","organizations_url":"https://api.github.com/users/bizybot/orgs","repos_url":"https://api.github.com/users/bizybot/repos","events_url":"https://api.github.com/users/bizybot/events{/privacy}","received_events_url":"https://api.github.com/users/bizybot/received_events","type":"User","site_admin":false},"created_at":"2019-07-26T01:34:43Z","updated_at":"2019-07-29T05:24:44Z","author_association":"CONTRIBUTOR","body":"Thank you, @albertzaharovits, for your comments.\r\n\r\nWhen I last talked to Tim, he suggested if we could explore the option of adding a boolean to request indicating if the operation is for owned API keys. I like that idea as by default it can be `false` and preserve the backward compatibility.\r\n`my_api_keys_only` as a new optional parameter which is by default `false`.\r\n\r\nThe Get API behavior would be:\r\n- when `my_api_keys_only` is set to `true`\r\n  `GET /_security/api_key?id=abcd&my_api_keys_only=true`\r\n        the Rest controller will take care of setting `realm_name` and `username` to `_self`\r\n        and only return results if it finds one owned by the currently authenticated user.\r\n\r\n- when `my_api_keys_only` is set to `false` (default)\r\n  `GET /_security/api_key?id=abcd`\r\n        the Rest controller will assume `realm_name` and `username` to be unspecified meaning it will try to search for the API key across users and realms. This will fail if the user has only `manage_own_api_key` privilege.\r\n\r\nSimilarly, for Delete API key behavior:\r\n- when `my_api_keys_only` is set to `true`\r\n   `DELETE /_security/api_key`\r\n   ```\r\n   {\r\n     \"id\" : \"VuaCfGcBCdbkQm-e5aOx\",\r\n     \"my_api_keys_only\": \"true\"\r\n   }\r\n   ```\r\n\r\n   the Rest controller will take care of setting `realm_name` and `username` to `_self`\r\n   and only invalidate key if it finds one owned by the currently authenticated user.\r\n\r\n- when `my_api_keys_only` is set to `false` (default)\r\n   `DELETE /_security/api_key`\r\n   ```\r\n   {\r\n     \"id\" : \"VuaCfGcBCdbkQm-e5aOx\",\r\n     \"my_api_keys_only\": \"false\"\r\n   }\r\n   ```\r\n\r\n    the Rest controller will assume `realm_name` and `username` to be unspecified meaning it will \r\n    try to search for the API key across users and realms. This will fail if the user has only \r\n    `manage_own_api_key` privilege. \r\n\r\nThis seems a clean option to me which also preserves backward compatibility, the intent of the user is expressed clearly and is not complicated. wdyt?","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/515886958","html_url":"https://github.com/elastic/elasticsearch/issues/40031#issuecomment-515886958","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/40031","id":515886958,"node_id":"MDEyOklzc3VlQ29tbWVudDUxNTg4Njk1OA==","user":{"login":"albertzaharovits","id":4568420,"node_id":"MDQ6VXNlcjQ1Njg0MjA=","avatar_url":"https://avatars2.githubusercontent.com/u/4568420?v=4","gravatar_id":"","url":"https://api.github.com/users/albertzaharovits","html_url":"https://github.com/albertzaharovits","followers_url":"https://api.github.com/users/albertzaharovits/followers","following_url":"https://api.github.com/users/albertzaharovits/following{/other_user}","gists_url":"https://api.github.com/users/albertzaharovits/gists{/gist_id}","starred_url":"https://api.github.com/users/albertzaharovits/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/albertzaharovits/subscriptions","organizations_url":"https://api.github.com/users/albertzaharovits/orgs","repos_url":"https://api.github.com/users/albertzaharovits/repos","events_url":"https://api.github.com/users/albertzaharovits/events{/privacy}","received_events_url":"https://api.github.com/users/albertzaharovits/received_events","type":"User","site_admin":false},"created_at":"2019-07-29T07:57:40Z","updated_at":"2019-07-29T07:57:40Z","author_association":"CONTRIBUTOR","body":"> This seems a clean option to me which also preserves backward compatibility, the intent of the user is expressed clearly and is not complicated. wdyt?\r\n\r\nI think this is in accordance with the principle of not mixing application and authz logic in the REST layer, and it is very BWC friendly and relatively easy to implement. In this circumstances I don't have a strong opinion on the REST interface, so I'll be trusting your appreciation. Anyway, I think overall this is a good trade-off.\r\n\r\nThank you for considering my input!\r\nI see you already put out a PR, I'll take a look today.","performed_via_github_app":null}]