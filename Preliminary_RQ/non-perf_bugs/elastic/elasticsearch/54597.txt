{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/54597","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/54597/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/54597/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/54597/events","html_url":"https://github.com/elastic/elasticsearch/issues/54597","id":592063728,"node_id":"MDU6SXNzdWU1OTIwNjM3Mjg=","number":54597,"title":"EQL: Grammar improvements","user":{"login":"costin","id":76245,"node_id":"MDQ6VXNlcjc2MjQ1","avatar_url":"https://avatars3.githubusercontent.com/u/76245?v=4","gravatar_id":"","url":"https://api.github.com/users/costin","html_url":"https://github.com/costin","followers_url":"https://api.github.com/users/costin/followers","following_url":"https://api.github.com/users/costin/following{/other_user}","gists_url":"https://api.github.com/users/costin/gists{/gist_id}","starred_url":"https://api.github.com/users/costin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/costin/subscriptions","organizations_url":"https://api.github.com/users/costin/orgs","repos_url":"https://api.github.com/users/costin/repos","events_url":"https://api.github.com/users/costin/events{/privacy}","received_events_url":"https://api.github.com/users/costin/received_events","type":"User","site_admin":false},"labels":[{"id":1690690117,"node_id":"MDU6TGFiZWwxNjkwNjkwMTE3","url":"https://api.github.com/repos/elastic/elasticsearch/labels/:Query%20Languages/EQL","name":":Query Languages/EQL","color":"0e8a16","default":false,"description":"EQL querying"}],"state":"closed","locked":false,"assignee":{"login":"rw-access","id":31489089,"node_id":"MDQ6VXNlcjMxNDg5MDg5","avatar_url":"https://avatars1.githubusercontent.com/u/31489089?v=4","gravatar_id":"","url":"https://api.github.com/users/rw-access","html_url":"https://github.com/rw-access","followers_url":"https://api.github.com/users/rw-access/followers","following_url":"https://api.github.com/users/rw-access/following{/other_user}","gists_url":"https://api.github.com/users/rw-access/gists{/gist_id}","starred_url":"https://api.github.com/users/rw-access/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/rw-access/subscriptions","organizations_url":"https://api.github.com/users/rw-access/orgs","repos_url":"https://api.github.com/users/rw-access/repos","events_url":"https://api.github.com/users/rw-access/events{/privacy}","received_events_url":"https://api.github.com/users/rw-access/received_events","type":"User","site_admin":false},"assignees":[{"login":"rw-access","id":31489089,"node_id":"MDQ6VXNlcjMxNDg5MDg5","avatar_url":"https://avatars1.githubusercontent.com/u/31489089?v=4","gravatar_id":"","url":"https://api.github.com/users/rw-access","html_url":"https://github.com/rw-access","followers_url":"https://api.github.com/users/rw-access/followers","following_url":"https://api.github.com/users/rw-access/following{/other_user}","gists_url":"https://api.github.com/users/rw-access/gists{/gist_id}","starred_url":"https://api.github.com/users/rw-access/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/rw-access/subscriptions","organizations_url":"https://api.github.com/users/rw-access/orgs","repos_url":"https://api.github.com/users/rw-access/repos","events_url":"https://api.github.com/users/rw-access/events{/privacy}","received_events_url":"https://api.github.com/users/rw-access/received_events","type":"User","site_admin":false}],"milestone":null,"comments":7,"created_at":"2020-04-01T16:57:32Z","updated_at":"2020-04-16T10:47:12Z","closed_at":"2020-04-09T16:23:44Z","author_association":"MEMBER","active_lock_reason":null,"body":"In its current state the EQL grammar resembles the python version to support as much parsing as possible.\r\n\r\nHowever it's clear that some cases cannot be supported so the question is whether we should:\r\n\r\n1. allow them in the grammar and throw an error when they occur\r\nThis is the most friendly approach however the costly in terms of maintenance and it's worth evaluation whether said features are actually used or not.\r\n\r\n2. reduce the grammar and the code\r\nThe most convenient in terms of support yet fairly unfriendly for the users.\r\n\r\nBased on the existing queries and support, we should try and pick as many 2 as possible vs 1.\r\n\r\nBelow a list of things that stand out in the grammar:\r\n\r\n- [x] Sequence by and params - #55023\r\n\r\n`SEQUENCE  (by=joinKeys sequenceParams? | sequenceParams by=joinKeys?)?`\r\n\r\nA sequence can be declared with both join keys and sequence params but the order does not matter. However in all our examples and test suite only the first form is present.\r\nIt also seems the most natural:\r\n\r\n`sequence by key with param` vs `sequence with param by key`\r\n\r\nThe latter variant is redundant and a bit forced hence why I propose removing it.\r\n\r\n- [x] maxspan number and time units - #54680\r\n\r\nThe EQL tests allow fractional values and different time units to be specified:\r\n\r\n```\r\nsequence with \r\nmaxspan=200\r\nmaxspan=2s\r\nmaxspan=2sec\r\nmaxspan=2seconds\r\nmaxspan=2.5m\r\nmaxspan=1.0075d\r\n```\r\n\r\nI haven't tried it but since it accepts a decimal, the scientific notation is legal:\r\n```\r\nwith maxspan = 3.3733E+15ms\r\n```\r\n\r\nThe vast range of options here is trappy - from leniency (no time unit) to multiple units in different forms and fractional numbers. \r\nI propose to:\r\na. remove leniency - no time unit specified is a bug\r\n\r\nb. clarify the supported time units - seconds, minutes, hours, days (is that too big) and their supported names.\r\n\r\nc. move away from fractional numbers and keep only integers\r\nAs we've experienced in ES, fractional time units are tricky since millis & co have 1000 units, seconds, minutes, hours = 60 units while days - 24 units.\r\nA large enough fraction will cause a unit to be broken down to a large amount of very small time unit making it hard to compute.\r\n\r\n- [x]  separate bool expressions from non-bool - #54544\r\n\r\nCurrently all expression types can be compounded together even though that do not make sense. For example `NOT 5 + 1` , `TRUE + 5` or  `NOT length(\"mystring\", -4)`\r\n\r\nWhile the engine does handle this at runtime, it's essentially allowing unsupported / undefined queries to be inspected only to be, in the best case scenario, ignored.\r\nI'd like to revisit the grammar and take the SQL approach by breaking down the expression into types ((e.g. [boolean expressions](https://github.com/elastic/elasticsearch/blob/5d590b5be6ffaa28d5fd8c07fe8cda0cb94c8272/x-pack/plugin/sql/src/main/antlr/SqlBase.g4#L177)) and thus do small enforcement into the grammar itself.\r\n\r\n- [x] sequence fork\r\n```\r\nsequence by unique_pid \r\n    [process where true] \r\n    [file where true] fork \r\n    [network where true];\r\n```\r\nUnclear what fork is suppose to do and whether that's something we could support in ES.","closed_by":{"login":"costin","id":76245,"node_id":"MDQ6VXNlcjc2MjQ1","avatar_url":"https://avatars3.githubusercontent.com/u/76245?v=4","gravatar_id":"","url":"https://api.github.com/users/costin","html_url":"https://github.com/costin","followers_url":"https://api.github.com/users/costin/followers","following_url":"https://api.github.com/users/costin/following{/other_user}","gists_url":"https://api.github.com/users/costin/gists{/gist_id}","starred_url":"https://api.github.com/users/costin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/costin/subscriptions","organizations_url":"https://api.github.com/users/costin/orgs","repos_url":"https://api.github.com/users/costin/repos","events_url":"https://api.github.com/users/costin/events{/privacy}","received_events_url":"https://api.github.com/users/costin/received_events","type":"User","site_admin":false},"performed_via_github_app":null}