{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/787","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/787/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/787/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/787/events","html_url":"https://github.com/elastic/elasticsearch/issues/787","id":681224,"node_id":"MDU6SXNzdWU2ODEyMjQ=","number":787,"title":"Query: Provide an option to analyze wildcard/prefix in query_string / field queries","user":{"login":"emedina","id":617121,"node_id":"MDQ6VXNlcjYxNzEyMQ==","avatar_url":"https://avatars1.githubusercontent.com/u/617121?v=4","gravatar_id":"","url":"https://api.github.com/users/emedina","html_url":"https://github.com/emedina","followers_url":"https://api.github.com/users/emedina/followers","following_url":"https://api.github.com/users/emedina/following{/other_user}","gists_url":"https://api.github.com/users/emedina/gists{/gist_id}","starred_url":"https://api.github.com/users/emedina/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/emedina/subscriptions","organizations_url":"https://api.github.com/users/emedina/orgs","repos_url":"https://api.github.com/users/emedina/repos","events_url":"https://api.github.com/users/emedina/events{/privacy}","received_events_url":"https://api.github.com/users/emedina/received_events","type":"User","site_admin":false},"labels":[{"id":23174,"node_id":"MDU6TGFiZWwyMzE3NA==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/%3Eenhancement","name":">enhancement","color":"4a4ea8","default":false,"description":null},{"id":76649,"node_id":"MDU6TGFiZWw3NjY0OQ==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/v0.16.0","name":"v0.16.0","color":"ededed","default":false,"description":null}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":1,"created_at":"2011-03-17T09:54:50Z","updated_at":"2011-03-17T20:01:35Z","closed_at":"2011-03-17T20:01:35Z","author_association":"NONE","active_lock_reason":null,"body":"Add a flag called `analyze_wildcard` to both `query_string` and `field` queries, once set, a best effort will be made to analyze wildcard and prefix queries as well.\n\nMore details:\n\nWhen we use an analyzer that stems terms into tokens, and then later we want to search against those analyzed terms using a wildcard, by default the search terms are not analyzed, as that analysis could lead into several tokens and the search engine would not be sure which one to use:\n\nhttp://www.jguru.com/faq/view.jsp?EID=538312\n\nHowever, in certain circumstances, when the liability of the search can be somehow constrained in favor of better expected results, it would be nice to tell the search engine to analyze the wildcard terms before executing the search, therefore allowing for a more precise search (at least, expected).\n\nLet's put here an example with the Spanish analyzer (which uses the snowball stemmer):\n- We index the phrase \"I have an iPhone\"\n- We index the phrase \"I love the triad iPad/iPhone/iPod\"\n- We index the phrase \"I found the perfect combination: iPhone/MP3\"\n\nIf we use the standard current 'query_string', when searching for \"*phone*\", we will only get the last phrase, due to the way in which the terms have been analyzed:\n\n\"I have an iPhone\":\n\n{\"tokens\":[{\"token\":\"i\",\"start_offset\":0,\"end_offset\":1,\"type\":\"<ALPHANUM>\",\"position\":1},{\"token\":\"hav\",\"start_offset\":2,\"end_offset\":6,\"type\":\"<ALPHANUM>\",\"position\":2},{\"token\":\"an\",\"start_offset\":7,\"end_offset\":9,\"type\":\"<ALPHANUM>\",\"position\":3},{\"token\":\"iphon\",\"start_offset\":10,\"end_offset\":16,\"type\":\"<ALPHANUM>\",\"position\":4}]}\n\n\"I love the triad iPad/iPhone/iPod\":\n\n{\"tokens\":[{\"token\":\"i\",\"start_offset\":0,\"end_offset\":1,\"type\":\"<ALPHANUM>\",\"position\":1},{\"token\":\"lov\",\"start_offset\":2,\"end_offset\":6,\"type\":\"<ALPHANUM>\",\"position\":2},{\"token\":\"the\",\"start_offset\":7,\"end_offset\":10,\"type\":\"<ALPHANUM>\",\"position\":3},{\"token\":\"tri\",\"start_offset\":11,\"end_offset\":16,\"type\":\"<ALPHANUM>\",\"position\":4},{\"token\":\"ipad\",\"start_offset\":17,\"end_offset\":21,\"type\":\"<ALPHANUM>\",\"position\":5},{\"token\":\"iphon\",\"start_offset\":22,\"end_offset\":28,\"type\":\"<ALPHANUM>\",\"position\":6},{\"token\":\"ipod\",\"start_offset\":29,\"end_offset\":33,\"type\":\"<ALPHANUM>\",\"position\":7}]}\n\n\"I found the perfect combination: iPhone/MP3\":\n\n{\"tokens\":[{\"token\":\"i\",\"start_offset\":0,\"end_offset\":1,\"type\":\"<ALPHANUM>\",\"position\":1},{\"token\":\"found\",\"start_offset\":2,\"end_offset\":7,\"type\":\"<ALPHANUM>\",\"position\":2},{\"token\":\"the\",\"start_offset\":8,\"end_offset\":11,\"type\":\"<ALPHANUM>\",\"position\":3},{\"token\":\"perfect\",\"start_offset\":12,\"end_offset\":19,\"type\":\"<ALPHANUM>\",\"position\":4},{\"token\":\"combination\",\"start_offset\":20,\"end_offset\":31,\"type\":\"<ALPHANUM>\",\"position\":5},{\"token\":\"iphone/mp3\",\"start_offset\":33,\"end_offset\":43,\"type\":\"<NUM>\",\"position\":6}]}\n\nSee how the latter stems \"iPhone/MP3\" as \"iphone/mp3\"? Hence this is the only one matching a 'query_string' equal to \"*phone*\" (and similar 'unexpected' results occur when using just one leading or trailing wildcard as well).\n\nThis result would be dissapointing for the user, as she'd expect at least something like \"iPhone\" or even \"telephone\" to be returned as a result, but due to fact that the Spanish analyzer will always remove the trailing 'e' from most of the words, it won't find them.\n\nSo enhancement would be to provide a mechanism, in the form of a parameter, for instance, in the 'query_string', that would tell the ES query parser to analyze those search terms surrounded by wildcards (i.e. either enclosed completely, or just with a leading or trailing wildcard).\n\nFollowing our previous example, a 'query_string' for \"*phone*\" would be actually analyzed in the Spanish analyzer as \"*phon*\" therefore returning absolutely all the phrases previously created, which would be the expected and reasonable behaviour from a user's perspective. Of course, it could have some side effects on other searches, but as a parameter, it would be up to the search designer to either use it or not.\n","closed_by":{"login":"kimchy","id":41300,"node_id":"MDQ6VXNlcjQxMzAw","avatar_url":"https://avatars1.githubusercontent.com/u/41300?v=4","gravatar_id":"","url":"https://api.github.com/users/kimchy","html_url":"https://github.com/kimchy","followers_url":"https://api.github.com/users/kimchy/followers","following_url":"https://api.github.com/users/kimchy/following{/other_user}","gists_url":"https://api.github.com/users/kimchy/gists{/gist_id}","starred_url":"https://api.github.com/users/kimchy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/kimchy/subscriptions","organizations_url":"https://api.github.com/users/kimchy/orgs","repos_url":"https://api.github.com/users/kimchy/repos","events_url":"https://api.github.com/users/kimchy/events{/privacy}","received_events_url":"https://api.github.com/users/kimchy/received_events","type":"User","site_admin":false},"performed_via_github_app":null}