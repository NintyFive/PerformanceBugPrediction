{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/17630","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/17630/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/17630/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/17630/events","html_url":"https://github.com/elastic/elasticsearch/issues/17630","id":147031600,"node_id":"MDU6SXNzdWUxNDcwMzE2MDA=","number":17630,"title":"Primary shard failures should not block other primary shard recoveries","user":{"login":"dakrone","id":19060,"node_id":"MDQ6VXNlcjE5MDYw","avatar_url":"https://avatars3.githubusercontent.com/u/19060?v=4","gravatar_id":"","url":"https://api.github.com/users/dakrone","html_url":"https://github.com/dakrone","followers_url":"https://api.github.com/users/dakrone/followers","following_url":"https://api.github.com/users/dakrone/following{/other_user}","gists_url":"https://api.github.com/users/dakrone/gists{/gist_id}","starred_url":"https://api.github.com/users/dakrone/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dakrone/subscriptions","organizations_url":"https://api.github.com/users/dakrone/orgs","repos_url":"https://api.github.com/users/dakrone/repos","events_url":"https://api.github.com/users/dakrone/events{/privacy}","received_events_url":"https://api.github.com/users/dakrone/received_events","type":"User","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":4,"created_at":"2016-04-08T20:29:13Z","updated_at":"2016-04-11T22:06:25Z","closed_at":"2016-04-11T22:06:25Z","author_association":"MEMBER","active_lock_reason":null,"body":"On master, if I have an index with 5 primary shards, and I corrupt the `0` and\n`1` shards, once ES hits a corrupt shard, it will not attempt to recovery the\nnext primary shard.\n\n**Steps to reproduce**:\n1. Create an index with 5 shards\n2. Corrupt the 0 and 1 shards (I used https://github.com/joshsegall/corrupt\n   to add bytes to the end of the `segments_#` files)\n3. Start up ES\n\nHere's what I get:\n\n```\n[2016-04-08 14:11:35,850][WARN ][indices.cluster          ] [Captain Zero] [[i][1]] marking and sending shard failed due to [failed recovery]\n[i/QzoKda9aQCG_hCaZQ18GEg][[i][1]] IndexShardRecoveryException[failed to fetch index version after copying it over]; nested: IndexShardRecoveryException[shard allocated for local recovery (post api), should exist, but doesn't, current files: [segments_3, write.lock]]; nested: IndexFormatTooOldException[Format version is not supported (resource BufferedChecksumIndexInput(NIOFSIndexInput(path=\"/home/hinmanm/scratch/elasticsearch-5.0.0-alpha1-SNAPSHOT/data/elasticsearch/nodes/0/indices/QzoKda9aQCG_hCaZQ18GEg/1/index/segments_3\"))): 317397653 (needs to be between 1071082519 and 1071082519). This version of Lucene only supports indexes created with release 5.0 and later.];\n    at org.elasticsearch.index.shard.StoreRecovery.internalRecoverFromStore(StoreRecovery.java:208)\n    at org.elasticsearch.index.shard.StoreRecovery.lambda$recoverFromStore$0(StoreRecovery.java:78)\n    at org.elasticsearch.index.shard.StoreRecovery.executeRecovery(StoreRecovery.java:123)\n    at org.elasticsearch.index.shard.StoreRecovery.recoverFromStore(StoreRecovery.java:76)\n    at org.elasticsearch.index.shard.IndexShard.recoverFromStore(IndexShard.java:1092)\n    at org.elasticsearch.indices.cluster.IndicesClusterStateService.lambda$applyInitializingShard$2(IndicesClusterStateService.java:636)\n    at org.elasticsearch.common.util.concurrent.ThreadContext$ContextPreservingRunnable.run(ThreadContext.java:408)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n    at java.lang.Thread.run(Thread.java:745)\nCaused by: [i/QzoKda9aQCG_hCaZQ18GEg][[i][1]] IndexShardRecoveryException[shard allocated for local recovery (post api), should exist, but doesn't, current files: [segments_3, write.lock]]; nested: IndexFormatTooOldException[Format version is not supported (resource BufferedChecksumIndexInput(NIOFSIndexInput(path=\"/home/hinmanm/scratch/elasticsearch-5.0.0-alpha1-SNAPSHOT/data/elasticsearch/nodes/0/indices/QzoKda9aQCG_hCaZQ18GEg/1/index/segments_3\"))): 317397653 (needs to be between 1071082519 and 1071082519). This version of Lucene only supports indexes created with release 5.0 and later.];\n    at org.elasticsearch.index.shard.StoreRecovery.internalRecoverFromStore(StoreRecovery.java:193)\n    ... 9 more\nCaused by: org.apache.lucene.index.IndexFormatTooOldException: Format version is not supported (resource BufferedChecksumIndexInput(NIOFSIndexInput(path=\"/home/hinmanm/scratch/elasticsearch-5.0.0-alpha1-SNAPSHOT/data/elasticsearch/nodes/0/indices/QzoKda9aQCG_hCaZQ18GEg/1/index/segments_3\"))): 317397653 (needs to be between 1071082519 and 1071082519). This version of Lucene only supports indexes created with release 5.0 and later.\n    at org.apache.lucene.index.SegmentInfos.readCommit(SegmentInfos.java:295)\n    at org.apache.lucene.index.SegmentInfos.readCommit(SegmentInfos.java:284)\n    at org.apache.lucene.index.SegmentInfos$1.doBody(SegmentInfos.java:441)\n    at org.apache.lucene.index.SegmentInfos$1.doBody(SegmentInfos.java:438)\n    at org.apache.lucene.index.SegmentInfos$FindSegmentsFile.run(SegmentInfos.java:685)\n    at org.apache.lucene.index.SegmentInfos$FindSegmentsFile.run(SegmentInfos.java:637)\n    at org.apache.lucene.index.SegmentInfos.readLatestCommit(SegmentInfos.java:443)\n    at org.elasticsearch.common.lucene.Lucene.readSegmentInfos(Lucene.java:123)\n    at org.elasticsearch.index.store.Store.readSegmentsInfo(Store.java:191)\n    at org.elasticsearch.index.store.Store.readLastCommittedSegmentsInfo(Store.java:176)\n    at org.elasticsearch.index.shard.StoreRecovery.internalRecoverFromStore(StoreRecovery.java:184)\n```\n\nWhich is great, and expected (I corrupted the files).\n\nWhat I do expect is that ES will skip this shard (shard 1) since it failed and\ntry shard 0, instead, it gives up and never gets that far, leaving it unassigned\nand un-tried:\n\n```\nindex shard prirep state      docs store ip        node\ni     4     p      STARTED       0  130b 127.0.0.1 Captain Zero\ni     4     r      UNASSIGNED\ni     3     p      STARTED       0  130b 127.0.0.1 Captain Zero\ni     3     r      UNASSIGNED\ni     2     p      STARTED       0  130b 127.0.0.1 Captain Zero\ni     2     r      UNASSIGNED\ni     1     p      UNASSIGNED\ni     1     r      UNASSIGNED\ni     0     p      UNASSIGNED\ni     0     r      UNASSIGNED\n```\n\nThis might not sound like a big deal, however, for the shard that was tried\n(shard 1), `UnassignedInfo` will contain the `IndexShardRecoveryException` with\nall the details about the file being corrupt and all that. For the shard that\nwas never tried (shard 0), it doesn't have those details (even though I\ncorrupted the shard).\n\nIt would be great if both shards' `UnassignedInfo` had any exception that\noccurred during recovery.\n","closed_by":{"login":"dakrone","id":19060,"node_id":"MDQ6VXNlcjE5MDYw","avatar_url":"https://avatars3.githubusercontent.com/u/19060?v=4","gravatar_id":"","url":"https://api.github.com/users/dakrone","html_url":"https://github.com/dakrone","followers_url":"https://api.github.com/users/dakrone/followers","following_url":"https://api.github.com/users/dakrone/following{/other_user}","gists_url":"https://api.github.com/users/dakrone/gists{/gist_id}","starred_url":"https://api.github.com/users/dakrone/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dakrone/subscriptions","organizations_url":"https://api.github.com/users/dakrone/orgs","repos_url":"https://api.github.com/users/dakrone/repos","events_url":"https://api.github.com/users/dakrone/events{/privacy}","received_events_url":"https://api.github.com/users/dakrone/received_events","type":"User","site_admin":false},"performed_via_github_app":null}