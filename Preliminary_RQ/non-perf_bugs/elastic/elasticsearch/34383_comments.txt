[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/428613379","html_url":"https://github.com/elastic/elasticsearch/issues/34383#issuecomment-428613379","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/34383","id":428613379,"node_id":"MDEyOklzc3VlQ29tbWVudDQyODYxMzM3OQ==","user":{"login":"elasticmachine","id":15837671,"node_id":"MDQ6VXNlcjE1ODM3Njcx","avatar_url":"https://avatars3.githubusercontent.com/u/15837671?v=4","gravatar_id":"","url":"https://api.github.com/users/elasticmachine","html_url":"https://github.com/elasticmachine","followers_url":"https://api.github.com/users/elasticmachine/followers","following_url":"https://api.github.com/users/elasticmachine/following{/other_user}","gists_url":"https://api.github.com/users/elasticmachine/gists{/gist_id}","starred_url":"https://api.github.com/users/elasticmachine/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/elasticmachine/subscriptions","organizations_url":"https://api.github.com/users/elasticmachine/orgs","repos_url":"https://api.github.com/users/elasticmachine/repos","events_url":"https://api.github.com/users/elasticmachine/events{/privacy}","received_events_url":"https://api.github.com/users/elasticmachine/received_events","type":"User","site_admin":false},"created_at":"2018-10-10T15:16:59Z","updated_at":"2018-10-10T15:16:59Z","author_association":"COLLABORATOR","body":"Pinging @elastic/es-security","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/428680418","html_url":"https://github.com/elastic/elasticsearch/issues/34383#issuecomment-428680418","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/34383","id":428680418,"node_id":"MDEyOklzc3VlQ29tbWVudDQyODY4MDQxOA==","user":{"login":"jaymode","id":4339958,"node_id":"MDQ6VXNlcjQzMzk5NTg=","avatar_url":"https://avatars1.githubusercontent.com/u/4339958?v=4","gravatar_id":"","url":"https://api.github.com/users/jaymode","html_url":"https://github.com/jaymode","followers_url":"https://api.github.com/users/jaymode/followers","following_url":"https://api.github.com/users/jaymode/following{/other_user}","gists_url":"https://api.github.com/users/jaymode/gists{/gist_id}","starred_url":"https://api.github.com/users/jaymode/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jaymode/subscriptions","organizations_url":"https://api.github.com/users/jaymode/orgs","repos_url":"https://api.github.com/users/jaymode/repos","events_url":"https://api.github.com/users/jaymode/events{/privacy}","received_events_url":"https://api.github.com/users/jaymode/received_events","type":"User","site_admin":false},"created_at":"2018-10-10T18:26:58Z","updated_at":"2018-10-10T18:26:58Z","author_association":"MEMBER","body":"@jbaiera and @chrisdavies FYI. Let me know if you see any issues with this proposal. ","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/429015669","html_url":"https://github.com/elastic/elasticsearch/issues/34383#issuecomment-429015669","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/34383","id":429015669,"node_id":"MDEyOklzc3VlQ29tbWVudDQyOTAxNTY2OQ==","user":{"login":"jasontedor","id":4744941,"node_id":"MDQ6VXNlcjQ3NDQ5NDE=","avatar_url":"https://avatars3.githubusercontent.com/u/4744941?v=4","gravatar_id":"","url":"https://api.github.com/users/jasontedor","html_url":"https://github.com/jasontedor","followers_url":"https://api.github.com/users/jasontedor/followers","following_url":"https://api.github.com/users/jasontedor/following{/other_user}","gists_url":"https://api.github.com/users/jasontedor/gists{/gist_id}","starred_url":"https://api.github.com/users/jasontedor/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jasontedor/subscriptions","organizations_url":"https://api.github.com/users/jasontedor/orgs","repos_url":"https://api.github.com/users/jasontedor/repos","events_url":"https://api.github.com/users/jasontedor/events{/privacy}","received_events_url":"https://api.github.com/users/jasontedor/received_events","type":"User","site_admin":false},"created_at":"2018-10-11T16:07:28Z","updated_at":"2018-10-11T16:07:28Z","author_association":"MEMBER","body":"@martijnvg @ywelsch Let us watch this issue in the context of CCR where we would consider using these tokens instead of the current approach of associating authorization headers with the persistent task.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/429040072","html_url":"https://github.com/elastic/elasticsearch/issues/34383#issuecomment-429040072","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/34383","id":429040072,"node_id":"MDEyOklzc3VlQ29tbWVudDQyOTA0MDA3Mg==","user":{"login":"jbaiera","id":875779,"node_id":"MDQ6VXNlcjg3NTc3OQ==","avatar_url":"https://avatars1.githubusercontent.com/u/875779?v=4","gravatar_id":"","url":"https://api.github.com/users/jbaiera","html_url":"https://github.com/jbaiera","followers_url":"https://api.github.com/users/jbaiera/followers","following_url":"https://api.github.com/users/jbaiera/following{/other_user}","gists_url":"https://api.github.com/users/jbaiera/gists{/gist_id}","starred_url":"https://api.github.com/users/jbaiera/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jbaiera/subscriptions","organizations_url":"https://api.github.com/users/jbaiera/orgs","repos_url":"https://api.github.com/users/jbaiera/repos","events_url":"https://api.github.com/users/jbaiera/events{/privacy}","received_events_url":"https://api.github.com/users/jbaiera/received_events","type":"User","site_admin":false},"created_at":"2018-10-11T17:11:53Z","updated_at":"2018-10-11T17:11:53Z","author_association":"CONTRIBUTOR","body":"> * By default, tokens have no expiration. A cluster level setting will\r\nbe available to specify a maximum lifetime\r\n> * When creating a token, a maximum lifetime can be specified for cases\r\nwhere the token is expected to stop working after a certain amount of\r\ntime\r\n\r\nAre we thinking that the cluster setting for maximum token lifetime will be the absolute maximum even if a client requests a longer lifetime? So if the maximum TTL for a token is set at 7 days in the cluster settings, and a client requests a token that lives for 1 month, will the client receive a token that expires in 7 days or 1 month?\r\n\r\nNot sure if this was already assumed, but when we receive a token, it should probably denote its expiration date and time. I didn't see any example responses, so I figured I would put that here.\r\n\r\nFinal thought - It might make sense to allow clients to name the tokens to make interacting with and managing responses from the token api easier.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/429872590","html_url":"https://github.com/elastic/elasticsearch/issues/34383#issuecomment-429872590","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/34383","id":429872590,"node_id":"MDEyOklzc3VlQ29tbWVudDQyOTg3MjU5MA==","user":{"login":"jaymode","id":4339958,"node_id":"MDQ6VXNlcjQzMzk5NTg=","avatar_url":"https://avatars1.githubusercontent.com/u/4339958?v=4","gravatar_id":"","url":"https://api.github.com/users/jaymode","html_url":"https://github.com/jaymode","followers_url":"https://api.github.com/users/jaymode/followers","following_url":"https://api.github.com/users/jaymode/following{/other_user}","gists_url":"https://api.github.com/users/jaymode/gists{/gist_id}","starred_url":"https://api.github.com/users/jaymode/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jaymode/subscriptions","organizations_url":"https://api.github.com/users/jaymode/orgs","repos_url":"https://api.github.com/users/jaymode/repos","events_url":"https://api.github.com/users/jaymode/events{/privacy}","received_events_url":"https://api.github.com/users/jaymode/received_events","type":"User","site_admin":false},"created_at":"2018-10-15T14:22:34Z","updated_at":"2018-10-15T14:22:34Z","author_association":"MEMBER","body":"> Are we thinking that the cluster setting for maximum token lifetime will be the absolute maximum even if a client requests a longer lifetime? \r\n\r\nYes.\r\n\r\n> So if the maximum TTL for a token is set at 7 days in the cluster settings, and a client requests a token that lives for 1 month, will the client receive a token that expires in 7 days or 1 month?\r\n\r\nI'd prefer for this to be an error condition, but given the variability in what a user could define the client would receive a token that expires in 7 days.\r\n\r\n> Not sure if this was already assumed, but when we receive a token, it should probably denote its expiration date and time\r\n\r\nMakes sense.\r\n\r\nAlthough the more I think about this, I am contemplating leaving out this ability in the first iteration and see what kind of feedback we get.\r\n\r\n> Final thought - It might make sense to allow clients to name the tokens to make interacting with and managing responses from the token api easier.\r\n\r\n++\r\n\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/429997684","html_url":"https://github.com/elastic/elasticsearch/issues/34383#issuecomment-429997684","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/34383","id":429997684,"node_id":"MDEyOklzc3VlQ29tbWVudDQyOTk5NzY4NA==","user":{"login":"jaymode","id":4339958,"node_id":"MDQ6VXNlcjQzMzk5NTg=","avatar_url":"https://avatars1.githubusercontent.com/u/4339958?v=4","gravatar_id":"","url":"https://api.github.com/users/jaymode","html_url":"https://github.com/jaymode","followers_url":"https://api.github.com/users/jaymode/followers","following_url":"https://api.github.com/users/jaymode/following{/other_user}","gists_url":"https://api.github.com/users/jaymode/gists{/gist_id}","starred_url":"https://api.github.com/users/jaymode/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jaymode/subscriptions","organizations_url":"https://api.github.com/users/jaymode/orgs","repos_url":"https://api.github.com/users/jaymode/repos","events_url":"https://api.github.com/users/jaymode/events{/privacy}","received_events_url":"https://api.github.com/users/jaymode/received_events","type":"User","site_admin":false},"created_at":"2018-10-15T20:16:45Z","updated_at":"2018-10-15T20:16:45Z","author_association":"MEMBER","body":"The ability to define scoped access is allowed by providing a role definition with the token but is not necessarily a role that can retrieved using another mechanism. In order to support this, we need to think about how this role is handled in a few different scenarios:\r\n\r\n1. Same node\r\n2. Node to node in the same cluster\r\n3. Node to remote node\r\n\r\nThe current thinking for 1 is that the role would be loaded by the service that loads the token. We need a way to get this role into the authorization service. The `ThreadContext` is the quick way out but I'd like to avoid using this as it feels like a mistake. We may be able to make use of metadata on the AuthenticationResult object that was recently added.\r\n\r\nFor the node to node scenario, there is a question of whether the receiving node should perform the loading of the role or if it should be serialized with the request and token. We've never serialized a role like this before, so we would be adding to the data that one nodes trusts from the other.\r\n\r\nIn terms of cross cluster, we've always just sent the role names and relied on the remote cluster looking this up. I think we set a dangerous precedent if we decide to serialize the role. However, if we do not serialize the role then these tokens cannot be used for cross cluster jobs, which hinders their use significantly.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/430120878","html_url":"https://github.com/elastic/elasticsearch/issues/34383#issuecomment-430120878","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/34383","id":430120878,"node_id":"MDEyOklzc3VlQ29tbWVudDQzMDEyMDg3OA==","user":{"login":"tvernum","id":2244393,"node_id":"MDQ6VXNlcjIyNDQzOTM=","avatar_url":"https://avatars0.githubusercontent.com/u/2244393?v=4","gravatar_id":"","url":"https://api.github.com/users/tvernum","html_url":"https://github.com/tvernum","followers_url":"https://api.github.com/users/tvernum/followers","following_url":"https://api.github.com/users/tvernum/following{/other_user}","gists_url":"https://api.github.com/users/tvernum/gists{/gist_id}","starred_url":"https://api.github.com/users/tvernum/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/tvernum/subscriptions","organizations_url":"https://api.github.com/users/tvernum/orgs","repos_url":"https://api.github.com/users/tvernum/repos","events_url":"https://api.github.com/users/tvernum/events{/privacy}","received_events_url":"https://api.github.com/users/tvernum/received_events","type":"User","site_admin":false},"created_at":"2018-10-16T06:48:41Z","updated_at":"2018-10-16T06:49:04Z","author_association":"CONTRIBUTOR","body":"> Invalidation or a removal of a token should remove the token document from the security index.\r\n\r\nIt's an implementation detail, but I think we should keep the tokens in an \"invalidated\" state for a short period (~24h?).\r\nMy two reasons for that are:\r\n- Forensics. If invalidating a token removes all record of it, then it might be used by someone to cover their tracks. 24h is long enough for an admin to generate audit logs of whatever they think they need to retain.\r\n- Simple debugging. It's nicer to be able to diagnose (in the server logs) that a job attempted to use a token after it was \"deleted\" as opposed to using a token that never existed.\r\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/431039916","html_url":"https://github.com/elastic/elasticsearch/issues/34383#issuecomment-431039916","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/34383","id":431039916,"node_id":"MDEyOklzc3VlQ29tbWVudDQzMTAzOTkxNg==","user":{"login":"kobelb","id":627123,"node_id":"MDQ6VXNlcjYyNzEyMw==","avatar_url":"https://avatars0.githubusercontent.com/u/627123?v=4","gravatar_id":"","url":"https://api.github.com/users/kobelb","html_url":"https://github.com/kobelb","followers_url":"https://api.github.com/users/kobelb/followers","following_url":"https://api.github.com/users/kobelb/following{/other_user}","gists_url":"https://api.github.com/users/kobelb/gists{/gist_id}","starred_url":"https://api.github.com/users/kobelb/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/kobelb/subscriptions","organizations_url":"https://api.github.com/users/kobelb/orgs","repos_url":"https://api.github.com/users/kobelb/repos","events_url":"https://api.github.com/users/kobelb/events{/privacy}","received_events_url":"https://api.github.com/users/kobelb/received_events","type":"User","site_admin":false},"created_at":"2018-10-18T14:52:21Z","updated_at":"2018-10-18T14:52:21Z","author_association":"CONTRIBUTOR","body":"Is it safe to assume that we'd be able to use an existing token in the situation of SAML to get a long-lived token?","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/431065308","html_url":"https://github.com/elastic/elasticsearch/issues/34383#issuecomment-431065308","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/34383","id":431065308,"node_id":"MDEyOklzc3VlQ29tbWVudDQzMTA2NTMwOA==","user":{"login":"jkakavas","id":10281256,"node_id":"MDQ6VXNlcjEwMjgxMjU2","avatar_url":"https://avatars2.githubusercontent.com/u/10281256?v=4","gravatar_id":"","url":"https://api.github.com/users/jkakavas","html_url":"https://github.com/jkakavas","followers_url":"https://api.github.com/users/jkakavas/followers","following_url":"https://api.github.com/users/jkakavas/following{/other_user}","gists_url":"https://api.github.com/users/jkakavas/gists{/gist_id}","starred_url":"https://api.github.com/users/jkakavas/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jkakavas/subscriptions","organizations_url":"https://api.github.com/users/jkakavas/orgs","repos_url":"https://api.github.com/users/jkakavas/repos","events_url":"https://api.github.com/users/jkakavas/events{/privacy}","received_events_url":"https://api.github.com/users/jkakavas/received_events","type":"User","site_admin":false},"created_at":"2018-10-18T15:59:26Z","updated_at":"2018-10-18T15:59:26Z","author_association":"CONTRIBUTOR","body":"I would add a future consideration for the possibility to invalidate all long lived tokens of user or realm as we've discussed for the oAuth tokens ( currently tracked in https://github.com/elastic/elasticsearch/issues/34556 ) ","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/431067348","html_url":"https://github.com/elastic/elasticsearch/issues/34383#issuecomment-431067348","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/34383","id":431067348,"node_id":"MDEyOklzc3VlQ29tbWVudDQzMTA2NzM0OA==","user":{"login":"jaymode","id":4339958,"node_id":"MDQ6VXNlcjQzMzk5NTg=","avatar_url":"https://avatars1.githubusercontent.com/u/4339958?v=4","gravatar_id":"","url":"https://api.github.com/users/jaymode","html_url":"https://github.com/jaymode","followers_url":"https://api.github.com/users/jaymode/followers","following_url":"https://api.github.com/users/jaymode/following{/other_user}","gists_url":"https://api.github.com/users/jaymode/gists{/gist_id}","starred_url":"https://api.github.com/users/jaymode/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jaymode/subscriptions","organizations_url":"https://api.github.com/users/jaymode/orgs","repos_url":"https://api.github.com/users/jaymode/repos","events_url":"https://api.github.com/users/jaymode/events{/privacy}","received_events_url":"https://api.github.com/users/jaymode/received_events","type":"User","site_admin":false},"created_at":"2018-10-18T16:05:03Z","updated_at":"2018-10-18T16:05:03Z","author_association":"MEMBER","body":"> Is it safe to assume that we'd be able to use an existing token in the situation of SAML to get a long-lived token?\r\n\r\nYes. Given how we use the short lived tokens, I think we need this","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/431789313","html_url":"https://github.com/elastic/elasticsearch/issues/34383#issuecomment-431789313","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/34383","id":431789313,"node_id":"MDEyOklzc3VlQ29tbWVudDQzMTc4OTMxMw==","user":{"login":"bizybot","id":902768,"node_id":"MDQ6VXNlcjkwMjc2OA==","avatar_url":"https://avatars2.githubusercontent.com/u/902768?v=4","gravatar_id":"","url":"https://api.github.com/users/bizybot","html_url":"https://github.com/bizybot","followers_url":"https://api.github.com/users/bizybot/followers","following_url":"https://api.github.com/users/bizybot/following{/other_user}","gists_url":"https://api.github.com/users/bizybot/gists{/gist_id}","starred_url":"https://api.github.com/users/bizybot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bizybot/subscriptions","organizations_url":"https://api.github.com/users/bizybot/orgs","repos_url":"https://api.github.com/users/bizybot/repos","events_url":"https://api.github.com/users/bizybot/events{/privacy}","received_events_url":"https://api.github.com/users/bizybot/received_events","type":"User","site_admin":false},"created_at":"2018-10-22T09:48:55Z","updated_at":"2018-10-22T09:48:55Z","author_association":"CONTRIBUTOR","body":"> By default, tokens have no expiration. A cluster level setting will\r\nbe available to specify a maximum lifetime\r\n\r\nI think instead of no expiration, we can go with a pre-defined expiration ( like 7 days or something) and the configuration setting allows option to say no expiration if one wants to use it.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/431849458","html_url":"https://github.com/elastic/elasticsearch/issues/34383#issuecomment-431849458","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/34383","id":431849458,"node_id":"MDEyOklzc3VlQ29tbWVudDQzMTg0OTQ1OA==","user":{"login":"jaymode","id":4339958,"node_id":"MDQ6VXNlcjQzMzk5NTg=","avatar_url":"https://avatars1.githubusercontent.com/u/4339958?v=4","gravatar_id":"","url":"https://api.github.com/users/jaymode","html_url":"https://github.com/jaymode","followers_url":"https://api.github.com/users/jaymode/followers","following_url":"https://api.github.com/users/jaymode/following{/other_user}","gists_url":"https://api.github.com/users/jaymode/gists{/gist_id}","starred_url":"https://api.github.com/users/jaymode/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jaymode/subscriptions","organizations_url":"https://api.github.com/users/jaymode/orgs","repos_url":"https://api.github.com/users/jaymode/repos","events_url":"https://api.github.com/users/jaymode/events{/privacy}","received_events_url":"https://api.github.com/users/jaymode/received_events","type":"User","site_admin":false},"created_at":"2018-10-22T14:20:19Z","updated_at":"2018-10-22T14:20:19Z","author_association":"MEMBER","body":"Can you add details about why you feel that way? My current thinking is to leave the setting out completely. There are use cases where some users may not want an expiration; an example of existing work would be github personal access tokens. The reason I am considering that the setting can be left out initially is because it can cause issues with Kibana task manager and hadoop if the duration is too short; additionally leaving it out also simplifies the implementation.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/432465429","html_url":"https://github.com/elastic/elasticsearch/issues/34383#issuecomment-432465429","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/34383","id":432465429,"node_id":"MDEyOklzc3VlQ29tbWVudDQzMjQ2NTQyOQ==","user":{"login":"bizybot","id":902768,"node_id":"MDQ6VXNlcjkwMjc2OA==","avatar_url":"https://avatars2.githubusercontent.com/u/902768?v=4","gravatar_id":"","url":"https://api.github.com/users/bizybot","html_url":"https://github.com/bizybot","followers_url":"https://api.github.com/users/bizybot/followers","following_url":"https://api.github.com/users/bizybot/following{/other_user}","gists_url":"https://api.github.com/users/bizybot/gists{/gist_id}","starred_url":"https://api.github.com/users/bizybot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bizybot/subscriptions","organizations_url":"https://api.github.com/users/bizybot/orgs","repos_url":"https://api.github.com/users/bizybot/repos","events_url":"https://api.github.com/users/bizybot/events{/privacy}","received_events_url":"https://api.github.com/users/bizybot/received_events","type":"User","site_admin":false},"created_at":"2018-10-24T00:09:04Z","updated_at":"2018-10-24T00:09:04Z","author_association":"CONTRIBUTOR","body":"Well, the reason I have is mostly that these are,**not** API keys but API tokens which we are using for authentication. For me giving out expiring tokens by defaults seems to minimize the threat on leaks and theft. Even if we plan to add setting this in the later version, the customer's who will be using the version with non-expiring API tokens can be at risk. I agree the different scenarios demand different expiration, and we would want all of these scenarios to be supported, so if possible I would go with a simple setting that allows it to be controlled.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/441641380","html_url":"https://github.com/elastic/elasticsearch/issues/34383#issuecomment-441641380","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/34383","id":441641380,"node_id":"MDEyOklzc3VlQ29tbWVudDQ0MTY0MTM4MA==","user":{"login":"albertzaharovits","id":4568420,"node_id":"MDQ6VXNlcjQ1Njg0MjA=","avatar_url":"https://avatars2.githubusercontent.com/u/4568420?v=4","gravatar_id":"","url":"https://api.github.com/users/albertzaharovits","html_url":"https://github.com/albertzaharovits","followers_url":"https://api.github.com/users/albertzaharovits/followers","following_url":"https://api.github.com/users/albertzaharovits/following{/other_user}","gists_url":"https://api.github.com/users/albertzaharovits/gists{/gist_id}","starred_url":"https://api.github.com/users/albertzaharovits/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/albertzaharovits/subscriptions","organizations_url":"https://api.github.com/users/albertzaharovits/orgs","repos_url":"https://api.github.com/users/albertzaharovits/repos","events_url":"https://api.github.com/users/albertzaharovits/events{/privacy}","received_events_url":"https://api.github.com/users/albertzaharovits/received_events","type":"User","site_admin":false},"created_at":"2018-11-26T13:37:33Z","updated_at":"2018-11-26T13:37:33Z","author_association":"CONTRIBUTOR","body":"> In terms of cross cluster, we've always just sent the role names and relied on the remote cluster looking this up. I think we set a dangerous precedent if we decide to serialize the role. However, if we do not serialize the role then these tokens cannot be used for cross cluster jobs, which hinders their use significantly.\r\n\r\nI think it's fine to confine the API key to the local cluster. Sure it would be wonderful to generate an API key and use it over a group of clusters, similar to cross-cluster search. But this is stretching cross-cluster search. With cross-cluster search you have to think about the roles on the remote cluster: *What roles make sense in the remote cluster and what is to be their definition.* This is important because index schema could differ on the remote cluster so role definition should also differ.\r\nWhereas with scoped api we would effectively enforce the role definition on the remote cluster.\r\n\r\nMoreover I view these api keys on the same rank with users as they have permissions attached to them. Generating an api key usable for cross cluster searches would be akin to generating a user on the remote cluster, which the user generating the api key might not have privileges to do (not that we want to do this in the first place, or have the means to do so).\r\n\r\nIf we really wish that long running jobs be capable to cross-cluster search, then we should add the capability to pair api keys, such that an api key from remote is translated to an api key from local.","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/449351271","html_url":"https://github.com/elastic/elasticsearch/issues/34383#issuecomment-449351271","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/34383","id":449351271,"node_id":"MDEyOklzc3VlQ29tbWVudDQ0OTM1MTI3MQ==","user":{"login":"bizybot","id":902768,"node_id":"MDQ6VXNlcjkwMjc2OA==","avatar_url":"https://avatars2.githubusercontent.com/u/902768?v=4","gravatar_id":"","url":"https://api.github.com/users/bizybot","html_url":"https://github.com/bizybot","followers_url":"https://api.github.com/users/bizybot/followers","following_url":"https://api.github.com/users/bizybot/following{/other_user}","gists_url":"https://api.github.com/users/bizybot/gists{/gist_id}","starred_url":"https://api.github.com/users/bizybot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bizybot/subscriptions","organizations_url":"https://api.github.com/users/bizybot/orgs","repos_url":"https://api.github.com/users/bizybot/repos","events_url":"https://api.github.com/users/bizybot/events{/privacy}","received_events_url":"https://api.github.com/users/bizybot/received_events","type":"User","site_admin":false},"created_at":"2018-12-21T10:28:53Z","updated_at":"2019-02-04T00:22:00Z","author_association":"CONTRIBUTOR","body":"Subtasking so we can track the progress:-\r\n- [x] Create an API key\r\n  - [x]  API Key service generates API key and stores it in the index.\r\n  - [x]  Rest API\r\n  - [x] HLRC changes for the API\r\n- [x] Authenticate using the API key\r\n  new Authentication scheme to handle authentication of the API key\r\n- [x] Authorization for the API key\r\n- [x] Invalidate API key\r\n  Rest API to invalidate key(s) and HLRC changes for the API.\r\n- [x] Get API key\r\n  - [x] Rest API\r\n  - [x] HLRC changes for the API","performed_via_github_app":null}]