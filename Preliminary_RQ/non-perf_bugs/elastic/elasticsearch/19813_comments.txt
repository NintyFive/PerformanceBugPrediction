[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/237701329","html_url":"https://github.com/elastic/elasticsearch/issues/19813#issuecomment-237701329","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19813","id":237701329,"node_id":"MDEyOklzc3VlQ29tbWVudDIzNzcwMTMyOQ==","user":{"login":"abeyad","id":1631297,"node_id":"MDQ6VXNlcjE2MzEyOTc=","avatar_url":"https://avatars2.githubusercontent.com/u/1631297?v=4","gravatar_id":"","url":"https://api.github.com/users/abeyad","html_url":"https://github.com/abeyad","followers_url":"https://api.github.com/users/abeyad/followers","following_url":"https://api.github.com/users/abeyad/following{/other_user}","gists_url":"https://api.github.com/users/abeyad/gists{/gist_id}","starred_url":"https://api.github.com/users/abeyad/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/abeyad/subscriptions","organizations_url":"https://api.github.com/users/abeyad/orgs","repos_url":"https://api.github.com/users/abeyad/repos","events_url":"https://api.github.com/users/abeyad/events{/privacy}","received_events_url":"https://api.github.com/users/abeyad/received_events","type":"User","site_admin":false},"created_at":"2016-08-04T22:21:58Z","updated_at":"2016-08-04T22:21:58Z","author_association":"CONTRIBUTOR","body":"> Disable real time get API and optimistic concurrency control on these indices.\n\nI was wondering what the reason is that real-time gets wouldn't work with the solutions outlined above?\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/237707399","html_url":"https://github.com/elastic/elasticsearch/issues/19813#issuecomment-237707399","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19813","id":237707399,"node_id":"MDEyOklzc3VlQ29tbWVudDIzNzcwNzM5OQ==","user":{"login":"s1monw","id":973334,"node_id":"MDQ6VXNlcjk3MzMzNA==","avatar_url":"https://avatars0.githubusercontent.com/u/973334?v=4","gravatar_id":"","url":"https://api.github.com/users/s1monw","html_url":"https://github.com/s1monw","followers_url":"https://api.github.com/users/s1monw/followers","following_url":"https://api.github.com/users/s1monw/following{/other_user}","gists_url":"https://api.github.com/users/s1monw/gists{/gist_id}","starred_url":"https://api.github.com/users/s1monw/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/s1monw/subscriptions","organizations_url":"https://api.github.com/users/s1monw/orgs","repos_url":"https://api.github.com/users/s1monw/repos","events_url":"https://api.github.com/users/s1monw/events{/privacy}","received_events_url":"https://api.github.com/users/s1monw/received_events","type":"User","site_admin":false},"created_at":"2016-08-04T22:48:55Z","updated_at":"2016-08-04T22:48:55Z","author_association":"CONTRIBUTOR","body":"> I was wondering what the reason is that real-time gets wouldn't work with the solutions outlined above?\n\nWe do RAM heavy accounting in the engine to allow GET operations to work in real-time vs. near-real-time. If we optimize for append only I think the need for realtime GET is a corner case and we can make use of the RAM for indexing instead. Hope that helps?\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/237707986","html_url":"https://github.com/elastic/elasticsearch/issues/19813#issuecomment-237707986","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19813","id":237707986,"node_id":"MDEyOklzc3VlQ29tbWVudDIzNzcwNzk4Ng==","user":{"login":"abeyad","id":1631297,"node_id":"MDQ6VXNlcjE2MzEyOTc=","avatar_url":"https://avatars2.githubusercontent.com/u/1631297?v=4","gravatar_id":"","url":"https://api.github.com/users/abeyad","html_url":"https://github.com/abeyad","followers_url":"https://api.github.com/users/abeyad/followers","following_url":"https://api.github.com/users/abeyad/following{/other_user}","gists_url":"https://api.github.com/users/abeyad/gists{/gist_id}","starred_url":"https://api.github.com/users/abeyad/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/abeyad/subscriptions","organizations_url":"https://api.github.com/users/abeyad/orgs","repos_url":"https://api.github.com/users/abeyad/repos","events_url":"https://api.github.com/users/abeyad/events{/privacy}","received_events_url":"https://api.github.com/users/abeyad/received_events","type":"User","site_admin":false},"created_at":"2016-08-04T22:51:03Z","updated_at":"2016-08-04T22:51:03Z","author_association":"CONTRIBUTOR","body":"@s1monw makes sense, thank you!\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/243052336","html_url":"https://github.com/elastic/elasticsearch/issues/19813#issuecomment-243052336","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19813","id":243052336,"node_id":"MDEyOklzc3VlQ29tbWVudDI0MzA1MjMzNg==","user":{"login":"s1monw","id":973334,"node_id":"MDQ6VXNlcjk3MzMzNA==","avatar_url":"https://avatars0.githubusercontent.com/u/973334?v=4","gravatar_id":"","url":"https://api.github.com/users/s1monw","html_url":"https://github.com/s1monw","followers_url":"https://api.github.com/users/s1monw/followers","following_url":"https://api.github.com/users/s1monw/following{/other_user}","gists_url":"https://api.github.com/users/s1monw/gists{/gist_id}","starred_url":"https://api.github.com/users/s1monw/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/s1monw/subscriptions","organizations_url":"https://api.github.com/users/s1monw/orgs","repos_url":"https://api.github.com/users/s1monw/repos","events_url":"https://api.github.com/users/s1monw/events{/privacy}","received_events_url":"https://api.github.com/users/s1monw/received_events","type":"User","site_admin":false},"created_at":"2016-08-29T07:31:38Z","updated_at":"2016-08-29T07:31:38Z","author_association":"CONTRIBUTOR","body":"@bleskes I was looking into the problem of more than once delivery due to retries on the primary. The entire task manager / network generation ideas that I had might work but I'd want to discuss a potentially simpler and more elegant way of doing this. IMO we just need a \"happens before\" relationship on the target shard. For instance if we send a document that is has the `canHaveDuplicates` property set (we can set it on the primary when we retry or when we recover from translog) we _remember_ for instance the _sequence_id_ or maybe the _timestamp_ something that is the same on the duplicates and inside the engine we just deoptimize (use updateDocument) if we see a document with a `deoptimizeProperty =< minSeenDeoptimizeProperty` this might then hit other potentially unrelated documents which is ok but it would guarantee that we always deoptimize on the one that looses the race? this sounds simpler to me instead of adding stuff to the network layer etc?\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/243079678","html_url":"https://github.com/elastic/elasticsearch/issues/19813#issuecomment-243079678","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19813","id":243079678,"node_id":"MDEyOklzc3VlQ29tbWVudDI0MzA3OTY3OA==","user":{"login":"bleskes","id":1006375,"node_id":"MDQ6VXNlcjEwMDYzNzU=","avatar_url":"https://avatars1.githubusercontent.com/u/1006375?v=4","gravatar_id":"","url":"https://api.github.com/users/bleskes","html_url":"https://github.com/bleskes","followers_url":"https://api.github.com/users/bleskes/followers","following_url":"https://api.github.com/users/bleskes/following{/other_user}","gists_url":"https://api.github.com/users/bleskes/gists{/gist_id}","starred_url":"https://api.github.com/users/bleskes/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bleskes/subscriptions","organizations_url":"https://api.github.com/users/bleskes/orgs","repos_url":"https://api.github.com/users/bleskes/repos","events_url":"https://api.github.com/users/bleskes/events{/privacy}","received_events_url":"https://api.github.com/users/bleskes/received_events","type":"User","site_admin":false},"created_at":"2016-08-29T09:40:00Z","updated_at":"2016-08-29T09:40:00Z","author_association":"MEMBER","body":"@s1monw that sounds very promising. I would love it if we can come up with something which is limited to the engine working together with the replication code and leave the networking code/task management out of it. \n\nLet me try and reword what you say, to make sure we are on the same page. \n\nOn the engine level, we already lock based on doc id, so we don't have to worry about concurrency on that level (as it seems this is not an indexing bottleneck , we can keep this lock around, at least for now). With this in place, we need to make sure that an \"optimized\" request is never executed (either at all, or in an unsafe manner) after a \"retry\" request has been completed - i.e., we need some barrier which the \"retry\" request leaves behind which blocks the \"optimized\" request. A naive implementation would be to have a map of doc ids for which \"optimized\" requests should be dealt with carefully. This obviously problematic is there is now clear way to indicate when the map should be cleaned. Instead the idea is to do it as follows:\n\n1) Mark every request with a timestamp. This is done once on the first node that receives a request and is fixed for this request. This can be even the machine local time (see why later). The important part is that retry requests will have the same value as the original one.\n2) In the engine we make sure we keep the highest seen time stamp of \"retry\" requests. This is updated while the retry request has its doc id lock. Call this `highestRetriedTimestamp`\n3) When the engine runs an \"optimized\" request comes, it compares it's timestamp with the current `highestRetriedTimestamp` (but doesn't update it). If the the request timestamp is higher it is safe to execute it as optimized (no retry request with the same timestamp has been run before). If not we fall back to \"non-optimzed\" mode and run the request as a retry one.\n\nThe first and last step guarantees that we will never run an \"optimized\" request after a \"retry\" request on the same doc (because the will have the same timestamp)/\n\nThe roughly monotonic nature of the timestamp (which  can be different on different nodes, and can go back in time) limits the potentially secondary damage where a retry request cause _other_ unrelated \"optimized\" requests to run as retries.\n\n@s1monw are we on the same page. If so 🏆  🎉  :)\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/243117951","html_url":"https://github.com/elastic/elasticsearch/issues/19813#issuecomment-243117951","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19813","id":243117951,"node_id":"MDEyOklzc3VlQ29tbWVudDI0MzExNzk1MQ==","user":{"login":"s1monw","id":973334,"node_id":"MDQ6VXNlcjk3MzMzNA==","avatar_url":"https://avatars0.githubusercontent.com/u/973334?v=4","gravatar_id":"","url":"https://api.github.com/users/s1monw","html_url":"https://github.com/s1monw","followers_url":"https://api.github.com/users/s1monw/followers","following_url":"https://api.github.com/users/s1monw/following{/other_user}","gists_url":"https://api.github.com/users/s1monw/gists{/gist_id}","starred_url":"https://api.github.com/users/s1monw/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/s1monw/subscriptions","organizations_url":"https://api.github.com/users/s1monw/orgs","repos_url":"https://api.github.com/users/s1monw/repos","events_url":"https://api.github.com/users/s1monw/events{/privacy}","received_events_url":"https://api.github.com/users/s1monw/received_events","type":"User","site_admin":false},"created_at":"2016-08-29T13:04:23Z","updated_at":"2016-08-29T13:04:23Z","author_association":"CONTRIBUTOR","body":"🎉  ++ that's it :)\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/247766692","html_url":"https://github.com/elastic/elasticsearch/issues/19813#issuecomment-247766692","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19813","id":247766692,"node_id":"MDEyOklzc3VlQ29tbWVudDI0Nzc2NjY5Mg==","user":{"login":"clintongormley","id":56599,"node_id":"MDQ6VXNlcjU2NTk5","avatar_url":"https://avatars0.githubusercontent.com/u/56599?v=4","gravatar_id":"","url":"https://api.github.com/users/clintongormley","html_url":"https://github.com/clintongormley","followers_url":"https://api.github.com/users/clintongormley/followers","following_url":"https://api.github.com/users/clintongormley/following{/other_user}","gists_url":"https://api.github.com/users/clintongormley/gists{/gist_id}","starred_url":"https://api.github.com/users/clintongormley/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/clintongormley/subscriptions","organizations_url":"https://api.github.com/users/clintongormley/orgs","repos_url":"https://api.github.com/users/clintongormley/repos","events_url":"https://api.github.com/users/clintongormley/events{/privacy}","received_events_url":"https://api.github.com/users/clintongormley/received_events","type":"User","site_admin":false},"created_at":"2016-09-17T12:26:14Z","updated_at":"2016-09-17T12:26:14Z","author_association":"CONTRIBUTOR","body":"@bleskes can this issue be closed now or is there more to do?\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/247768666","html_url":"https://github.com/elastic/elasticsearch/issues/19813#issuecomment-247768666","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19813","id":247768666,"node_id":"MDEyOklzc3VlQ29tbWVudDI0Nzc2ODY2Ng==","user":{"login":"s1monw","id":973334,"node_id":"MDQ6VXNlcjk3MzMzNA==","avatar_url":"https://avatars0.githubusercontent.com/u/973334?v=4","gravatar_id":"","url":"https://api.github.com/users/s1monw","html_url":"https://github.com/s1monw","followers_url":"https://api.github.com/users/s1monw/followers","following_url":"https://api.github.com/users/s1monw/following{/other_user}","gists_url":"https://api.github.com/users/s1monw/gists{/gist_id}","starred_url":"https://api.github.com/users/s1monw/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/s1monw/subscriptions","organizations_url":"https://api.github.com/users/s1monw/orgs","repos_url":"https://api.github.com/users/s1monw/repos","events_url":"https://api.github.com/users/s1monw/events{/privacy}","received_events_url":"https://api.github.com/users/s1monw/received_events","type":"User","site_admin":false},"created_at":"2016-09-17T13:10:22Z","updated_at":"2016-09-17T13:10:22Z","author_association":"CONTRIBUTOR","body":"I think we should update the description we haven't done the live version map stuff yet\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/247864248","html_url":"https://github.com/elastic/elasticsearch/issues/19813#issuecomment-247864248","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19813","id":247864248,"node_id":"MDEyOklzc3VlQ29tbWVudDI0Nzg2NDI0OA==","user":{"login":"bleskes","id":1006375,"node_id":"MDQ6VXNlcjEwMDYzNzU=","avatar_url":"https://avatars1.githubusercontent.com/u/1006375?v=4","gravatar_id":"","url":"https://api.github.com/users/bleskes","html_url":"https://github.com/bleskes","followers_url":"https://api.github.com/users/bleskes/followers","following_url":"https://api.github.com/users/bleskes/following{/other_user}","gists_url":"https://api.github.com/users/bleskes/gists{/gist_id}","starred_url":"https://api.github.com/users/bleskes/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bleskes/subscriptions","organizations_url":"https://api.github.com/users/bleskes/orgs","repos_url":"https://api.github.com/users/bleskes/repos","events_url":"https://api.github.com/users/bleskes/events{/privacy}","received_events_url":"https://api.github.com/users/bleskes/received_events","type":"User","site_admin":false},"created_at":"2016-09-18T18:24:02Z","updated_at":"2016-09-18T18:24:02Z","author_association":"MEMBER","body":"@s1monw ++ . I have updated the issue description.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/247930299","html_url":"https://github.com/elastic/elasticsearch/issues/19813#issuecomment-247930299","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/19813","id":247930299,"node_id":"MDEyOklzc3VlQ29tbWVudDI0NzkzMDI5OQ==","user":{"login":"s1monw","id":973334,"node_id":"MDQ6VXNlcjk3MzMzNA==","avatar_url":"https://avatars0.githubusercontent.com/u/973334?v=4","gravatar_id":"","url":"https://api.github.com/users/s1monw","html_url":"https://github.com/s1monw","followers_url":"https://api.github.com/users/s1monw/followers","following_url":"https://api.github.com/users/s1monw/following{/other_user}","gists_url":"https://api.github.com/users/s1monw/gists{/gist_id}","starred_url":"https://api.github.com/users/s1monw/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/s1monw/subscriptions","organizations_url":"https://api.github.com/users/s1monw/orgs","repos_url":"https://api.github.com/users/s1monw/repos","events_url":"https://api.github.com/users/s1monw/events{/privacy}","received_events_url":"https://api.github.com/users/s1monw/received_events","type":"User","site_admin":false},"created_at":"2016-09-19T07:52:44Z","updated_at":"2016-09-19T07:52:44Z","author_association":"CONTRIBUTOR","body":"thx @bleskes \n","performed_via_github_app":null}]