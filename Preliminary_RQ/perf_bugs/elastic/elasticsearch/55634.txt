{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/55634","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/55634/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/55634/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/55634/events","html_url":"https://github.com/elastic/elasticsearch/issues/55634","id":605130362,"node_id":"MDU6SXNzdWU2MDUxMzAzNjI=","number":55634,"title":"High volume of ingest traffic can cause Enrich to deadlock","user":{"login":"jbaiera","id":875779,"node_id":"MDQ6VXNlcjg3NTc3OQ==","avatar_url":"https://avatars1.githubusercontent.com/u/875779?v=4","gravatar_id":"","url":"https://api.github.com/users/jbaiera","html_url":"https://github.com/jbaiera","followers_url":"https://api.github.com/users/jbaiera/followers","following_url":"https://api.github.com/users/jbaiera/following{/other_user}","gists_url":"https://api.github.com/users/jbaiera/gists{/gist_id}","starred_url":"https://api.github.com/users/jbaiera/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jbaiera/subscriptions","organizations_url":"https://api.github.com/users/jbaiera/orgs","repos_url":"https://api.github.com/users/jbaiera/repos","events_url":"https://api.github.com/users/jbaiera/events{/privacy}","received_events_url":"https://api.github.com/users/jbaiera/received_events","type":"User","site_admin":false},"labels":[{"id":268963484,"node_id":"MDU6TGFiZWwyNjg5NjM0ODQ=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/:Core/Features/Ingest","name":":Core/Features/Ingest","color":"0e8a16","default":false,"description":"Execution or management of Ingest Pipelines"},{"id":23173,"node_id":"MDU6TGFiZWwyMzE3Mw==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/%3Ebug","name":">bug","color":"b60205","default":false,"description":null},{"id":1967496097,"node_id":"MDU6TGFiZWwxOTY3NDk2MDk3","url":"https://api.github.com/repos/elastic/elasticsearch/labels/Team:Core/Features","name":"Team:Core/Features","color":"fef2c0","default":false,"description":"Meta label for core/features team"},{"id":1933555094,"node_id":"MDU6TGFiZWwxOTMzNTU1MDk0","url":"https://api.github.com/repos/elastic/elasticsearch/labels/v7.7.1","name":"v7.7.1","color":"dddddd","default":false,"description":""},{"id":2040341496,"node_id":"MDU6TGFiZWwyMDQwMzQxNDk2","url":"https://api.github.com/repos/elastic/elasticsearch/labels/v7.8.1","name":"v7.8.1","color":"dddddd","default":false,"description":""},{"id":2040343033,"node_id":"MDU6TGFiZWwyMDQwMzQzMDMz","url":"https://api.github.com/repos/elastic/elasticsearch/labels/v7.9.0","name":"v7.9.0","color":"dddddd","default":false,"description":""},{"id":1194435738,"node_id":"MDU6TGFiZWwxMTk0NDM1NzM4","url":"https://api.github.com/repos/elastic/elasticsearch/labels/v8.0.0","name":"v8.0.0","color":"dddddd","default":false,"description":""}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":6,"created_at":"2020-04-22T23:11:43Z","updated_at":"2020-07-06T14:26:54Z","closed_at":"2020-07-06T14:26:17Z","author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"Enrich processors all route their search requests through the `EnrichCoordinatorProxyAction`, which collects enrichment search requests together in order to collapse them down and submit them in one multi-search request. The coordinator maintains an internal queue of search requests  for this purpose. Each thread entering the coordinator adds to this queue, then atomically drains the contents into a multi-search request which is executed asynchronously on a search thread. A maximum number of in-flight search requests is allowed (default 8). If that limit is reached then the coordinator simply queues ingest documents up until a new multi-search request can be executed. When the enrich coordinator queue reaches maximum capacity (1024 requests by default) it blocks the write thread under the assumption that a search request will eventually complete and begin draining the queue. This is meant to create a back pressure to the rest of the ingestion framework. \r\n\r\nThe discovered bug pertains to when the search thread completes the enrich lookup. When the multi-search completes, the search thread calls the response handler for the search. This handler simply returns to the ingestion framework and begins processing the next set of processors in the pipeline, potentially even the next document in the bulk request. Since the pipeline contains an enrich processor, the search thread will attempt to add a search request to the coordinator queue when it reaches it, just like a write request would. If this queue is filled, then the search thread is captured waiting for the queue to drain, just as the write threads would be. No threads would be able to pass this critical section to drain the queue and schedule the next search results. Thus, a deadlock arises, consuming the write threads and a portion of the read threads on a node.\r\n\r\nNormally, even though search threads are erroneously captured to perform ingestion work, they are eventually released back to the search pool once the bulk request they are stuck in completes processing. This may have been why this bug flew under the radar and only manifests in cases where there is high load placed on the enrich system for an extended period of time. If the write threads are able to create more search requests in the coordination queue than the search threads can keep up with, then the system will degrade until it passes the queue capacity and locks in place.","closed_by":{"login":"jbaiera","id":875779,"node_id":"MDQ6VXNlcjg3NTc3OQ==","avatar_url":"https://avatars1.githubusercontent.com/u/875779?v=4","gravatar_id":"","url":"https://api.github.com/users/jbaiera","html_url":"https://github.com/jbaiera","followers_url":"https://api.github.com/users/jbaiera/followers","following_url":"https://api.github.com/users/jbaiera/following{/other_user}","gists_url":"https://api.github.com/users/jbaiera/gists{/gist_id}","starred_url":"https://api.github.com/users/jbaiera/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jbaiera/subscriptions","organizations_url":"https://api.github.com/users/jbaiera/orgs","repos_url":"https://api.github.com/users/jbaiera/repos","events_url":"https://api.github.com/users/jbaiera/events{/privacy}","received_events_url":"https://api.github.com/users/jbaiera/received_events","type":"User","site_admin":false},"performed_via_github_app":null}