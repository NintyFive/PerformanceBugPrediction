[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/54936139","html_url":"https://github.com/elastic/elasticsearch/issues/7526#issuecomment-54936139","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/7526","id":54936139,"node_id":"MDEyOklzc3VlQ29tbWVudDU0OTM2MTM5","user":{"login":"martijnvg","id":580421,"node_id":"MDQ6VXNlcjU4MDQyMQ==","avatar_url":"https://avatars3.githubusercontent.com/u/580421?v=4","gravatar_id":"","url":"https://api.github.com/users/martijnvg","html_url":"https://github.com/martijnvg","followers_url":"https://api.github.com/users/martijnvg/followers","following_url":"https://api.github.com/users/martijnvg/following{/other_user}","gists_url":"https://api.github.com/users/martijnvg/gists{/gist_id}","starred_url":"https://api.github.com/users/martijnvg/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/martijnvg/subscriptions","organizations_url":"https://api.github.com/users/martijnvg/orgs","repos_url":"https://api.github.com/users/martijnvg/repos","events_url":"https://api.github.com/users/martijnvg/events{/privacy}","received_events_url":"https://api.github.com/users/martijnvg/received_events","type":"User","site_admin":false},"created_at":"2014-09-09T07:54:18Z","updated_at":"2014-09-09T07:54:18Z","author_association":"MEMBER","body":"@markharwood Yes, using include/exclude is slow since it will iterate over all terms and for each term check if it matches with the provided includes and doesn't match with the provided exclude. Each terms that is accepted the global ordinal will be saved in a bitset. The idea here was to be potentially slower (which really is the case for high cardinality fields) rather than increasing the transient memory footprint of a search request with a terms aggregation. \n\nI think we can optimize this logic in certain scenarios. For example if include with without regex expression is used or a simple include prefix is used we can iterator over all includes and lookup the global ordinal instead of iterating over all possible terms and check if they match with the defined include terms. I think the same can be done for exclude terms without regex and prefixes. Would this help in your tests?\n\nAnd maybe then if include/exclude terms are used with regex we should then fallback to the map execution hint? Similar to what happens if terms aggregation with script is executed.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/54960032","html_url":"https://github.com/elastic/elasticsearch/issues/7526#issuecomment-54960032","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/7526","id":54960032,"node_id":"MDEyOklzc3VlQ29tbWVudDU0OTYwMDMy","user":{"login":"markharwood","id":170925,"node_id":"MDQ6VXNlcjE3MDkyNQ==","avatar_url":"https://avatars0.githubusercontent.com/u/170925?v=4","gravatar_id":"","url":"https://api.github.com/users/markharwood","html_url":"https://github.com/markharwood","followers_url":"https://api.github.com/users/markharwood/followers","following_url":"https://api.github.com/users/markharwood/following{/other_user}","gists_url":"https://api.github.com/users/markharwood/gists{/gist_id}","starred_url":"https://api.github.com/users/markharwood/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/markharwood/subscriptions","organizations_url":"https://api.github.com/users/markharwood/orgs","repos_url":"https://api.github.com/users/markharwood/repos","events_url":"https://api.github.com/users/markharwood/events{/privacy}","received_events_url":"https://api.github.com/users/markharwood/received_events","type":"User","site_admin":false},"created_at":"2014-09-09T12:13:55Z","updated_at":"2014-09-09T12:13:55Z","author_association":"CONTRIBUTOR","body":"Thanks for the comment, @martijnvg My use case is when looking at the interactions of a pre-defined set of entities e.g. all the actors who have appeared in \"mafia\" movies or all the people in Enron who participated in emails referencing \"LJM\". This is likely to be a common form of analysis as it provides us with the raw data required to conduct graph analytics (centrality measures, key influencers, initiators etc)\nIn these scenarios a previous query for a topic (\"mafia\" or \"LJM\") may have selected the main entities of interest (using a _terms_ or _significant_terms_ agg) and these IDs are then used in a subsequent query like the one below to produce the edges in our graph:\n\n```\n        \"aggs\" : {\n                        \"actor\":{\n                            \"terms\":{\"field\":\"actorName\",  \"size\":500,\n                                \"include\": [\"Robert DeNiro\", \"Joe Pesci\", \"Al Pacino\"...]\n                            },\n                            \"aggs\":{\n                                    \"costar\":{\n                                        \"terms\":{\"field\":\"actorName\",  \"size\":500,\n                                                    \"include\": [\"Robert DeNiro\", \"Joe Pesci\", \"Al Pacino\"...]\n                                        }\n                                        }\n                                }                            \n                            }\n        }\n```\n\nEach leaf bucket is then an edge in our graph with a count of number of interactions between a pair of actors and the potential for further child aggs (date histograms summarising relationship over time etc).\n\nThis is a little clumsy and we could create a special \"graph\" agg for this use case as it would overcome these concerns:\n1) the need to declare 2 aggs clauses repeating the same list of \"includes\"\n2) the default removal of \"self-connecting\" edges i.e. a DeNiro->DeNiro bucket\n\nI'm not sure what the other use cases are that require these include clauses but this feels like a broad one deserving of its own agg.\n\nFor the general case I like your suggestion of taking the terms in my include set and looking up just their global ordinals as an alternative to looking up ALL terms. Would you suggest we always adopt this approach for non-regex IncludeExcludes?\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/54963974","html_url":"https://github.com/elastic/elasticsearch/issues/7526#issuecomment-54963974","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/7526","id":54963974,"node_id":"MDEyOklzc3VlQ29tbWVudDU0OTYzOTc0","user":{"login":"martijnvg","id":580421,"node_id":"MDQ6VXNlcjU4MDQyMQ==","avatar_url":"https://avatars3.githubusercontent.com/u/580421?v=4","gravatar_id":"","url":"https://api.github.com/users/martijnvg","html_url":"https://github.com/martijnvg","followers_url":"https://api.github.com/users/martijnvg/followers","following_url":"https://api.github.com/users/martijnvg/following{/other_user}","gists_url":"https://api.github.com/users/martijnvg/gists{/gist_id}","starred_url":"https://api.github.com/users/martijnvg/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/martijnvg/subscriptions","organizations_url":"https://api.github.com/users/martijnvg/orgs","repos_url":"https://api.github.com/users/martijnvg/repos","events_url":"https://api.github.com/users/martijnvg/events{/privacy}","received_events_url":"https://api.github.com/users/martijnvg/received_events","type":"User","site_admin":false},"created_at":"2014-09-09T12:53:07Z","updated_at":"2014-09-09T12:53:07Z","author_association":"MEMBER","body":"> Would you suggest we always adopt this approach for non-regex IncludeExcludes?\n\nYes, this will improve non-regex includes/excludes a lot and this should be a trivial change.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/54964219","html_url":"https://github.com/elastic/elasticsearch/issues/7526#issuecomment-54964219","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/7526","id":54964219,"node_id":"MDEyOklzc3VlQ29tbWVudDU0OTY0MjE5","user":{"login":"markharwood","id":170925,"node_id":"MDQ6VXNlcjE3MDkyNQ==","avatar_url":"https://avatars0.githubusercontent.com/u/170925?v=4","gravatar_id":"","url":"https://api.github.com/users/markharwood","html_url":"https://github.com/markharwood","followers_url":"https://api.github.com/users/markharwood/followers","following_url":"https://api.github.com/users/markharwood/following{/other_user}","gists_url":"https://api.github.com/users/markharwood/gists{/gist_id}","starred_url":"https://api.github.com/users/markharwood/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/markharwood/subscriptions","organizations_url":"https://api.github.com/users/markharwood/orgs","repos_url":"https://api.github.com/users/markharwood/repos","events_url":"https://api.github.com/users/markharwood/events{/privacy}","received_events_url":"https://api.github.com/users/markharwood/received_events","type":"User","site_admin":false},"created_at":"2014-09-09T12:55:25Z","updated_at":"2014-09-09T12:55:25Z","author_association":"CONTRIBUTOR","body":"I made the change - what was a 74 seconds lookup is now only 153 milliseconds on my dataset\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/54974985","html_url":"https://github.com/elastic/elasticsearch/issues/7526#issuecomment-54974985","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/7526","id":54974985,"node_id":"MDEyOklzc3VlQ29tbWVudDU0OTc0OTg1","user":{"login":"markharwood","id":170925,"node_id":"MDQ6VXNlcjE3MDkyNQ==","avatar_url":"https://avatars0.githubusercontent.com/u/170925?v=4","gravatar_id":"","url":"https://api.github.com/users/markharwood","html_url":"https://github.com/markharwood","followers_url":"https://api.github.com/users/markharwood/followers","following_url":"https://api.github.com/users/markharwood/following{/other_user}","gists_url":"https://api.github.com/users/markharwood/gists{/gist_id}","starred_url":"https://api.github.com/users/markharwood/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/markharwood/subscriptions","organizations_url":"https://api.github.com/users/markharwood/orgs","repos_url":"https://api.github.com/users/markharwood/repos","events_url":"https://api.github.com/users/markharwood/events{/privacy}","received_events_url":"https://api.github.com/users/markharwood/received_events","type":"User","site_admin":false},"created_at":"2014-09-09T14:15:19Z","updated_at":"2014-09-09T14:15:19Z","author_association":"CONTRIBUTOR","body":"Blocked pending a review for the required non-regex support in https://github.com/elasticsearch/elasticsearch/pull/7529 \n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/55419155","html_url":"https://github.com/elastic/elasticsearch/issues/7526#issuecomment-55419155","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/7526","id":55419155,"node_id":"MDEyOklzc3VlQ29tbWVudDU1NDE5MTU1","user":{"login":"markharwood","id":170925,"node_id":"MDQ6VXNlcjE3MDkyNQ==","avatar_url":"https://avatars0.githubusercontent.com/u/170925?v=4","gravatar_id":"","url":"https://api.github.com/users/markharwood","html_url":"https://github.com/markharwood","followers_url":"https://api.github.com/users/markharwood/followers","following_url":"https://api.github.com/users/markharwood/following{/other_user}","gists_url":"https://api.github.com/users/markharwood/gists{/gist_id}","starred_url":"https://api.github.com/users/markharwood/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/markharwood/subscriptions","organizations_url":"https://api.github.com/users/markharwood/orgs","repos_url":"https://api.github.com/users/markharwood/repos","events_url":"https://api.github.com/users/markharwood/events{/privacy}","received_events_url":"https://api.github.com/users/markharwood/received_events","type":"User","site_admin":false},"created_at":"2014-09-12T15:29:21Z","updated_at":"2014-09-12T15:29:21Z","author_association":"CONTRIBUTOR","body":"For simpler cases where exact terms are passed in include/exclude clauses (a feature enabled in this addition: https://github.com/elasticsearch/elasticsearch/pull/7529 ) performance is radically improved.\n\nHowever it is acknowledged that performance is still bad for a pure regex-based filter on high cardinality fields (we deliberately chose a slow response over the possibility of running out of RAM). @jpountz  has suggested we could look at using some of Lucene's automaton features to efficiently filter termsenums. For that reason I have labeled this issue as \"high hanging fruit\" to recognise the remaining work that may need doing to make regex-based filters faster\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/62126255","html_url":"https://github.com/elastic/elasticsearch/issues/7526#issuecomment-62126255","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/7526","id":62126255,"node_id":"MDEyOklzc3VlQ29tbWVudDYyMTI2MjU1","user":{"login":"jpountz","id":299848,"node_id":"MDQ6VXNlcjI5OTg0OA==","avatar_url":"https://avatars2.githubusercontent.com/u/299848?v=4","gravatar_id":"","url":"https://api.github.com/users/jpountz","html_url":"https://github.com/jpountz","followers_url":"https://api.github.com/users/jpountz/followers","following_url":"https://api.github.com/users/jpountz/following{/other_user}","gists_url":"https://api.github.com/users/jpountz/gists{/gist_id}","starred_url":"https://api.github.com/users/jpountz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jpountz/subscriptions","organizations_url":"https://api.github.com/users/jpountz/orgs","repos_url":"https://api.github.com/users/jpountz/repos","events_url":"https://api.github.com/users/jpountz/events{/privacy}","received_events_url":"https://api.github.com/users/jpountz/received_events","type":"User","site_admin":false},"created_at":"2014-11-07T10:46:02Z","updated_at":"2014-11-07T10:46:02Z","author_association":"CONTRIBUTOR","body":"We talked about intersecting the field data terms dictionary with automatons to speed up the generation of the bit set of matching terms. This would be a breaking change in 2.0 as we would switch from Java's regular expressions to Lucene's which have a slightly different syntax.\n\nAnother change might be required: in some cases evaluating whether a term matches the regular expression at search time can be faster than doing it ahead of time like we do today.\n","performed_via_github_app":null}]