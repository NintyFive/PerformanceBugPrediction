{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/14697","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/14697/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/14697/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/14697/events","html_url":"https://github.com/elastic/elasticsearch/issues/14697","id":116467894,"node_id":"MDU6SXNzdWUxMTY0Njc4OTQ=","number":14697,"title":"Master can get stuck AsyncFetching forever","user":{"login":"jolynch","id":1420460,"node_id":"MDQ6VXNlcjE0MjA0NjA=","avatar_url":"https://avatars1.githubusercontent.com/u/1420460?v=4","gravatar_id":"","url":"https://api.github.com/users/jolynch","html_url":"https://github.com/jolynch","followers_url":"https://api.github.com/users/jolynch/followers","following_url":"https://api.github.com/users/jolynch/following{/other_user}","gists_url":"https://api.github.com/users/jolynch/gists{/gist_id}","starred_url":"https://api.github.com/users/jolynch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jolynch/subscriptions","organizations_url":"https://api.github.com/users/jolynch/orgs","repos_url":"https://api.github.com/users/jolynch/repos","events_url":"https://api.github.com/users/jolynch/events{/privacy}","received_events_url":"https://api.github.com/users/jolynch/received_events","type":"User","site_admin":false},"labels":[{"id":111624690,"node_id":"MDU6TGFiZWwxMTE2MjQ2OTA=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/feedback_needed","name":"feedback_needed","color":"d4c5f9","default":false,"description":null}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":5,"created_at":"2015-11-12T02:42:54Z","updated_at":"2015-11-17T09:54:52Z","closed_at":"2015-11-17T09:54:52Z","author_association":"NONE","active_lock_reason":null,"body":"While trying to upgrade our clusters to 1.7.3 I came across a fun issue with the async shard fetch mechanism, namely that the [cache](https://github.com/elastic/elasticsearch/blob/05d4530971ef0ea46d0f4fa6ee64dbc8df659682/src/main/java/org/elasticsearch/gateway/AsyncShardFetch.java#L64) can get poisoned by nodes that change IDs. The basic issue is that [`processAsyncFetch`](https://github.com/elastic/elasticsearch/blob/05d4530971ef0ea46d0f4fa6ee64dbc8df659682/src/main/java/org/elasticsearch/gateway/AsyncShardFetch.java#L270) passes `response.getNodes()` instead of `nodesIds`. This means that if the master thinks it is talking to node 1234 and the response comes back with \"I'm node 3456\" we [continue](https://github.com/elastic/elasticsearch/blob/05d4530971ef0ea46d0f4fa6ee64dbc8df659682/src/main/java/org/elasticsearch/gateway/AsyncShardFetch.java#L178) and poison the cache in the process as the master will never get a response from node 1234.\n\nNodes should never change IDs, but I think they actually can when they first start up because of something like [LocalDiscovery](https://github.com/elastic/elasticsearch/blob/05d4530971ef0ea46d0f4fa6ee64dbc8df659682/src/main/java/org/elasticsearch/discovery/local/LocalDiscovery.java#L110-L111) which sets the localNode to one name and then [InternalClusterService](https://github.com/elastic/elasticsearch/blob/05d4530971ef0ea46d0f4fa6ee64dbc8df659682/src/main/java/org/elasticsearch/cluster/service/InternalClusterService.java#L162-L163) sets it to something different. More generally it seems like one node shouldn't trust that it will get a response back from a node with the same ID that it sent to (I can't actually come up with a real world situation where the node both is still in the cluster and the id changes ... but ...). My understanding of Zen is that this can't happen (and nodes really _shouldn't_ ever change IDs) but if they do the master gets a poisoned cache and it will be stuck forever in [fetchData](https://github.com/elastic/elasticsearch/blob/05d4530971ef0ea46d0f4fa6ee64dbc8df659682/src/main/java/org/elasticsearch/gateway/AsyncShardFetch.java#L121).\n\nI think that passing the `nodesIds` instead of `response.getNodes()` is not a particularly good solution because it defends against something that should never happen, but it does seem like a [NodeEntry](https://github.com/elastic/elasticsearch/blob/05d4530971ef0ea46d0f4fa6ee64dbc8df659682/src/main/java/org/elasticsearch/gateway/AsyncShardFetch.java#L333) \"fetching\" state really should expire after some amount of time to be robust. If I were to submit a PR that expired the async fetch cache after 20s or added some equivalent bookeeping, would you be opposed to that?\n","closed_by":{"login":"bleskes","id":1006375,"node_id":"MDQ6VXNlcjEwMDYzNzU=","avatar_url":"https://avatars1.githubusercontent.com/u/1006375?v=4","gravatar_id":"","url":"https://api.github.com/users/bleskes","html_url":"https://github.com/bleskes","followers_url":"https://api.github.com/users/bleskes/followers","following_url":"https://api.github.com/users/bleskes/following{/other_user}","gists_url":"https://api.github.com/users/bleskes/gists{/gist_id}","starred_url":"https://api.github.com/users/bleskes/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bleskes/subscriptions","organizations_url":"https://api.github.com/users/bleskes/orgs","repos_url":"https://api.github.com/users/bleskes/repos","events_url":"https://api.github.com/users/bleskes/events{/privacy}","received_events_url":"https://api.github.com/users/bleskes/received_events","type":"User","site_admin":false},"performed_via_github_app":null}