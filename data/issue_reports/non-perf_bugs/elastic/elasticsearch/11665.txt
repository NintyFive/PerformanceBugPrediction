{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/11665","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/11665/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/11665/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/11665/events","html_url":"https://github.com/elastic/elasticsearch/issues/11665","id":88374771,"node_id":"MDU6SXNzdWU4ODM3NDc3MQ==","number":11665,"title":"Concurrent deletion of indices and master failure can cause indices to be reimported","user":{"login":"brwe","id":4320215,"node_id":"MDQ6VXNlcjQzMjAyMTU=","avatar_url":"https://avatars0.githubusercontent.com/u/4320215?v=4","gravatar_id":"","url":"https://api.github.com/users/brwe","html_url":"https://github.com/brwe","followers_url":"https://api.github.com/users/brwe/followers","following_url":"https://api.github.com/users/brwe/following{/other_user}","gists_url":"https://api.github.com/users/brwe/gists{/gist_id}","starred_url":"https://api.github.com/users/brwe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/brwe/subscriptions","organizations_url":"https://api.github.com/users/brwe/orgs","repos_url":"https://api.github.com/users/brwe/repos","events_url":"https://api.github.com/users/brwe/events{/privacy}","received_events_url":"https://api.github.com/users/brwe/received_events","type":"User","site_admin":false},"labels":[{"id":836504707,"node_id":"MDU6TGFiZWw4MzY1MDQ3MDc=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/:Distributed/Distributed","name":":Distributed/Distributed","color":"0e8a16","default":false,"description":"A catch all label for anything in the Distributed Area. If you aren't sure, use this one."},{"id":23173,"node_id":"MDU6TGFiZWwyMzE3Mw==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/%3Ebug","name":">bug","color":"b60205","default":false,"description":null},{"id":110815527,"node_id":"MDU6TGFiZWwxMTA4MTU1Mjc=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/help%20wanted","name":"help wanted","color":"207de5","default":true,"description":"adoptme"},{"id":302749677,"node_id":"MDU6TGFiZWwzMDI3NDk2Nzc=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/v2.3.0","name":"v2.3.0","color":"dddddd","default":false,"description":null},{"id":246685314,"node_id":"MDU6TGFiZWwyNDY2ODUzMTQ=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/v5.0.0-alpha1","name":"v5.0.0-alpha1","color":"dddddd","default":false,"description":null}],"state":"closed","locked":false,"assignee":{"login":"abeyad","id":1631297,"node_id":"MDQ6VXNlcjE2MzEyOTc=","avatar_url":"https://avatars2.githubusercontent.com/u/1631297?v=4","gravatar_id":"","url":"https://api.github.com/users/abeyad","html_url":"https://github.com/abeyad","followers_url":"https://api.github.com/users/abeyad/followers","following_url":"https://api.github.com/users/abeyad/following{/other_user}","gists_url":"https://api.github.com/users/abeyad/gists{/gist_id}","starred_url":"https://api.github.com/users/abeyad/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/abeyad/subscriptions","organizations_url":"https://api.github.com/users/abeyad/orgs","repos_url":"https://api.github.com/users/abeyad/repos","events_url":"https://api.github.com/users/abeyad/events{/privacy}","received_events_url":"https://api.github.com/users/abeyad/received_events","type":"User","site_admin":false},"assignees":[{"login":"abeyad","id":1631297,"node_id":"MDQ6VXNlcjE2MzEyOTc=","avatar_url":"https://avatars2.githubusercontent.com/u/1631297?v=4","gravatar_id":"","url":"https://api.github.com/users/abeyad","html_url":"https://github.com/abeyad","followers_url":"https://api.github.com/users/abeyad/followers","following_url":"https://api.github.com/users/abeyad/following{/other_user}","gists_url":"https://api.github.com/users/abeyad/gists{/gist_id}","starred_url":"https://api.github.com/users/abeyad/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/abeyad/subscriptions","organizations_url":"https://api.github.com/users/abeyad/orgs","repos_url":"https://api.github.com/users/abeyad/repos","events_url":"https://api.github.com/users/abeyad/events{/privacy}","received_events_url":"https://api.github.com/users/abeyad/received_events","type":"User","site_admin":false}],"milestone":null,"comments":5,"created_at":"2015-06-15T09:49:15Z","updated_at":"2018-02-13T19:56:53Z","closed_at":"2016-03-01T14:53:22Z","author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"Currently, a data node deletes indices by evaluating the cluster state. If a new cluster state comes in it is compared to the last known cluster state, and if the new state does not contain an index that the node has in its last cluster state, then this index is deleted.\n\nThis could cause data to be deleted if the data folder of all master nodes was lost (#8823): \n\nAll master nodes of a cluster go down at the same time and their data folders cannot be recovered. \nA new master is brought up but it does not have any indices in its cluster state because the data was lost.\nBecause all other node are data nodes it cannot get the cluster state from them too and therefore sends a cluster state without any indices in it to the data nodes. The data nodes then delete all their data. \n\nOn the master branch we prevent this now by checking if the current cluster state comes from a different master than the previous one and if so, we keep the indices and import them as dangling (see #9952, ClusterChangedEvent).\n\nWhile this prevents the deletion, it also means that we might in other cases not delete indices although we should.\n\nExample:\n1. two masters eligible nodes, m1 is master, one data node (d).\n2. m1, m2 and d are on cluster state version 1 that contains and index\n3. The index is deleted through the API, causing m1 to send cluster state 2 which does not contain the index to m2 and d that should trigger the actual index deletion.\n4. m1 goes down\n5. m2 receives the new cluster state but d does not (network issues etc)\n6. m2 is elected master and sends cluster state 3 to d which again does not contain the index\n7. d will not delete the index because the state comes from a different master than cluster state 1 (the last one it knows of) and will therefore not delete the index and instead import it back into the cluster \n\nCurrently there is no way for a data node to decide if an index should actually be deleted or not if the cluster state that triggers the delete comes from a new master. We chose between: (1) deleting all data in case a node receives an empty cluster state or (2) run the risk to keep indices around that should actually be deleted.\n\nWe decided for (2) in #9952. Just opening this issue so that this behavior is documented.\n","closed_by":{"login":"abeyad","id":1631297,"node_id":"MDQ6VXNlcjE2MzEyOTc=","avatar_url":"https://avatars2.githubusercontent.com/u/1631297?v=4","gravatar_id":"","url":"https://api.github.com/users/abeyad","html_url":"https://github.com/abeyad","followers_url":"https://api.github.com/users/abeyad/followers","following_url":"https://api.github.com/users/abeyad/following{/other_user}","gists_url":"https://api.github.com/users/abeyad/gists{/gist_id}","starred_url":"https://api.github.com/users/abeyad/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/abeyad/subscriptions","organizations_url":"https://api.github.com/users/abeyad/orgs","repos_url":"https://api.github.com/users/abeyad/repos","events_url":"https://api.github.com/users/abeyad/events{/privacy}","received_events_url":"https://api.github.com/users/abeyad/received_events","type":"User","site_admin":false},"performed_via_github_app":null}