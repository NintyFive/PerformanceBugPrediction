{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/11814","repository_url":"https://api.github.com/repos/elastic/elasticsearch","labels_url":"https://api.github.com/repos/elastic/elasticsearch/issues/11814/labels{/name}","comments_url":"https://api.github.com/repos/elastic/elasticsearch/issues/11814/comments","events_url":"https://api.github.com/repos/elastic/elasticsearch/issues/11814/events","html_url":"https://github.com/elastic/elasticsearch/issues/11814","id":90240606,"node_id":"MDU6SXNzdWU5MDI0MDYwNg==","number":11814,"title":"Item Query","user":{"login":"alexksikes","id":43475,"node_id":"MDQ6VXNlcjQzNDc1","avatar_url":"https://avatars2.githubusercontent.com/u/43475?v=4","gravatar_id":"","url":"https://api.github.com/users/alexksikes","html_url":"https://github.com/alexksikes","followers_url":"https://api.github.com/users/alexksikes/followers","following_url":"https://api.github.com/users/alexksikes/following{/other_user}","gists_url":"https://api.github.com/users/alexksikes/gists{/gist_id}","starred_url":"https://api.github.com/users/alexksikes/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alexksikes/subscriptions","organizations_url":"https://api.github.com/users/alexksikes/orgs","repos_url":"https://api.github.com/users/alexksikes/repos","events_url":"https://api.github.com/users/alexksikes/events{/privacy}","received_events_url":"https://api.github.com/users/alexksikes/received_events","type":"User","site_admin":false},"labels":[{"id":146832564,"node_id":"MDU6TGFiZWwxNDY4MzI1NjQ=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/:Search/Search","name":":Search/Search","color":"0e8a16","default":false,"description":"Search-related issues that do not fall into other categories"},{"id":23172,"node_id":"MDU6TGFiZWwyMzE3Mg==","url":"https://api.github.com/repos/elastic/elasticsearch/labels/%3Efeature","name":">feature","color":"006b75","default":false,"description":null},{"id":158399402,"node_id":"MDU6TGFiZWwxNTgzOTk0MDI=","url":"https://api.github.com/repos/elastic/elasticsearch/labels/Meta","name":"Meta","color":"e11d21","default":false,"description":null}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":1,"created_at":"2015-06-22T23:21:04Z","updated_at":"2018-02-14T13:44:18Z","closed_at":"2016-01-18T20:42:49Z","author_association":"CONTRIBUTOR","active_lock_reason":null,"body":"## Introduction\n\nThis a proposal for a different implementation of More Like This (MLT) which is purely based on the term vectors API. The goal of MLT is to find documents that are more like or similar to a given input document (or set of user input documents). In order to do so MLT simply performs nearest neighbor search in the vector space model induced by the query. This consists of forming a disjunctive query of all the terms in the input document, to execute that query and to finally return the results. However, in order to speed things up, MLT first performs a greedy selection of the best terms, that is the terms that would most contribute to the score of each matching document. In this respect, MLT assumes that the default [Lucene similarity](https://lucene.apache.org/core/5_2_0/core/org/apache/lucene/search/similarities/TFIDFSimilarity.html) measure is being used, and therefore selects the terms with highest tf-idf. Furthermore, in order to limit the expensive call on the document frequency of each term, MLT prunes the selection space by only considering terms that have a certain minimum term frequency or length.\n\nItem Query better decouples the process performed by MLT in three different steps. First, a characteristic vector of the input document is found using the Term Vectors API with the terms filtering (#9561). Second, the query is formed from these terms. Third, the same query is then sent to and executed on every shard. This approach has a couple of advantages that we now list below.\n## Advantages\n- This approach is a cleaner and a more faithful implementation to nearest neighbor search with feature selection. It is simpler to implement and easier to understand. For example, we can easily explain the query without even having executed it. We could also always return the query formed together with the results returned at no additional cost.\n- The same query is executed on every shard, which has some nice performance implication with the file system cache. Furthermore, this approach lowers the load on the cluster as terms filtering is only performed on the single shard holding the requested document.\n- Together with the ongoing work on query refactoring (#10217), we would no longer need to serialize all candidate terms but only the selected ones used to form the query. Implementation wise we would simply re-use serialization of the terms query.\n- Allows for more complex terms filtering with scripting, and therefore for different feature selection procedures. This would allow us to perform feature selection on a different feature metric space, not necessarily limited to the Lucene default similarity measure. See the example below on Bayesian Sets.\n## Disadvantages\n- We could now have a speed bottleneck if the shard holding the document and performing filtering is busy or slow.\n- We are no longer based off Lucene MLT code.\n- We are loosing on the terms that increase recall as the selection is only performed on the shard holding the input document. MLT does perform the term selection on every shard. However, with enough data document frequencies should be well distributed. With small indices it is also always possible to allow for the dfs option of the Terms Vectors API.\n## Example of Usage: Bayesian Sets\n\n[Bayesian Sets](http://papers.nips.cc/paper/2817-bayesian-sets.pdf) (BSets) is an item based search algorithm that has been shown to return good results for multimedia documents, such as [images](https://stat.duke.edu/~kheller/810_Heller_K.pdf), but not [only](http://machinelearning.wustl.edu/mlpapers/paper_files/AISTATS07_SilvaHG.pdf). There are two important ideas behind item based search. First, the query is made of items (not only textual documents), and the results are items. Second, the similarity measure is solely implicitly defined by the choice of features, requiring very little tweaking of the underlying matching algorithm. The features of an item could be thought as defining some summary statistics characterizing this item. It usually takes the form of a vector of characteristics. For example, an image could be turned into a feature vector by using the histogram of its most common colors.\n\nThe formula employed by BSets to compute the score of each item with respect to the input item(s) is given as follow:\n\n**s** = c + **X** · **q**\n\nwhere **s** is the score vector for an item _i_, c is a pre-computed constant, **X** is an item-feature matrix and **q** is a computed query vector based off the input item(s).\n\nThis formula is in fact very similar to the vector space model but under the new similarity measure given by **q**. In essence, each feature _j_ is weighted according to some q__j_. Therefore, we can readily approximate BSets by changing the similarity measure to **q**, and by using an Item Query where the best features (represented as unique terms) are selected according to the q__j_. It is true that we do not have all the q__j_ as this would be too expensive, but we do now have the ones which would most contribute to the final score of each matching document, under this new similarity measure.\n## Implementation Notes\n\nItem Query would probably be implemented as an experimental feature or as a plugin. We pretty much have all the elements required for Item Query, but here is a list of things to do and additional features:\n- add scripting for term vectors filtering.\n- add an option to dfs only the best n + k terms, and return the best n terms.\n- implement like_text as an artificial document with cross fields.\n- benchmark traditional MLT vs. Item Query.\n- provide an example of using BSets on an image dataset such as MIRFLICKR.\n","closed_by":{"login":"clintongormley","id":56599,"node_id":"MDQ6VXNlcjU2NTk5","avatar_url":"https://avatars0.githubusercontent.com/u/56599?v=4","gravatar_id":"","url":"https://api.github.com/users/clintongormley","html_url":"https://github.com/clintongormley","followers_url":"https://api.github.com/users/clintongormley/followers","following_url":"https://api.github.com/users/clintongormley/following{/other_user}","gists_url":"https://api.github.com/users/clintongormley/gists{/gist_id}","starred_url":"https://api.github.com/users/clintongormley/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/clintongormley/subscriptions","organizations_url":"https://api.github.com/users/clintongormley/orgs","repos_url":"https://api.github.com/users/clintongormley/repos","events_url":"https://api.github.com/users/clintongormley/events{/privacy}","received_events_url":"https://api.github.com/users/clintongormley/received_events","type":"User","site_admin":false},"performed_via_github_app":null}