[{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/115418328","html_url":"https://github.com/elastic/elasticsearch/issues/11867#issuecomment-115418328","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/11867","id":115418328,"node_id":"MDEyOklzc3VlQ29tbWVudDExNTQxODMyOA==","user":{"login":"szroland","id":10174523,"node_id":"MDQ6VXNlcjEwMTc0NTIz","avatar_url":"https://avatars2.githubusercontent.com/u/10174523?v=4","gravatar_id":"","url":"https://api.github.com/users/szroland","html_url":"https://github.com/szroland","followers_url":"https://api.github.com/users/szroland/followers","following_url":"https://api.github.com/users/szroland/following{/other_user}","gists_url":"https://api.github.com/users/szroland/gists{/gist_id}","starred_url":"https://api.github.com/users/szroland/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/szroland/subscriptions","organizations_url":"https://api.github.com/users/szroland/orgs","repos_url":"https://api.github.com/users/szroland/repos","events_url":"https://api.github.com/users/szroland/events{/privacy}","received_events_url":"https://api.github.com/users/szroland/received_events","type":"User","site_admin":false},"created_at":"2015-06-25T22:25:25Z","updated_at":"2015-06-25T22:25:25Z","author_association":"CONTRIBUTOR","body":"It seems like this was a known issue with `ignore_unmapped`, which is why I believe it would have been deprecated in favor of `unmapped_type`, e.g. see #2255. The current behavior of `ignore_unmapped=true` is practically to set `unmapped_type` to `long`. You might as well stop using `ignore_unmapped` and use `\"unmapped_type\": \"long\"` yourself to understand what is going on.\n\nNow, I believe there is an implicit assumption that if you sort across indices, the same field will be consistently mapped everywhere, or not mapped at all, this latter being handled by `unmapped_type`. If this is the case, you can actually discover what the field ended up being mapped to before doing the sort by checking `GET my_alias/my_type/_mapping`. Whatever the consistent mapping is, you can simply plug the same type into `unmapped_type` when you search and have a working solution with the current code. Maybe elastic could actually do this for you, which is likely the semantics you may be expecting from `ignore_unmapped`, but currently this doesn't happen.\n\nHowever, if what you are writing is true, and you have no control over mapping and fields get auto-mapped in each index, you can run into a situation where you have conflicting mapping, and there will be no way to trivially sort in that case.\n\nLet me demonstrate, assuming the setup you described already loaded, let's have `FieldStr` auto-mapped to `long` in `my_index2`:\n\n```\nPOST my_index2/my_type\n{\n  \"FieldStr\": 234\n}\n```\n\nNow, if you run your query, that worked before:\n\n```\n{\n  \"query\": {\n    \"match_all\": {}\n  },\n  \"sort\": [\n    {\n      \"FieldStr\": {\n        \"order\": \"desc\",\n        \"missing\": \"_last\",\n        \"unmapped_type\": \"String\"\n      }\n    }\n  ]\n}\n```\n\nYou will run into the same issue of casting because of the different mapping of the same field in the indices:\n\n```\n{\n  type: \"class_cast_exception\"\n  reason: \"java.lang.Long cannot be cast to org.apache.lucene.util.BytesRef\"\n}\n```\n\nThere is no way to sort by this field anymore. Note that, in your case, assuming you truly have no control in your app, you can use the `GET my_alias/my_type/_mapping` call to detect this situation as well (e.g. discover conflicting types in the various indices for the same field) and either:\n1. disable sorting on this field altogether knowing it will fail\n2. maybe use scripting to create a field on the fly with the right semantics (e.g. numeric or string), and sort by that artificial sort support field (https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-sort.html#_script_based_sorting) (less storage, less performance)\n3. use multifields to store a string version of all fields which you can fall back to during sorting (https://www.elastic.co/guide/en/elasticsearch/guide/current/multi-fields.html) (more storage, higher performance I'd guess)\n\nIn general, Elastic would not be able to decide for you whether to sort numerically or alphabetically, even if it supported type-conversions during sorting. Also, you can get weird results in your example with analyzed text fields (default), this could also be addressed by option 3, e.g. set the raw version, which you use for sorting, not analyzed, and always use that for sorting, unless you have a consistent numeric mapping on the primary field.\n","performed_via_github_app":null},{"url":"https://api.github.com/repos/elastic/elasticsearch/issues/comments/115653708","html_url":"https://github.com/elastic/elasticsearch/issues/11867#issuecomment-115653708","issue_url":"https://api.github.com/repos/elastic/elasticsearch/issues/11867","id":115653708,"node_id":"MDEyOklzc3VlQ29tbWVudDExNTY1MzcwOA==","user":{"login":"clintongormley","id":56599,"node_id":"MDQ6VXNlcjU2NTk5","avatar_url":"https://avatars0.githubusercontent.com/u/56599?v=4","gravatar_id":"","url":"https://api.github.com/users/clintongormley","html_url":"https://github.com/clintongormley","followers_url":"https://api.github.com/users/clintongormley/followers","following_url":"https://api.github.com/users/clintongormley/following{/other_user}","gists_url":"https://api.github.com/users/clintongormley/gists{/gist_id}","starred_url":"https://api.github.com/users/clintongormley/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/clintongormley/subscriptions","organizations_url":"https://api.github.com/users/clintongormley/orgs","repos_url":"https://api.github.com/users/clintongormley/repos","events_url":"https://api.github.com/users/clintongormley/events{/privacy}","received_events_url":"https://api.github.com/users/clintongormley/received_events","type":"User","site_admin":false},"created_at":"2015-06-26T11:44:00Z","updated_at":"2015-06-26T11:44:00Z","author_association":"CONTRIBUTOR","body":"Well answered @szroland - I think you've captured all of the problems.\n\nThis looks like a won't fix, so I'm going to close this issue.\n","performed_via_github_app":null}]